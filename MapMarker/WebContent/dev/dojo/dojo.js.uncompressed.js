(function(
	userConfig,
	defaultConfig
){
	// summary:
	//		This is the "source loader" and is the entry point for Dojo during development. You may also load Dojo with
	//		any AMD-compliant loader via the package main module dojo/main.
	// description:
	//		This is the "source loader" for Dojo. It provides an AMD-compliant loader that can be configured
	//		to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
	//		IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
	//		via the package main module dojo/main and this loader is not required; see dojo/package.json for details.
	//
	//		In order to keep compatibility with the v1.x line, this loader includes additional machinery that enables
	//		the dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed
	//		via the has.js API and statically removed via the build system.
	//
	//		This loader includes sniffing machinery to determine the environment; the following environments are supported:
	//
	//		- browser
	//		- node.js
	//		- rhino
	//
	//		This is the so-called "source loader". As such, it includes many optional features that may be discarded by
	//		building a customized version with the build system.

	// Design and Implementation Notes
	//
	// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.
	//
	// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)
	// loader that can be configured to operate in either synchronous or asynchronous modes.
	//
	// Since this machinery implements a loader, it does not have the luxury of using a load system and/or
	// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:
	//
	//	 1. Small library for use implementing the loader.
	//	 2. Define the has.js API; this is used throughout the loader to bracket features.
	//	 3. Define the node.js and rhino sniffs and sniff.
	//	 4. Define the loader's data.
	//	 5. Define the configuration machinery.
	//	 6. Define the script element sniffing machinery and sniff for configuration data.
	//	 7. Configure the loader IAW the provided user, default, and sniffing data.
	//	 8. Define the global require function.
	//	 9. Define the module resolution machinery.
	//	10. Define the module and plugin module definition machinery
	//	11. Define the script injection machinery.
	//	12. Define the window load detection.
	//	13. Define the logging API.
	//	14. Define the tracing API.
	//	16. Define the AMD define function.
	//	17. Define the dojo v1.x provide/require machinery--so called "legacy" modes.
	//	18. Publish global variables.
	//
	// Language and Acronyms and Idioms
	//
	// moduleId: a CJS module identifier, (used for public APIs)
	// mid: moduleId (used internally)
	// packageId: a package identifier (used for public APIs)
	// pid: packageId (used internally); the implied system or default package has pid===""
	// pack: package is used internally to reference a package object (since javascript has reserved words including "package")
	// prid: plugin resource identifier
	// The integer constant 1 is used in place of true and 0 in place of false.

	// define a minimal library to help build the loader
	var	noop = function(){
		},

		isEmpty = function(it){
			for(var p in it){
				return 0;
			}
			return 1;
		},

		toString = {}.toString,

		isFunction = function(it){
			return toString.call(it) == "[object Function]";
		},

		isString = function(it){
			return toString.call(it) == "[object String]";
		},

		isArray = function(it){
			return toString.call(it) == "[object Array]";
		},

		forEach = function(vector, callback){
			if(vector){
				for(var i = 0; i < vector.length;){
					callback(vector[i++]);
				}
			}
		},

		mix = function(dest, src){
			for(var p in src){
				dest[p] = src[p];
			}
			return dest;
		},

		makeError = function(error, info){
			return mix(new Error(error), {src:"dojoLoader", info:info});
		},

		uidSeed = 1,

		uid = function(){
			// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.
			return "_" + uidSeed++;
		},

		// FIXME: how to doc window.require() api

		// this will be the global require function; define it immediately so we can start hanging things off of it
		req = function(
			config,		  //(object, optional) hash of configuration properties
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback
			callback	  //(function, optional) lambda expression to apply to module values implied by dependencies
		){
			return contextRequire(config, dependencies, callback, 0, req);
		},

		// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout
		global = this,

		doc = global.document,

		element = doc && doc.createElement("DiV"),

		has = req.has = function(name){
			return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
		},

		hasCache = has.cache = defaultConfig.hasCache;

	has.add = function(name, test, now, force){
		(hasCache[name]===undefined || force) && (hasCache[name] = test);
		return now && has(name);
	};

	 0 && has.add("host-node", userConfig.has && "host-node" in userConfig.has ?
		userConfig.has["host-node"] :
		(typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
	if( 0 ){
		// fixup the default config for node.js environment
		require("./_base/configNode.js").config(defaultConfig);
		// remember node's require (with respect to baseUrl==dojo's root)
		defaultConfig.loaderPatch.nodeRequire = require;
	}

	 0 && has.add("host-rhino", userConfig.has && "host-rhino" in userConfig.has ?
		userConfig.has["host-rhino"] :
		(typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
	if( 0 ){
		// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...
		for(var baseUrl = userConfig.baseUrl || ".", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){
			arg = (rhinoArgs[i++] + "").split("=");
			if(arg[0] == "baseUrl"){
				baseUrl = arg[1];
				break;
			}
		}
		load(baseUrl + "/_base/configRhino.js");
		rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
	}

	has.add("host-webworker", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));
	if(has("host-webworker")){
		mix(defaultConfig.hasCache, {
			"host-browser": 0,
			"dom": 0,
			"dojo-dom-ready-api": 0,
			"dojo-sniff": 0,
			"dojo-inject-api": 1,
			"host-webworker": 1
		});

		defaultConfig.loaderPatch = {
			injectUrl: function(url, callback){
				// TODO:
				//		This is not async, nor can it be in Webworkers.  It could be made better by passing
				//		the entire require array into importScripts at.  This way the scripts are loaded in
				//		async mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers
				//		tend to be long running where initial startup is not a major factor.

				try{
					importScripts(url);
					callback();
				}catch(e){
					console.info("failed to load resource (" + url + ")");
					console.error(e);
				}
			}
		};
	}

	// userConfig has tests override defaultConfig has tests; do this after the environment detection because
	// the environment detection usually sets some has feature values in the hasCache.
	for(var p in userConfig.has){
		has.add(p, userConfig.has[p], 0, 1);
	}

	//
	// define the loader data
	//

	// the loader will use these like symbols if the loader has the traceApi; otherwise
	// define magic numbers so that modules can be provided as part of defaultConfig
	var	requested = 1,
		arrived = 2,
		nonmodule = 3,
		executing = 4,
		executed = 5;

	if( 0 ){
		// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code
		requested = "requested";
		arrived = "arrived";
		nonmodule = "not-a-module";
		executing = "executing";
		executed = "executed";
	}

	var legacyMode = 0,
		sync = "sync",
		xd = "xd",
		syncExecStack = [],
		dojoRequirePlugin = 0,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	if( 1 ){
		req.isXdUrl = noop;

		req.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){
			// the first dojo/_base/loader loaded gets to define these variables; they are designed to work
			// in the presence of zero to many mapped dojo/_base/loaders
			if(!dojoRequirePlugin){
				dojoRequirePlugin = dojoRequirePlugin_;
				checkDojoRequirePlugin = checkDojoRequirePlugin_;
				transformToAmd = transformToAmd_;
			}

			return {
				sync:sync,
				requested:requested,
				arrived:arrived,
				nonmodule:nonmodule,
				executing:executing,
				executed:executed,
				syncExecStack:syncExecStack,
				modules:modules,
				execQ:execQ,
				getModule:getModule,
				injectModule:injectModule,
				setArrived:setArrived,
				signal:signal,
				finishExec:finishExec,
				execModule:execModule,
				dojoRequirePlugin:dojoRequirePlugin,
				getLegacyMode:function(){return legacyMode;},
				guardCheckComplete:guardCheckComplete
			};
		};

		if( 1  || has("host-webworker")){
			// in legacy sync mode, the loader needs a minimal XHR library

			var locationProtocol = location.protocol,
				locationHost = location.host;
			req.isXdUrl = function(url){
				if(/^\./.test(url)){
					// begins with a dot is always relative to page URL; therefore not xdomain
					return false;
				}
				if(/^\/\//.test(url)){
					// for v1.6- backcompat, url starting with // indicates xdomain
					return true;
				}
				// get protocol and host
				// \/+ takes care of the typical file protocol that looks like file:///drive/path/to/file
				// locationHost is falsy if file protocol => if locationProtocol matches and is "file:", || will return false
				var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
				return match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));
			};


			// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config
			 1 || has.add("dojo-xhr-factory", 1);
			has.add("dojo-force-activex-xhr",  1  && !doc.addEventListener && window.location.protocol == "file:");
			has.add("native-xhr", typeof XMLHttpRequest != "undefined");
			if(has("native-xhr") && !has("dojo-force-activex-xhr")){
				getXhr = function(){
					return new XMLHttpRequest();
				};
			}else{
				// if in the browser an old IE; find an xhr
				for(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){
					try{
						progid = XMLHTTP_PROGIDS[i++];
						if(new ActiveXObject(progid)){
							// this progid works; therefore, use it from now on
							break;
						}
					}catch(e){
						// squelch; we're just trying to find a good ActiveX progid
						// if they all fail, then progid ends up as the last attempt and that will signal the error
						// the first time the client actually tries to exec an xhr
					}
				}
				getXhr = function(){
					return new ActiveXObject(progid);
				};
			}
			req.getXhr = getXhr;

			has.add("dojo-gettext-api", 1);
			req.getText = function(url, async, onLoad){
				var xhr = getXhr();
				xhr.open('GET', fixupUrl(url), false);
				xhr.send(null);
				if(xhr.status == 200 || (!location.host && !xhr.status)){
					if(onLoad){
						onLoad(xhr.responseText, async);
					}
				}else{
					throw makeError("xhrFailed", xhr.status);
				}
				return xhr.responseText;
			};
		}
	}else{
		req.async = 1;
	}

	//
	// loader eval
	//
	var eval_ =
		// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution
		new Function('return eval(arguments[0]);');

	req.eval =
		function(text, hint){
			return eval_(text + "\r\n//# sourceURL=" + hint);
		};

	//
	// loader micro events API
	//
	var listenerQueues = {},
		error = "error",
		signal = req.signal = function(type, args){
			var queue = listenerQueues[type];
			// notice we run a copy of the queue; this allows listeners to add/remove
			// other listeners without affecting this particular signal
			forEach(queue && queue.slice(0), function(listener){
				listener.apply(null, isArray(args) ? args : [args]);
			});
		},
		on = req.on = function(type, listener){
			// notice a queue is not created until a client actually connects
			var queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			return {
				remove:function(){
					for(var i = 0; i<queue.length; i++){
						if(queue[i]===listener){
							queue.splice(i, 1);
							return;
						}
					}
				}
			};
		};

	// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
	// lexical variables hold key loader data structures to help with minification; these may be completely,
	// one-time initialized by defaultConfig for optimized/built versions
	var
		aliases
			// a vector of pairs of [regexs or string, replacement] => (alias, actual)
			= [],

		paths
			// CommonJS paths
			= {},

		pathsMapProg
			// list of (from-path, to-path, regex, length) derived from paths;
			// a "program" to apply paths; see computeMapProg
			= [],

		packs
			// a map from packageId to package configuration object; see fixupPackageInfo
			= {},

		map = req.map
			// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map
			= {},

		mapProgs
			// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
			= [],

		modules
			// A hash:(mid) --> (module-object) the module namespace
			//
			// pid: the package identifier to which the module belongs (e.g., "dojo"); "" indicates the system or default package
			// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., "dojo/io/script")
			// url: the URL from which the module was retrieved
			// pack: the package object of the package to which the module belongs
			// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed
			// deps: the dependency vector for this module (vector of modules objects)
			// def: the factory for this module
			// result: the result of the running the factory for this module
			// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define
			// load: plugin load function; applicable only for plugins
			//
			// Modules go through several phases in creation:
			//
			// 1. Requested: some other module's definition or a require application contained the requested module in
			//	  its dependency vector or executing code explicitly demands a module via req.require.
			//
			// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL
			//
			// 3. Loaded: the resource injected in [2] has been evaluated.
			//
			// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some
			//	  resources may just contain a bundle of code and never formally define a module via define
			//
			// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
			= {},

		cacheBust
			// query string to append to module URLs to bust browser cache
			= "",

		cache
			// hash:(mid | url)-->(function | string)
			//
			// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or
			// url --> string. The url key is distinguished from the mid key by always containing the prefix "url:". url keys as provided
			// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided
			// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.
			//
			// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given
			// by any mappings *iff* the config.cache was received as part of a module resource request.
			//
			// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules
			// to retrieve cached items that may have arrived consequent to another namespace.
			//
			 = {},

		urlKeyPrefix
			// the prefix to prepend to a URL key in the cache.
			= "url:",

		pendingCacheInsert
			// hash:(mid)-->(function)
			//
			// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
			// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another
			// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending
			// cache for the local configuration, possibly relocating modules.
			 = {},

		dojoSniffConfig
			// map of configuration variables
			// give the data-dojo-config as sniffed from the document (if any)
			= {},

		insertPointSibling
			// the nodes used to locate where scripts are injected into the document
			= 0;

	if( 1 ){
		var consumePendingCacheInsert = function(referenceModule){
				var p, item, match, now, m;
				for(p in pendingCacheInsert){
					item = pendingCacheInsert[p];
					match = p.match(/^url\:(.+)/);
					if(match){
						cache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;
					}else if(p=="*now"){
						now = item;
					}else if(p!="*noref"){
						m = getModuleInfo(p, referenceModule, true);
						cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
					}
				}
				if(now){
					now(createRequire(referenceModule));
				}
				pendingCacheInsert = {};
			},

			escapeString = function(s){
				return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c){ return "\\" + c; });
			},

			computeMapProg = function(map, dest){
				// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
				// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
				// of-map-key. The regex looks for the map-key followed by either "/" or end-of-string at the beginning
				// of a the search source. Notice the map-value is irrelevant to the algorithm
				dest.splice(0, dest.length);
				for(var p in map){
					dest.push([
						p,
						map[p],
						new RegExp("^" + escapeString(p) + "(\/|$)"),
						p.length]);
				}
				dest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });
				return dest;
			},

			computeAliases = function(config, dest){
				forEach(config, function(pair){
					// take a fixed-up copy...
					dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]]);
				});
			},


			fixupPackageInfo = function(packageInfo){
				// calculate the precise (name, location, main, mappings) for a package
				var name = packageInfo.name;
				if(!name){
					// packageInfo must be a string that gives the name
					name = packageInfo;
					packageInfo = {name:name};
				}
				packageInfo = mix({main:"main"}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;

				// packageMap is deprecated in favor of AMD map
				if(packageInfo.packageMap){
					map[name] = packageInfo.packageMap;
				}

				if(!packageInfo.main.indexOf("./")){
					packageInfo.main = packageInfo.main.substring(2);
				}

				// now that we've got a fully-resolved package object, push it into the configuration
				packs[name] = packageInfo;
			},

			delayedModuleConfig
				// module config cannot be consumed until the loader is completely initialized; therefore, all
				// module config detected during booting is memorized and applied at the end of loader initialization
				// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but
				// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete
				= [],


			config = function(config, booting, referenceModule){
				for(var p in config){
					if(p=="waitSeconds"){
						req.waitms = (config[p] || 0) * 1000;
					}
					if(p=="cacheBust"){
						cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + "") : "";
					}
					if(p=="baseUrl" || p=="combo"){
						req[p] = config[p];
					}
					if( 1  && p=="async"){
						// falsy or "sync" => legacy sync loader
						// "xd" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)
						// "legacyAsync" => permanently in "xd" by choice
						// "debugAtAllCosts" => trying to load everything via script injection (not implemented)
						// otherwise, must be truthy => AMD
						// legacyMode: sync | legacyAsync | xd | false
						var mode = config[p];
						req.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));
						req.async = !legacyMode;
					}
					if(config[p]!==hasCache){
						// accumulate raw config info for client apps which can use this to pass their own config
						req.rawConfig[p] = config[p];
						p!="has" && has.add("config-"+p, config[p], 0, booting);
					}
				}

				// make sure baseUrl exists
				if(!req.baseUrl){
					req.baseUrl = "./";
				}
				// make sure baseUrl ends with a slash
				if(!/\/$/.test(req.baseUrl)){
					req.baseUrl += "/";
				}

				// now do the special work for has, packages, packagePaths, paths, aliases, and cache

				for(p in config.has){
					has.add(p, config.has[p], 0, booting);
				}

				// for each package found in any packages config item, augment the packs map owned by the loader
				forEach(config.packages, fixupPackageInfo);

				// for each packagePath found in any packagePaths config item, augment the packageConfig
				// packagePaths is deprecated; remove in 2.0
				for(var baseUrl in config.packagePaths){
					forEach(config.packagePaths[baseUrl], function(packageInfo){
						var location = baseUrl + "/" + packageInfo;
						if(isString(packageInfo)){
							packageInfo = {name:packageInfo};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}

				// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
				// is published (see dojo-publish-privates), the published variable will always hold a valid value.

				// this must come after all package processing since package processing may mutate map
				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, function(item){
					item[1] = computeMapProg(item[1], []);
					if(item[0]=="*"){
						mapProgs.star = item;
					}
				});

				// push in any paths and recompute the internal pathmap
				computeMapProg(mix(paths, config.paths), pathsMapProg);

				// aliases
				computeAliases(config.aliases, aliases);

				if(booting){
					delayedModuleConfig.push({config:config.config});
				}else{
					for(p in config.config){
						var module = getModule(p, referenceModule);
						module.config = mix(module.config || {}, config.config[p]);
					}
				}

				// push in any new cache values
				if(config.cache){
					consumePendingCacheInsert();
					pendingCacheInsert = config.cache;
					if(config.cache["*noref"]){
						consumePendingCacheInsert();
					}
				}

				signal("config", [config, req.rawConfig]);
			};

		//
		// execute the various sniffs; userConfig can override and value
		//

		if(has("dojo-cdn") ||  1 ){
			// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.
			// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the
			// dojo location on CDN deployments and baseUrl when either/both of these are not provided
			// explicitly in the config data; this is the 1.6- behavior.

			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script, dojoDir, src, match;
			while(i < scripts.length){
				script = scripts[i++];
				if((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))){
					// sniff dojoDir and baseUrl
					dojoDir = match[3] || "";
					defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff configuration on attribute in script element
				if((src = (script.getAttribute("data-dojo-config") || script.getAttribute("djConfig")))){
					dojoSniffConfig = req.eval("({ " + src + " })", "data-dojo-config");

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff requirejs attribute
				if( 0 ){
					if((src = script.getAttribute("data-main"))){
						dojoSniffConfig.deps = dojoSniffConfig.deps || [src];
					}
				}
			}
		}

		if( 0 ){
			// pass down doh.testConfig from parent as if it were a data-dojo-config
			try{
				if(window.parent != window && window.parent.require){
					var doh = window.parent.require("doh");
					doh && mix(dojoSniffConfig, doh.testConfig);
				}
			}catch(e){}
		}

		// configure the loader; let the user override defaults
		req.rawConfig = {};
		config(defaultConfig, 1);

		// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides
		if(has("dojo-cdn")){
			packs.dojo.location = dojoDir;
			if(dojoDir){
				dojoDir += "/";
			}
			packs.dijit.location = dojoDir + "../dijit/";
			packs.dojox.location = dojoDir + "../dojox/";
		}

		config(userConfig, 1);
		config(dojoSniffConfig, 1);

	}else{
		// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application
		paths = defaultConfig.paths;
		pathsMapProg = defaultConfig.pathsMapProg;
		packs = defaultConfig.packs;
		aliases = defaultConfig.aliases;
		mapProgs = defaultConfig.mapProgs;
		modules = defaultConfig.modules;
		cache = defaultConfig.cache;
		cacheBust = defaultConfig.cacheBust;

		// remember the default config for other processes (e.g., dojo/config)
		req.rawConfig = defaultConfig;
	}


	if( 0 ){
		req.combo = req.combo || {add:noop};
		var	comboPending = 0,
			combosPending = [],
			comboPendingTimer = null;
	}


	// build the loader machinery iaw configuration, including has feature tests
	var	injectDependencies = function(module){
			// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
			guardCheckComplete(function(){
				forEach(module.deps, injectModule);
				if( 0  && comboPending && !comboPendingTimer){
					comboPendingTimer = setTimeout(function() {
						comboPending = 0;
						comboPendingTimer = null;
						req.combo.done(function(mids, url) {
							var onLoadCallback= function(){
								// defQ is a vector of module definitions 1-to-1, onto mids
								runDefQ(0, mids);
								checkComplete();
							};
							combosPending.push(mids);
							injectingModule = mids;
							req.injectUrl(url, onLoadCallback, mids);
							injectingModule = 0;
						}, req);
					}, 0);
				}
			});
		},

		contextRequire = function(a1, a2, a3, referenceModule, contextRequire){
			var module, syntheticMid;
			if(isString(a1)){
				// signature is (moduleId)
				module = getModule(a1, referenceModule, true);
				if(module && module.executed){
					return module.result;
				}
				throw makeError("undefinedModule", a1);
			}
			if(!isArray(a1)){
				// a1 is a configuration
				config(a1, 0, referenceModule);

				// juggle args; (a2, a3) may be (dependencies, callback)
				a1 = a2;
				a2 = a3;
			}
			if(isArray(a1)){
				// signature is (requestList [,callback])
				if(!a1.length){
					a2 && a2();
				}else{
					syntheticMid = "require*" + uid();

					// resolve the request list with respect to the reference module
					for(var mid, deps = [], i = 0; i < a1.length;){
						mid = a1[i++];
						deps.push(getModule(mid, referenceModule));
					}

					// construct a synthetic module to control execution of the requestList, and, optionally, callback
					module = mix(makeModuleInfo("", syntheticMid, 0, ""), {
						injected: arrived,
						deps: deps,
						def: a2 || noop,
						require: referenceModule ? referenceModule.require : req,
						gc: 1 //garbage collect
					});
					modules[module.mid] = module;

					// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
					injectDependencies(module);

					// try to immediately execute
					// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe
					// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.
					// ...but *always* insist on immediate in synch mode
					var strict = checkCompleteGuard && legacyMode!=sync;
					guardCheckComplete(function(){
						execModule(module, strict);
					});
					if(!module.executed){
						// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ
						execQ.push(module);
					}
					checkComplete();
				}
			}
			return contextRequire;
		},

		createRequire = function(module){
			if(!module){
				return req;
			}
			var result = module.require;
			if(!result){
				result = function(a1, a2, a3){
					return contextRequire(a1, a2, a3, module, result);
				};
				module.require = mix(result, req);
				result.module = module;
				result.toUrl = function(name){
					return toUrl(name, module);
				};
				result.toAbsMid = function(mid){
					return toAbsMid(mid, module);
				};
				if( 0 ){
					result.undef = function(mid){
						req.undef(mid, module);
					};
				}
				if( 1 ){
					result.syncLoadNls = function(mid){
						var nlsModuleInfo = getModuleInfo(mid, module),
							nlsModule = modules[nlsModuleInfo.mid];
						if(!nlsModule || !nlsModule.executed){
							cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
							if(cached){
								evalModuleText(cached);
								nlsModule = modules[nlsModuleInfo.mid];
							}
						}
						return nlsModule && nlsModule.executed && nlsModule.result;
					};
				}

			}
			return result;
		},

		execQ =
			// The list of modules that need to be evaluated.
			[],

		defQ =
			// The queue of define arguments sent to loader.
			[],

		waiting =
			// The set of modules upon which the loader is waiting for definition to arrive
			{},

		setRequested = function(module){
			module.injected = requested;
			waiting[module.mid] = 1;
			if(module.url){
				waiting[module.url] = module.pack || 1;
			}
			startTimer();
		},

		setArrived = function(module){
			module.injected = arrived;
			delete waiting[module.mid];
			if(module.url){
				delete waiting[module.url];
			}
			if(isEmpty(waiting)){
				clearTimer();
				 1  && legacyMode==xd && (legacyMode = sync);
			}
		},

		execComplete = req.idle =
			// says the loader has completed (or not) its work
			function(){
				return !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;
			},

		runMapProg = function(targetMid, map){
			// search for targetMid in map; return the map item if found; falsy otherwise
			if(map){
			for(var i = 0; i < map.length; i++){
				if(map[i][2].test(targetMid)){
					return map[i];
				}
			}
			}
			return 0;
		},

		compactPath = function(path){
			var result = [],
				segment, lastSegment;
			path = path.replace(/\\/g, '/').split('/');
			while(path.length){
				segment = path.shift();
				if(segment==".." && result.length && lastSegment!=".."){
					result.pop();
					lastSegment = result[result.length - 1];
				}else if(segment!="."){
					result.push(lastSegment= segment);
				} // else ignore "."
			}
			return result.join("/");
		},

		makeModuleInfo = function(pid, mid, pack, url){
			if( 1 ){
				var xd= req.isXdUrl(url);
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};
			}else{
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
			}
		},

		getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate){
			// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
			// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader
			var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = /^\./.test(mid);
			if(/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative && !referenceModule)){
				// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
				// whatever it is, it's not a module but just a URL of some sort
				// note: pid===0 indicates the routine is returning an unmodified mid

				return makeModuleInfo(0, mid, 0, mid);
			}else{
				// relative module ids are relative to the referenceModule; get rid of any dots
				mid = compactPath(isRelative ? (referenceModule.mid + "/../" + mid) : mid);
				if(/^\./.test(mid)){
					throw makeError("irrationalPath", mid);
				}
				// at this point, mid is an absolute mid

				// map the mid
				if(referenceModule){
					mapItem = runMapProg(referenceModule.mid, mapProgs);
				}
				mapItem = mapItem || mapProgs.star;
				mapItem = mapItem && runMapProg(mid, mapItem[1]);

				if(mapItem){
					mid = mapItem[1] + mid.substring(mapItem[3]);
					}

				match = mid.match(/^([^\/]+)(\/(.+))?$/);
				pid = match ? match[1] : "";
				if((pack = packs[pid])){
					mid = pid + "/" + (midInPackage = (match[3] || pack.main));
				}else{
					pid = "";
				}

				// search aliases
				var candidateLength = 0,
					candidate = 0;
				forEach(aliases, function(pair){
					var match = mid.match(pair[0]);
					if(match && match.length>candidateLength){
						candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
					}
				});
				if(candidate){
					return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
				}

				result = modules[mid];
				if(result){
					return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}
			// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
			// fully resolved (i.e., all relative indicators and package mapping resolved) module id

			// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid
			mapItem = runMapProg(mid, pathsMapProg);
			if(mapItem){
				url = mapItem[1] + mid.substring(mapItem[3]);
			}else if(pid){
				url = pack.location + "/" + midInPackage;
			}else if(has("config-tlmSiblingOfDojo")){
				url = "../" + mid;
			}else{
				url = mid;
			}
			// if result is not absolute, add baseUrl
			if(!(/(^\/)|(\:)/.test(url))){
				url = baseUrl + url;
			}
			url += ".js";
			return makeModuleInfo(pid, mid, pack, compactPath(url));
		},

		getModuleInfo = function(mid, referenceModule, fromPendingCache){
			return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, fromPendingCache ? [] : mapProgs, fromPendingCache ? [] : pathsMapProg, fromPendingCache ? [] : aliases);
		},

		resolvePluginResourceId = function(plugin, prid, referenceModule){
			return plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);
		},

		dynamicPluginUidGenerator = 0,

		getModule = function(mid, referenceModule, immediate){
			// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule
			var match, plugin, prid, result;
			match = mid.match(/^(.+?)\!(.*)$/);
			if(match){
				// name was <plugin-module>!<plugin-resource-id>
				plugin = getModule(match[1], referenceModule, immediate);

				if( 1  && legacyMode == sync && !plugin.executed){
					injectModule(plugin);
					if(plugin.injected===arrived && !plugin.executed){
						guardCheckComplete(function(){
							execModule(plugin);
						});
					}
					if(plugin.executed){
						promoteModuleToPlugin(plugin);
					}else{
						// we are in xdomain mode for some reason
						execQ.unshift(plugin);
					}
				}



				if(plugin.executed === executed && !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise
				if(plugin.load){
					prid = resolvePluginResourceId(plugin, match[2], referenceModule);
					mid = (plugin.mid + "!" + (plugin.dynamic ? ++dynamicPluginUidGenerator + "!" : "") + prid);
				}else{
					prid = match[2];
					mid = plugin.mid + "!" + (++dynamicPluginUidGenerator) + "!waitingForPlugin";
				}
				result = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};
			}else{
				result = getModuleInfo(mid, referenceModule);
			}
			return modules[result.mid] || (!immediate && (modules[result.mid] = result));
		},

		toAbsMid = req.toAbsMid = function(mid, referenceModule){
			return getModuleInfo(mid, referenceModule).mid;
		},

		toUrl = req.toUrl = function(name, referenceModule){
			var moduleInfo = getModuleInfo(name+"/x", referenceModule),
				url= moduleInfo.url;
			return fixupUrl(moduleInfo.pid===0 ?
				// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases
				name :
				// "/x.js" since getModuleInfo automatically appends ".js" and we appended "/x" to make name look like a module id
				url.substring(0, url.length-5)
			);
		},

		nonModuleProps = {
			injected: arrived,
			executed: executed,
			def: nonmodule,
			result: nonmodule
		},

		makeCjs = function(mid){
			return modules[mid] = mix({mid:mid}, nonModuleProps);
		},

		cjsRequireModule = makeCjs("require"),
		cjsExportsModule = makeCjs("exports"),
		cjsModuleModule = makeCjs("module"),

		runFactory = function(module, args){
			req.trace("loader-run-factory", [module.mid]);
			var factory = module.def,
				result;
			 1  && syncExecStack.unshift(module);
			if(has("config-dojo-loader-catches")){
				try{
					result= isFunction(factory) ? factory.apply(null, args) : factory;
				}catch(e){
					signal(error, module.result = makeError("factoryThrew", [module, e]));
				}
			}else{
				result= isFunction(factory) ? factory.apply(null, args) : factory;
			}
			module.result = result===undefined && module.cjs ? module.cjs.exports : result;
			 1  && syncExecStack.shift(module);
		},

		abortExec = {},

		defOrder = 0,

		promoteModuleToPlugin = function(pluginModule){
			var plugin = pluginModule.result;
			pluginModule.dynamic = plugin.dynamic;
			pluginModule.normalize = plugin.normalize;
			pluginModule.load = plugin.load;
			return pluginModule;
		},

		resolvePluginLoadQ = function(plugin){
			// plugins is a newly executed module that has a loadQ waiting to run

			// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid
			// recall the original mid was created before the plugin was on board and therefore it was impossible to
			// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change
			var map = {};
			forEach(plugin.loadQ, function(pseudoPluginResource){
				// manufacture and insert the real module in modules
				var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
					mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + "!" + prid),
					pluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});
				if(!modules[mid]){
					// create a new (the real) plugin resource and inject it normally now that the plugin is on board
					injectPlugin(modules[mid] = pluginResource);
				} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin

				// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)
				// mark is as arrived and delete it from modules; the real module was requested above
				map[pseudoPluginResource.mid] = modules[mid];
				setArrived(pseudoPluginResource);
				delete modules[pseudoPluginResource.mid];
			});
			plugin.loadQ = 0;

			// step2: replace all references to any placeholder modules with real modules
			var substituteModules = function(module){
				for(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){
					replacement = map[deps[i].mid];
					if(replacement){
						deps[i] = replacement;
					}
				}
			};
			for(var p in modules){
				substituteModules(modules[p]);
			}
			forEach(execQ, substituteModules);
		},

		finishExec = function(module){
			req.trace("loader-finish-exec", [module.mid]);
			module.executed = executed;
			module.defOrder = defOrder++;
			 1  && forEach(module.provides, function(cb){ cb(); });
			if(module.loadQ){
				// the module was a plugin
				promoteModuleToPlugin(module);
				resolvePluginLoadQ(module);
			}
			// remove all occurrences of this module from the execQ
			for(i = 0; i < execQ.length;){
				if(execQ[i] === module){
					execQ.splice(i, 1);
				}else{
					i++;
				}
			}
			// delete references to synthetic modules
			if (/^require\*/.test(module.mid)) {
				delete modules[module.mid];
			}
		},

		circleTrace = [],

		execModule = function(module, strict){
			// run the dependency vector, then run the factory for module
			if(module.executed === executing){
				req.trace("loader-circular-dependency", [circleTrace.concat(module.mid).join("->")]);
				return (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);
			}
			// at this point the module is either not executed or fully executed


			if(!module.executed){
				if(!module.def){
					return abortExec;
				}
				var mid = module.mid,
					deps = module.deps || [],
					arg, argResult,
					args = [],
					i = 0;

				if( 0 ){
					circleTrace.push(mid);
					req.trace("loader-exec-module", ["exec", circleTrace.length, mid]);
				}

				// for circular dependencies, assume the first module encountered was executed OK
				// modules that circularly depend on a module that has not run its factory will get
				// the pre-made cjs.exports===module.result. They can take a reference to this object and/or
				// add properties to it. When the module finally runs its factory, the factory can
				// read/write/replace this object. Notice that so long as the object isn't replaced, any
				// reference taken earlier while walking the deps list is still valid.
				module.executed = executing;
				while((arg = deps[i++])){
					argResult = ((arg === cjsRequireModule) ? createRequire(module) :
									((arg === cjsExportsModule) ? module.cjs.exports :
										((arg === cjsModuleModule) ? module.cjs :
											execModule(arg, strict))));
					if(argResult === abortExec){
						module.executed = 0;
						req.trace("loader-exec-module", ["abort", mid]);
						 0  && circleTrace.pop();
						return abortExec;
					}
					args.push(argResult);
				}
				runFactory(module, args);
				finishExec(module);
				 0  && circleTrace.pop();
			}
			// at this point the module is guaranteed fully executed

			return module.result;
		},


		checkCompleteGuard = 0,

		guardCheckComplete = function(proc){
			try{
				checkCompleteGuard++;
				proc();
			}finally{
				checkCompleteGuard--;
			}
			if(execComplete()){
				signal("idle", []);
			}
		},

		checkComplete = function(){
			// keep going through the execQ as long as at least one factory is executed
			// plugins, recursion, cached modules all make for many execution path possibilities
			if(checkCompleteGuard){
				return;
			}
			guardCheckComplete(function(){
				checkDojoRequirePlugin();
				for(var currentDefOrder, module, i = 0; i < execQ.length;){
					currentDefOrder = defOrder;
					module = execQ[i];
					execModule(module);
					if(currentDefOrder!=defOrder){
						// defOrder was bumped one or more times indicating something was executed (note, this indicates
						// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)
						checkDojoRequirePlugin();
						i = 0;
					}else{
						// nothing happened; check the next module in the exec queue
						i++;
					}
				}
			});
		};


	if( 0 ){
		req.undef = function(moduleId, referenceModule){
			// In order to reload a module, it must be undefined (this routine) and then re-requested.
			// This is useful for testing frameworks (at least).
			var module = getModule(moduleId, referenceModule);
			setArrived(module);
			mix(module, {def:0, executed:0, injected:0, node:0});
		};
	}

	if( 1 ){
		if(has("dojo-loader-eval-hint-url")===undefined){
			has.add("dojo-loader-eval-hint-url", 1);
		}

		var fixupUrl= typeof userConfig.fixupUrl == "function" ? userConfig.fixupUrl : function(url){
				url += ""; // make sure url is a Javascript string (some paths may be a Java string)
				return url + (cacheBust ? ((/\?/.test(url) ? "&" : "?") + cacheBust) : "");
			},

			injectPlugin = function(
				module
			){
				// injects the plugin module given by module; may have to inject the plugin itself
				var plugin = module.plugin;

				if(plugin.executed === executed && !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				var onLoad = function(def){
						module.result = def;
						setArrived(module);
						finishExec(module);
						checkComplete();
					};

				if(plugin.load){
					plugin.load(module.prid, module.req, onLoad);
				}else if(plugin.loadQ){
					plugin.loadQ.push(module);
				}else{
					// the unshift instead of push is important: we don't want plugins to execute as
					// dependencies of some other module because this may cause circles when the plugin
					// loadQ is run; also, generally, we want plugins to run early since they may load
					// several other modules and therefore can potentially unblock many modules
					plugin.loadQ = [module];
					execQ.unshift(plugin);
					injectModule(plugin);
				}
			},

			// for IE, injecting a module may result in a recursive execution if the module is in the cache

			cached = 0,

			injectingModule = 0,

			injectingCachedModule = 0,

			evalModuleText = function(text, module){
				// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit
				if(has("config-stripStrict")){
					text = text.replace(/"use strict"/g, '');
				}
				injectingCachedModule = 1;
				if(has("config-dojo-loader-catches")){
					try{
						if(text===cached){
							cached.call(null);
						}else{
							req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
						}
					}catch(e){
						signal(error, makeError("evalModuleThrew", module));
					}
				}else{
					if(text===cached){
						cached.call(null);
					}else{
						req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
					}
				}
				injectingCachedModule = 0;
			},

			injectModule = function(module){
				// Inject the module. In the browser environment, this means appending a script element into
				// the document; in other environments, it means loading a file.
				//
				// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.

				var mid = module.mid,
					url = module.url;
				if(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){
					return;
				}
				setRequested(module);

				if( 0 ){
					var viaCombo = 0;
					if(module.plugin && module.plugin.isCombo){
						// a combo plugin; therefore, must be handled by combo service
						// the prid should have already been converted to a URL (if required by the plugin) during
						// the normalize process; in any event, there is no way for the loader to know how to
						// to the conversion; therefore the third argument is zero
						req.combo.add(module.plugin.mid, module.prid, 0, req);
						viaCombo = 1;
					}else if(!module.plugin){
						viaCombo = req.combo.add(0, module.mid, module.url, req);
					}
					if(viaCombo){
						comboPending= 1;
						return;
					}
				}

				if(module.plugin){
					injectPlugin(module);
					return;
				} // else a normal module (not a plugin)


				var onLoadCallback = function(){
					runDefQ(module);
					if(module.injected !== arrived){
						// the script that contained the module arrived and has been executed yet
						// nothing was added to the defQ (so it wasn't an AMD module) and the module
						// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);
						// therefore, it must not have been a module; adjust state accordingly
						if(has("dojo-enforceDefine")){
							signal(error, makeError("noDefine", module));
							return;
						}
						setArrived(module);
						mix(module, nonModuleProps);
						req.trace("loader-define-nonmodule", [module.url]);
					}

					if( 1  && legacyMode){
						// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;
						// but, if xd loading, then don't call checkComplete until out of the current sync traversal
						// in order to preserve order of execution of the dojo.required modules
						!syncExecStack.length && checkComplete();
					}else{
						checkComplete();
					}
				};
				cached = cache[mid] || cache[urlKeyPrefix + module.url];
				if(cached){
					req.trace("loader-inject", ["cache", module.mid, url]);
					evalModuleText(cached, module);
					onLoadCallback();
					return;
				}
				if( 1  && legacyMode){
					if(module.isXd){
						// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}
						legacyMode==sync && (legacyMode = xd);
						// fall through and load via script injection
					}else if(module.isAmd && legacyMode!=sync){
						// fall through and load via script injection
					}else{
						// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain
						var xhrCallback = function(text){
							if(legacyMode==sync){
								// the top of syncExecStack gives the current synchronously executing module; the loader needs
								// to know this if it has to switch to async loading in the middle of evaluating a legacy module
								// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain
								// (using unshift/shift because there is no back() methods for Javascript arrays)
								syncExecStack.unshift(module);
								evalModuleText(text, module);
								syncExecStack.shift();

								// maybe the module was an AMD module
								runDefQ(module);

								// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing
								if(!module.cjs){
									setArrived(module);
									finishExec(module);
								}

								if(module.finish){
									// while synchronously evaluating this module, dojo.require was applied referencing a module
									// that had to be loaded async; therefore, the loader stopped answering all dojo.require
									// requests so they could be answered completely in the correct sequence; module.finish gives
									// the list of dojo.requires that must be re-applied once all target modules are available;
									// make a synthetic module to execute the dojo.require's in the correct order

									// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module
									// TODO: can we just leave the module.finish...what's it hurting?
									var finishMid = mid + "*finish",
										finish = module.finish;
									delete module.finish;

									def(finishMid, ["dojo", ("dojo/require!" + finish.join(",")).replace(/\./g, "/")], function(dojo){
										forEach(finish, function(mid){ dojo.require(mid); });
									});
									// unshift, not push, which causes the current traversal to be reattempted from the top
									execQ.unshift(getModule(finishMid));
								}
								onLoadCallback();
							}else{
								text = transformToAmd(module, text);
								if(text){
									evalModuleText(text, module);
									onLoadCallback();
								}else{
									// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected
									// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)
									injectingModule = module;
									req.injectUrl(fixupUrl(url), onLoadCallback, module);
									injectingModule = 0;
								}
							}
						};

						req.trace("loader-inject", ["xhr", module.mid, url, legacyMode!=sync]);
						if(has("config-dojo-loader-catches")){
							try{
								req.getText(url, legacyMode!=sync, xhrCallback);
							}catch(e){
								signal(error, makeError("xhrInjectFailed", [module, e]));
							}
						}else{
							req.getText(url, legacyMode!=sync, xhrCallback);
						}
						return;
					}
				} // else async mode or fell through in xdomain loading mode; either way, load by script injection
				req.trace("loader-inject", ["script", module.mid, url]);
				injectingModule = module;
				req.injectUrl(fixupUrl(url), onLoadCallback, module);
				injectingModule = 0;
			},

			defineModule = function(module, deps, def){
				req.trace("loader-define-module", [module.mid, deps]);

				if( 0  && module.plugin && module.plugin.isCombo){
					// the module is a plugin resource loaded by the combo service
					// note: check for module.plugin should be enough since normal plugin resources should
					// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders
					module.result = isFunction(def) ? def() : def;
					setArrived(module);
					finishExec(module);
					return module;
				}

				var mid = module.mid;
				if(module.injected === arrived){
					signal(error, makeError("multipleDefine", module));
					return module;
				}
				mix(module, {
					deps: deps,
					def: def,
					cjs: {
						id: module.mid,
						uri: module.url,
						exports: (module.result = {}),
						setExports: function(exports){
							module.cjs.exports = exports;
						},
						config:function(){
							return module.config;
						}
					}
				});

				// resolve deps with respect to this module
				for(var i = 0; deps[i]; i++){
					deps[i] = getModule(deps[i], module);
				}

				if( 1  && legacyMode && !waiting[mid]){
					// the module showed up without being asked for; it was probably in a <script> element
					injectDependencies(module);
					execQ.push(module);
					checkComplete();
				}
				setArrived(module);

				if(!isFunction(def) && !deps.length){
					module.result = def;
					finishExec(module);
				}

				return module;
			},

			runDefQ = function(referenceModule, mids){
				// defQ is an array of [id, dependencies, factory]
				// mids (if any) is a vector of mids given by a combo service
				var definedModules = [],
					module, args;
				while(defQ.length){
					args = defQ.shift();
					mids && (args[0]= mids.shift());
					// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully
					// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue
					// TODO: what if no args[0] and no referenceModule
					module = (args[0] && getModule(args[0])) || referenceModule;
					definedModules.push([module, args[1], args[2]]);
				}
				consumePendingCacheInsert(referenceModule);
				forEach(definedModules, function(args){
					injectDependencies(defineModule.apply(null, args));
				});
			};
	}

	var timerId = 0,
		clearTimer = noop,
		startTimer = noop;
	if( 1 ){
		// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.
		clearTimer = function(){
			timerId && clearTimeout(timerId);
			timerId = 0;
		};

		startTimer = function(){
			clearTimer();
			if(req.waitms){
				timerId = global.setTimeout(function(){
					clearTimer();
					signal(error, makeError("timeout", waiting));
				}, req.waitms);
			}
		};
	}

	if ( 1 ) {
		// Test for IE's different way of signaling when scripts finish loading.  Note that according to
		// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the
		// IE specific code path even though it has an addEventListener() method.
		// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.
		// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()
		//  is defined in both those environments.
		has.add("ie-event-behavior", doc.attachEvent && typeof Windows === "undefined" &&
			(typeof opera === "undefined" || opera.toString() != "[object Opera]"));
	}

	if( 1  && ( 1  ||  1 )){
		var domOn = function(node, eventName, ieEventName, handler){
				// Add an event listener to a DOM node using the API appropriate for the current browser;
				// return a function that will disconnect the listener.
				if(!has("ie-event-behavior")){
					node.addEventListener(eventName, handler, false);
					return function(){
						node.removeEventListener(eventName, handler, false);
					};
				}else{
					node.attachEvent(ieEventName, handler);
					return function(){
						node.detachEvent(ieEventName, handler);
					};
				}
			},
			windowOnLoadListener = domOn(window, "load", "onload", function(){
				req.pageLoaded = 1;
				doc.readyState!="complete" && (doc.readyState = "complete");
				windowOnLoadListener();
			});

		if( 1 ){
			// if the loader is on the page, there must be at least one script element
			// getting its parent and then doing insertBefore solves the "Operation Aborted"
			// error in IE from appending to a node that isn't properly closed; see
			// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example
			// don't use scripts with type dojo/... since these may be removed; see #15809
			// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958
			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script;
			while(!insertPointSibling){
				if(!/^dojo/.test((script = scripts[i++]) && script.type)){
					insertPointSibling= script;
				}
			}

			req.injectUrl = function(url, callback, owner){
				// insert a script element to the insert-point element with src=url;
				// apply callback upon detecting the script has loaded.

				var node = owner.node = doc.createElement("script"),
					onLoad = function(e){
						e = e || window.event;
						var node = e.target || e.srcElement;
						if(e.type === "load" || /complete|loaded/.test(node.readyState)){
							loadDisconnector();
							errorDisconnector();
							callback && callback();
						}
					},
					loadDisconnector = domOn(node, "load", "onreadystatechange", onLoad),
					errorDisconnector = domOn(node, "error", "onerror", function(e){
						loadDisconnector();
						errorDisconnector();
						signal(error, makeError("scriptError", [url, e]));
					});

				node.type = "text/javascript";
				node.charset = "utf-8";
				node.src = url;
				insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
				return node;
			};
		}
	}

	if( 1 ){
		req.log = function(){
			try{
				for(var i = 0; i < arguments.length; i++){
					console.log(arguments[i]);
				}
			}catch(e){}
		};
	}else{
		req.log = noop;
	}

	if( 0 ){
		var trace = req.trace = function(
			group,	// the trace group to which this application belongs
			args	// the contents of the trace
		){
			///
			// Tracing interface by group.
			//
			// Sends the contents of args to the console iff (req.trace.on && req.trace[group])

			if(trace.on && trace.group[group]){
				signal("trace", [group, args]);
				for(var arg, dump = [], text= "trace:" + group + (args.length ? (":" + args[0]) : ""), i= 1; i<args.length;){
					arg = args[i++];
					if(isString(arg)){
						text += ", " + arg;
					}else{
						dump.push(arg);
					}
				}
				req.log(text);
				dump.length && dump.push(".");
				req.log.apply(req, dump);
			}
		};
		mix(trace, {
			on:1,
			group:{},
			set:function(group, value){
				if(isString(group)){
					trace.group[group]= value;
				}else{
					mix(trace.group, group);
				}
			}
		});
		trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
		on("config", function(config){
			config.trace && trace.set(config.trace);
		});
	}else{
		req.trace = noop;
	}

	var def = function(
		mid,		  //(commonjs.moduleId, optional)
		dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory
		factory		  //(any)
	){
		///
		// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.
		///
		//note
		// CommonJS factory scan courtesy of http://requirejs.org

		var arity = arguments.length,
			defaultDeps = ["require", "exports", "module"],
			// the predominate signature...
			args = [0, mid, dependencies];
		if(arity==1){
			args = [0, (isFunction(mid) ? defaultDeps : []), mid];
		}else if(arity==2 && isString(mid)){
			args = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];
		}else if(arity==3){
			args = [mid, dependencies, factory];
		}

		if( 0  && args[1]===defaultDeps){
			args[2].toString()
				.replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, "")
				.replace(/require\(["']([\w\!\-_\.\/]+)["']\)/g, function(match, dep){
				args[1].push(dep);
			});
		}

		req.trace("loader-define", args.slice(0, 2));
		var targetModule = args[0] && getModule(args[0]),
			module;
		if(targetModule && !waiting[targetModule.mid]){
			// given a mid that hasn't been requested; therefore, defined through means other than injecting
			// consequent to a require() or define() application; examples include defining modules on-the-fly
			// due to some code path or including a module in a script element. In any case,
			// there is no callback waiting to finish processing and nothing to trigger the defQ and the
			// dependencies are never requested; therefore, do it here.
			injectDependencies(defineModule(targetModule, args[1], args[2]));
		}else if(!has("ie-event-behavior") || ! 1  || injectingCachedModule){
			// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately
			// after script finishes being evaluated and the defQ can be run from that callback to detect the module id
			defQ.push(args);
		}else{
			// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,
			// in-order exec of onLoad with script eval (since it's IE) and must manually detect here
			targetModule = targetModule || injectingModule;
			if(!targetModule){
				for(mid in waiting){
					module = modules[mid];
					if(module && module.node && module.node.readyState === 'interactive'){
						targetModule = module;
						break;
					}
				}
				if( 0  && !targetModule){
					for(var i = 0; i<combosPending.length; i++){
						targetModule = combosPending[i];
						if(targetModule.node && targetModule.node.readyState === 'interactive'){
							break;
						}
						targetModule= 0;
					}
				}
			}
			if( 0  && isArray(targetModule)){
				injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
				if(!targetModule.length){
					combosPending.splice(i, 1);
				}
			}else if(targetModule){
				consumePendingCacheInsert(targetModule);
				injectDependencies(defineModule(targetModule, args[1], args[2]));
			}else{
				signal(error, makeError("ieDefineFailed", args[0]));
			}
			checkComplete();
		}
	};
	def.amd = {
		vendor:"dojotoolkit.org"
	};

	if( 0 ){
		req.def = def;
	}

	// allow config to override default implementation of named functions; this is useful for
	// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
	// also useful for testing and monkey patching loader
	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);

	// now that req is fully initialized and won't change, we can hook it up to the error signal
	on(error, function(arg){
		try{
			console.error(arg);
			if(arg instanceof Error){
				for(var p in arg){
					console.log(p + ":", arg[p]);
				}
				console.log(".");
			}
		}catch(e){}
	});

	// always publish these
	mix(req, {
		uid:uid,
		cache:cache,
		packs:packs
	});


	if( 0 ){
		mix(req, {
			// these may be interesting to look at when debugging
			paths:paths,
			aliases:aliases,
			modules:modules,
			legacyMode:legacyMode,
			execQ:execQ,
			defQ:defQ,
			waiting:waiting,

			// these are used for testing
			// TODO: move testing infrastructure to a different has feature
			packs:packs,
			mapProgs:mapProgs,
			pathsMapProg:pathsMapProg,
			listenerQueues:listenerQueues,

			// these are used by the builder (at least)
			computeMapProg:computeMapProg,
			computeAliases:computeAliases,
			runMapProg:runMapProg,
			compactPath:compactPath,
			getModuleInfo:getModuleInfo_
		});
	}

	// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
	// *required* to define (as opposed to require, which is optional)
	if(global.define){
		if( 1 ){
			signal(error, makeError("defineAlreadyDefined", 0));
		}
		return;
	}else{
		global.define = def;
		global.require = req;
		if( 0 ){
			require = req;
		}
	}

	if( 0  && req.combo && req.combo.plugins){
		var plugins = req.combo.plugins,
			pluginName;
		for(pluginName in plugins){
			mix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:"executed", load:1});
		}
	}

	if( 1 ){
		forEach(delayedModuleConfig, function(c){ config(c); });
		var bootDeps = dojoSniffConfig.deps ||	userConfig.deps || defaultConfig.deps,
			bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
		req.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;
	}
	if(! 1 ){
		!req.async && req(["dojo"]);
		req.boot && req.apply(null, req.boot);
	}
})
(this.dojoConfig || this.djConfig || this.require || {}, {
		async:1,
		hasCache:{
				'config-selectorEngine':"lite",
				'config-tlmSiblingOfDojo':1,
				'dojo-built':1,
				'dojo-loader':1,
				dom:1,
				'host-browser':1
		},
		packages:[
				{
					 location:".",
					 name:"dojo"
				},
				{
					 location:"../dijit",
					 name:"dijit"
				},
				{
					 location:"../dojox",
					 name:"dojox"
				},
				{
					 location:"../esri",
					 name:"esri"
				},
				{
					 location:"../dgrid",
					 main:"OnDemandGrid",
					 name:"dgrid"
				},
				{
					 location:"../put-selector",
					 main:"put",
					 name:"put-selector"
				},
				{
					 location:"../xstyle",
					 name:"xstyle"
				},
				{
					 location:"../jquery",
					 main:"jquery",
					 name:"jquery"
				},
				{
					 location:"../fastclick",
					 main:"fastclick",
					 name:"fastclick"
				},
				{
					 location:"../moment",
					 main:"moment",
					 name:"moment"
				},
				{
					 location:"../bootstrap",
					 main:"bootstrap",
					 name:"bootstrap"
				},
				{
					 location:"../bootstrapmap",
					 name:"bootstrapmap"
				},
				{
					 location:"../bootstrap-datetimepicker",
					 main:"bootstrap-datetimepicker",
					 name:"bootstrap-datetimepicker"
				},
				{
					 location:"../bootstrap-jasny",
					 main:"bootstrap-jasny",
					 name:"bootstrap-jasny"
				}
		]
});require({cache:{
'dojo/_base/array':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	 1  && lang.mixin(dojo, array);

	return array;
});

},
'dojo/_base/kernel':function(){
define(["../has", "./config", "require", "module"], function(has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		global = (function () { return this; })(),
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:global,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			global[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = ! 1  || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev: ae6be82 $".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 10, patch: 3, flag: "",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If  1  is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	 1 || has.add("extend-dojo", 1);


	(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if( 0 ){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	 1 || has.add("dojo-guarantee-console",
		// ensure that console.log, console.warn, etc. are defined
		1
	);
	if( 1 ){
		typeof console != "undefined" || (console = {});
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.prototype.slice.call(arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	 1 || has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if( 1 ){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	 1 || has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if( 1 ){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lengthy relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
});

},
'dojo/has':function(){
define(["require", "module"], function(require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(! 1 ){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			global = (function () { return this; })(),
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		 1 || has.add("host-browser", isBrowser);
		 0 && has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
		 0 && has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
		 1 || has.add("dom", isBrowser);
		 1 || has.add("dojo-dom-ready-api", 1);
		 1 || has.add("dojo-sniff", 1);
	}

	if( 1 ){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);

		// Do the device and browser have touch capability?
		has.add("touch", "ontouchstart" in document
			|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
			|| window.navigator.msMaxTouchPoints);

		// Touch events support
		has.add("touch-events", "ontouchstart" in document);

		// Pointer Events support
		has.add("pointer-events", "onpointerdown" in document);
		has.add("MSPointer", "msMaxTouchPoints" in navigator); //IE10 (+IE11 preview)

		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
});

},
'dojo/_base/config':function(){
define(["../has", "require"], function(has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback via Firebug. If Firebug is not available
	//		on your platform, setting `isDebug` to `true` will force Dojo to
	//		pull in (and display) the version of Firebug Lite which is
	//		integrated into the Dojo distribution, thereby always providing a
	//		debugging/logging console when `isDebug` is enabled. Note that
	//		Firebug's `console.*` methods are ALWAYS defined by Dojo. If
	//		`isDebug` is false and you are on a platform without Firebug, these
	//		methods will be defined as no-ops.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// useCustomLogger: Anything?
	//		If set to a value that evaluates to true such as a string or array and
	//		isDebug is true and Firebug is not available or running, then it bypasses
	//		the creation of Firebug Lite allowing you to define your own console object.
	useCustomLogger: undefined,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if( 1 ){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		var global = (function () { return this; })();
		result =  1  ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers.
		var language = (navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
});


},
'dojo/_base/lang':function(){
define(["./kernel", "../has", "../sniff"], function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			if(!context){
				if(parts[0] && dojo.scopeMap[parts[0]]) {
					// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
					// rather than just window.dojo
					context = dojo.scopeMap[parts.shift()][1];
				}else{
					context = dojo.global;
				}
			}

			try{
				for(var i = 0; i < parts.length; i++){
					var p = parts[i];
					if(!(p in context)){
						if(create){
							context[p] = {};
						}else{
							return;		// return undefined
						}
					}
					context = context[p];
				}
				return context; // mixed
			}catch(e){
				// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
				// so in that corner case just return undefined (by having no return statement)
			}
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
				if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return getProp(name ? name.split(".") : [], create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: function(it){
			// summary:
			//		Return true if it is an Array.
			//		Does not work on Arrays created in other windows.
			// it: anything
			//		Item to test.
			return it && (it instanceof Array || typeof it == "array"); // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return it && it !== undefined && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r.push(lang.clone(src[i]));
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	 1  && lang.mixin(dojo, lang);

	return lang;
});


},
'dojo/sniff':function(){
define(["./has"], function(has){
	// module:
	//		dojo/sniff

	/*=====
	return function(){
		// summary:
		//		This module sets has() flags based on the current browser.
		//		It returns the has() function.
	};
	=====*/

	if( 1 ){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);

		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("webkit", parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari")>=0 && !has("chrome") ? parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("android", parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("khtml") && !has("webkit") && !has("trident")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
});

},
'dojo/_base/browser':function(){
if(require.has){
	require.has.add("config-selectorEngine", "acme");
}
define([
	"../ready",
	"./kernel",
	"./connect", // until we decide if connect is going back into non-browser environments
	"./unload",
	"./window",
	"./event",
	"./html",
	"./NodeList",
	"../query",
	"./xhr",
	"./fx"], function(dojo){

	// module:
	//		dojo/_base/browser

	/*=====
	return {
		// summary:
		//		This module causes the browser-only base modules to be loaded.
	};
	=====*/

	return dojo;
});

},
'dojo/ready':function(){
define(["./_base/kernel", "./has", "require", "./domReady", "./_base/lang"], function(dojo, has, require, domReady, lang){
	// module:
	//		dojo/ready
	// note:
	//		This module should be unnecessary in dojo 2.0

	var
		// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
		isDomReady = 0,

		// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
		loadQ = [],

		// prevent recursion in onLoad
		onLoadRecursiveGuard = 0,

		handleDomReady = function(){
			isDomReady = 1;
			dojo._postLoad = dojo.config.afterOnLoad = true;
			onEvent();
		},

		onEvent = function(){
			// Called when some state changes:
			//		- dom ready
			//		- dojo/domReady has finished processing everything in its queue
			//		- task added to loadQ
			//		- require() has finished loading all currently requested modules
			//
			// Run the functions queued with dojo.ready if appropriate.


			//guard against recursions into this function
			if(onLoadRecursiveGuard){
				return;
			}
			onLoadRecursiveGuard = 1;

			// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
			// pending tasks registered via domReady().
			// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
			// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
			// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
			while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
				var f = loadQ.shift();
				try{
					f();
				}catch(e){
					// force the dojo.js on("error") handler do display the message
					e.info = e.message;
					if(require.signal){
						require.signal("error", e);
					}else{
						throw e;
					}
				}
			}

			onLoadRecursiveGuard = 0;
		};

	// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
	// finishes processing it's queue.
	require.on && require.on("idle", onEvent);
	if(domReady){
		domReady._onQEmpty = onEvent;
	}

	var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
		// summary:
		//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
		//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
		//
		//		When called in a non-browser environment, just checks that all requested modules have arrived and been
		//		evaluated.
		// priority: Integer?
		//		The order in which to exec this callback relative to other callbacks, defaults to 1000
		// context: Object?|Function
		//		The context in which to run execute callback, or a callback if not using context
		// callback: Function?
		//		The function to execute.
		//
		// example:
		//	Simple DOM and Modules ready syntax
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(function(){ alert("Dom ready!"); });
		//	|	});
		//
		// example:
		//	Using a priority
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(2, function(){ alert("low priority ready!"); })
		//	|	});
		//
		// example:
		//	Using context
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(foo, function(){
		//	|			// in here, this == foo
		//	|		});
		//	|	});
		//
		// example:
		//	Using dojo/hitch style args:
		//	|	require(["dojo/ready"], function(ready){
		//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		//	|		ready(foo, "dojoReady");
		//	|	});

		var hitchArgs = lang._toArray(arguments);
		if(typeof priority != "number"){
			callback = context;
			context = priority;
			priority = 1000;
		}else{
			hitchArgs.shift();
		}
		callback = callback ?
			lang.hitch.apply(dojo, hitchArgs) :
			function(){
				context();
			};
		callback.priority = priority;
		for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
		loadQ.splice(i, 0, callback);
		onEvent();
	};

	 1 || has.add("dojo-config-addOnLoad", 1);
	if( 1 ){
		var dca = dojo.config.addOnLoad;
		if(dca){
			ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
		}
	}

	if( 1  && dojo.config.parseOnLoad && !dojo.isAsync){
		ready(99, function(){
			if(!dojo.parser){
				dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
				require(["dojo/parser"]);
			}
		});
	}

	if(domReady){
		domReady(handleDomReady);
	}else{
		handleDomReady();
	}

	return ready;
});

},
'dojo/domReady':function(){
define(['./has'], function(has){
	var global = (function () { return this; })(),
		doc = document,
		readyStates = { 'loaded': 1, 'complete': 1 },
		fixReadyState = typeof doc.readyState != "string",
		ready = !!readyStates[doc.readyState],
		readyQ = [],
		recursiveGuard;

	function domReady(callback){
		// summary:
		//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
		readyQ.push(callback);
		if(ready){ processQ(); }
	}
	domReady.load = function(id, req, load){
		domReady(load);
	};

	// Export queue so that ready() can check if it's empty or not.
	domReady._Q = readyQ;
	domReady._onQEmpty = function(){
		// summary:
		//		Private method overridden by dojo/ready, to notify when everything in the
		//		domReady queue has been processed.  Do not use directly.
		//		Will be removed in 2.0, along with domReady._Q.
	};

	// For FF <= 3.5
	if(fixReadyState){ doc.readyState = "loading"; }

	function processQ(){
		// Calls all functions in the queue in order, unless processQ() is already running, in which case just return

		if(recursiveGuard){ return; }
		recursiveGuard = true;

		while(readyQ.length){
			try{
				(readyQ.shift())(doc);
			}catch(err){
				console.error(err, "in domReady callback", err.stack);
			}
		}

		recursiveGuard = false;

		// Notification for dojo/ready.  Remove for 2.0.
		// Note that this could add more tasks to the ready queue.
		domReady._onQEmpty();
	}

	if(!ready){
		var tests = [],
			detectReady = function(evt){
				evt = evt || global.event;
				if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }

				// For FF <= 3.5
				if(fixReadyState){ doc.readyState = "complete"; }

				ready = 1;
				processQ();
			},
			on = function(node, event){
				node.addEventListener(event, detectReady, false);
				readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
			};

		if(!has("dom-addeventlistener")){
			on = function(node, event){
				event = "on" + event;
				node.attachEvent(event, detectReady);
				readyQ.push(function(){ node.detachEvent(event, detectReady); });
			};

			var div = doc.createElement("div");
			try{
				if(div.doScroll && global.frameElement === null){
					// the doScroll test is only useful if we're in the top-most frame
					tests.push(function(){
						// Derived with permission from Diego Perini's IEContentLoaded
						// http://javascript.nwbox.com/IEContentLoaded/
						try{
							div.doScroll("left");
							return 1;
						}catch(e){}
					});
				}
			}catch(e){}
		}

		on(doc, "DOMContentLoaded");
		on(global, "load");

		if("onreadystatechange" in doc){
			on(doc, "readystatechange");
		}else if(!fixReadyState){
			// if the ready state property exists and there's
			// no readystatechange event, poll for the state
			// to change
			tests.push(function(){
				return readyStates[doc.readyState];
			});
		}

		if(tests.length){
			var poller = function(){
				if(ready){ return; }
				var i = tests.length;
				while(i--){
					if(tests[i]()){
						detectReady("poller");
						return;
					}
				}
				setTimeout(poller, 30);
			};
			poller();
		}
	}

	return domReady;
});

},
'dojo/_base/connect':function(){
define(["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

 1  && lang.mixin(dojo, connect);
return connect;

});



},
'dojo/on':function(){
define(["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has){

	"use strict";
	if( 1 ){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			return 'onfocusin' in element;
		});
		
		if(has("touch")){
			has.add("touch-can-modify-event-delegate", function(){
				// This feature test checks whether deleting a property of an event delegate works
				// for a touch-enabled device. If it works, event delegation can be used as fallback
				// for browsers such as Safari in older iOS where deleting properties of the original
				// event does not work.
				var EventDelegate = function(){};
				EventDelegate.prototype =
					document.createEvent("MouseEvents"); // original event
				// Attempt to modify a property of an event delegate and check if
				// it succeeds. Depending on browsers and on whether dojo/on's
				// strict mode is stripped in a Dojo build, there are 3 known behaviors:
				// it may either succeed, or raise an error, or fail to set the property
				// without raising an error.
				try{
					var eventDelegate = new EventDelegate;
					eventDelegate.target = null;
					return eventDelegate.target === null;
				}catch(e){
					return false; // cannot use event delegation
				}
			});
		}
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(listen){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(listen, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it 
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype 
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The 
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type instanceof Array){
			// allow an array of event names (or event handler functions)
			events = type;
		}else if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			var events = type.split(/\s*,\s*/);
		} 
		if(events){
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){
				handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1, 
				//but works through "resize" on window
				type = "resize"; 
				target = window;
				listener = fixTouchListener(listener);
			} 
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}
	on.matches = function(node, selector, context, children, matchesTarget) {
		// summary:
		//		Check if a node match the current selector within the constraint of a context
		// node: DOMNode
		//		The node that originate the event
		// selector: String
		//		The selector to check against
		// context: DOMNode
		//		The context to search in.
		// children: Boolean
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// matchesTarget: Object|dojo/query?
		//		An object with a property "matches" as a function. Default is dojo/query.
		//		Matching DOMNodes will be done against this function
		//		The function must return a Boolean.
		//		It will have 3 arguments: "node", "selector" and "context"
		//		True is expected if "node" is matching the current "selector" in the passed "context"
		// returns: DOMNode?
		//		The matching node, if any. Else you get false

		// see if we have a valid matchesTarget or default to dojo/query
		matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
		children = children !== false;
		// there is a selector, so make sure it matches
		if(node.nodeType != 1){
			// text node will fail in native match selector
			node = node.parentNode;
		}
		while(!matchesTarget.matches(node, selector, context)){
			if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
				return false;
			}
		}
		return node;
	}
	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to 
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(listen, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				return on.matches(eventTarget, selector, target, children, matchesTarget);
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				if (eventTarget) {
					return listener.call(eventTarget, event);
				}
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain 
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and 
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent 
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable 
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		}
	} 
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event				
				// we could create branch into the different types of event constructors, but 
				// that would be a lot of extra code, with little benefit that I can see, seems 
				// best to use the generic constructor and copy properties over, making it 
				// easy to have events look like the ones created with specific initializers
				var ownerDocument = target.ownerDocument || document;
				var nativeEvent = ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || 
						has("jscript") < 5.8) && 
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){ 
		var EventDelegate = function(){};
		var windowOrientation = window.orientation; 
		var fixTouchListener = function(listener){ 
			return function(originalEvent){ 
				//Event normalization(for ontouchxxx and resize): 
				//1.incorrect e.pageX|pageY in iOS 
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
					}catch(e){} 
					if(originalEvent.type){
						// Deleting the property of the original event did not work (this is the case of
						// browsers such as older Safari iOS), hence fallback:
						if(has("touch-can-modify-event-delegate")){
							// If deleting properties of delegated event works, use event delegation:
							EventDelegate.prototype = originalEvent;
							event = new EventDelegate;
						}else{
							// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
							// delegated properties, so we have to copy
							event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){ 
							return null;//double tap causes an unexpected 'resize' in Android
						} 
						windowOrientation = window.orientation;
						event.type = "orientationchange"; 
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0; 
						event.scale = 1;
					}
					//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
					var firstChangeTouch = event.changedTouches[0];
					for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
						delete event[i]; // delete it first to make it mutable
						event[i] = firstChangeTouch[i];
					}
				}
				return listener.call(this, event); 
			}; 
		}; 
	}
	return on;
});

},
'dojo/topic':function(){
define(["./Evented"], function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
});

},
'dojo/Evented':function(){
define(["./aspect", "./on"], function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
});

},
'dojo/aspect':function(){
define([], function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined, nextId = 0;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						args = before.advice.apply(this, args) || args;
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.receiveArguments){
							var newResults = after.advice.apply(this, args);
							// change the return value only if a new value was returned
							results = newResults === undefined ? results : newResults;
						}else{
							results = after.advice.call(this, results, args);
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
});

},
'dojo/_base/event':function(){
define(["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if( 1 ){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
});

},
'dojo/dom-geometry':function(){
define(["./sniff", "./_base/window","./dom", "./dom-style"],
		function(has, win, dom, style){
	// module:
	//		dojo/dom-geometry

	// the result object
	var geom = {
		// summary:
		//		This module defines the core dojo DOM geometry API.
	};

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.

	// can be either:
	//	"border-box"
	//	"content-box" (default)
	geom.boxModel = "content-box";

	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

	if(has("ie") /*|| has("opera")*/){
		// client code may have to adjust if compatMode varies across iframes
		geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
	}

	geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with special values specifically useful for node
		//		fitting.
		// description:
		//		Returns an object with `w`, `h`, `l`, `t` properties:
		//	|		l/t/r/b = left/top/right/bottom padding (respectively)
		//	|		w = the total of the left and right padding
		//	|		h = the total of the top and bottom padding
		//		If 'node' has position, l/t forms the origin for child nodes.
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	var none = "none";

	geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right border
		//		- h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
			l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
			t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
			r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
			b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right padding and border
		//		- h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node),
			p = geom.getPadExtents(node, s),
			b = geom.getBorderExtents(node, s);
		return {
			l: p.l + b.l,
			t: p.t + b.t,
			r: p.r + b.r,
			b: p.b + b.b,
			w: p.w + b.w,
			h: p.h + b.h
		};
	};

	geom.getMarginExtents = function getMarginExtents(node, computedStyle){
		// summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		- l/t = marginLeft, marginTop, respectively
		//		- w = total width, margin inclusive
		//		- h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes

	geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
			l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
		if(has("mozilla")){
			// Mozilla:
			// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
			// by the parent's border.
			// We don't want to compute the parent's style, so instead we examine node's
			// computed left/top which is more stable.
			var sl = parseFloat(s.left), st = parseFloat(s.top);
			if(!isNaN(sl) && !isNaN(st)){
				l = sl;
				t = st;
			}else{
				// If child's computed left/top are not parseable as a number (e.g. "auto"), we
				// have no choice but to examine the parent's computed style.
				if(p && p.style){
					pcs = style.getComputedStyle(p);
					if(pcs.overflow != "visible"){
						l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
						t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
					}
				}
			}
		}else if(has("opera") || (has("ie") == 8 && !has("quirks"))){
			// On Opera and IE 8, offsetLeft/Top includes the parent's border
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}
		return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
	};

	geom.getContentBox = function getContentBox(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
			pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
		if(!w){
			w = node.offsetWidth;
			h = node.offsetHeight;
		}else{
			h = node.clientHeight;
			be.w = be.h = 0;
		}
		// On Opera, offsetLeft includes the parent's border
		if(has("opera")){
			pe.l += be.l;
			pe.t += be.t;
		}
		return {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};
	};

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of boxModel is used to determine box context.
	// boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.
	//
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear
	// at all in computedStyle on Mozilla.

	function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
		// summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimensions. Uses the unit passed in u.
		// node:
		//		DOM Node reference. Id string not supported for performance
		//		reasons.
		// l:
		//		left offset from parent.
		// t:
		//		top offset from parent.
		// w:
		//		width in current box model.
		// h:
		//		width in current box model.
		// u:
		//		unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){
			s.left = l + u;
		}
		if(!isNaN(t)){
			s.top = t + u;
		}
		if(w >= 0){
			s.width = w + u;
		}
		if(h >= 0){
			s.height = h + u;
		}
	}

	function isButtonTag(/*DomNode*/ node){
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName.toLowerCase() == "button" ||
			node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
	}

	function usesBorderBox(/*DomNode*/ node){
		// summary:
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.

		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.

		return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
	}

	geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		// node: DOMNode
		// box: Object
		//		hash with optional "w", and "h" properties for "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var w = box.w, h = box.h;
		if(usesBorderBox(node)){
			var pb = geom.getPadBorderExtents(node, computedStyle);
			if(w >= 0){
				w += pb.w;
			}
			if(h >= 0){
				h += pb.h;
			}
		}
		setBox(node, NaN, NaN, w, h);
	};

	var nilExtents = {l: 0, t: 0, w: 0, h: 0};

	geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to setBox that handles box-model vagaries for
		//		you.
		// node: DOMNode
		// box: Object
		//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
		// Some elements have special padding, margin, and box-model settings.
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
			pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
			mb = geom.getMarginExtents(node, s);
		if(has("webkit")){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(isButtonTag(node)){
				var ns = node.style;
				if(w >= 0 && !ns.width){
					ns.width = "4px";
				}
				if(h >= 0 && !ns.height){
					ns.height = "4px";
				}
			}
		}
		if(w >= 0){
			w = Math.max(w - pb.w - mb.w, 0);
		}
		if(h >= 0){
			h = Math.max(h - pb.h - mb.h, 0);
		}
		setBox(node, box.l, box.t, w, h);
	};

	// =============================
	// Positioning
	// =============================

	geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
		// summary:
		//		Returns true if the current language is left-to-right, and false otherwise.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Boolean

		doc = doc || win.doc;
		return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	};

	geom.docScroll = function docScroll(/*Document?*/ doc){
		// summary:
		//		Returns an object with {node, x, y} with corresponding offsets.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Object

		doc = doc || win.doc;
		var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
		return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
				{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
	};

	if(has("ie")){
		geom.getIeDocumentElementOffset = function getIeDocumentElementOffset(/*Document?*/ doc){
			// summary:
			//		returns the offset in x and y from the document body to the
			//		visual edge of the page for IE
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// description:
			//		The following values in IE contain an offset:
			//	|		event.clientX
			//	|		event.clientY
			//	|		node.getBoundingClientRect().left
			//	|		node.getBoundingClientRect().top
			//		But other position related values do not contain this offset,
			//		such as node.offsetLeft, node.offsetTop, node.style.left and
			//		node.style.top. The offset is always (2, 2) in LTR direction.
			//		When the body is in RTL direction, the offset counts the width
			//		of left scroll bar's width.  This function computes the actual
			//		offset.

			//NOTE: assumes we're being called in an IE browser

			doc = doc || win.doc;
			var de = doc.documentElement; // only deal with HTML element here, position() handles body/quirks

			if(has("ie") < 8){
				var r = de.getBoundingClientRect(), // works well for IE6+
					l = r.left, t = r.top;
				if(has("ie") < 7){
					l += de.clientLeft;	// scrollbar size in strict/RTL, or,
					t += de.clientTop;	// HTML border size in strict
				}
				return {
					x: l < 0 ? 0 : l, // FRAME element border size can lead to inaccurate negative values
					y: t < 0 ? 0 : t
				};
			}else{
				return {
					x: 0,
					y: 0
				};
			}
		};
	}

	geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
		// summary:
		//		In RTL direction, scrollLeft should be a negative value, but IE
		//		returns a positive one. All codes using documentElement.scrollLeft
		//		must call this function to fix this error, otherwise the position
		//		will offset to right when there is a horizontal scrollbar.
		// scrollLeft: Number
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Number

		// In RTL direction, scrollLeft should be a negative value, but IE
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

		doc = doc || win.doc;
		var ie = has("ie");
		if(ie && !geom.isBodyLtr(doc)){
			var qk = has("quirks"),
				de = qk ? win.body(doc) : doc.documentElement,
				pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
			if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
				scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
			}
			return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
		}
		return scrollLeft; // Integer
	};

	geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
		// summary:
		//		Gets the position and size of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		// description:
		//		Returns an object of the form:
		//		`{ x: 100, y: 300, w: 20, h: 15 }`.
		//		If includeScroll==true, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.
		//		Uses the border-box model (inclusive of border and padding but
		//		not margin).  Does not act as a setter.
		// node: DOMNode|String
		// includeScroll: Boolean?
		// returns: Object

		node = dom.byId(node);
		var	db = win.body(node.ownerDocument),
			ret = node.getBoundingClientRect();
		ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

		if(has("ie") < 9){
			// On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()
			var offset = geom.getIeDocumentElementOffset(node.ownerDocument);

			// fixes the position in IE, quirks mode
			ret.x -= offset.x + (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
			ret.y -= offset.y + (has("quirks") ? db.clientTop + db.offsetTop : 0);
		}

		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = geom.docScroll(node.ownerDocument);
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	};

	// random "private" functions wildly used throughout the toolkit

	geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width and height of
		//		the node's margin box
		// node: DOMNode|String
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
		var size = node.getBoundingClientRect();
		return {
			w: (size.right - size.left) + me.w,
			h: (size.bottom - size.top) + me.h
		};
	};

	geom.normalizeEvent = function(event){
		// summary:
		//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
		//		offsetX, offsetY, layerX, and layerX properties
		// event: Object
		if(!("layerX" in event)){
			event.layerX = event.offsetX;
			event.layerY = event.offsetY;
		}
		if(!has("dom-addeventlistener")){
			// old IE version
			// FIXME: scroll position query is duped from dojo/_base/html to
			// avoid dependency on that entire module. Now that HTML is in
			// Base, we should convert back to something similar there.
			var se = event.target;
			var doc = (se && se.ownerDocument) || document;
			// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var docBody = has("quirks") ? doc.body : doc.documentElement;
			var offset = geom.getIeDocumentElementOffset(doc);
			event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;
			event.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;
		}
	};

	// TODO: evaluate separate getters/setters for position and sizes?

	return geom;
});

},
'dojo/_base/window':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: dojo.global["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

 1  && lang.mixin(dojo, ret);

return ret;

});

},
'dojo/dom':function(){
define(["./sniff", "./_base/window"],
		function(has, win){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	dom.isDescendant = function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
		// summary:
		//		Returns true if node is a descendant of ancestor
		// node: DOMNode|String
		//		string id or node reference to test
		// ancestor: DOMNode|String
		//		string id or node reference of potential parent to test against
		//
		// example:
		//		Test is node id="bar" is a descendant of node id="foo"
		//	|	require(["dojo/dom"], function(dom){
		//	|		if(dom.isDescendant("bar", "foo")){ ... }
		//	|	});

		try{
			node = dom.byId(node);
			ancestor = dom.byId(ancestor);
			while(node){
				if(node == ancestor){
					return true; // Boolean
				}
				node = node.parentNode;
			}
		}catch(e){ /* squelch, return false */ }
		return false; // Boolean
	};


	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	// TODO: The user-select CSS property as of May 2014 is no longer part of
	// any CSS specification. In IE, -ms-user-select does not do the same thing
	// as the unselectable attribute on elements; namely, dijit Editor buttons
	// do not properly prevent the content of the editable content frame from
	// unblurring. As a result, the -ms- prefixed version is omitted here.
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }
		
		var style = element.style;
		var prefixes = ["Khtml", "O", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
});

},
'dojo/dom-style':function(){
define(["./sniff", "./dom"], function(has, dom){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			return node.nodeType == 1 /* ELEMENT_NODE*/ ?
				node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	style.getComputedStyle = function(node){
		// summary:
		//		Returns a "computed style" object.
		//
		// description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node.
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
		//		return values.
		//
		// node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		// example:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
		//	|	});
		//
		// example:
		//		Reusing the returned object, avoiding multiple lookups:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
		//	|		var w = cs.width, h = cs.height;
		//	|	});
		return; // CSS2Properties
	};
	=====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	style.toPixelValue = function(node, value){
		// summary:
		//		converts style value to pixels on IE or return a numeric value.
		// node: DOMNode
		// value: String
		// returns: Number
	};
	=====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
		function(node){
			return getComputedStyle(node).opacity;
		};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
		function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();
		if(has("ie") || has("trident")){
			if(value == "auto"){
				if(type == "height"){ return node.offsetHeight; }
				if(type == "width"){ return node.offsetWidth; }
			}
			if(type == "fontweight"){
				switch(value){
					case 700: return "bold";
					case 400:
					default: return "normal";
				}
			}
		}
		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
});

},
'dojo/mouse':function(){
define(["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
});

},
'dojo/_base/sniff':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(! 1 ){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
});

},
'dojo/keys':function(){
define(["./_base/kernel", "./sniff"], function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
});

},
'dojo/_base/unload':function(){
define(["./kernel", "./lang", "../on"], function(dojo, lang, on){

// module:
//		dojo/unload

var win = window;

var unload = {
	// summary:
	//		This module contains the document and window unload detection API.
	//		This module is deprecated.  Use on(window, "unload", func)
	//		and on(window, "beforeunload", func) instead.

	addOnWindowUnload: function(/*Object|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when window.onunload fires.
		//		Deprecated, use on(window, "unload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnWindowUnload is called Dojo
		//		will register a page listener to trigger your unload
		//		handler with. Note that registering these handlers may
		//		destroy "fastback" page caching in browsers that support
		//		it. Be careful trying to modify the DOM or access
		//		JavaScript properties during this phase of page unloading:
		//		they may not always be available. Consider
		//		addOnUnload() if you need to modify the DOM or do
		//		heavy JavaScript work since it fires at the equivalent of
		//		the page's "onbeforeunload" event.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnWindowUnload(afunc);
		//	|		unload.addOnWindowUnload(foo, "bar");
		//	|		unload.addOnWindowUnload(foo, function(){console.log("", this.data);});
		//	|	});

		if (!dojo.windowUnloaded){
			on(win, "unload", (dojo.windowUnloaded = function(){
				// summary:
				//		signal fired by impending window destruction. You may use
				//		dojo.addOnWindowUnload() to register a listener for this
				//		event. NOTE: if you wish to dojo.connect() to this method
				//		to perform page/application cleanup, be aware that this
				//		event WILL NOT fire if no handler has been registered with
				//		addOnWindowUnload(). This behavior started in Dojo 1.3.
				//		Previous versions always triggered windowUnloaded(). See
				//		addOnWindowUnload for more info.
			}));
		}
		on(win, "unload", lang.hitch(obj, functionName));
	},

	addOnUnload: function(/*Object?|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when the page unloads.
		//		Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnUnload is called Dojo will
		//		register a page listener to trigger your unload handler
		//		with.
		//
		//		In a browser environment, the functions will be triggered
		//		during the window.onbeforeunload event. Be careful of doing
		//		too much work in an unload handler. onbeforeunload can be
		//		triggered if a link to download a file is clicked, or if
		//		the link is a javascript: link. In these cases, the
		//		onbeforeunload event fires, but the document is not
		//		actually destroyed. So be careful about doing destructive
		//		operations in a dojo.addOnUnload callback.
		//
		//		Further note that calling dojo.addOnUnload will prevent
		//		browsers from using a "fast back" cache to make page
		//		loading via back button instantaneous.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnUnload(afunc);
		//	|		unload.addOnUnload(foo, "bar");
		//	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
		//	|	});

		on(win, "beforeunload", lang.hitch(obj, functionName));
	}
};

dojo.addOnWindowUnload = unload.addOnWindowUnload;
dojo.addOnUnload = unload.addOnUnload;

return unload;

});

},
'dojo/_base/html':function(){
define(["./kernel", "../dom", "../dom-style", "../dom-attr", "../dom-prop", "../dom-class", "../dom-construct", "../dom-geometry"], function(dojo, dom, style, attr, prop, cls, ctr, geom){
	// module:
	//		dojo/dom

	/*=====
	return {
		// summary:
		//		This module is a stub for the core dojo DOM API.
	};
	=====*/

	// mix-in dom
	dojo.byId = dom.byId;
	dojo.isDescendant = dom.isDescendant;
	dojo.setSelectable = dom.setSelectable;

	// mix-in dom-attr
	dojo.getAttr = attr.get;
	dojo.setAttr = attr.set;
	dojo.hasAttr = attr.has;
	dojo.removeAttr = attr.remove;
	dojo.getNodeProp = attr.getNodeProp;

	dojo.attr = function(node, name, value){
		// summary:
		//		Gets or sets an attribute on an HTML element.
		// description:
		//		Handles normalized getting and setting of attributes on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to get or set the attribute on
		// name: String|Object
		//		the name of the attribute to get or set.
		// value: String?
		//		The value to set for the attribute
		// returns:
		//		when used as a getter, the value of the requested attribute
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	dojo.attr(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.attr("nodeId", "foo");
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	dojo.attr("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.attr("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//	Style is s special case: Only set with an object hash of styles
		//	|	dojo.attr("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//	Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.attr("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return attr[typeof name == "string" ? "get" : "set"](node, name);
		}
		return attr.set(node, name, value);
	};

	// mix-in dom-class
	dojo.hasClass = cls.contains;
	dojo.addClass = cls.add;
	dojo.removeClass = cls.remove;
	dojo.toggleClass = cls.toggle;
	dojo.replaceClass = cls.replace;

	// mix-in dom-construct
	dojo._toDom = dojo.toDom = ctr.toDom;
	dojo.place = ctr.place;
	dojo.create = ctr.create;
	dojo.empty = function(node){ ctr.empty(node); };
	dojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };

	// mix-in dom-geometry
	dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
	dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
	dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
	dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
	dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
	dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
	dojo.setMarginBox = geom.setMarginBox;
	dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
	dojo.setContentSize = geom.setContentSize;
	dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
	dojo._docScroll = dojo.docScroll = geom.docScroll;
	dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
	dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
	dojo.position = geom.position;

	dojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the margin-box of node.
		// description:
		//		Getter/setter for the margin-box of node.
		//		Returns an object in the expected format of box (regardless
		//		if box is passed). The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a margin width of 300px and a margin-height of
		//		150px.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.marginBox() should
		//		update/set the margin box for node. Box is an object in the
		//		above format. All properties are optional if passed.
		// example:
		//		Retrieve the margin box of a passed node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	console.dir(box);
		//
		// example:
		//		Set a node's margin box to the size of another node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	dojo.marginBox("someOtherNode", box);
		return box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object
	};

	dojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the content-box of node.
		// description:
		//		Returns an object in the expected format of box (regardless if box is passed).
		//		The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a content width of 300px and a content-height of
		//		150px. Note that the content box may have a much larger border
		//		or margin box, depending on the box model currently in use and
		//		CSS values set/inherited for node.
		//		While the getter will return top and left values, the
		//		setter only accepts setting the width and height.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.contentBox() should
		//		update/set the content box for node. Box is an object in the
		//		above format, but only w (width) and h (height) are supported.
		//		All properties are optional if passed.
		return box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object
	};

	dojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//
		//		Returns an object that measures margin-box (w)idth/(h)eight
		//		and absolute position x/y of the border-box. Also returned
		//		is computed (l)eft and (t)op values in pixels from the
		//		node's offsetParent as returned from marginBox().
		//		Return value will be in the form:
		//|			{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
		//		Does not act as a setter. If includeScroll is passed, the x and
		//		y params are affected as one would expect in dojo.position().
		dojo.deprecated("dojo.coords()", "Use dojo.position() or dojo.marginBox().");
		node = dom.byId(node);
		var s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);
		var abs = geom.position(node, includeScroll);
		mb.x = abs.x;
		mb.y = abs.y;
		return mb;	// Object
	};

	// mix-in dom-prop
	dojo.getProp = prop.get;
	dojo.setProp = prop.set;

	dojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){
		// summary:
		//		Gets or sets a property on an HTML element.
		// description:
		//		Handles normalized getting and setting of properties on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node:
		//		id or reference to the element to get or set the property on
		// name:
		//		the name of the property to get or set.
		// value:
		//		The value to set for the property
		// returns:
		//		when used as a getter, the value of the requested property
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	dojo.prop(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.prop("nodeId", "foo");
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	dojo.prop("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.prop("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//		Style is s special case: Only set with an object hash of styles
		//	|	dojo.prop("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//		Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.prop("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return prop[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return prop.set(node, name, value);
	};

	// mix-in dom-style
	dojo.getStyle = style.get;
	dojo.setStyle = style.set;
	dojo.getComputedStyle = style.getComputedStyle;
	dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;

	dojo.style = function(node, name, value){
		// summary:
		//		Accesses styles on a node. If 2 arguments are
		//		passed, acts as a getter. If 3 arguments are passed, acts
		//		as a setter.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo.marginBox()`,
		//		`dojo.contentBox()` or `dojo.position()`.
		// node: DOMNode|String
		//		id or reference to node to get/set style for
		// name: String|Object?
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		// returns:
		//		when used as a getter, return the computed style of the node if passing in an ID or node,
		//		or return the normalized, computed value for the property when passing in a node and a style property
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	dojo.style("thinger");
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	dojo.style("thinger", "opacity"); // 1 by default
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	dojo.style("thinger", "opacity", 0.5); // == 0.5
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	dojo.style("thinger", {
		//	|		"opacity": 0.5,
		//	|		"border": "3px solid black",
		//	|		"height": "300px"
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	dojo.style("thinger",{
		//	|		fontSize:"14pt",
		//	|		letterSpacing:"1.2em"
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo.style() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	dojo.query(".someClassName").style("visibility","hidden");
		//	|	// or
		//	|	dojo.query("#baz > div").style({
		//	|		opacity:0.75,
		//	|		fontSize:"13pt"
		//	|	});

		switch(arguments.length){
			case 1:
				return style.get(node);
			case 2:
				return style[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return style.set(node, name, value);
	};

	return dojo;
});

},
'dojo/dom-attr':function(){
define(["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"],
		function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)
	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie"),
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}
	
	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}
		
		if(propName == "textContent"){
			return prop.get(node, propName);
		}
		
		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
});

},
'dojo/dom-prop':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"],
		function(exports, dojo, has, lang, dom, style, ctr, conn){
	// module:
	//		dojo/dom-prop
	// summary:
	//		This module defines the core dojo DOM properties API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element properties Functions
	// =============================

	// helper to connect events
	var _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + "attrid";
	has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

	exports.names = {
		// properties renamed to avoid clashes with reserved words
		"class": "className",
		"for": "htmlFor",
		// properties written as camelCase
		tabindex: "tabIndex",
		readonly: "readOnly",
		colspan: "colSpan",
		frameborder: "frameBorder",
		rowspan: "rowSpan",
		textcontent: "textContent",
		valuetype: "valueType"
	};
	
	function getText(/*DOMNode*/node){
		// summary:
		//		recursion method for get('textContent') to use. Gets text value for a node.
		// description:
		//		Juse uses nodedValue so things like <br/> tags do not end up in
		//		the text as any sort of line return.
		var text = "", ch = node.childNodes;
		for(var i = 0, n; n = ch[i]; i++){
			//Skip comments.
			if(n.nodeType != 8){
				if(n.nodeType == 1){
					text += getText(n);
				}else{
					text += n.nodeValue;
				}
			}
		}
		return text;
	}

	exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets a property on an HTML element.
		// description:
		//		Handles normalized getting of properties on DOM nodes.
		//
		// node: DOMNode|String
		//		id or reference to the element to get the property on
		// name: String
		//		the name of the property to get.
		// returns:
		//		the value of the requested property or its default value
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
		//	|		domProp.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domProp.get("nodeId", "foo");
		//	|	});

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		
		if(propName == "textContent" && !has("dom-textContent")){
			return getText(node);
		}
		
		return node[propName];	// Anything
	};

	exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets a property on an HTML element.
		// description:
		//		Handles normalized setting of properties on DOM nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the property on
		// name: String|Object
		//		the name of the property to set, or a hash object to set
		//		multiple properties at once.
		// value: String?
		//		The value to set for the property
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST",
		//	|		});
		//	|	});

		node = dom.byId(node);
		var l = arguments.length;
		if(l == 2 && typeof name != "string"){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(propName == "innerHTML"){
			// special case: assigning HTML
			// the hash lists elements with read-only innerHTML on IE
			if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
				ctr.empty(node);
				node.appendChild(ctr.toDom(value, node.ownerDocument));
			}else{
				node[propName] = value;
			}
			return node; // DomNode
		}
		if(propName == "textContent" && !has("dom-textContent")) {
			ctr.empty(node);
			node.appendChild(node.ownerDocument.createTextNode(value));
			return node;
		}
		if(lang.isFunction(value)){
			// special case: assigning an event handler
			// clobber if we can
			var attrId = node[_attrId];
			if(!attrId){
				attrId = _ctr++;
				node[_attrId] = attrId;
			}
			if(!_evtHdlrMap[attrId]){
				_evtHdlrMap[attrId] = {};
			}
			var h = _evtHdlrMap[attrId][propName];
			if(h){
				//h.remove();
				conn.disconnect(h);
			}else{
				try{
					delete node[propName];
				}catch(e){}
			}
			// ensure that event objects are normalized, etc.
			if(value){
				//_evtHdlrMap[attrId][propName] = on(node, propName, value);
				_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
			}else{
				node[propName] = null;
			}
			return node; // DomNode
		}
		node[propName] = value;
		return node;	// DomNode
	};
});

},
'dojo/dom-construct':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"],
		function(exports, dojo, has, win, dom, attr){
	// module:
	//		dojo/dom-construct
	// summary:
	//		This module defines the core dojo DOM construction API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// support stuff for toDom()
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + dojo._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		if(tagWrap.hasOwnProperty(param)){
			var tw = tagWrap[param];
			tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
			tw.post = "</" + tw.reverse().join("></") + ">";
			// the last line is destructive: it reverses the array,
			// but we don't care at this point
		}
	}

	var html5domfix;
	if(has("ie") <= 8){
		html5domfix = function(doc){
			doc.__dojo_html5_tested = "yes";
			var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
			if(div.childNodes.length !== 1){
				('abbr article aside audio canvas details figcaption figure footer header ' +
				'hgroup mark meter nav output progress section summary time video').replace(
					/\b\w+\b/g, function(n){
						doc.createElement(n);
					}
				);
			}
			destroy(div);
		}
	}

	function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
		// summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	exports.toDom = function toDom(frag, doc){
		// summary:
		//		instantiates an HTML fragment returning the corresponding DOM.
		// frag: String
		//		the HTML fragment
		// doc: DocumentNode?
		//		optional document to use when creating DOM nodes, defaults to
		//		dojo/_base/window.doc if not specified.
		// returns:
		//		Document fragment, unless it's a single node in which case it returns the node itself
		// example:
		//		Create a table row:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
		//	|	});

		doc = doc || win.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		if(has("ie") <= 8){
			if(!doc.__dojo_html5_tested && doc.body){
				html5domfix(doc);
			}
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}

		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while((fc = master.firstChild)){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DocumentFragment
	};

	exports.place = function place(node, refNode, position){
		// summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns the first argument resolved to a DOM node.
		// node: DOMNode|DocumentFragment|String
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		// refNode: DOMNode|String
		//		id or node reference to use as basis for placement
		// position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode.
		//		Accepted string values are:
		//
		//		- before
		//		- after
		//		- replace
		//		- only
		//		- first
		//		- last
		//
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		// returns: DOMNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
		// example:
		//		Place a node by string id as the last child of another node by string id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode");
		//	|	});
		// example:
		//		Place a node by string id before another node by string id
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode", "before");
		//	|	});
		// example:
		//		Create a Node, and place it in the body element (last child):
		//	|	require(["dojo/dom-construct", "dojo/_base/window"
		//	|	], function(domConstruct, win){
		//	|		domConstruct.place("<div></div>", win.body());
		//	|	});
		// example:
		//		Put a new LI as the first child of a list by id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("<li></li>", "someUl", "first");
		//	|	});

		refNode = dom.byId(refNode);
		if(typeof node == "string"){ // inline'd type check
			node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
		}
		if(typeof position == "number"){ // inline'd type check
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break;
				case "only":
					exports.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
					refNode.appendChild(node);
			}
		}
		return node; // DomNode
	};

	var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
		// summary:
		//		Create an element, allowing for optional attribute decoration
		//		and placement.
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step,
		//		as well as an optional DOM placement reference.
		//
		//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
		//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
		//
		//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
		//		the action node, passing along the optional reference node and position.
		// tag: DOMNode|String
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo/dom-attr.set` for a description of available attributes.
		// refNode: DOMNode|String?
		//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		// example:
		//		Create a DIV:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div");
		//	|	});
		//
		// example:
		//		Create a DIV with content:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
		//	|	});
		//
		// example:
		//		Place a new DIV in the BODY, with no attributes set
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		var n = domConstruct.create("div", null, win.body());
		//	|	});
		//
		// example:
		//		Create an UL, and populate it with LI's. Place the list as the first-child of a
		//		node with id="someId":
		//	|	require(["dojo/dom-construct", "dojo/_base/array"],
		//	|	function(domConstruct, arrayUtil){
		//	|		var ul = domConstruct.create("ul", null, "someId", "first");
		//	|		var items = ["one", "two", "three", "four"];
		//	|		arrayUtil.forEach(items, function(data){
		//	|			domConstruct.create("li", { innerHTML: data }, ul);
		//	|		});
		//	|	});
		//
		// example:
		//		Create an anchor, with an href. Place in BODY:
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
		//	|	});

		var doc = win.doc;
		if(refNode){
			refNode = dom.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(typeof tag == "string"){ // inline'd type check
			tag = doc.createElement(tag);
		}
		if(attrs){ attr.set(tag, attrs); }
		if(refNode){ exports.place(tag, refNode, pos); }
		return tag; // DomNode
	};

	function _empty(/*DomNode*/ node){
		// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
		// and then uncomment the emptyGrandchildren() test case from html.html.
		// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
		// see http://jsperf.com/clear-dom-node.
		if("innerHTML" in node){
			try{
				// fast path
				node.innerHTML = "";
				return;
			}catch(e){
				// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
				// Fall through (saves bytes)
			}
		}

		// SVG/strict elements don't support innerHTML
		for(var c; c = node.lastChild;){ // intentional assignment
			node.removeChild(c);
		}
	}

	exports.empty = function empty(/*DOMNode|String*/ node){
		// summary:
		//		safely removes all children of the node.
		// node: DOMNode|String
		//		a reference to a DOM node or an id.
		// example:
		//		Destroy node's children byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.empty("someId");
		//	|	});

		_empty(dom.byId(node));
	};


	function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
		// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
		if(node.firstChild){
			_empty(node);
		}
		if(parent){
			// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
			// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
			// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
			// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
			has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
		}
	}
	var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
		// summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		// description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//
		// node: DOMNode|String
		//		A String ID or DomNode reference of the element to be destroyed
		//
		// example:
		//		Destroy a node byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.destroy("someId");
		//	|	});

		node = dom.byId(node);
		if(!node){ return; }
		_destroy(node, node.parentNode);
	};
});

},
'dojo/dom-class':function(){
define(["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(dojo.hasClass("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling dojo.removeClass and dojo.addClass
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
});

},
'dojo/_base/NodeList':function(){
define(["./kernel", "../query", "./array", "./html", "../NodeList-dom"], function(dojo, query, array){
	// module:
	//		dojo/_base/NodeList

	/*=====
	return {
		// summary:
		//		This module extends dojo/NodeList with the legacy connect(), coords(),
		//		blur(), focus(), change(), click(), error(), keydown(), keypress(),
		//		keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
		//		mouseout(), mouseover(), mouseup(), and submit() methods.
	};
	=====*/
 
	var NodeList = query.NodeList,
		nlp = NodeList.prototype;

	nlp.connect = NodeList._adaptAsForEach(function(){
		// don't bind early to dojo.connect since we no longer explicitly depend on it
		return dojo.connect.apply(this, arguments);
	});
	/*=====
	nlp.connect = function(methodName, objOrFunc, funcName){
		// summary:
		//		Attach event handlers to every item of the NodeList. Uses dojo.connect()
		//		so event properties are normalized.
		//
		//		Application must manually require() "dojo/_base/connect" before using this method.
		// methodName: String
		//		the name of the method to attach to. For DOM events, this should be
		//		the lower-case name of the event
		// objOrFunc: Object|Function|String
		//		if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
		//		reference a function or be the name of the function in the global
		//		namespace to attach. If 3 arguments are provided
		//		(methodName, objOrFunc, funcName), objOrFunc must be the scope to
		//		locate the bound function in
		// funcName: String?
		//		optional. A string naming the function in objOrFunc to bind to the
		//		event. May also be a function reference.
		// example:
		//		add an onclick handler to every button on the page
		//		|	query("div:nth-child(odd)").connect("onclick", function(e){
		//		|		console.log("clicked!");
		//		|	});
		// example:
		//		attach foo.bar() to every odd div's onmouseover
		//		|	query("div:nth-child(odd)").connect("onmouseover", foo, "bar");

		return null;	// NodeList
	};
	=====*/

	nlp.coords = NodeList._adaptAsMap(dojo.coords);
	/*=====
	nlp.coords = function(){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//		Returns the box objects of all elements in a node list as
		//		an Array (*not* a NodeList). Acts like `domGeom.coords`, though assumes
		//		the node passed is each node in this list.

		return []; // Array
	};
	=====*/

	NodeList.events = [
		// summary:
		//		list of all DOM events used in NodeList
		"blur", "focus", "change", "click", "error", "keydown", "keypress",
		"keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove",
		"mouseout", "mouseover", "mouseup", "submit"
	];

	// FIXME: pseudo-doc the above automatically generated on-event functions

	// syntactic sugar for DOM events
	array.forEach(NodeList.events, function(evt){
			var _oe = "on" + evt;
			nlp[_oe] = function(a, b){
				return this.connect(_oe, a, b);
			};
				// FIXME: should these events trigger publishes?
				/*
				return (a ? this.connect(_oe, a, b) :
							this.forEach(function(n){
								// FIXME:
								//		listeners get buried by
								//		addEventListener and can't be dug back
								//		out to be triggered externally.
								// see:
								//		http://developer.mozilla.org/en/docs/DOM:element

								console.log(n, evt, _oe);

								// FIXME: need synthetic event support!
								var _e = { target: n, faux: true, type: evt };
								// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });
								try{ n[evt](_e); }catch(e){ console.log(e); }
								try{ n[_oe](_e); }catch(e){ console.log(e); }
							})
				);
				*/
		}
	);

	dojo.NodeList = NodeList;
	return NodeList;
});

},
'dojo/query':function(){
define(["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"],
	function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
});

},
'dojo/selector/_loader':function(){
define(["../has", "require"],
		function(has, require){

"use strict";
var testDiv = document.createElement("div");
has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
has.add("dom-qsa3", function(){
			// test to see if we have a reasonable native selector engine available
			try{
				testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
				// Safari can't handle uppercase or unicode characters when
				// in quirks mode, IE8 can't handle pseudos like :empty
				return testDiv.querySelectorAll(".TEST:empty").length == 1;
			}catch(e){}
		});
var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
});

},
'dojo/NodeList-dom':function(){
define(["./_base/kernel", "./query", "./_base/array", "./_base/lang", "./dom-class", "./dom-construct", "./dom-geometry", "./dom-attr", "./dom-style"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle){

	// module:
	//		dojo/NodeList-dom.js

	/*=====
	 return function(){
		 // summary:
		 //		Adds DOM related methods to NodeList, and returns NodeList constructor.
	 };
	 =====*/

	var magicGuard = function(a){
		// summary:
		//		the guard function for dojo/dom-attr() and dojo/dom-style()
		return a.length == 1 && (typeof a[0] == "string"); // inline'd type check
	};

	var orphan = function(node){
		// summary:
		//		function to orphan nodes
		var p = node.parentNode;
		if(p){
			p.removeChild(node);
		}
	};
	// FIXME: should we move orphan() to dojo/_base/html?

	var NodeList = query.NodeList,
		awc = NodeList._adaptWithCondition,
		aafe = NodeList._adaptAsForEach,
		aam = NodeList._adaptAsMap;

	function getSet(module){
		return function(node, name, value){
			if(arguments.length == 2){
				return module[typeof name == "string" ? "get" : "set"](node, name);
			}
			// setter
			return module.set(node, name, value);
		};
	}

	lang.extend(NodeList, {
		_normalize: function(/*String||Element||Object||NodeList*/content, /*DOMNode?*/refNode){
			// summary:
			//		normalizes data to an array of items to insert.
			// description:
			//		If content is an object, it can have special properties "template" and
			//		"parse". If "template" is defined, then the template value is run through
			//		dojo/string.substitute (if dojo/string.substitute() has been required elsewhere),
			//		or if templateFunc is a function on the content, that function will be used to
			//		transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
			//		If content.parse is true, then it is remembered for later, for when the content
			//		nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
			//		(if dojo/parser has been required elsewhere).

			//Wanted to just use a DocumentFragment, but for the array/NodeList
			//case that meant using cloneNode, but we may not want that.
			//Cloning should only happen if the node operations span
			//multiple refNodes. Also, need a real array, not a NodeList from the
			//DOM since the node movements could change those NodeLists.

			var parse = content.parse === true;

			//Do we have an object that needs to be run through a template?
			if(typeof content.template == "string"){
				var templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);
				content = templateFunc ? templateFunc(content.template, content) : content;
			}

			var type = (typeof content);
			if(type == "string" || type == "number"){
				content = domCtr.toDom(content, (refNode && refNode.ownerDocument));
				if(content.nodeType == 11){
					//DocumentFragment. It cannot handle cloneNode calls, so pull out the children.
					content = lang._toArray(content.childNodes);
				}else{
					content = [content];
				}
			}else if(!lang.isArrayLike(content)){
				content = [content];
			}else if(!lang.isArray(content)){
				//To get to this point, content is array-like, but
				//not an array, which likely means a DOM NodeList. Convert it now.
				content = lang._toArray(content);
			}

			//Pass around the parse info
			if(parse){
				content._runParse = true;
			}
			return content; //Array
		},

		_cloneNode: function(/*DOMNode*/ node){
			// summary:
			//		private utility to clone a node. Not very interesting in the vanilla
			//		dojo/NodeList case, but delegates could do interesting things like
			//		clone event handlers if that is derivable from the node.
			return node.cloneNode(true);
		},

		_place: function(/*Array*/ary, /*DOMNode*/refNode, /*String*/position, /*Boolean*/useClone){
			// summary:
			//		private utility to handle placing an array of nodes relative to another node.
			// description:
			//		Allows for cloning the nodes in the array, and for
			//		optionally parsing widgets, if ary._runParse is true.

			//Avoid a disallowed operation if trying to do an innerHTML on a non-element node.
			if(refNode.nodeType != 1 && position == "only"){
				return;
			}
			var rNode = refNode, tempNode;

			//Always cycle backwards in case the array is really a
			//DOM NodeList and the DOM operations take it out of the live collection.
			var length = ary.length;
			for(var i = length - 1; i >= 0; i--){
				var node = (useClone ? this._cloneNode(ary[i]) : ary[i]);

				//If need widget parsing, use a temp node, instead of waiting after inserting into
				//real DOM because we need to start widget parsing at one node up from current node,
				//which could cause some already parsed widgets to be parsed again.
				if(ary._runParse && dojo.parser && dojo.parser.parse){
					if(!tempNode){
						tempNode = rNode.ownerDocument.createElement("div");
					}
					tempNode.appendChild(node);
					dojo.parser.parse(tempNode);
					node = tempNode.firstChild;
					while(tempNode.firstChild){
						tempNode.removeChild(tempNode.firstChild);
					}
				}

				if(i == length - 1){
					domCtr.place(node, rNode, position);
				}else{
					rNode.parentNode.insertBefore(node, rNode);
				}
				rNode = node;
			}
		},


		position: aam(domGeom.position),
		/*=====
		position: function(){
			// summary:
			//		Returns border-box objects (x/y/w/h) of all elements in a node list
			//		as an Array (*not* a NodeList). Acts like `dojo/dom-geometry-position`, though
			//		assumes the node passed is each node in this list.

			return dojo.map(this, dojo.position); // Array
		},
		=====*/

		attr: awc(getSet(domAttr), magicGuard),
		/*=====
		attr: function(property, value){
			// summary:
			//		gets or sets the DOM attribute for every element in the
			//		NodeList. See also `dojo/dom-attr`
			// property: String
			//		the attribute to get/set
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of attribute values
			//		If a value is passed, the return is this NodeList
			// example:
			//		Make all nodes with a particular class focusable:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query(".focusable").attr("tabIndex", -1);
			//	|	});
			// example:
			//		Disable a group of buttons:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query("button.group").attr("disabled", true);
			//	|	});
			// example:
			//		innerHTML can be assigned or retrieved as well:
			//	|	// get the innerHTML (as an array) for each list item
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		var ih = query("li.replaceable").attr("innerHTML");
			//	|	});
			return; // dojo/NodeList|Array
		},
		=====*/

		style: awc(getSet(domStyle), magicGuard),
		/*=====
		style: function(property, value){
			// summary:
			//		gets or sets the CSS property for every element in the NodeList
			// property: String
			//		the CSS property to get/set, in JavaScript notation
			//		("lineHieght" instead of "line-height")
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of strings.
			//		If a value is passed, the return is this NodeList
			return; // dojo/NodeList
			return; // Array
		},
		=====*/

		addClass: aafe(domCls.add),
		/*=====
		addClass: function(className){
			// summary:
			//		adds the specified class to every node in the list
			// className: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		},
		=====*/

		removeClass: aafe(domCls.remove),
		/*=====
		removeClass: function(className){
			// summary:
			//		removes the specified class from every node in the list
			// className: String|Array?
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			// returns:
			//		this list
			return; // dojo/NodeList
		},
		=====*/

		toggleClass: aafe(domCls.toggle),
		/*=====
		toggleClass: function(className, condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			// condition: Boolean?
			//		If passed, true means to add the class, false means to remove.
			// className: String
			//		the CSS class to add
			return; // dojo/NodeList
		},
		=====*/

		replaceClass: aafe(domCls.replace),
		/*=====
		replaceClass: function(addClassStr, removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling `removeClass()` and `addClass()`
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		 },
		 =====*/

		empty: aafe(domCtr.empty),
		/*=====
		empty: function(){
			// summary:
			//		clears all content from each node in the list. Effectively
			//		equivalent to removing all child nodes from every item in
			//		the list.
			return this.forEach("item.innerHTML='';"); // dojo/NodeList
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		=====*/

		removeAttr: aafe(domAttr.remove),
		/*=====
		 removeAttr: function(name){
			// summary:
			//		Removes an attribute from each node in the list.
			// name: String
			//		the name of the attribute to remove
			return;		// dojo/NodeList
		},
		=====*/

		marginBox: aam(domGeom.getMarginBox),
		/*=====
		marginBox: function(){
			// summary:
			//		Returns margin-box size of nodes
		 	return; // dojo/NodeList
		 },
		 =====*/

		// FIXME: connectPublisher()? connectRunOnce()?

		/*
		destroy: function(){
			// summary:
			//		destroys every item in the list.
			this.forEach(d.destroy);
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		*/

		place: function(/*String||Node*/ queryOrNode, /*String*/ position){
			// summary:
			//		places elements of this node list relative to the first element matched
			//		by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
			// queryOrNode:
			//		may be a string representing any valid CSS3 selector or a DOM node.
			//		In the selector case, only the first matching element will be used
			//		for relative positioning.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			var item = query(queryOrNode)[0];
			return this.forEach(function(node){ domCtr.place(node, item, position); }); // dojo/NodeList
		},

		orphan: function(/*String?*/ filter){
			// summary:
			//		removes elements in this list that match the filter
			//		from their parents and returns them as a new NodeList.
			// filter:
			//		CSS selector like ".foo" or "div > span"
			// returns:
			//		NodeList containing the orphaned elements
			return (filter ? query._filterResult(this, filter) : this).forEach(orphan); // dojo/NodeList
		},

		adopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){
			// summary:
			//		places any/all elements in queryOrListOrNode at a
			//		position relative to the first element in this list.
			//		Returns a dojo/NodeList of the adopted elements.
			// queryOrListOrNode:
			//		a DOM node or a query string or a query result.
			//		Represents the nodes to be adopted relative to the
			//		first element of this NodeList.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			return query(queryOrListOrNode).place(this[0], position)._stash(this);	// dojo/NodeList
		},

		// FIXME: do we need this?
		query: function(/*String*/ queryStr){
			// summary:
			//		Returns a new list whose members match the passed query,
			//		assuming elements of the current NodeList as the root for
			//		each search.
			// example:
			//		assume a DOM created by this markup:
			//	|	<div id="foo">
			//	|		<p>
			//	|			bacon is tasty, <span>dontcha think?</span>
			//	|		</p>
			//	|	</div>
			//	|	<div id="bar">
			//	|		<p>great comedians may not be funny <span>in person</span></p>
			//	|	</div>
			//		If we are presented with the following definition for a NodeList:
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		var l = new NodeList(dom.byId("foo"), dom.byId("bar"));
			//		it's possible to find all span elements under paragraphs
			//		contained by these elements with this sub-query:
			//	|		var spans = l.query("p span");
			//	|	});

			// FIXME: probably slow
			if(!queryStr){ return this; }
			var ret = new NodeList;
			this.map(function(node){
				// FIXME: why would we ever get undefined here?
				query(queryStr, node).forEach(function(subNode){
					if(subNode !== undefined){
						ret.push(subNode);
					}
				});
			});
			return ret._stash(this);	// dojo/NodeList
		},

		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in dojo.filter:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter(function(item){
			//	|			// highlight every paragraph
			//	|			return (item.nodeName == "p");
			//	|		}).style("backgroundColor", "yellow");
			//	|	});
			// example:
			//	the same filtering using a CSS selector
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter("p").styles("backgroundColor", "yellow");
			//	|	});
			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},

		/*
		// FIXME: should this be "copyTo" and include parenting info?
		clone: function(){
			// summary:
			//		creates node clones of each element of this list
			//		and returns a new list containing the clones
		},
		*/

		addContent: function(/*String||DomNode||Object||dojo/NodeList*/ content, /*String||Integer?*/ position){
			// summary:
			//		add a node, NodeList or some HTML as a string to every item in the
			//		list.  Returns the original list.
			// description:
			//		a copy of the HTML content is added to each item in the
			//		list, with an optional position argument. If no position
			//		argument is provided, the content is appended to the end of
			//		each item.
			// content:
			//		DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
			//		NodeList, the content will be cloned if the current NodeList has more than one
			//		element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
			//		it should be an object with at "template" String property that has the HTML string
			//		to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
			//		will be used on the "template" to generate the final HTML string. Other allowed
			//		properties on the object are: "parse" if the HTML
			//		string should be parsed for widgets (dojo.require("dojo.parser") to get that
			//		option to work), and "templateFunc" if a template function besides dojo.string.substitute
			//		should be used to transform the "template".
			// position:
			//		can be one of:
			//
			//		-	"last"||"end" (default)
			//		-	"first||"start"
			//		-	"before"
			//		-	"after"
			//		-	"replace" (replaces nodes in this NodeList with new content)
			//		-	"only" (removes other children of the nodes so new content is the only child)
			//
			//		or an offset in the childNodes property
			// example:
			//		appends content to the end if the position is omitted
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("h3 > p").addContent("hey there!");
			//	|	});
			// example:
			//		add something to the front of each element that has a
			//		"thinger" property:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("[thinger]").addContent("...", "first");
			//	|	});
			// example:
			//		adds a header before each element of the list
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query(".note").addContent("<h4>NOTE:</h4>", "before");
			//	|	});
			// example:
			//		add a clone of a DOM node to the end of every element in
			//		the list, removing it from its existing parent.
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		query(".note").addContent(dom.byId("foo"));
			//	|	});
			// example:
			//		Append nodes from a templatized string.
			//	|	require(["dojo/string", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, query){
			//	|		query(".note").addContent({
			//	|			template: '<b>${id}: </b><span>${name}</span>',
			//	|			id: "user332",
			//	|			name: "Mr. Anderson"
			//	|		});
			//	|	});
			// example:
			//		Append nodes from a templatized string that also has widgets parsed.
			//	|	require(["dojo/string", "dojo/parser", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, parser, query){
			//	|		var notes = query(".note").addContent({
			//	|			template: '<button dojoType="dijit/form/Button">${text}</button>',
			//	|			parse: true,
			//	|			text: "Send"
			//	|		});
			//	|	});
			content = this._normalize(content, this[0]);
			for(var i = 0, node; (node = this[i]); i++){
				if(content.length){
					this._place(content, node, position, i > 0);
				}else{
					// if it is an empty array, we empty the target node
					domCtr.empty(node);
				}
			}
			return this; // dojo/NodeList
		}
	});

	return NodeList;
});

},
'dojo/_base/xhr':function(){
define([
	"./kernel",
	"./sniff",
	"require",
	"../io-query",
	/*===== "./declare", =====*/
	"../dom",
	"../dom-form",
	"./Deferred",
	"./config",
	"./json",
	"./lang",
	"./array",
	"../on",
	"../aspect",
	"../request/watch",
	"../request/xhr",
	"../request/util"
], function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = [{}];

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			miArgs.push(formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			miArgs.push(args.content);
		}
		if(args.preventCache){
			miArgs.push({"dojo.preventCache": new Date().valueOf()});
		}
		ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({url:url, sync:true, load:function(text){
			result = text;
		}});
		return result;
	};

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
});

},
'dojo/io-query':function(){
define(["./_base/lang"], function(lang){

// module:
//		dojo/io-query

var backstop = {};

return {
// summary:
//		This module defines query string processing functions.

	objectToQuery: function objectToQuery(/*Object*/ map){
		// summary:
        //		takes a name/value mapping object and returns a string representing
        //		a URL-encoded version of that object.
        // example:
        //		this object:
        //
        //	|	{
        //	|		blah: "blah",
        //	|		multi: [
        //	|			"thud",
        //	|			"thonk"
        //	|		]
        //	|	};
        //
        //		yields the following query string:
        //
        //	|	"blah=blah&multi=thud&multi=thonk"

        // FIXME: need to implement encodeAscii!!
        var enc = encodeURIComponent, pairs = [];
        for(var name in map){
            var value = map[name];
            if(value != backstop[name]){
                var assign = enc(name) + "=";
                if(lang.isArray(value)){
                    for(var i = 0, l = value.length; i < l; ++i){
                        pairs.push(assign + enc(value[i]));
                    }
                }else{
                    pairs.push(assign + enc(value));
                }
            }
        }
        return pairs.join("&"); // String
    },

	queryToObject: function queryToObject(/*String*/ str){
        // summary:
        //		Create an object representing a de-serialized query section of a
        //		URL. Query keys with multiple values are returned in an array.
        //
        // example:
        //		This string:
        //
        //	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
        //
        //		results in this object structure:
        //
        //	|		{
        //	|			foo: [ "bar", "baz" ],
        //	|			thinger: " spaces =blah",
        //	|			zonk: "blarg"
        //	|		}
        //
        //		Note that spaces and other urlencoded entities are correctly
        //		handled.

        // FIXME: should we grab the URL string if we're not passed one?
        var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
        for(var i = 0, l = qp.length, item; i < l; ++i){
            item = qp[i];
            if(item.length){
                var s = item.indexOf("=");
                if(s < 0){
                    name = dec(item);
                    val = "";
                }else{
                    name = dec(item.slice(0, s));
                    val  = dec(item.slice(s + 1));
                }
                if(typeof ret[name] == "string"){ // inline'd type check
                    ret[name] = [ret[name]];
                }

                if(lang.isArray(ret[name])){
                    ret[name].push(val);
                }else{
                    ret[name] = val;
                }
            }
        }
        return ret; // Object
    }
};
});
},
'dojo/dom-form':function(){
define(["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
});

},
'dojo/json':function(){
define(["./has"], function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
});

},
'dojo/_base/Deferred':function(){
define([
	"./kernel",
	"../Deferred",
	"../promise/Promise",
	"../errors/CancelError",
	"../has",
	"./lang",
	"../when"
], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
});

},
'dojo/Deferred':function(){
define([
	"./has",
	"./_base/lang",
	"./errors/CancelError",
	"./promise/Promise",
	"./promise/instrumentation"
], function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};

	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if( 1  && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if( 1  && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
});

},
'dojo/errors/CancelError':function(){
define(["./create"], function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	return create("CancelError", null, null, { dojoType: "cancel" });
});

},
'dojo/errors/create':function(){
define(["../_base/lang"], function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
});

},
'dojo/promise/Promise':function(){
define([
	"../_base/lang"
], function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
});

},
'dojo/promise/instrumentation':function(){
define([
	"./tracer",
	"../has",
	"../_base/lang",
	"../_base/array"
], function(tracer, has, lang, arrayUtil){
	has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");

	function logError(error, rejection, deferred){
		var stack = "";
		if(error && error.stack){
			stack += error.stack;
		}
		if(rejection && rejection.stack){
			stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
		}
		if(deferred && deferred.stack){
			stack += "\n    ----------------------------------------\n" + deferred.stack;
		}
		console.error(error, stack);
	}

	function reportRejections(error, handled, rejection, deferred){
		if(!handled){
			logError(error, rejection, deferred);
		}
	}

	var errors = [];
	var activeTimeout = false;
	var unhandledWait = 1000;
	function trackUnhandledRejections(error, handled, rejection, deferred){
		// try to find the existing tracking object
		if(!arrayUtil.some(errors, function(obj){
			if(obj.error === error){
				// found the tracking object for this error
				if(handled){
					// if handled, update the state
					obj.handled = true;
				}
				return true;
			}
		})){
			// no tracking object has been setup, create one
			errors.push({
				error: error,
				rejection: rejection,
				handled: handled,
				deferred: deferred,
				timestamp: new Date().getTime()
			});
		}

		if(!activeTimeout){
			activeTimeout = setTimeout(logRejected, unhandledWait);
		}
	}

	function logRejected(){
		var now = new Date().getTime();
		var reportBefore = now - unhandledWait;
		errors = arrayUtil.filter(errors, function(obj){
			// only report the error if we have waited long enough and
			// it hasn't been handled
			if(obj.timestamp < reportBefore){
				if(!obj.handled){
					logError(obj.error, obj.rejection, obj.deferred);
				}
				return false;
			}
			return true;
		});

		if(errors.length){
			activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
		}else{
			activeTimeout = false;
		}
	}

	return function(Deferred){
		// summary:
		//		Initialize instrumentation for the Deferred class.
		// description:
		//		Initialize instrumentation for the Deferred class.
		//		Done automatically by `dojo/Deferred` if the
		//		`deferredInstrumentation` and `useDeferredInstrumentation`
		//		config options are set.
		//
		//		Sets up `dojo/promise/tracer` to log to the console.
		//
		//		Sets up instrumentation of rejected deferreds so unhandled
		//		errors are logged to the console.

		var usage = has("config-useDeferredInstrumentation");
		if(usage){
			tracer.on("resolved", lang.hitch(console, "log", "resolved"));
			tracer.on("rejected", lang.hitch(console, "log", "rejected"));
			tracer.on("progress", lang.hitch(console, "log", "progress"));

			var args = [];
			if(typeof usage === "string"){
				args = usage.split(",");
				usage = args.shift();
			}
			if(usage === "report-rejections"){
				Deferred.instrumentRejected = reportRejections;
			}else if(usage === "report-unhandled-rejections" || usage === true || usage === 1){
				Deferred.instrumentRejected = trackUnhandledRejections;
				unhandledWait = parseInt(args[0], 10) || unhandledWait;
			}else{
				throw new Error("Unsupported instrumentation usage <" + usage + ">");
			}
		}
	};
});

},
'dojo/promise/tracer':function(){
define([
	"../_base/lang",
	"./Promise",
	"../Evented"
], function(lang, Promise, Evented){
	"use strict";

	// module:
	//		dojo/promise/tracer

	/*=====
	return {
		// summary:
		//		Trace promise fulfillment.
		// description:
		//		Trace promise fulfillment. Calling `.trace()` or `.traceError()` on a
		//		promise enables tracing. Will emit `resolved`, `rejected` or `progress`
		//		events.

		on: function(type, listener){
			// summary:
			//		Subscribe to traces.
			// description:
			//		See `dojo/Evented#on()`.
			// type: String
			//		`resolved`, `rejected`, or `progress`
			// listener: Function
			//		The listener is passed the traced value and any arguments
			//		that were used with the `.trace()` call.
		}
	};
	=====*/

	var evented = new Evented;
	var emit = evented.emit;
	evented.emit = null;
	// Emit events asynchronously since they should not change the promise state.
	function emitAsync(args){
		setTimeout(function(){
			emit.apply(evented, args);
		}, 0);
	}

	Promise.prototype.trace = function(){
		// summary:
		//		Trace the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `trace()` is called on.

		var args = lang._toArray(arguments);
		this.then(
			function(value){ emitAsync(["resolved", value].concat(args)); },
			function(error){ emitAsync(["rejected", error].concat(args)); },
			function(update){ emitAsync(["progress", update].concat(args)); }
		);
		return this;
	};

	Promise.prototype.traceRejected = function(){
		// summary:
		//		Trace rejection of the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `traceRejected()` is called on.

		var args = lang._toArray(arguments);
		this.otherwise(function(error){
			emitAsync(["rejected", error].concat(args));
		});
		return this;
	};

	return evented;
});

},
'dojo/when':function(){
define([
	"./Deferred",
	"./promise/Promise"
], function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
});

},
'dojo/_base/json':function(){
define(["./kernel", "../json"], function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
});

},
'dojo/request/watch':function(){
define([
	'./util',
	'../errors/RequestTimeoutError',
	'../errors/CancelError',
	'../_base/array',
	'../_base/window',
	'../has!host-browser?dom-addeventlistener?:../on:'
], function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
});

},
'dojo/request/util':function(){
define([
	'exports',
	'../errors/RequestError',
	'../errors/CancelError',
	'../Deferred',
	'../io-query',
	'../_base/array',
	'../_base/lang',
	'../promise/Promise'
], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise){
	exports.deepCopy = function deepCopy(target, source){
		for(var name in source){
			var tval = target[name],
				sval = source[name];
			if(tval !== sval){
				if(tval && typeof tval === 'object' && sval && typeof sval === 'object'){
					exports.deepCopy(tval, sval);
				}else{
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data || response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;
		
		if(data && !skipData){
			if(typeof data === 'object'){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
});

},
'dojo/errors/RequestError':function(){
define(['./create'], function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
});

},
'dojo/errors/RequestTimeoutError':function(){
define(['./create', './RequestError'], function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
});

},
'dojo/request/xhr':function(){
define([
	'../errors/RequestError',
	'./watch',
	'./handlers',
	'./util',
	'../has'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && !document.addEventListener && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData !== 'undefined';
	});

	has.add('native-response-type', function(){
		return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
	});

	has.add('native-xhr2-blob', function(){
		if(!has('native-response-type')){ return; }
		var x = new XMLHttpRequest();
		x.open('GET', '/', true);
		x.responseType = 'blob';
		// will not be set if unsupported
		var responseType = x.responseType;
		x.abort();
		return responseType === 'blob';
	});

	// Google Chrome doesn't support "json" response type
	// up to version 30, so it's intentionally not included here
	var nativeResponseTypes = {
		'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
		'document': 'document',
		'arraybuffer': 'arraybuffer'
	};

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;

		try {
			// Firefox throws an error when trying to access
			// xhr.responseText if response isn't text
			response.text = _xhr.responseText;
		} catch (e) {}

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		if(!error){
			try{
				handlers(response);
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(util.checkStatus(_xhr.status)){
			this.resolve(response);
		}else{
			error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);

			this.reject(error);
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(evt){
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				} else if(response.xhr.readyState === 3){
					response.loaded = evt.position;
					dfd.progress(response);
				}
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onProgress, false);

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			isFormData
		);
		url = response.url;
		options = response.options;

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response);
		}

		var data = options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
				_xhr.responseType = nativeResponseTypes[options.handleAs];
			}

			var headers = options.headers,
				contentType = isFormData ? false : 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
});

},
'dojo/request/handlers':function(){
define([
	'../json',
	'../_base/kernel',
	'../_base/array',
	'../has',
	'../selector/_loader' // only included for has() qsa tests
], function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];
		var lastParser;

		handleXML = function(response){
			var result = response.data;
			var text = response.text;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(text, 'application/xml');
			}

			function createDocument(p) {
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
						lastParser = p;
					}catch(e){ return false; }
					return true;
			}

			if(!result || !result.documentElement){
				// The creation of an ActiveX object is expensive, so we cache the
				// parser type to avoid trying all parser types each time we handle a
				// document. There is some concern that some parser types might fail
				// depending on the document being parsed. If parsing using the cached
				// parser type fails, we do the more expensive operation of finding one
				// that works for the given document.
				// https://bugs.dojotoolkit.org/ticket/15246
				if(!lastParser || !createDocument(lastParser)) {
					array.some(dp, createDocument);
				}
			}

			return result;
		};
	}

	var handleNativeResponse = function(response) {
		if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
			return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
		}

		return response.xhr.response;
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML,
		'blob': handleNativeResponse,
		'arraybuffer': handleNativeResponse,
		'document': handleNativeResponse
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
});

},
'dojo/_base/fx':function(){
define(["./kernel", "./config", /*===== "./declare", =====*/ "./lang", "../Evented", "./Color", "../aspect", "../sniff", "../dom", "../dom-style"],
	function(dojo, config, /*===== declare, =====*/ lang, Evented, Color, aspect, has, dom, style){
	// module:
	//		dojo/_base/fx
	// notes:
	//		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
	//		http://pupius.co.uk/js/Toolkit.Drawing.js

	var _mixin = lang.mixin;

	// Module export
	var basefx = {
		// summary:
		//		This module defines the base dojo/_base/fx implementation.
	};

	var _Line = basefx._Line = function(/*int*/ start, /*int*/ end){
		// summary:
		//		Object used to generate values from a start value to an end value
		// start: int
		//		Beginning value for range
		// end: int
		//		Ending value for range
		this.start = start;
		this.end = end;
	};

	_Line.prototype.getValue = function(/*float*/ n){
		// summary:
		//		Returns the point on the line
		// n:
		//		a floating point number greater than 0 and less than 1
		return ((this.end - this.start) * n) + this.start; // Decimal
	};

	var Animation = basefx.Animation = function(args){
		// summary:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states.
		// description:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states. Nearly all dojo animation functions
		//		return an instance of this method, usually without calling the
		//		.play() method beforehand. Therefore, you will likely need to
		//		call .play() on instances of `Animation` when one is
		//		returned.
		// args: Object
		//		The 'magic argument', mixing all the properties into this
		//		animation instance.

		_mixin(this, args);
		if(lang.isArray(this.curve)){
			this.curve = new _Line(this.curve[0], this.curve[1]);
		}

	};
	Animation.prototype = new Evented();

	lang.extend(Animation, {
		// duration: Integer
		//		The time in milliseconds the animation will take to run
		duration: 350,

	/*=====
		// curve: _Line|Array
		//		A two element array of start and end values, or a `_Line` instance to be
		//		used in the Animation.
		curve: null,

		// easing: Function?
		//		A Function to adjust the acceleration (or deceleration) of the progress
		//		across a _Line
		easing: null,
	=====*/

		// repeat: Integer?
		//		The number of times to loop the animation
		repeat: 0,

		// rate: Integer?
		//		the time in milliseconds to wait before advancing to next frame
		//		(used as a fps timer: 1000/rate = fps)
		rate: 20 /* 50 fps */,

	/*=====
		// delay: Integer?
		//		The time in milliseconds to wait before starting animation after it
		//		has been .play()'ed
		delay: null,

		// beforeBegin: Event?
		//		Synthetic event fired before a Animation begins playing (synchronous)
		beforeBegin: null,

		// onBegin: Event?
		//		Synthetic event fired as a Animation begins playing (useful?)
		onBegin: null,

		// onAnimate: Event?
		//		Synthetic event fired at each interval of the Animation
		onAnimate: null,

		// onEnd: Event?
		//		Synthetic event fired after the final frame of the Animation
		onEnd: null,

		// onPlay: Event?
		//		Synthetic event fired any time the Animation is play()'ed
		onPlay: null,

		// onPause: Event?
		//		Synthetic event fired when the Animation is paused
		onPause: null,

		// onStop: Event
		//		Synthetic event fires when the Animation is stopped
		onStop: null,

	=====*/

		_percent: 0,
		_startRepeatCount: 0,

		_getStep: function(){
			var _p = this._percent,
				_e = this.easing
			;
			return _e ? _e(_p) : _p;
		},
		_fire: function(/*Event*/ evt, /*Array?*/ args){
			// summary:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			// description:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			//		Fires the callback in the scope of this Animation
			//		instance.
			// evt:
			//		The event to fire.
			// args:
			//		The arguments to pass to the event.
			var a = args||[];
			if(this[evt]){
				if(config.debugAtAllCosts){
					this[evt].apply(this, a);
				}else{
					try{
						this[evt].apply(this, a);
					}catch(e){
						// squelch and log because we shouldn't allow exceptions in
						// synthetic event handlers to cause the internal timer to run
						// amuck, potentially pegging the CPU. I'm not a fan of this
						// squelch, but hopefully logging will make it clear what's
						// going on
						console.error("exception in animation handler for:", evt);
						console.error(e);
					}
				}
			}
			return this; // Animation
		},

		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			// summary:
			//		Start the animation.
			// delay:
			//		How many milliseconds to delay before starting.
			// gotoStart:
			//		If true, starts the animation from the beginning; otherwise,
			//		starts it from its current position.
			// returns: Animation
			//		The instance to allow chaining.

			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(gotoStart){
				_t._stopTimer();
				_t._active = _t._paused = false;
				_t._percent = 0;
			}else if(_t._active && !_t._paused){
				return _t;
			}

			_t._fire("beforeBegin", [_t.node]);

			var de = delay || _t.delay,
				_p = lang.hitch(_t, "_play", gotoStart);

			if(de > 0){
				_t._delayTimer = setTimeout(_p, de);
				return _t;
			}
			_p();
			return _t;	// Animation
		},

		_play: function(gotoStart){
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._startTime = new Date().valueOf();
			if(_t._paused){
				_t._startTime -= _t.duration * _t._percent;
			}

			_t._active = true;
			_t._paused = false;
			var value = _t.curve.getValue(_t._getStep());
			if(!_t._percent){
				if(!_t._startRepeatCount){
					_t._startRepeatCount = _t.repeat;
				}
				_t._fire("onBegin", [value]);
			}

			_t._fire("onPlay", [value]);

			_t._cycle();
			return _t; // Animation
		},

		pause: function(){
			// summary:
			//		Pauses a running animation.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._stopTimer();
			if(!_t._active){ return _t; /*Animation*/ }
			_t._paused = true;
			_t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
			return _t; // Animation
		},

		gotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){
			// summary:
			//		Sets the progress of the animation.
			// percent:
			//		A percentage in decimal notation (between and including 0.0 and 1.0).
			// andPlay:
			//		If true, play the animation after setting the progress.
			var _t = this;
			_t._stopTimer();
			_t._active = _t._paused = true;
			_t._percent = percent;
			if(andPlay){ _t.play(); }
			return _t; // Animation
		},

		stop: function(/*boolean?*/ gotoEnd){
			// summary:
			//		Stops a running animation.
			// gotoEnd:
			//		If true, the animation will end.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(!_t._timer){ return _t; /* Animation */ }
			_t._stopTimer();
			if(gotoEnd){
				_t._percent = 1;
			}
			_t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
			_t._active = _t._paused = false;
			return _t; // Animation
		},

		destroy: function(){
			// summary:
			//		cleanup the animation
			this.stop();
		},

		status: function(){
			// summary:
			//		Returns a string token representation of the status of
			//		the animation, one of: "paused", "playing", "stopped"
			if(this._active){
				return this._paused ? "paused" : "playing"; // String
			}
			return "stopped"; // String
		},

		_cycle: function(){
			var _t = this;
			if(_t._active){
				var curr = new Date().valueOf();
				// Allow durations of 0 (instant) by setting step to 1 - see #13798
				var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / (_t.duration);

				if(step >= 1){
					step = 1;
				}
				_t._percent = step;

				// Perform easing
				if(_t.easing){
					step = _t.easing(step);
				}

				_t._fire("onAnimate", [_t.curve.getValue(step)]);

				if(_t._percent < 1){
					_t._startTimer();
				}else{
					_t._active = false;

					if(_t.repeat > 0){
						_t.repeat--;
						_t.play(null, true);
					}else if(_t.repeat == -1){
						_t.play(null, true);
					}else{
						if(_t._startRepeatCount){
							_t.repeat = _t._startRepeatCount;
							_t._startRepeatCount = 0;
						}
					}
					_t._percent = 0;
					_t._fire("onEnd", [_t.node]);
					!_t.repeat && _t._stopTimer();
				}
			}
			return _t; // Animation
		},

		_clearTimer: function(){
			// summary:
			//		Clear the play delay timer
			clearTimeout(this._delayTimer);
			delete this._delayTimer;
		}

	});

	// the local timer, stubbed into all Animation instances
	var ctr = 0,
		timer = null,
		runner = {
			run: function(){}
		};

	lang.extend(Animation, {

		_startTimer: function(){
			if(!this._timer){
				this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
				ctr++;
			}
			if(!timer){
				timer = setInterval(lang.hitch(runner, "run"), this.rate);
			}
		},

		_stopTimer: function(){
			if(this._timer){
				this._timer.remove();
				this._timer = null;
				ctr--;
			}
			if(ctr <= 0){
				clearInterval(timer);
				timer = null;
				ctr = 0;
			}
		}

	});

	var _makeFadeable =
		has("ie") ? function(node){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			var ns = node.style;
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(!ns.width.length && style.get(node, "width") == "auto"){
				ns.width = "auto";
			}
		} :
		function(){};

	basefx._fade = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will fade the node defined by
		//		args.node from the start to end values passed (args.start
		//		args.end) (end is mandatory, start is optional)

		args.node = dom.byId(args.node);
		var fArgs = _mixin({ properties: {} }, args),
			props = (fArgs.properties.opacity = {});

		props.start = !("start" in fArgs) ?
			function(){
				return +style.get(fArgs.node, "opacity")||0;
			} : fArgs.start;
		props.end = fArgs.end;

		var anim = basefx.animateProperty(fArgs);
		aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);

		return anim; // Animation
	};

	/*=====
	var __FadeArgs = declare(null, {
		// node: DOMNode|String
		//		The node referenced in the animation
		// duration: Integer?
		//		Duration of the animation in milliseconds.
		// easing: Function?
		//		An easing function.
	});
	=====*/

	basefx.fadeIn = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args' from
		//		its current opacity to fully opaque.
		return basefx._fade(_mixin({ end: 1 }, args)); // Animation
	};

	basefx.fadeOut = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args'
		//		from its current opacity to fully transparent.
		return basefx._fade(_mixin({ end: 0 }, args)); // Animation
	};

	basefx._defaultEasing = function(/*Decimal?*/ n){
		// summary:
		//		The default easing function for Animation(s)
		return 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);	// Decimal
	};

	var PropLine = function(properties){
		// PropLine is an internal class which is used to model the values of
		// an a group of CSS properties across an animation lifecycle. In
		// particular, the "getValue" function handles getting interpolated
		// values between start and end for a particular CSS value.
		this._properties = properties;
		for(var p in properties){
			var prop = properties[p];
			if(prop.start instanceof Color){
				// create a reusable temp color object to keep intermediate results
				prop.tempColor = new Color();
			}
		}
	};

	PropLine.prototype.getValue = function(r){
		var ret = {};
		for(var p in this._properties){
			var prop = this._properties[p],
				start = prop.start;
			if(start instanceof Color){
				ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
			}else if(!lang.isArray(start)){
				ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
			}
		}
		return ret;
	};

	/*=====
	var __AnimArgs = declare(__FadeArgs, {
		// properties: Object?
		//		A hash map of style properties to Objects describing the transition,
		//		such as the properties of _Line with an additional 'units' property
		properties: {}

		//TODOC: add event callbacks
	});
	=====*/

	basefx.animateProperty = function(/*__AnimArgs*/ args){
		// summary:
		//		Returns an animation that will transition the properties of
		//		node defined in `args` depending how they are defined in
		//		`args.properties`
		//
		// description:
		//		Foundation of most `dojo/_base/fx`
		//		animations. It takes an object of "properties" corresponding to
		//		style properties, and animates them in parallel over a set
		//		duration.
		//
		// example:
		//		A simple animation that changes the width of the specified node.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		properties: { width: 400 },
		//	|	}).play();
		//		Dojo figures out the start value for the width and converts the
		//		integer specified for the width to the more expressive but
		//		verbose form `{ width: { end: '400', units: 'px' } }` which you
		//		can also specify directly. Defaults to 'px' if omitted.
		//
		// example:
		//		Animate width, height, and padding over 2 seconds... the
		//		pedantic way:
		//	|	basefx.animateProperty({ node: node, duration:2000,
		//	|		properties: {
		//	|			width: { start: '200', end: '400', units:"px" },
		//	|			height: { start:'200', end: '400', units:"px" },
		//	|			paddingTop: { start:'5', end:'50', units:"px" }
		//	|		}
		//	|	}).play();
		//		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
		//		are written using "mixed case", as the hyphen is illegal as an object key.
		//
		// example:
		//		Plug in a different easing function and register a callback for
		//		when the animation ends. Easing functions accept values between
		//		zero and one and return a value on that basis. In this case, an
		//		exponential-in curve.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		// dojo figures out the start value
		//	|		properties: { width: { end: 400 } },
		//	|		easing: function(n){
		//	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
		//	|		},
		//	|		onEnd: function(node){
		//	|			// called when the animation finishes. The animation
		//	|			// target is passed to this function
		//	|		}
		//	|	}).play(500); // delay playing half a second
		//
		// example:
		//		Like all `Animation`s, animateProperty returns a handle to the
		//		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
		//		to access these events outside of the Animation definition:
		//	|	var anim = basefx.animateProperty({
		//	|		node:"someId",
		//	|		properties:{
		//	|			width:400, height:500
		//	|		}
		//	|	});
		//	|	aspect.after(anim, "onEnd", function(){
		//	|		console.log("animation ended");
		//	|	}, true);
		//	|	// play the animation now:
		//	|	anim.play();
		//
		// example:
		//		Each property can be a function whose return value is substituted along.
		//		Additionally, each measurement (eg: start, end) can be a function. The node
		//		reference is passed directly to callbacks.
		//	|	basefx.animateProperty({
		//	|		node:"mine",
		//	|		properties:{
		//	|			height:function(node){
		//	|				// shrink this node by 50%
		//	|				return domGeom.position(node).h / 2
		//	|			},
		//	|			width:{
		//	|				start:function(node){ return 100; },
		//	|				end:function(node){ return 200; }
		//	|			}
		//	|		}
		//	|	}).play();
		//

		var n = args.node = dom.byId(args.node);
		if(!args.easing){ args.easing = dojo._defaultEasing; }

		var anim = new Animation(args);
		aspect.after(anim, "beforeBegin", lang.hitch(anim, function(){
			var pm = {};
			for(var p in this.properties){
				// Make shallow copy of properties into pm because we overwrite
				// some values below. In particular if start/end are functions
				// we don't want to overwrite them or the functions won't be
				// called if the animation is reused.
				if(p == "width" || p == "height"){
					this.node.display = "block";
				}
				var prop = this.properties[p];
				if(lang.isFunction(prop)){
					prop = prop(n);
				}
				prop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop: { end: prop }));

				if(lang.isFunction(prop.start)){
					prop.start = prop.start(n);
				}
				if(lang.isFunction(prop.end)){
					prop.end = prop.end(n);
				}
				var isColor = (p.toLowerCase().indexOf("color") >= 0);
				function getStyle(node, p){
					// domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
					var v = { height: node.offsetHeight, width: node.offsetWidth }[p];
					if(v !== undefined){ return v; }
					v = style.get(node, p);
					return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
				}
				if(!("end" in prop)){
					prop.end = getStyle(n, p);
				}else if(!("start" in prop)){
					prop.start = getStyle(n, p);
				}

				if(isColor){
					prop.start = new Color(prop.start);
					prop.end = new Color(prop.end);
				}else{
					prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
				}
			}
			this.curve = new PropLine(pm);
		}), true);
		aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
		return anim; // Animation
	};

	basefx.anim = function(	/*DOMNode|String*/	node,
							/*Object*/			properties,
							/*Integer?*/		duration,
							/*Function?*/		easing,
							/*Function?*/		onEnd,
							/*Integer?*/		delay){
		// summary:
		//		A simpler interface to `animateProperty()`, also returns
		//		an instance of `Animation` but begins the animation
		//		immediately, unlike nearly every other Dojo animation API.
		// description:
		//		Simpler (but somewhat less powerful) version
		//		of `animateProperty`.  It uses defaults for many basic properties
		//		and allows for positional parameters to be used in place of the
		//		packed "property bag" which is used for other Dojo animation
		//		methods.
		//
		//		The `Animation` object returned will be already playing, so
		//		calling play() on it again is (usually) a no-op.
		// node:
		//		a DOM node or the id of a node to animate CSS properties on
		// duration:
		//		The number of milliseconds over which the animation
		//		should run. Defaults to the global animation default duration
		//		(350ms).
		// easing:
		//		An easing function over which to calculate acceleration
		//		and deceleration of the animation through its duration.
		//		A default easing algorithm is provided, but you may
		//		plug in any you wish. A large selection of easing algorithms
		//		are available in `dojo/fx/easing`.
		// onEnd:
		//		A function to be called when the animation finishes
		//		running.
		// delay:
		//		The number of milliseconds to delay beginning the
		//		animation by. The default is 0.
		// example:
		//		Fade out a node
		//	|	basefx.anim("id", { opacity: 0 });
		// example:
		//		Fade out a node over a full second
		//	|	basefx.anim("id", { opacity: 0 }, 1000);
		return basefx.animateProperty({ // Animation
			node: node,
			duration: duration || Animation.prototype.duration,
			properties: properties,
			easing: easing,
			onEnd: onEnd
		}).play(delay || 0);
	};


	if( 1 ){
		_mixin(dojo, basefx);
		// Alias to drop come 2.0:
		dojo._Animation = Animation;
	}

	return basefx;
});

},
'dojo/_base/Color':function(){
define(["./kernel", "./lang", "./array", "./config"], function(dojo, lang, ArrayUtil, config){

	var Color = dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		//		Work with a Color instance:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var c = new Color();
		//	|		c.setColor([0,0,0]); // black
		//	|		var hex = c.toHex(); // #000000
		//	|	});
		//
		// example:
		//		Work with a node's color:
		//	| 
		//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
		//	|		var color = domStyle("someNode", "backgroundColor");
		//	|		var n = new Color(color);
		//	|		// adjust the color some
		//	|		n.r *= .5;
		//	|		console.log(n.toString()); // rgb(128, 255, 255);
		//	|	});
		if(color){ this.setColor(color); }
	};

	// FIXME:
	// there's got to be a more space-efficient way to encode or discover
	// these!! Use hex?
	Color.named = {
		// summary:
		//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
		"black":  [0,0,0],
		"silver": [192,192,192],
		"gray":	  [128,128,128],
		"white":  [255,255,255],
		"maroon": [128,0,0],
		"red":	  [255,0,0],
		"purple": [128,0,128],
		"fuchsia":[255,0,255],
		"green":  [0,128,0],
		"lime":	  [0,255,0],
		"olive":  [128,128,0],
		"yellow": [255,255,0],
		"navy":	  [0,0,128],
		"blue":	  [0,0,255],
		"teal":	  [0,128,128],
		"aqua":	  [0,255,255],
		"transparent": config.transparentColor || [0,0,0,0]
	};

	lang.extend(Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and sets this color instance to that value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color(); // no color
			//	|		c.setColor("#ededed"); // greyish
			//	|	});
			if(lang.isString(color)){
				Color.fromString(color, this);
			}else if(lang.isArray(color)){
				Color.fromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof Color)){ this.sanitize(); }
			}
			return this;	// Color
		},
		sanitize: function(){
			// summary:
			//		Ensures the object has correct attributes
			// description:
			//		the default implementation does nothing, include dojo.colors to
			//		augment it with real checks
			return this;	// Color
		},
		toRgb: function(){
			// summary:
			//		Returns 3 component array of rgb values
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#000000");
			//	|		console.log(c.toRgb()); // [0,0,0]
			//	|	});
			var t = this;
			return [t.r, t.g, t.b]; // Array
		},
		toRgba: function(){
			// summary:
			//		Returns a 4 component array of rgba values from the color
			//		represented by this object.
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary:
			//		Returns a CSS color string in hexadecimal representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		console.log(new Color([0,0,0]).toHex()); // #000000
			//	|	});
			var arr = ArrayUtil.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary:
			//		Returns a css color string in rgb(a) representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#FFF").toCss();
			//	|		console.log(c); // rgb('255','255','255')
			//	|	});
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary:
			//		Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	Color.blendColors = dojo.blendColors = function(
		/*Color*/ start,
		/*Color*/ end,
		/*Number*/ weight,
		/*Color?*/ obj
	){
		// summary:
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated Color object for the result
		var t = obj || new Color();
		ArrayUtil.forEach(["r", "g", "b", "a"], function(x){
			t[x] = start[x] + (end[x] - start[x]) * weight;
			if(x != "a"){ t[x] = Math.round(t[x]); }
		});
		return t.sanitize();	// Color
	};

	Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Returns a `Color` instance from a string of the form
		//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
		//		object to update with the parsed value and return instead of
		//		creating a new object.
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
	};

	Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Converts a hex string with a '#' prefix to a color object.
		//		Supports 12-bit #rgb shorthand. Optionally accepts a
		//		`Color` object to update with the parsed value.
		//
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		//
		// example:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
		//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
		//	|	});
		var t = obj || new Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // Color
		}
		ArrayUtil.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// Color
	};

	Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
		// summary:
		//		Builds a `Color` from a 3 or 4 element array, mapping each
		//		element in sequence to the rgb(a) values of the color.
		// example:
		//		|	require(["dojo/_base/color"], function(Color){
		//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
		//		|	});
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var t = obj || new Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// Color
	};

	Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
		// summary:
		//		Parses `str` for a color value. Accepts hex, rgb, and rgba
		//		style color values.
		// description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var a = Color.named[str];
		return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
	};

	return Color;
});

},
'dojo/_base/declare':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor = new Function, counter = 0, cname = "constructor";

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args == "string"){
			name = args;
			args = a;
			a = f;
		}
		f = 0;

		caller = args.callee;
		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args){
		if(typeof name == "string"){
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2){
		var f = this.getInherited(args, a1);
		if(f){ return f.apply(this, a2 || a1 || args); }
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

    function createSubclass(mixins, props){
        // crack parameters
        if(!(mixins instanceof Array || typeof mixins == 'function')){
            props = mixins;
            mixins = undefined;
        }

        props = props || {};
        mixins = mixins || [];

        return declare([this].concat(mixins), props);
    }

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				ctor = new Function;
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},

		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
});

},
'dojo/_base/loader':function(){
define(["./kernel", "../has", "require", "module", "../json", "./lang", "./array"], function(dojo, has, require, thisModule, json, lang, array) {
	// module:
	//		dojo/_base/loader

	//		This module defines the v1.x synchronous loader API.

	// signal the loader in sync mode...
	//>>pure-amd

	if (! 1 ){
		console.error("cannot load the Dojo v1.x loader with a foreign loader");
		return 0;
	}

	 1 || has.add("dojo-fast-sync-require", 1);


	var makeErrorToken = function(id){
			return {src:thisModule.id, id:id};
		},

		slashName = function(name){
			return name.replace(/\./g, "/");
		},

		buildDetectRe = /\/\/>>built/,

		dojoRequireCallbacks = [],
		dojoRequireModuleStack = [],

		dojoRequirePlugin = function(mid, require, loaded){
			dojoRequireCallbacks.push(loaded);
			array.forEach(mid.split(","), function(mid){
				var module = getModule(mid, require.module);
				dojoRequireModuleStack.push(module);
				injectModule(module);
			});
			checkDojoRequirePlugin();
		},

		checkDojoRequirePlugin = ( 1  ?
			// This version of checkDojoRequirePlugin makes the observation that all dojoRequireCallbacks can be released
			// when all *non-dojo/require!, dojo/loadInit!* modules are either executed, not requested, or arrived. This is
			// the case since there are no more modules the loader is waiting for, therefore, dojo/require! must have
			// everything it needs on board.
			//
			// The potential weakness of this algorithm is that dojo/require will not execute callbacks until *all* dependency
			// trees are ready. It is possible that some trees may be ready earlier than others, and this extra wait is non-optimal.
			// Still, for big projects, this seems better than the original algorithm below that proved slow in some cases.
			// Note, however, the original algorithm had the potential to execute partial trees,  but that potential was never enabled.
			// There are also other optimization available with the original algorithm that have not been explored.
			function(){
				var module, mid;
				for(mid in modules){
					module = modules[mid];
					if(module.noReqPluginCheck===undefined){
						// tag the module as either a loadInit or require plugin or not for future reference
						module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0;
					}
					if(!module.executed && !module.noReqPluginCheck && module.injected==requested){
						return;
					}
				}

				guardCheckComplete(function(){
					var oldCallbacks = dojoRequireCallbacks;
					dojoRequireCallbacks = [];
					array.forEach(oldCallbacks, function(cb){cb(1);});
				});
		} : (function(){
			// Note: this is the original checkDojoRequirePlugin that is much slower than the algorithm above. However, we know it
			// works, so we leave it here in case the algorithm above fails in some corner case.
			//
			// checkDojoRequirePlugin inspects all of the modules demanded by a dojo/require!<module-list> dependency
			// to see if they have arrived. The loader does not release *any* of these modules to be instantiated
			// until *all* of these modules are on board, thereby preventing the evaluation of a module with dojo.require's
			// that reference modules that are not available.
			//
			// The algorithm works by traversing the dependency graphs (remember, there can be cycles so they are not trees)
			// of each module in the dojoRequireModuleStack array (which contains the list of modules demanded by dojo/require!).
			// The moment a single module is discovered that is missing, the algorithm gives up and indicates that not all
			// modules are on board. dojo/loadInit! and dojo/require! are ignored because there dependencies are inserted
			// directly in dojoRequireModuleStack. For example, if "your/module" module depends on "dojo/require!my/module", then
			// *both* "dojo/require!my/module" and "my/module" will be in dojoRequireModuleStack. Obviously, if "my/module"
			// is on board, then "dojo/require!my/module" is also satisfied, so the algorithm doesn't check for "dojo/require!my/module".
			//
			// Note: inserting a dojo/require!<some-module-list> dependency in the dojoRequireModuleStack achieves nothing
			// with the current algorithm; however, having such modules present makes it possible to optimize the algorithm
			//
			// Note: prior versions of this algorithm had an optimization that signaled loaded on dojo/require! dependencies
			// individually (rather than waiting for them all to be resolved). The implementation proved problematic with cycles
			// and plugins. However, it is possible to reattach that strategy in the future.

			// a set from module-id to {undefined | 1 | 0}, where...
			//	 undefined => the module has not been inspected
			//	 0 => the module or at least one of its dependencies has not arrived
			//	 1 => the module is a loadInit! or require! plugin resource, or is currently being traversed (therefore, assume
			//		  OK until proven otherwise), or has been completely traversed and all dependencies have arrived

			var touched,
			traverse = function(m){
				touched[m.mid] = 1;
				for(var t, module, deps = m.deps || [], i= 0; i<deps.length; i++){
					module = deps[i];
					if(!(t = touched[module.mid])){
						if(t===0 || !traverse(module)){
							touched[m.mid] = 0;
							return false;
						}
					}
				}
				return true;
			};

			return function(){
				// initialize the touched hash with easy-to-compute values that help short circuit recursive algorithm;
				// recall loadInit/require plugin modules are dependencies of modules in dojoRequireModuleStack...
				// which would cause a circular dependency chain that would never be resolved if checked here
				// notice all dependencies of any particular loadInit/require plugin module will already
				// be checked since those are pushed into dojoRequireModuleStack explicitly by the
				// plugin...so if a particular loadInitPlugin module's dependencies are not really
				// on board, that *will* be detected elsewhere in the traversal.
				var module, mid;
				touched = {};
				for(mid in modules){
					module = modules[mid];
					if(module.executed || module.noReqPluginCheck){
						touched[mid] = 1;
					}else{
						if(module.noReqPluginCheck!==0){
							// tag the module as either a loadInit or require plugin or not for future reference
							module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0;
						}
						if(module.noReqPluginCheck){
							touched[mid] = 1;
						}else if(module.injected!==arrived){
							// not executed, has not arrived, and is not a loadInit or require plugin resource
							touched[mid] = 0;
						}// else, leave undefined and we'll traverse the dependencies
					}
				}
				for(var t, i = 0, end = dojoRequireModuleStack.length; i<end; i++){
					module = dojoRequireModuleStack[i];
					if(!(t = touched[module.mid])){
						if(t===0 || !traverse(module)){
							return;
						}
					}
				}
				guardCheckComplete(function(){
					var oldCallbacks = dojoRequireCallbacks;
					dojoRequireCallbacks = [];
					array.forEach(oldCallbacks, function(cb){cb(1);});
				});
			};
		})()),

		dojoLoadInitPlugin = function(mid, require, loaded){
			// mid names a module that defines a "dojo load init" bundle, an object with two properties:
			//
			//	 * names: a vector of module ids that give top-level names to define in the lexical scope of def
			//	 * def: a function that contains some some legacy loader API applications
			//
			// The point of def is to possibly cause some modules to be loaded (but not executed) by dojo/require! where the module
			// ids are possibly-determined at runtime. For example, here is dojox.gfx from v1.6 expressed as an AMD module using the dojo/loadInit
			// and dojo/require plugins.
			//
			// // dojox/gfx:
			//
			//	 define("*loadInit_12, {
			//	   names:["dojo", "dijit", "dojox"],
			//	   def: function(){
			//		 dojo.loadInit(function(){
			//		   var gfx = lang.getObject("dojox.gfx", true);
			//
			//		   //
			//		   // code required to set gfx properties ommitted...
			//		   //
			//
			//		   // now use the calculations to include the runtime-dependent module
			//		   dojo.require("dojox.gfx." + gfx.renderer);
			//		 });
			//	   }
			//	 });
			//
			//	 define(["dojo", "dojo/loadInit!" + id].concat("dojo/require!dojox/gfx/matric,dojox/gfx/_base"), function(dojo){
			//	   // when this AMD factory function is executed, the following modules are guaranteed downloaded but not executed:
			//	   //	"dojox.gfx." + gfx.renderer
			//	   //	dojox.gfx.matrix
			//	   //	dojox.gfx._base
			//	   dojo.provide("dojo.gfx");
			//	   dojo.require("dojox.gfx.matrix");
			//	   dojo.require("dojox.gfx._base");
			//	   dojo.require("dojox.gfx." + gfx.renderer);
			//	   return lang.getObject("dojo.gfx");
			//	 });
			//	})();
			//
			// The idea is to run the legacy loader API with global variables shadowed, which allows these variables to
			// be relocated. For example, dojox and dojo could be relocated to different names by giving a map and the code above will
			// execute properly (because the plugin below resolves the load init bundle.names module with respect to the module that demanded
			// the plugin resource).
			//
			// Note that the relocation is specified in the runtime configuration; relocated names need not be set at build-time.
			//
			// Warning: this is not the best way to express dojox.gfx as and AMD module. In fact, the module has been properly converted in
			// v1.7. However, this technique allows the builder to convert legacy modules into AMD modules and guarantee the codepath is the
			// same in the converted AMD module.
			require([mid], function(bundle){
				// notice how names is resolved with respect to the module that demanded the plugin resource
				require(bundle.names, function(){
					// bring the bundle names into scope
					for(var scopeText = "", args= [], i = 0; i<arguments.length; i++){
						scopeText+= "var " + bundle.names[i] + "= arguments[" + i + "]; ";
						args.push(arguments[i]);
					}
					eval(scopeText);

					var callingModule = require.module,
						// the list of modules that need to be downloaded but not executed before the callingModule can be executed
						requireList = [],

						// the list of i18n bundles that are xdomain; undefined if none
						i18nDeps,

						syncLoaderApi = {
							provide:function(moduleName){
								// mark modules that arrive consequent to multiple provides in this module as arrived since they can't be injected
								moduleName = slashName(moduleName);
								var providedModule = getModule(moduleName, callingModule);
								if(providedModule!==callingModule){
									setArrived(providedModule);
								}
							},
							require:function(moduleName, omitModuleCheck){
								moduleName = slashName(moduleName);
								omitModuleCheck && (getModule(moduleName, callingModule).result = nonmodule);
								requireList.push(moduleName);
							},
							requireLocalization:function(moduleName, bundleName, locale){
								// since we're going to need dojo/i8n, add it to i18nDeps if not already there
								if(!i18nDeps){
									// don't have to map since that will occur when the dependency is resolved
									i18nDeps = ["dojo/i18n"];
								}

								// figure out if the bundle is xdomain; if so, add it to the i18nDepsSet
								locale = (locale || dojo.locale).toLowerCase();
								moduleName = slashName(moduleName) + "/nls/" + (/root/i.test(locale) ? "" : locale + "/") + slashName(bundleName);
								if(getModule(moduleName, callingModule).isXd){
									// don't have to map since that will occur when the dependency is resolved
									i18nDeps.push("dojo/i18n!" + moduleName);
								}// else the bundle will be loaded synchronously when the module is evaluated
							},
							loadInit:function(f){
								f();
							}
						},

						hold = {},
						p;

					// hijack the correct dojo and apply bundle.def
					try{
						for(p in syncLoaderApi){
							hold[p] = dojo[p];
							dojo[p] = syncLoaderApi[p];
						}
						bundle.def.apply(null, args);
					}catch(e){
						signal("error", [makeErrorToken("failedDojoLoadInit"), e]);
					}finally{
						for(p in syncLoaderApi){
							dojo[p] = hold[p];
						}
					}

					if(i18nDeps){
						requireList = requireList.concat(i18nDeps);
					}

					if(requireList.length){
						dojoRequirePlugin(requireList.join(","), require, loaded);
					}else{
						loaded();
					}
				});
			});
		},

		extractApplication = function(
			text,			  // the text to search
			startSearch,	  // the position in text to start looking for the closing paren
			startApplication  // the position in text where the function application expression starts
		){
			// find end of the call by finding the matching end paren
			// Warning: as usual, this will fail in the presence of unmatched right parans contained in strings, regexs, or unremoved comments
			var parenRe = /\(|\)/g,
				matchCount = 1,
				match;
			parenRe.lastIndex = startSearch;
			while((match = parenRe.exec(text))){
				if(match[0] == ")"){
					matchCount -= 1;
				}else{
					matchCount += 1;
				}
				if(matchCount == 0){
					break;
				}
			}

			if(matchCount != 0){
				throw "unmatched paren around character " + parenRe.lastIndex + " in: " + text;
			}

			//Put the master matching string in the results.
			return [dojo.trim(text.substring(startApplication, parenRe.lastIndex))+";\n", parenRe.lastIndex];
		},

		// the following regex is taken from 1.6. It is a very poor technique to remove comments and
		// will fail in some cases; for example, consider the code...
		//
		//	  var message = "Category-1 */* Category-2";
		//
		// The regex that follows will see a /* comment and trash the code accordingly. In fact, there are all
		// kinds of cases like this with strings and regexs that will cause this design to fail miserably.
		//
		// Alternative regex designs exist that will result in less-likely failures, but will still fail in many cases.
		// The only solution guaranteed 100% correct is to parse the code and that seems overkill for this
		// backcompat/unbuilt-xdomain layer. In the end, since it's been this way for a while, we won't change it.
		// See the opening paragraphs of Chapter 7 or ECME-262 which describes the lexical abiguity further.
		removeCommentRe = /(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg,

		syncLoaderApiRe = /(^|\s)dojo\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\s*\(/mg,

		amdLoaderApiRe = /(^|\s)(require|define)\s*\(/m,

		extractLegacyApiApplications = function(text, noCommentText){
			// scan the noCommentText for any legacy loader API applications. Copy such applications into result (this is
			// used by the builder). Move dojo.loadInit applications to loadInitApplications string. Copy all other applications
			// to otherApplications string. If no applications were found, return 0, signalling an AMD module. Otherwise, return
			// loadInitApplications + otherApplications. Fixup text by replacing
			//
			//	 dojo.loadInit(// etc...
			//
			// with
			//
			//	 \n 0 && dojo.loadInit(// etc...
			//
			// Which results in the dojo.loadInit from *not* being applied. This design goes a long way towards protecting the
			// code from an over-agressive removeCommentRe. However...
			//
			// WARNING: the removeCommentRe will cause an error if a detected comment removes all or part of a legacy-loader application
			// that is not in a comment.

			var match, startSearch, startApplication, application,
				loadInitApplications = [],
				otherApplications = [],
				allApplications = [];

			// noCommentText may be provided by a build app with comments extracted by a better method than regex (hopefully)
			noCommentText = noCommentText || text.replace(removeCommentRe, function(match){
				// remove iff the detected comment has text that looks like a sync loader API application; this helps by
				// removing as little as possible, minimizing the changes the janky regex will kill the module
				syncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = 0;
				return (syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match)) ? "" : match;
			});

			// find and extract all dojo.loadInit applications
			while((match = syncLoaderApiRe.exec(noCommentText))){
				startSearch = syncLoaderApiRe.lastIndex;
				startApplication = startSearch	- match[0].length;
				application = extractApplication(noCommentText, startSearch, startApplication);
				if(match[2]=="loadInit"){
					loadInitApplications.push(application[0]);
				}else{
					otherApplications.push(application[0]);
				}
				syncLoaderApiRe.lastIndex = application[1];
			}
			allApplications = loadInitApplications.concat(otherApplications);
			if(allApplications.length || !amdLoaderApiRe.test(noCommentText)){
				// either there were some legacy loader API applications or there were no AMD API applications
				return [text.replace(/(^|\s)dojo\.loadInit\s*\(/g, "\n0 && dojo.loadInit("), allApplications.join(""), allApplications];
			}else{
				// legacy loader API *was not* detected and AMD API *was* detected; therefore, assume it's an AMD module
				return 0;
			}
		},

		transformToAmd = function(module, text){
			// This is roughly the equivalent of dojo._xdCreateResource in 1.6-; however, it expresses a v1.6- dojo
			// module in terms of AMD define instead of creating the dojo proprietary xdomain module expression.
			// The module could have originated from several sources:
			//
			//	 * amd require() a module, e.g., require(["my/module"])
			//	 * amd require() a nonmodule, e.g., require(["my/resource.js"')
			//	 * amd define() deps vector (always a module)
			//	 * dojo.require() a module, e.g. dojo.require("my.module")
			//	 * dojo.require() a nonmodule, e.g., dojo.require("my.module", true)
			//	 * dojo.requireIf/requireAfterIf/platformRequire a module
			//
			// The module is scanned for legacy loader API applications; if none are found, then assume the module is an
			// AMD module and return 0. Otherwise, a synthetic dojo/loadInit plugin resource is created and the module text
			// is rewritten as an AMD module with the single dependency of this synthetic resource. When the dojo/loadInit
			// plugin loaded the synthetic resource, it will cause all dojo.loadInit's to be executed, find all dojo.require's
			// (either directly consequent to dojo.require or indirectly consequent to dojo.require[After]If or
			// dojo.platformRequire, and finally cause loading of all dojo.required modules with the dojo/require plugin. Thus,
			// when the dojo/loadInit plugin reports it has been loaded, all modules required by the given module are guaranteed
			// loaded (but not executed). This then allows the module to execute it's code path without interupts, thereby
			// following the synchronous code path.
			//
			// Notice that this function behaves the same whether or not it happens to be in a mapped dojo/loader module.

			var extractResult, id, names = [], namesAsStrings = [];
			if(buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))){
				// buildDetectRe.test(text) => a built module, always AMD
				// extractResult==0 => no sync API
				return 0;
			}

			// manufacture a synthetic module id that can never be a real mdule id (just like require does)
			id = module.mid + "-*loadInit";

			// construct the dojo/loadInit names vector which causes any relocated names to be defined as lexical variables under their not-relocated name
			// the dojo/loadInit plugin assumes the first name in names is "dojo"

			for(var p in getModule("dojo", module).result.scopeMap){
				names.push(p);
				namesAsStrings.push('"' + p + '"');
			}

			// rewrite the module as a synthetic dojo/loadInit plugin resource + the module expressed as an AMD module that depends on this synthetic resource
			// don't have to map dojo/init since that will occur when the dependency is resolved
			return "// xdomain rewrite of " + module.mid + "\n" +
				"define('" + id + "',{\n" +
				"\tnames:" + json.stringify(names) + ",\n" +
				"\tdef:function(" + names.join(",") + "){" + extractResult[1] + "}" +
				"});\n\n" +
				"define(" + json.stringify(names.concat(["dojo/loadInit!"+id])) + ", function(" + names.join(",") + "){\n" + extractResult[0] + "});";
		},

		loaderVars = require.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd),

		sync =
			loaderVars.sync,

		requested =
			loaderVars.requested,

		arrived =
			loaderVars.arrived,

		nonmodule =
			loaderVars.nonmodule,

		executing =
			loaderVars.executing,

		executed =
			loaderVars.executed,

		syncExecStack =
			loaderVars.syncExecStack,

		modules =
			loaderVars.modules,

		execQ =
			loaderVars.execQ,

		getModule =
			loaderVars.getModule,

		injectModule =
			loaderVars.injectModule,

		setArrived =
			loaderVars.setArrived,

		signal =
			loaderVars.signal,

		finishExec =
			loaderVars.finishExec,

		execModule =
			loaderVars.execModule,

		getLegacyMode =
			loaderVars.getLegacyMode,

		guardCheckComplete =
			loaderVars.guardCheckComplete;

	// there is exactly one dojoRequirePlugin among possibly-many dojo/_base/loader's (owing to mapping)
	dojoRequirePlugin = loaderVars.dojoRequirePlugin;

	dojo.provide = function(mid){
		var executingModule = syncExecStack[0],
			module = lang.mixin(getModule(slashName(mid), require.module), {
				executed:executing,
				result:lang.getObject(mid, true)
			});
		setArrived(module);
		if(executingModule){
			(executingModule.provides || (executingModule.provides = [])).push(function(){
				module.result = lang.getObject(mid);
				delete module.provides;
				module.executed!==executed && finishExec(module);
			});
		}// else dojo.provide called not consequent to loading; therefore, give up trying to publish module value to loader namespace
		return module.result;
	};

	has.add("config-publishRequireResult", 1, 0, 0);

	dojo.require = function(moduleName, omitModuleCheck) {
		// summary:
		//		loads a Javascript module from the appropriate URI
		//
		// moduleName: String
		//		module name to load, using periods for separators,
		//		 e.g. "dojo.date.locale".  Module paths are de-referenced by dojo's
		//		internal mapping of locations to names and are disambiguated by
		//		longest prefix. See `dojo.registerModulePath()` for details on
		//		registering new modules.
		//
		// omitModuleCheck: Boolean?
		//		if `true`, omitModuleCheck skips the step of ensuring that the
		//		loaded file actually defines the symbol it is referenced by.
		//		For example if it called as `dojo.require("a.b.c")` and the
		//		file located at `a/b/c.js` does not define an object `a.b.c`,
		//		and exception will be throws whereas no exception is raised
		//		when called as `dojo.require("a.b.c", true)`
		//
		// description:
		//		Modules are loaded via dojo.require by using one of two loaders: the normal loader
		//		and the xdomain loader. The xdomain loader is used when dojo was built with a
		//		custom build that specified loader=xdomain and the module lives on a modulePath
		//		that is a whole URL, with protocol and a domain. The versions of Dojo that are on
		//		the Google and AOL CDNs use the xdomain loader.
		//
		//		If the module is loaded via the xdomain loader, it is an asynchronous load, since
		//		the module is added via a dynamically created script tag. This
		//		means that dojo.require() can return before the module has loaded. However, this
		//		should only happen in the case where you do dojo.require calls in the top-level
		//		HTML page, or if you purposely avoid the loader checking for dojo.require
		//		dependencies in your module by using a syntax like dojo["require"] to load the module.
		//
		//		Sometimes it is useful to not have the loader detect the dojo.require calls in the
		//		module so that you can dynamically load the modules as a result of an action on the
		//		page, instead of right at module load time.
		//
		//		Also, for script blocks in an HTML page, the loader does not pre-process them, so
		//		it does not know to download the modules before the dojo.require calls occur.
		//
		//		So, in those two cases, when you want on-the-fly module loading or for script blocks
		//		in the HTML page, special care must be taken if the dojo.required code is loaded
		//		asynchronously. To make sure you can execute code that depends on the dojo.required
		//		modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
		//		callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
		//		executing.
		//
		//		This type of syntax works with both xdomain and normal loaders, so it is good
		//		practice to always use this idiom for on-the-fly code loading and in HTML script
		//		blocks. If at some point you change loaders and where the code is loaded from,
		//		it will all still work.
		//
		//		More on how dojo.require
		//		`dojo.require("A.B")` first checks to see if symbol A.B is
		//		defined. If it is, it is simply returned (nothing to do).
		//
		//		If it is not defined, it will look for `A/B.js` in the script root
		//		directory.
		//
		//		`dojo.require` throws an exception if it cannot find a file
		//		to load, or if the symbol `A.B` is not defined after loading.
		//
		//		It returns the object `A.B`, but note the caveats above about on-the-fly loading and
		//		HTML script blocks when the xdomain loader is loading a module.
		//
		//		`dojo.require()` does nothing about importing symbols into
		//		the current namespace.	It is presumed that the caller will
		//		take care of that.
		//
		// example:
		//		To use dojo.require in conjunction with dojo.ready:
		//
		//		|	dojo.require("foo");
		//		|	dojo.require("bar");
		//		|	dojo.addOnLoad(function(){
		//		|		//you can now safely do something with foo and bar
		//		|	});
		//
		// example:
		//		For example, to import all symbols into a local block, you might write:
		//
		//		|	with (dojo.require("A.B")) {
		//		|		...
		//		|	}
		//
		//		And to import just the leaf symbol to a local variable:
		//
		//		|	var B = dojo.require("A.B");
		//		|	...
		//
		// returns:
		//		the required namespace object
		function doRequire(mid, omitModuleCheck){
			var module = getModule(slashName(mid), require.module);
			if(syncExecStack.length && syncExecStack[0].finish){
				// switched to async loading in the middle of evaluating a legacy module; stop
				// applying dojo.require so the remaining dojo.requires are applied in order
				syncExecStack[0].finish.push(mid);
				return undefined;
			}

			// recall module.executed has values {0, executing, executed}; therefore, truthy indicates executing or executed
			if(module.executed){
				return module.result;
			}
			omitModuleCheck && (module.result = nonmodule);

			// rcg...why here and in two lines??
			var currentMode = getLegacyMode();

			// recall, in sync mode to inject is to *eval* the module text
			// if the module is a legacy module, this is the same as executing
			// but if the module is an AMD module, this means defining, not executing
			injectModule(module);
			// the inject may have changed the mode
			currentMode = getLegacyMode();

			// in sync mode to dojo.require is to execute
			if(module.executed!==executed && module.injected===arrived){
				// the module was already here before injectModule was called probably finishing up a xdomain
				// load, but maybe a module given to the loader directly rather than having the loader retrieve it

				loaderVars.guardCheckComplete(function(){
					execModule(module);
				});
			}
			if(module.executed){
				return module.result;
			}

			if(currentMode==sync){
				// the only way to get here is in sync mode and dojo.required a module that
				//	 * was loaded async in the injectModule application a few lines up
				//	 * was an AMD module that had deps that are being loaded async and therefore couldn't execute
				if(module.cjs){
					// the module was an AMD module; unshift, not push, which causes the current traversal to be reattempted from the top
					execQ.unshift(module);
				}else{
					// the module was a legacy module
					syncExecStack.length && (syncExecStack[0].finish= [mid]);
				}
			}else{
				// the loader wasn't in sync mode on entry; probably async mode; therefore, no expectation of getting
				// the module value synchronously; make sure it gets executed though
				execQ.push(module);
			}

			return undefined;
		}

		var result = doRequire(moduleName, omitModuleCheck);
		if(has("config-publishRequireResult") && !lang.exists(moduleName) && result!==undefined){
			lang.setObject(moduleName, result);
		}
		return result;
	};

	dojo.loadInit = function(f) {
		f();
	};

	dojo.registerModulePath = function(/*String*/moduleName, /*String*/prefix){
		// summary:
		//		Maps a module name to a path
		// description:
		//		An unregistered module is given the default path of ../[module],
		//		relative to Dojo root. For example, module acme is mapped to
		//		../acme.  If you want to use a different module name, use
		//		dojo.registerModulePath.
		// example:
		//		If your dojo.js is located at this location in the web root:
		//	|	/myapp/js/dojo/dojo/dojo.js
		//		and your modules are located at:
		//	|	/myapp/js/foo/bar.js
		//	|	/myapp/js/foo/baz.js
		//	|	/myapp/js/foo/thud/xyzzy.js
		//		Your application can tell Dojo to locate the "foo" namespace by calling:
		//	|	dojo.registerModulePath("foo", "../../foo");
		//		At which point you can then use dojo.require() to load the
		//		modules (assuming they provide() the same things which are
		//		required). The full code might be:
		//	|	<script type="text/javascript"
		//	|		src="/myapp/js/dojo/dojo/dojo.js"></script>
		//	|	<script type="text/javascript">
		//	|		dojo.registerModulePath("foo", "../../foo");
		//	|		dojo.require("foo.bar");
		//	|		dojo.require("foo.baz");
		//	|		dojo.require("foo.thud.xyzzy");
		//	|	</script>

		var paths = {};
		paths[moduleName.replace(/\./g, "/")] = prefix;
		require({paths:paths});
	};

	dojo.platformRequire = function(/*Object*/modMap){
		// summary:
		//		require one or more modules based on which host environment
		//		Dojo is currently operating in
		// description:
		//		This method takes a "map" of arrays which one can use to
		//		optionally load dojo modules. The map is indexed by the
		//		possible dojo.name_ values, with two additional values:
		//		"default" and "common". The items in the "default" array will
		//		be loaded if none of the other items have been chosen based on
		//		dojo.name_, set by your host environment. The items in the
		//		"common" array will *always* be loaded, regardless of which
		//		list is chosen.
		// example:
		//		|	dojo.platformRequire({
		//		|		browser: [
		//		|			"foo.sample", // simple module
		//		|			"foo.test",
		//		|			["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
		//		|		],
		//		|		default: [ "foo.sample._base" ],
		//		|		common: [ "important.module.common" ]
		//		|	});

		var result = (modMap.common || []).concat(modMap[dojo._name] || modMap["default"] || []),
			temp;
		while(result.length){
			if(lang.isArray(temp = result.shift())){
				dojo.require.apply(dojo, temp);
			}else{
				dojo.require(temp);
			}
		}
	};

	dojo.requireIf = dojo.requireAfterIf = function(/*Boolean*/ condition, /*String*/ moduleName, /*Boolean?*/omitModuleCheck){
		// summary:
		//		If the condition is true then call `dojo.require()` for the specified
		//		resource
		//
		// example:
		//	|	dojo.requireIf(dojo.isBrowser, "my.special.Module");

		if(condition){
			dojo.require(moduleName, omitModuleCheck);
		}
	};

	dojo.requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale){
		require(["../i18n"], function(i18n){
			i18n.getLocalization(moduleName, bundleName, locale);
		});
	};

	return {
		// summary:
		//		This module defines the v1.x synchronous loader API.

		extractLegacyApiApplications:extractLegacyApiApplications,
		require:dojoRequirePlugin,
		loadInit:dojoLoadInitPlugin
	};
});

},
'dojo/_base/query':function(){
define(["../query", "./NodeList"], function(query){
	// module:
	//		dojo/_base/query

	/*=====
	return {
		// summary:
		//		Deprecated.   Use dojo/query instead.
	};
	=====*/

	return query;
});

},
'dojo/_base/url':function(){
define(["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'dojo/cache':function(){
define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'dojo/text':function(){
define(["./_base/kernel", "require", "./has", "./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if( 1 ){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});


},
'dojo/request':function(){
define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'dojo/request/default':function(){
define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'dojo/cldr/monetary':function(){
define(["../_base/kernel", "../_base/lang"], function(dojo, lang){

// module:
//		dojo/cldr/monetary

var monetary = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.cldr.monetary", monetary);

monetary.getData = function(/*String*/ code){
	// summary:
	//		A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
	// code:
	//		an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
		ADP:0,AFN:0,ALL:0,AMD:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,
		COP:0,CRC:0,DJF:0,ESP:0,GNF:0,GYD:0,HUF:0,IDR:0,IQD:0,
		IRR:3,ISK:0,ITL:0,JOD:3,JPY:0,KMF:0,KPW:0,KRW:0,KWD:3,
		LAK:0,LBP:0,LUF:0,LYD:3,MGA:0,MGF:0,MMK:0,MNT:0,MRO:0,
		MUR:0,OMR:3,PKR:0,PYG:0,RSD:0,RWF:0,SLL:0,SOS:0,STD:0,
		SYP:0,TMM:0,TND:3,TRL:0,TZS:0,UGX:0,UZS:0,VND:0,VUV:0,
		XAF:0,XOF:0,XPF:0,YER:0,ZMK:0,ZWD:0
	};

	var roundingData = {};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

return monetary;
});

},
'dojo/cldr/nls/currency':function(){
define({ root:

//begin v1.x content
{
	"USD_symbol": "US$",
	"CAD_symbol": "CA$",
	"GBP_symbol": "£",
	"HKD_symbol": "HK$",
	"JPY_symbol": "JP¥",
	"AUD_symbol": "A$",
	"CNY_symbol": "CN¥",
	"EUR_symbol": "€"
}
//end v1.x content
,
	"ar": true,
	"ca": true,
	"cs": true,
	"da": true,
	"de": true,
	"el": true,
	"en": true,
	"en-au": true,
	"en-ca": true,
	"en-gb": true,
	"es": true,
	"fi": true,
	"fr": true,
	"fr-ch": true,
	"he": true,
	"hu": true,
	"it": true,
	"ja": true,
	"ko": true,
	"nb": true,
	"nl": true,
	"pl": true,
	"pt": true,
	"pt-pt": true,
	"ro": true,
	"ru": true,
	"sk": true,
	"sl": true,
	"sv": true,
	"th": true,
	"tr": true,
	"zh": true,
	"zh-hant": true,
	"zh-hk": true,
	"zh-tw": true
});
},
'dojo/cldr/nls/en/currency':function(){
define(
//begin v1.x content
{
	"HKD_displayName": "Hong Kong Dollar",
	"CHF_displayName": "Swiss Franc",
	"JPY_symbol": "¥",
	"CAD_displayName": "Canadian Dollar",
	"CNY_displayName": "Chinese Yuan",
	"USD_symbol": "$",
	"AUD_displayName": "Australian Dollar",
	"JPY_displayName": "Japanese Yen",
	"USD_displayName": "US Dollar",
	"GBP_displayName": "British Pound Sterling",
	"EUR_displayName": "Euro"
}
//end v1.x content
);
},
'dojo/cldr/nls/gregorian':function(){
define({ root:

//begin v1.x content
{
	"dateFormatItem-Ehm": "E h:mm a",
	"days-standAlone-short": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"months-format-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"field-second-relative+0": "now",
	"quarters-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4"
	],
	"field-weekday": "Day of the Week",
	"dateFormatItem-yQQQ": "y QQQ",
	"dateFormatItem-yMEd": "y-MM-dd, E",
	"field-wed-relative+0": "this Wednesday",
	"field-wed-relative+1": "next Wednesday",
	"dateFormatItem-GyMMMEd": "G y MMM d, E",
	"dateFormatItem-MMMEd": "MMM d, E",
	"eraNarrow": [
		"BCE",
		"CE"
	],
	"field-tue-relative+-1": "last Tuesday",
	"days-format-short": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"dateTimeFormats-appendItem-Day-Of-Week": "{0} {1}",
	"dateFormat-long": "y MMMM d",
	"field-fri-relative+-1": "last Friday",
	"field-wed-relative+-1": "last Wednesday",
	"months-format-wide": [
		"M01",
		"M02",
		"M03",
		"M04",
		"M05",
		"M06",
		"M07",
		"M08",
		"M09",
		"M10",
		"M11",
		"M12"
	],
	"dateTimeFormat-medium": "{1} {0}",
	"dayPeriods-format-wide-pm": "PM",
	"dateFormat-full": "y MMMM d, EEEE",
	"field-thu-relative+-1": "last Thursday",
	"dateFormatItem-Md": "MM-dd",
	"dayPeriods-format-abbr-am": "AM",
	"dateTimeFormats-appendItem-Second": "{0} ({2}: {1})",
	"dayPeriods-format-wide-noon": "noon",
	"dateFormatItem-yMd": "y-MM-dd",
	"field-era": "Era",
	"dateFormatItem-yM": "y-MM",
	"months-standAlone-wide": [
		"M01",
		"M02",
		"M03",
		"M04",
		"M05",
		"M06",
		"M07",
		"M08",
		"M09",
		"M10",
		"M11",
		"M12"
	],
	"timeFormat-short": "HH:mm",
	"quarters-format-wide": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"dateFormatItem-yQQQQ": "y QQQQ",
	"timeFormat-long": "HH:mm:ss z",
	"field-year": "Year",
	"dateFormatItem-yMMM": "y MMM",
	"dateTimeFormats-appendItem-Era": "{1} {0}",
	"field-hour": "Hour",
	"months-format-abbr": [
		"M01",
		"M02",
		"M03",
		"M04",
		"M05",
		"M06",
		"M07",
		"M08",
		"M09",
		"M10",
		"M11",
		"M12"
	],
	"field-sat-relative+0": "this Saturday",
	"field-sat-relative+1": "next Saturday",
	"timeFormat-full": "HH:mm:ss zzzz",
	"dateTimeFormats-appendItem-Week": "{0} ({2}: {1})",
	"field-day-relative+0": "today",
	"field-thu-relative+0": "this Thursday",
	"field-day-relative+1": "tomorrow",
	"field-thu-relative+1": "next Thursday",
	"dateFormatItem-GyMMMd": "G y MMM d",
	"dateFormatItem-H": "HH",
	"months-standAlone-abbr": [
		"M01",
		"M02",
		"M03",
		"M04",
		"M05",
		"M06",
		"M07",
		"M08",
		"M09",
		"M10",
		"M11",
		"M12"
	],
	"quarters-format-abbr": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"quarters-standAlone-wide": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"dateFormatItem-Gy": "G y",
	"dateFormatItem-M": "L",
	"days-standAlone-wide": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"dayPeriods-format-abbr-noon": "noon",
	"timeFormat-medium": "HH:mm:ss",
	"field-sun-relative+0": "this Sunday",
	"dateFormatItem-Hm": "HH:mm",
	"field-sun-relative+1": "next Sunday",
	"quarters-standAlone-abbr": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"eraAbbr": [
		"BCE",
		"CE"
	],
	"field-minute": "Minute",
	"field-dayperiod": "Dayperiod",
	"days-standAlone-abbr": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"dateFormatItem-d": "d",
	"dateFormatItem-ms": "mm:ss",
	"quarters-format-narrow": [
		"1",
		"2",
		"3",
		"4"
	],
	"field-day-relative+-1": "yesterday",
	"dateTimeFormat-long": "{1} {0}",
	"dayPeriods-format-narrow-am": "a",
	"dateFormatItem-h": "h a",
	"dateFormatItem-MMMd": "MMM d",
	"dateFormatItem-MEd": "MM-dd, E",
	"dateTimeFormat-full": "{1} {0}",
	"field-fri-relative+0": "this Friday",
	"field-fri-relative+1": "next Friday",
	"field-day": "Day",
	"days-format-wide": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"field-zone": "Zone",
	"months-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"dateFormatItem-y": "y",
	"dateTimeFormats-appendItem-Day": "{0} ({2}: {1})",
	"field-year-relative+-1": "last year",
	"field-month-relative+-1": "last month",
	"dateTimeFormats-appendItem-Year": "{1} {0}",
	"dateFormatItem-hm": "h:mm a",
	"dateTimeFormats-appendItem-Hour": "{0} ({2}: {1})",
	"dayPeriods-format-abbr-pm": "PM",
	"days-format-abbr": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"eraNames": [
		"BCE",
		"CE"
	],
	"dateFormatItem-yMMMd": "y MMM d",
	"days-format-narrow": [
		"S",
		"M",
		"T",
		"W",
		"T",
		"F",
		"S"
	],
	"field-month": "Month",
	"days-standAlone-narrow": [
		"S",
		"M",
		"T",
		"W",
		"T",
		"F",
		"S"
	],
	"dateFormatItem-MMM": "LLL",
	"field-tue-relative+0": "this Tuesday",
	"dateTimeFormats-appendItem-Quarter": "{0} ({2}: {1})",
	"field-tue-relative+1": "next Tuesday",
	"dayPeriods-format-wide-am": "AM",
	"dateTimeFormats-appendItem-Month": "{0} ({2}: {1})",
	"dateTimeFormats-appendItem-Minute": "{0} ({2}: {1})",
	"dateFormatItem-EHm": "E HH:mm",
	"field-mon-relative+0": "this Monday",
	"field-mon-relative+1": "next Monday",
	"dateFormat-short": "y-MM-dd",
	"dateFormatItem-EHms": "E HH:mm:ss",
	"dateFormatItem-Ehms": "E h:mm:ss a",
	"dayPeriods-format-narrow-noon": "n",
	"field-second": "Second",
	"field-sat-relative+-1": "last Saturday",
	"dateFormatItem-yMMMEd": "y MMM d, E",
	"field-sun-relative+-1": "last Sunday",
	"field-month-relative+0": "this month",
	"field-month-relative+1": "next month",
	"dateTimeFormats-appendItem-Timezone": "{0} {1}",
	"dateFormatItem-Ed": "d, E",
	"field-week": "Week",
	"dateFormat-medium": "y MMM d",
	"field-week-relative+-1": "last week",
	"field-year-relative+0": "this year",
	"field-year-relative+1": "next year",
	"dayPeriods-format-narrow-pm": "p",
	"dateTimeFormat-short": "{1} {0}",
	"dateFormatItem-Hms": "HH:mm:ss",
	"dateFormatItem-hms": "h:mm:ss a",
	"dateFormatItem-GyMMM": "G y MMM",
	"field-mon-relative+-1": "last Monday",
	"field-week-relative+0": "this week",
	"field-week-relative+1": "next week"
}
//end v1.x content
,
	"ar": true,
	"ca": true,
	"cs": true,
	"da": true,
	"de": true,
	"el": true,
	"en": true,
	"en-au": true,
	"en-ca": true,
	"en-gb": true,
	"es": true,
	"fi": true,
	"fr": true,
	"fr-ch": true,
	"he": true,
	"hu": true,
	"it": true,
	"ja": true,
	"ko": true,
	"nb": true,
	"nl": true,
	"pl": true,
	"pt": true,
	"pt-pt": true,
	"ro": true,
	"ru": true,
	"sk": true,
	"sl": true,
	"sv": true,
	"th": true,
	"tr": true,
	"zh": true,
	"zh-hant": true,
	"zh-hk": true,
	"zh-tw": true
});
},
'dojo/cldr/nls/en/gregorian':function(){
define(
//begin v1.x content
{
	"dateFormatItem-Ehm": "E h:mm a",
	"days-standAlone-short": [
		"Su",
		"Mo",
		"Tu",
		"We",
		"Th",
		"Fr",
		"Sa"
	],
	"months-format-narrow": [
		"J",
		"F",
		"M",
		"A",
		"M",
		"J",
		"J",
		"A",
		"S",
		"O",
		"N",
		"D"
	],
	"field-second-relative+0": "now",
	"quarters-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4"
	],
	"field-weekday": "Day of the Week",
	"dateFormatItem-yQQQ": "QQQ y",
	"dateFormatItem-yMEd": "E, M/d/y",
	"field-wed-relative+0": "this Wednesday",
	"field-wed-relative+1": "next Wednesday",
	"dateFormatItem-GyMMMEd": "E, MMM d, y G",
	"dateFormatItem-MMMEd": "E, MMM d",
	"eraNarrow": [
		"B",
		"A",
		"AD",
		"CE"
	],
	"field-tue-relative+-1": "last Tuesday",
	"days-format-short": [
		"Su",
		"Mo",
		"Tu",
		"We",
		"Th",
		"Fr",
		"Sa"
	],
	"dateTimeFormats-appendItem-Day-Of-Week": "{0} {1}",
	"dateFormat-long": "MMMM d, y",
	"field-fri-relative+-1": "last Friday",
	"field-wed-relative+-1": "last Wednesday",
	"months-format-wide": [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	"dateTimeFormat-medium": "{1}, {0}",
	"dayPeriods-format-wide-pm": "PM",
	"dateFormat-full": "EEEE, MMMM d, y",
	"field-thu-relative+-1": "last Thursday",
	"dateFormatItem-Md": "M/d",
	"dateTimeFormats-appendItem-Second": "{0} ({2}: {1})",
	"dayPeriods-format-wide-noon": "noon",
	"dateFormatItem-yMd": "M/d/y",
	"field-era": "Era",
	"dateFormatItem-yM": "M/y",
	"months-standAlone-wide": [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	"timeFormat-short": "h:mm a",
	"quarters-format-wide": [
		"1st quarter",
		"2nd quarter",
		"3rd quarter",
		"4th quarter"
	],
	"dateFormatItem-yQQQQ": "QQQQ y",
	"timeFormat-long": "h:mm:ss a z",
	"field-year": "Year",
	"dateFormatItem-yMMM": "MMM y",
	"dateTimeFormats-appendItem-Era": "{0} {1}",
	"field-hour": "Hour",
	"months-format-abbr": [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	],
	"field-sat-relative+0": "this Saturday",
	"field-sat-relative+1": "next Saturday",
	"timeFormat-full": "h:mm:ss a zzzz",
	"dateTimeFormats-appendItem-Week": "{0} ({2}: {1})",
	"field-day-relative+0": "today",
	"field-thu-relative+0": "this Thursday",
	"field-day-relative+1": "tomorrow",
	"field-thu-relative+1": "next Thursday",
	"dateFormatItem-GyMMMd": "MMM d, y G",
	"dateFormatItem-H": "HH",
	"months-standAlone-abbr": [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	],
	"quarters-format-abbr": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"quarters-standAlone-wide": [
		"1st quarter",
		"2nd quarter",
		"3rd quarter",
		"4th quarter"
	],
	"dateFormatItem-Gy": "y G",
	"dateFormatItem-M": "L",
	"days-standAlone-wide": [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	"timeFormat-medium": "h:mm:ss a",
	"field-sun-relative+0": "this Sunday",
	"dateFormatItem-Hm": "HH:mm",
	"field-sun-relative+1": "next Sunday",
	"eraAbbr": [
		"BC",
		"BCE",
		"AD",
		"CE"
	],
	"field-minute": "Minute",
	"field-dayperiod": "AM/PM",
	"dateFormatItem-d": "d",
	"dateFormatItem-ms": "mm:ss",
	"field-day-relative+-1": "yesterday",
	"dateFormatItem-h": "h a",
	"dateTimeFormat-long": "{1} 'at' {0}",
	"dayPeriods-format-narrow-am": "a",
	"dateFormatItem-MMMd": "MMM d",
	"dateFormatItem-MEd": "E, M/d",
	"dateTimeFormat-full": "{1} 'at' {0}",
	"field-fri-relative+0": "this Friday",
	"field-fri-relative+1": "next Friday",
	"field-day": "Day",
	"days-format-wide": [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	"field-zone": "Time Zone",
	"dateTimeFormats-appendItem-Day": "{0} ({2}: {1})",
	"dateFormatItem-y": "y",
	"months-standAlone-narrow": [
		"J",
		"F",
		"M",
		"A",
		"M",
		"J",
		"J",
		"A",
		"S",
		"O",
		"N",
		"D"
	],
	"field-year-relative+-1": "last year",
	"field-month-relative+-1": "last month",
	"dateFormatItem-hm": "h:mm a",
	"dateTimeFormats-appendItem-Year": "{0} {1}",
	"dateTimeFormats-appendItem-Hour": "{0} ({2}: {1})",
	"days-format-abbr": [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	"dateFormatItem-yMMMd": "MMM d, y",
	"eraNames": [
		"Before Christ",
		"Before Common Era",
		"Anno Domini",
		"Common Era"
	],
	"days-standAlone-narrow": [
		"S",
		"M",
		"T",
		"W",
		"T",
		"F",
		"S"
	],
	"dateFormatItem-MMM": "LLL",
	"field-month": "Month",
	"field-tue-relative+0": "this Tuesday",
	"dateTimeFormats-appendItem-Quarter": "{0} ({2}: {1})",
	"field-tue-relative+1": "next Tuesday",
	"dayPeriods-format-wide-am": "AM",
	"dateTimeFormats-appendItem-Month": "{0} ({2}: {1})",
	"dateTimeFormats-appendItem-Minute": "{0} ({2}: {1})",
	"dateFormatItem-EHm": "E HH:mm",
	"field-mon-relative+0": "this Monday",
	"field-mon-relative+1": "next Monday",
	"dateFormat-short": "M/d/yy",
	"dateFormatItem-EHms": "E HH:mm:ss",
	"dateFormatItem-Ehms": "E h:mm:ss a",
	"dayPeriods-format-narrow-noon": "n",
	"field-second": "Second",
	"field-sat-relative+-1": "last Saturday",
	"dateFormatItem-yMMMEd": "E, MMM d, y",
	"field-sun-relative+-1": "last Sunday",
	"field-month-relative+0": "this month",
	"field-month-relative+1": "next month",
	"dateFormatItem-Ed": "d E",
	"dateTimeFormats-appendItem-Timezone": "{0} {1}",
	"field-week": "Week",
	"dateFormat-medium": "MMM d, y",
	"field-year-relative+0": "this year",
	"field-week-relative+-1": "last week",
	"field-year-relative+1": "next year",
	"dayPeriods-format-narrow-pm": "p",
	"dateTimeFormat-short": "{1}, {0}",
	"dateFormatItem-Hms": "HH:mm:ss",
	"dateFormatItem-hms": "h:mm:ss a",
	"dateFormatItem-GyMMM": "MMM y G",
	"field-mon-relative+-1": "last Monday",
	"field-week-relative+0": "this week",
	"field-week-relative+1": "next week"
}
//end v1.x content
);
},
'dojo/cldr/nls/number':function(){
define({ root:

//begin v1.x content
{
	"scientificFormat": "#E0",
	"currencySpacing-afterCurrency-currencyMatch": "[:^S:]",
	"infinity": "∞",
	"superscriptingExponent": "×",
	"list": ";",
	"percentSign": "%",
	"minusSign": "-",
	"currencySpacing-beforeCurrency-surroundingMatch": "[:digit:]",
	"decimalFormat-short": "000T",
	"currencySpacing-afterCurrency-insertBetween": " ",
	"nan": "NaN",
	"plusSign": "+",
	"currencySpacing-afterCurrency-surroundingMatch": "[:digit:]",
	"currencySpacing-beforeCurrency-currencyMatch": "[:^S:]",
	"currencyFormat": "¤ #,##0.00",
	"perMille": "‰",
	"group": ",",
	"percentFormat": "#,##0%",
	"decimalFormat-long": "000T",
	"decimalFormat": "#,##0.###",
	"decimal": ".",
	"currencySpacing-beforeCurrency-insertBetween": " ",
	"exponential": "E"
}
//end v1.x content
,
	"ar": true,
	"ca": true,
	"cs": true,
	"da": true,
	"de": true,
	"el": true,
	"en": true,
	"en-au": true,
	"es": true,
	"fi": true,
	"fr": true,
	"fr-ch": true,
	"he": true,
	"hu": true,
	"it": true,
	"ja": true,
	"ko": true,
	"nb": true,
	"nl": true,
	"pl": true,
	"pt": true,
	"pt-pt": true,
	"ro": true,
	"ru": true,
	"sk": true,
	"sl": true,
	"sv": true,
	"th": true,
	"tr": true,
	"zh": true,
	"zh-hant": true,
	"zh-hk": true,
	"zh-tw": true
});
},
'dojo/cldr/nls/en/number':function(){
define(
//begin v1.x content
{
	"group": ",",
	"percentSign": "%",
	"exponential": "E",
	"scientificFormat": "#E0",
	"percentFormat": "#,##0%",
	"list": ";",
	"infinity": "∞",
	"minusSign": "-",
	"decimal": ".",
	"superscriptingExponent": "×",
	"nan": "NaN",
	"perMille": "‰",
	"decimalFormat": "#,##0.###",
	"currencyFormat": "¤#,##0.00;(¤#,##0.00)",
	"plusSign": "+",
	"decimalFormat-long": "000 trillion",
	"decimalFormat-short": "000T"
}
//end v1.x content
);
},
'dojo/cldr/supplemental':function(){
define(["../_base/lang", "../i18n"], function(lang, i18n){

// module:
//		dojo/cldr/supplemental


var supplemental = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.cldr.supplemental", supplemental);

supplemental.getFirstDayOfWeek = function(/*String?*/locale){
	// summary:
	//		Returns a zero-based index for first day of the week
	// description:
	//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		bd:5,mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,iq:6,ir:6,jo:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,sy:6,ye:6,
		ag:0,ar:0,as:0,au:0,br:0,bs:0,bt:0,bw:0,by:0,bz:0,ca:0,cn:0,
		co:0,dm:0,'do':0,et:0,gt:0,gu:0,hk:0,hn:0,id:0,ie:0,il:0,'in':0,
		jm:0,jp:0,ke:0,kh:0,kr:0,la:0,mh:0,mm:0,mo:0,mt:0,mx:0,mz:0,
		ni:0,np:0,nz:0,pa:0,pe:0,ph:0,pk:0,pr:0,py:0,sg:0,sv:0,th:0,
		tn:0,tt:0,tw:0,um:0,us:0,ve:0,vi:0,ws:0,za:0,zw:0
	};

	var country = supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

supplemental._region = function(/*String?*/locale){
	locale = i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {
			aa:"et", ab:"ge", af:"za", ak:"gh", am:"et", ar:"eg", as:"in", av:"ru", ay:"bo", az:"az", ba:"ru",
			be:"by", bg:"bg", bi:"vu", bm:"ml", bn:"bd", bo:"cn", br:"fr", bs:"ba", ca:"es", ce:"ru", ch:"gu",
			co:"fr", cr:"ca", cs:"cz", cv:"ru", cy:"gb", da:"dk", de:"de", dv:"mv", dz:"bt", ee:"gh", el:"gr",
			en:"us", es:"es", et:"ee", eu:"es", fa:"ir", ff:"sn", fi:"fi", fj:"fj", fo:"fo", fr:"fr", fy:"nl",
			ga:"ie", gd:"gb", gl:"es", gn:"py", gu:"in", gv:"gb", ha:"ng", he:"il", hi:"in", ho:"pg", hr:"hr",
			ht:"ht", hu:"hu", hy:"am", ia:"fr", id:"id", ig:"ng", ii:"cn", ik:"us", "in":"id", is:"is", it:"it",
			iu:"ca", iw:"il", ja:"jp", ji:"ua", jv:"id", jw:"id", ka:"ge", kg:"cd", ki:"ke", kj:"na", kk:"kz",
			kl:"gl", km:"kh", kn:"in", ko:"kr", ks:"in", ku:"tr", kv:"ru", kw:"gb", ky:"kg", la:"va", lb:"lu",
			lg:"ug", li:"nl", ln:"cd", lo:"la", lt:"lt", lu:"cd", lv:"lv", mg:"mg", mh:"mh", mi:"nz", mk:"mk",
			ml:"in", mn:"mn", mo:"ro", mr:"in", ms:"my", mt:"mt", my:"mm", na:"nr", nb:"no", nd:"zw", ne:"np",
			ng:"na", nl:"nl", nn:"no", no:"no", nr:"za", nv:"us", ny:"mw", oc:"fr", om:"et", or:"in", os:"ge",
			pa:"in", pl:"pl", ps:"af", pt:"br", qu:"pe", rm:"ch", rn:"bi", ro:"ro", ru:"ru", rw:"rw", sa:"in",
			sd:"in", se:"no", sg:"cf", si:"lk", sk:"sk", sl:"si", sm:"ws", sn:"zw", so:"so", sq:"al", sr:"rs",
			ss:"za", st:"za", su:"id", sv:"se", sw:"tz", ta:"in", te:"in", tg:"tj", th:"th", ti:"et", tk:"tm",
			tl:"ph", tn:"za", to:"to", tr:"tr", ts:"za", tt:"ru", ty:"pf", ug:"cn", uk:"ua", ur:"pk", uz:"uz",
			ve:"za", vi:"vn", wa:"be", wo:"sn", xh:"za", yi:"il", yo:"ng", za:"cn", zh:"cn", zu:"za",
			ace:"id", ady:"ru", agq:"cm", alt:"ru", amo:"ng", asa:"tz", ast:"es", awa:"in", bal:"pk",
			ban:"id", bas:"cm", bax:"cm", bbc:"id", bem:"zm", bez:"tz", bfq:"in", bft:"pk", bfy:"in",
			bhb:"in", bho:"in", bik:"ph", bin:"ng", bjj:"in", bku:"ph", bqv:"ci", bra:"in", brx:"in",
			bss:"cm", btv:"pk", bua:"ru", buc:"yt", bug:"id", bya:"id", byn:"er", cch:"ng", ccp:"in",
			ceb:"ph", cgg:"ug", chk:"fm", chm:"ru", chp:"ca", chr:"us", cja:"kh", cjm:"vn", ckb:"iq",
			crk:"ca", csb:"pl", dar:"ru", dav:"ke", den:"ca", dgr:"ca", dje:"ne", doi:"in", dsb:"de",
			dua:"cm", dyo:"sn", dyu:"bf", ebu:"ke", efi:"ng", ewo:"cm", fan:"gq", fil:"ph", fon:"bj",
			fur:"it", gaa:"gh", gag:"md", gbm:"in", gcr:"gf", gez:"et", gil:"ki", gon:"in", gor:"id",
			grt:"in", gsw:"ch", guz:"ke", gwi:"ca", haw:"us", hil:"ph", hne:"in", hnn:"ph", hoc:"in",
			hoj:"in", ibb:"ng", ilo:"ph", inh:"ru", jgo:"cm", jmc:"tz", kaa:"uz", kab:"dz", kaj:"ng",
			kam:"ke", kbd:"ru", kcg:"ng", kde:"tz", kdt:"th", kea:"cv", ken:"cm", kfo:"ci", kfr:"in",
			kha:"in", khb:"cn", khq:"ml", kht:"in", kkj:"cm", kln:"ke", kmb:"ao", koi:"ru", kok:"in",
			kos:"fm", kpe:"lr", krc:"ru", kri:"sl", krl:"ru", kru:"in", ksb:"tz", ksf:"cm", ksh:"de",
			kum:"ru", lag:"tz", lah:"pk", lbe:"ru", lcp:"cn", lep:"in", lez:"ru", lif:"np", lis:"cn",
			lki:"ir", lmn:"in", lol:"cd", lua:"cd", luo:"ke", luy:"ke", lwl:"th", mad:"id", mag:"in",
			mai:"in", mak:"id", man:"gn", mas:"ke", mdf:"ru", mdh:"ph", mdr:"id", men:"sl", mer:"ke",
			mfe:"mu", mgh:"mz", mgo:"cm", min:"id", mni:"in", mnk:"gm", mnw:"mm", mos:"bf", mua:"cm",
			mwr:"in", myv:"ru", nap:"it", naq:"na", nds:"de", "new":"np", niu:"nu", nmg:"cm", nnh:"cm",
			nod:"th", nso:"za", nus:"sd", nym:"tz", nyn:"ug", pag:"ph", pam:"ph", pap:"bq", pau:"pw",
			pon:"fm", prd:"ir", raj:"in", rcf:"re", rej:"id", rjs:"np", rkt:"in", rof:"tz", rwk:"tz",
			saf:"gh", sah:"ru", saq:"ke", sas:"id", sat:"in", saz:"in", sbp:"tz", scn:"it", sco:"gb",
			sdh:"ir", seh:"mz", ses:"ml", shi:"ma", shn:"mm", sid:"et", sma:"se", smj:"se", smn:"fi",
			sms:"fi", snk:"ml", srn:"sr", srr:"sn", ssy:"er", suk:"tz", sus:"gn", swb:"yt", swc:"cd",
			syl:"bd", syr:"sy", tbw:"ph", tcy:"in", tdd:"cn", tem:"sl", teo:"ug", tet:"tl", tig:"er",
			tiv:"ng", tkl:"tk", tmh:"ne", tpi:"pg", trv:"tw", tsg:"ph", tts:"th", tum:"mw", tvl:"tv",
			twq:"ne", tyv:"ru", tzm:"ma", udm:"ru", uli:"fm", umb:"ao", unr:"in", unx:"in", vai:"lr",
			vun:"tz", wae:"ch", wal:"et", war:"ph", xog:"ug", xsr:"np", yao:"mz", yap:"fm", yav:"cm", zza:"tr"
		}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

supplemental.getWeekend = function(/*String?*/locale){
	// summary:
	//		Returns a hash containing the start and end days of the weekend
	// description:
	//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
	//		or by default in the user's locale.
	//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
			'in':0,
			af:4,dz:4,ir:4,om:4,sa:4,ye:4,
			ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
		},

		weekendEnd = {/*default is 0=Sunday*/
			af:5,dz:5,ir:5,om:5,sa:5,ye:5,
			ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
		},

		country = supplemental._region(locale),
		start = weekendStart[country],
		end = weekendEnd[country];

	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

return supplemental;
});

},
'dojo/i18n':function(){
define(["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json", "module"],
	function(dojo, require, has, array, config, lang, xhr, json, module){

	// module:
	//		dojo/i18n

	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	 1 || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule = dojo.i18n =
			{
				// summary:
				//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
				// description:
				//		We choose to include our own plugin to leverage functionality already contained in dojo
				//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
				//		allows foreign AMD loaders to be used without their plugins.
			},

		nlsRe =
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales = function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// summary:
			//		return a vector of module ids containing all available locales with respect to the target locale
			//		For example, assuming:
			//
			//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
			//		-  bundlePath is "myPackage/nls"
			//		- bundleName is "myBundle"
			//
			//		Then a locale argument of "fr-ca" would return
			//
			//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			//
			//		Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available

			for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
				current += (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
					result.specificity = current;
				}
			}
			return result;
		},

		cache = {},

		getBundleName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
			return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// summary:
			//		get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
					availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i = 1; i<availableLocales.length; i++){
						current = lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target = bundlePathAndName + "/" + locale;
					cache[target] = current;
					current.$locale = availableLocales.specificity;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// summary:
			//		id may be relative.
			//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
			//		therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			// summary:
			//		id is in one of the following formats
			//
			//		1. <path>/nls/<bundle>
			//			=> load the bundle, localized to config.locale; load all bundles localized to
			//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//		2. <path>/nls/<locale>/<bundle>
			//			=> load then return the bundle localized to <locale>
			//
			//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//			=> for config.locale and all config.extraLocale, load all bundles found
			//			in the best-matching bundle rollup. A value of 1 is returned, which
			//			is meaningless other than to say the plugin is executing the requested
			//			preloads
			//
			//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
			//
			//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//			<path>/nls/<bundle>/<locale>
			//
			//		will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			//		Given this algorithm, other machinery can provide fast load paths be preplacing
			//		values in the plugin's cache, which is public. When a load is demanded the
			//		cache is inspected before starting any loading. Explicitly placing values in the plugin
			//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			//		plugin what additional localized bundles are required for a particular locale. These
			//		additional locales are loaded and a mix of the root and each progressively-specific
			//		locale is returned. For example:
			//
			//		1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			//		2. The loader demands load(some/path/nls/someBundle)
			//
			//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//		ab-cd-ef as...
			//
			//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//		  			require("some/path/nls/ab/someBundle")),
			//					require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//		This value is inserted into the cache and published to the loader at the
			//		key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			//		(further preload requests will be serviced) until all ongoing preloading has completed.
			//
			//		The preload signature instructs the plugin that a special rollup module is available that contains
			//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			//		are available. Here is an example:
			//
			//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			//		This indicates the following rollup modules are available:
			//
			//			some/path/nls/someModule_ROOT
			//			some/path/nls/someModule_ab
			//			some/path/nls/someModule_ab-cd-ef
			//
			//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
			//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
			//
			//			define({
			//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			//			});
			//
			//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			//			require(["some/path/nls/someModule_ab"], function(rollup){
			//				for(var p in rollup){
			//					var id = p + "/ab",
			//					cache[id] = rollup[p];
			//					define(id, rollup[p]);
			//				}
			//			});
			//
			//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			//		load accordingly.
			//
			//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
			//		provided. Further, the builder will include the following cache entry in the cache associated with
			//		any layer.
			//
			//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			//		The *now special cache module instructs the loader to apply the provided function to context-require
			//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
			//		requests until all preloading is complete.
			//
			//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			//		where the target locale has a single segment and a layer depends on a single bundle:
			//
			//		Without Preloads:
			//
			//		1. Layer loads root bundle.
			//		2. bundle is demanded; plugin loads single localized bundle.
			//
			//		With Preloads:
			//
			//		1. Layer causes preloading of target bundle.
			//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.

			if(has("dojo-preload-i18n-Api")){
				var split = id.split("*"),
					preloadDemand = split[1] == "preload";
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1, require);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || waitForPreloads(id, require, load)){
					return;
				}
			}

			var match = nlsRe.exec(id),
				bundlePath = match[1] + "/",
				bundleName = match[5] || match[4],
				bundlePathAndName = bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale =	localeSpecified || dojo.locale || "",
				loadTarget = bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				};
			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-unit-tests")){
		var unitTests = thisModule.unitTests = [];
	}

	if(has("dojo-preload-i18n-Api") ||  1 ){
		var normalizeLocale = thisModule.normalizeLocale = function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid, contextRequire){
				return ( 1  &&  1 ) ?
					contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
				// summary:
				//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
				// description:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would only load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.

				// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
				// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
				// itself may have been mapped.
				contextRequire = contextRequire || require;

				function doRequire(mid, callback){
					if(isXd(mid, contextRequire) || guaranteedAmdFormat){
						contextRequire([mid], callback);
					}else{
						syncRequire([mid], callback, contextRequire);
					}
				}

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return;
						}
						parts.pop();
					}
					func("ROOT");
				}

					function preloadingAddLock(){
						preloading++;
					}

					function preloadingRelLock(){
						--preloading;
						while(!preloading && preloadWaitQueue.length){
							load.apply(null, preloadWaitQueue.shift());
						}
					}

					function cacheId(path, name, loc, require){
						// path is assumed to have a trailing "/"
						return require.toAbsMid(path + name + "/" + loc)
					}

					function preload(locale){
						locale = normalizeLocale(locale);
						forEachLocale(locale, function(loc){
							if(array.indexOf(localesGenerated, loc) >= 0){
								var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
								preloadingAddLock();
								doRequire(mid, function(rollup){
									for(var p in rollup){
										var bundle = rollup[p],
											match = p.match(/(.+)\/([^\/]+)$/),
											bundleName, bundlePath;
											
											// If there is no match, the bundle is not a regular bundle from an AMD layer.
											if (!match){continue;}

											bundleName = match[2];
											bundlePath = match[1] + "/";

										// backcompat
										bundle._localized = bundle._localized || {};

										var localized;
										if(loc === "ROOT"){
											var root = localized = bundle._localized;
											delete bundle._localized;
											root.root = bundle;
											cache[require.toAbsMid(p)] = root;
										}else{
											localized = bundle._localized;
											cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
										}

										if(loc !== locale){
											// capture some locale variables
											function improveBundle(bundlePath, bundleName, bundle, localized){
												// locale was not flattened and we've fallen back to a less-specific locale that was flattened
												// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
												// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
												// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
												// version of the bundle.
												//
												// Remember, different bundles may have different sets of locales available.
												//
												// we are really falling back on the regular algorithm here, but--hopefully--starting with most
												// of the required bundles already on board as given by the rollup and we need to "manually" load
												// only one locale from a few bundles...or even better...we won't find anything better to load.
												// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
												//
												// note: this feature is only available in async mode

												// inspect the loaded bundle that came from the rollup to see if something better is available
												// for any bundle in a rollup, more-specific available locales are given at localized.
												var requiredBundles = [],
													cacheIds = [];
												forEachLocale(locale, function(loc){
													if(localized[loc]){
														requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
														cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
													}
												});

												if(requiredBundles.length){
													preloadingAddLock();
													contextRequire(requiredBundles, function(){
														for(var i = 0; i < requiredBundles.length; i++){
															bundle = lang.mixin(lang.clone(bundle), arguments[i]);
															cache[cacheIds[i]] = bundle;
														}
														// this is the best possible (maybe a perfect match, maybe not), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
														preloadingRelLock();
													});
												}else{
													// this is the best possible (definitely not a perfect match), accept it
													cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
												}
											}
											improveBundle(bundlePath, bundleName, bundle, localized);
										}
									}
									preloadingRelLock();
								});
								return true;
							}
							return false;
						});
					}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			},

			checkForLegacyModules = function()
				{};
	}

	if( 1 ){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var amdValue = {},
			evalBundle =
				// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
				new Function(
					"__bundle",				   // the bundle to evalutate
					"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
					"__mid",				   // the mid that __bundle is intended to define
					"__amdValue",

					// returns one of:
					//		1 => the bundle was an AMD bundle
					//		a legacy bundle object that is the value of __mid
					//		instance of Error => could not figure out how to evaluate bundle

					  // used to detect when __bundle calls define
					  "var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
					+ "	   require = function(){define.called = 1;};"

					+ "try{"
					+		"define.called = 0;"
					+		"eval(__bundle);"
					+		"if(define.called==1)"
								// bundle called define; therefore signal it's an AMD bundle
					+			"return __amdValue;"

					+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
								// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
					+			"return __checkForLegacyModules;"

					+ "}catch(e){}"
					// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
					// either way, re-eval *after* surrounding with parentheses

					+ "try{"
					+		"return eval('('+__bundle+')');"
					+ "}catch(e){"
					+		"return e;"
					+ "}"
				),

			syncRequire = function(deps, callback, require){
				var results = [];
				array.forEach(deps, function(mid){
					var url = require.toUrl(mid + ".js");

					function load(text){
						var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
						if(result===amdValue){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							results.push(cache[url] = amdValue.result);
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle = require.syncLoadNls(mid);
						// don't need to check for legacy since syncLoadNls returns a module if the module
						// (1) was already loaded, or (2) was in the cache. In case 1, if syncRequire is called
						// from getLocalization --> load, then load will have called checkForLegacyModules() before
						// calling syncRequire; if syncRequire is called from preloadLocalizations, then we
						// don't care about checkForLegacyModules() because that will be done when a particular
						// bundle is actually demanded. In case 2, checkForLegacyModules() is never relevant
						// because cached modules are always v1.7+ built modules.
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url] = {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url] = {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			};

		checkForLegacyModules = function(target){
			// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
			for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
			if(object){
				result = object[names[i]];
				if(!result){
					// fallback for incorrect bundle build of 1.6
					result = object[names[i].replace(/-/g,"_")];
				}
				if(result){
					cache[target] = result;
				}
			}
			return result;
		};

		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var result,
				l10nName = getBundleName(moduleName, bundleName, locale);
			load(
				l10nName,

				// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
				// Since this legacy function does not have the concept of a reference module, resolve with respect to this
				// dojo/i18n module, which, itself may have been mapped.
				(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),

				function(result_){ result = result_; }
			);
			return result;
		};

		if(has("dojo-unit-tests")){
			unitTests.push(function(doh){
				doh.register("tests.i18n.unit", function(t){
					var check;

					check = evalBundle("{prop:1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("({prop:1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("{'prop-x':1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("define({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("define('some/module', {'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("this is total nonsense and should throw an error", checkForLegacyModules, "nonsense", amdValue);
					t.is(check instanceof Error, true);
				});
			});
		}
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache,
		getL10nName: getL10nName
	});
});

},
'dojo/cookie':function(){
define(["./_base/kernel", "./regexp"], function(dojo, regexp){

// module:
//		dojo/cookie

/*=====
var __cookieProps = {
	// expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	// path: String?
	//		The path to use for the cookie.
	// domain: String?
	//		The domain to use for the cookie.
	// secure: Boolean?
	//		Whether to only send the cookie on secure connections
};
=====*/


dojo.cookie = function(/*String*/name, /*String?*/ value, /*__cookieProps?*/ props){
	// summary:
	//		Get or set a cookie.
	// description:
	//		If one argument is passed, returns the value of the cookie
	//		For two or more arguments, acts as a setter.
	// name:
	//		Name of the cookie
	// value:
	//		Value for the cookie
	// props:
	//		Properties for the cookie
	// example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		cookie("configObj", json.stringify(config, {expires: 5 }));
	//	|	});
	//
	// example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		config = json.parse(cookie("configObj"));
	//	|	});
	//
	// example:
	//		delete a cookie:
	//	|	require(["dojo/cookie"], function(cookie){
	//	|		cookie("configObj", null, {expires: -1});
	//	|	});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	// summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'dojo/regexp':function(){
define(["./_base/kernel", "./_base/lang"], function(dojo, lang){

// module:
//		dojo/regexp

var regexp = {
	// summary:
	//		Regular expressions and Builder resources
};
lang.setObject("dojo.regexp", regexp);

regexp.escapeString = function(/*String*/str, /*String?*/except){
	// summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	// summary:
	//		Builds a regular expression that groups subexpressions
	// description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return regexp.group(b.join("|"), nonCapture); // String
};

regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return regexp;
});

},
'dojo/currency':function(){
define([
	"./_base/array",
	"./_base/lang",
	/*===== "./_base/declare", =====*/
	"./number",
	"./i18n", "./i18n!./cldr/nls/currency",
	"./cldr/monetary"
], function(darray, lang, /*===== declare, =====*/ dnumber, i18n, nlsCurrency, cldrMonetary){

// module:
//		dojo/currency

var currency = {
	// summary:
	//		localized formatting and parsing routines for currencies
	// description:
	//		extends dojo.number to provide culturally-appropriate formatting of values
	//		in various world currencies, including use of a currency symbol.  The currencies are specified
	//		by a three-letter international symbol in all uppercase, and support for the currencies is
	//		provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	//		currency support is included.  A fixed number of decimal places is determined based
	//		on the currency type and is not determined by the 'pattern' argument.  The fractional
	//		portion is optional, by default, and variable length decimals are not supported.
};
lang.setObject("dojo.currency", currency);

currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-dependent currency data, like the symbol
	var bundle = i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = cldrMonetary.getData(iso);

	darray.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return lang.mixin(data, options);
};

/*=====
currency.__FormatOptions = declare([dnumber.__FormatOptions], {
	// type: String?
	//		Should not be set.  Value is assumed to be "currency".
	// symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	// currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	// places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	currency: "",
	places: ""
});
=====*/

currency.format = function(/*Number*/ value, /*__FormatOptions?*/ options){
	// summary:
	//		Format a Number as a currency, using locale-specific settings
	//
	// description:
	//		Create a string from a Number using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
	//		appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
	//		as well as the appropriate symbols and delimiters and number of decimal places.
	//
	// value:
	//		the number to be formatted.

	return dnumber.format(value, currency._mixInDefaults(options));
};

currency.regexp = function(/*dnumber.__RegexpOptions?*/ options){
	//
	// summary:
	//		Builds the regular needed to parse a currency value
	//
	// description:
	//		Returns regular expression with positive and negative match, group and decimal separators
	//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dnumber.regexp(currency._mixInDefaults(options)); // String
};

/*=====
var __ParseOptions = currency.__ParseOptions = declare(dnumber.__ParseOptions, {
	// type: String?
	//		Should not be set.  Value is assumed to be currency.
	// currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	// symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	// places: Number?
	//		fixed number of decimal places to accept.  The default is determined based on which currency is used.
	// fractional: Boolean|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by the currency
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	//		By default for currencies, it the fractional portion is optional.
});
=====*/

currency.parse = function(/*String*/ expression, /*__ParseOptions?*/ options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	//		and number of decimal places.
	// expression:
	//		A string representation of a currency value

	return dnumber.parse(expression, currency._mixInDefaults(options));
};

return currency;
});

},
'dojo/number':function(){
define([/*===== "./_base/declare", =====*/ "./_base/lang", "./i18n", "./i18n!./cldr/nls/number", "./string", "./regexp"],
	function(/*===== declare, =====*/ lang, i18n, nlsNumber, dstring, dregexp){

// module:
//		dojo/number

var number = {
	// summary:
	//		localized formatting and parsing routines for Number
};
lang.setObject("dojo.number", number);

/*=====
number.__FormatOptions = declare(null, {
	// pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	// type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	// places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	// round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	// locale: String?
	//		override the locale used to determine formatting rules
	// fractional: Boolean?
	//		If false, show no decimal places, overriding places and pattern settings.
});
=====*/

number.format = function(/*Number*/ value, /*number.__FormatOptions?*/ options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = lang.mixin({}, options || {});
	var locale = i18n.normalizeLocale(options.locale),
		bundle = i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return number._applyPattern(value, pattern, options); // String
};

//number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

number._applyPattern = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatOptions?*/ options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: number.__FormatOptions?
	//		_applyPattern is usually called via `dojo/number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group,
		decimal = options.customs.decimal,
		patternList = pattern.split(';'),
		positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}

	//TODO: support @ sig figs?
	var numberPatternRE = number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
};

number.round = function(/*Number*/ value, /*Number?*/ places, /*Number?*/ increment){
	// summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	// description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.
	// value:
	//		The number to round
	// places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	// increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	// example:
	// |	>>> number.round(-0.5)
	// |	-1
	// |	>>> number.round(162.295, 2)
	// |	162.29  // note floating point error.  Should be 162.3
	// |	>>> number.round(10.71, 0, 2.5)
	// |	10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
};

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	var round = number.round;
	number.round = function(v, p, m){
		var d = Math.pow(10, -p || 0), a = Math.abs(v);
		if(!v || a >= d){
			d = 0;
		}else{
			a /= d;
			if(a < 0.5 || a >= 0.95){
				d = 0;
			}
		}
		return round(v, p, m) + (v > 0 ? d : -d);
	};

	// Use "doc hint" so the doc parser ignores this new definition of round(), and uses the one above.
	/*===== number.round = round; =====*/
}

/*=====
number.__FormatAbsoluteOptions = declare(null, {
	// decimal: String?
	//		the decimal separator
	// group: String?
	//		the group separator
	// places: Number|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	// round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
});
=====*/

number._formatAbsolute = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatAbsoluteOptions?*/ options){
	// summary:
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split("."),
		comma = typeof options.places == "string" && options.places.indexOf(","),
		maxPlaces = options.places;
	if(comma){
		maxPlaces = options.places.substring(comma + 1);
	}else if(!(maxPlaces >= 0)){
		maxPlaces = (patternParts[1] || []).length;
	}
	if(!(options.round < 0)){
		value = number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split("."),
		fractional = valueParts[1] || "";
	if(patternParts[1] || options.places){
		if(comma){
			options.places = options.places.substring(0, comma);
		}
		// Pad fractional with trailing zeros
		var pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf("0") + 1);
		if(pad > fractional.length){
			valueParts[1] = dstring.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		if(maxPlaces < fractional.length){
			valueParts[1] = fractional.substr(0, maxPlaces);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dstring.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(','),
		groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
number.__RegexpOptions = declare(null, {
	// pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	// type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	// locale: String?
	//		override the locale used to determine formatting rules
	// strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	// places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
});
=====*/
number.regexp = function(/*number.__RegexpOptions?*/ options){
	// summary:
	//		Builds the regular needed to parse a number
	// description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return number._parseInfo(options).regexp; // String
};

number._parseInfo = function(/*Object?*/ options){
	options = options || {};
	var locale = i18n.normalizeLocale(options.locale),
		bundle = i18n.getLocalization("dojo.cldr", "number", locale),
		pattern = options.pattern || bundle[(options.type || "decimal") + "Format"],
//TODO: memoize?
		group = bundle.group,
		decimal = bundle.decimal,
		factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dregexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dregexp.escapeString(pattern, '.')+")";
		return pattern.replace(number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false
				},

				parts = format.split('.'),
				places = options.places;

			// special condition for percent (factor != 1)
			// allow decimal places even if not specified in pattern
			if(parts.length == 1 && factor != 1){
			    parts[1] = "###";
			}
			if(parts.length == 1 || places === 0){
				flags.fractional = false;
			}else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length > 1){
				flags.groupSize = groups.pop().length;
				if(groups.length > 1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1],
				symbol = dregexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
};

/*=====
number.__ParseOptions = declare(null, {
	// pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	// type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	// locale: String?
	//		override the locale used to determine formatting rules
	// strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	// fractional: Boolean|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by pattern
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
});
=====*/
number.parse = function(/*String*/ expression, /*number.__ParseOptions?*/ options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
    	//		Note that literal characters in patterns are not supported.
	// expression:
	//		A string representation of a Number
	var info = number._parseInfo(options),
		results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
number.__RealNumberRegexpFlags = declare(null, {
	// places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	// decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	// fractional: Boolean|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	// exponent: Boolean|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	// eSigned: Boolean|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
});
=====*/

number._realNumberRegexp = function(/*__RealNumberRegexpFlags?*/ flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing parameters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	var integerRE = number._integerRegexp(flags),
		decimalRE = dregexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){
					re = "(?:" + re + "\\d+)?";
				}else{
					re += "\\d{" + flags.places + "}";
				}
			}
			return re;
		},
		true
	);

	var exponentRE = dregexp.buildGroupRE(flags.exponent,
		function(q){
			if(q){ return "([eE]" + number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return "";
		}
	);

	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
number.__IntegerRegexpFlags = declare(null, {
	// signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	// separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	// groupSize: Number?
	//		group size between separators
	// groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
});
=====*/

number._integerRegexp = function(/*number.__IntegerRegexpFlags?*/ flags){
	// summary:
	//		Builds a regular expression that matches an integer

	// assign default values to missing parameters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}

	var signRE = dregexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	var numberRE = dregexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dregexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	return signRE + numberRE; // String
};

return number;
});

},
'dojo/string':function(){
define([
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});

},
'dojo/data/util/filter':function(){
define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/filter
	// summary:
	//		TODOC

var filter = {};
lang.setObject("dojo.data.util.filter", filter);

filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	// summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	// description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//
	//		- ca*   -> /^ca.*$/
	//		- *ca*  -> /^.*ca.*$/
	//		- *c\*a*  -> /^.*c\*a.*$/
	//		- *c\*a?*  -> /^.*c\*a..*$/
	//
	//		and so on.
	// pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//
	//		- * Means match anything, so ca* means match anything starting with ca
	//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
	//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//
	//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//		represented by \\ to be treated as an ordinary \ character instead of an escape.
	// ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}

};

return filter;
});

},
'dojo/data/util/simpleFetch':function(){
define(["../../_base/lang", "../../_base/kernel", "./sorter"],
  function(lang, kernel, sorter){
	// module:
	//		dojo/data/util/simpleFetch
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.

var simpleFetch = {};
lang.setObject("dojo.data.util.simpleFetch", simpleFetch);

simpleFetch.errorHandler = function(/*Object*/ errorData, /*Object*/ requestObject){
	// summary:
	//		The error handler when there is an error fetching items.  This function should not be called
	//		directly and is used by simpleFetch.fetch().
	if(requestObject.onError){
		var scope = requestObject.scope || kernel.global;
		requestObject.onError.call(scope, errorData, requestObject);
	}
};

simpleFetch.fetchHandler = function(/*Array*/ items, /*Object*/ requestObject){
	// summary:
	//		The handler when items are successfully fetched.  This function should not be called directly
	//		and is used by simpleFetch.fetch().
	var oldAbortFunction = requestObject.abort || null,
		aborted = false,

		startIndex = requestObject.start?requestObject.start: 0,
		endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

	requestObject.abort = function(){
		aborted = true;
		if(oldAbortFunction){
			oldAbortFunction.call(requestObject);
		}
	};

	var scope = requestObject.scope || kernel.global;
	if(!requestObject.store){
		requestObject.store = this;
	}
	if(requestObject.onBegin){
		requestObject.onBegin.call(scope, items.length, requestObject);
	}
	if(requestObject.sort){
		items.sort(sorter.createSortFunction(requestObject.sort, this));
	}
	if(requestObject.onItem){
		for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
			var item = items[i];
			if(!aborted){
				requestObject.onItem.call(scope, item, requestObject);
			}
		}
	}
	if(requestObject.onComplete && !aborted){
		var subset = null;
		if(!requestObject.onItem){
			subset = items.slice(startIndex, endIndex);
		}
		requestObject.onComplete.call(scope, subset, requestObject);
	}
};

simpleFetch.fetch = function(/* Object? */ request){
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	// description:
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object --
	//		or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo/data/api/Read.fetch()
	//
	// request:
	//		The keywordArgs parameter may either be an instance of
	//		conforming to dojo/data/api/Request or may be a simple anonymous object
	//		that may contain any of the following:
	// |	{
	// |		query: query-object or query-string,
	// |		queryOptions: object,
	// |		onBegin: Function,
	// |		onItem: Function,
	// |		onComplete: Function,
	// |		onError: Function,
	// |		scope: object,
	// |		start: int
	// |		count: int
	// |		sort: array
	// |	}
	//		All implementations should accept keywordArgs objects with any of
	//		the 9 standard properties: query, onBegin, onItem, onComplete, onError
	//		scope, sort, start, and count.  Some implementations may accept additional
	//		properties in the keywordArgs object as valid parameters, such as
	//		{includeOutliers:true}.
	//
	//		####The *query* parameter
	//
	//		The query may be optional in some data store implementations.
	//		The dojo/data/api/Read API does not specify the syntax or semantics
	//		of the query itself -- each different data store implementation
	//		may have its own notion of what a query should look like.
	//		However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	//		and dojox.data support an object structure query, where the object is a set of
	//		name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	//		dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	//		when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	//		widgets the recommended query parameter is a key/value object.  That does not mean that the
	//		the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	//		or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
	//		format.
	//
	//		Further note:  In general for query objects that accept strings as attribute
	//		value matches, the store should also support basic filtering capability, such as *
	//		(match any character) and ? (match single character).  An example query that is a query object
	//		would be like: { attrFoo: "value*"}.  Which generally means match all items where they have
	//		an attribute named attrFoo, with a value that starts with 'value'.
	//
	//		####The *queryOptions* parameter
	//
	//		The queryOptions parameter is an optional parameter used to specify options that may modify
	//		the query in some fashion, such as doing a case insensitive search, or doing a deep search
	//		where all items in a hierarchical representation of data are scanned instead of just the root
	//		items.  It currently defines two options that all datastores should attempt to honor if possible:
	// |	{
	// |		ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
	// |		deep: boolean	// Whether or not a fetch should do a deep search of items and all child
	// |						// items instead of just root-level items in a datastore.  Default is false.
	// |	}
	//
	//		####The *onBegin* parameter.
	//
	//		function(size, request);
	//		If an onBegin callback function is provided, the callback function
	//		will be called just once, before the first onItem callback is called.
	//		The onBegin callback function will be passed two arguments, the
	//		the total number of items identified and the Request object.  If the total number is
	//		unknown, then size will be -1.  Note that size is not necessarily the size of the
	//		collection of items returned from the query, as the request may have specified to return only a
	//		subset of the total set of items through the use of the start and count parameters.
	//
	//		####The *onItem* parameter.
	//
	//		function(item, request);
	//
	//		If an onItem callback function is provided, the callback function
	//		will be called as each item in the result is received. The callback
	//		function will be passed two arguments: the item itself, and the
	//		Request object.
	//
	//		####The *onComplete* parameter.
	//
	//		function(items, request);
	//
	//		If an onComplete callback function is provided, the callback function
	//		will be called just once, after the last onItem callback is called.
	//		Note that if the onItem callback is not present, then onComplete will be passed
	//		an array containing all items which matched the query and the request object.
	//		If the onItem callback is present, then onComplete is called as:
	//		onComplete(null, request).
	//
	//		####The *onError* parameter.
	//
	//		function(errorData, request);
	//
	//		If an onError callback function is provided, the callback function
	//		will be called if there is any sort of error while attempting to
	//		execute the query.
	//		The onError callback function will be passed two arguments:
	//		an Error object and the Request object.
	//
	//		####The *scope* parameter.
	//
	//		If a scope object is provided, all of the callback functions (onItem,
	//		onComplete, onError, etc) will be invoked in the context of the scope
	//		object.  In the body of the callback function, the value of the "this"
	//		keyword will be the scope object.   If no scope object is provided,
	//		the callback functions will be called in the context of dojo.global().
	//		For example, onItem.call(scope, item, request) vs.
	//		onItem.call(dojo.global(), item, request)
	//
	//		####The *start* parameter.
	//
	//		If a start parameter is specified, this is a indication to the datastore to
	//		only start returning items once the start number of items have been located and
	//		skipped.  When this parameter is paired with 'count', the store should be able
	//		to page across queries with millions of hits by only returning subsets of the
	//		hits for each query
	//
	//		####The *count* parameter.
	//
	//		If a count parameter is specified, this is a indication to the datastore to
	//		only return up to that many items.  This allows a fetch call that may have
	//		millions of item matches to be paired down to something reasonable.
	//
	//		####The *sort* parameter.
	//
	//		If a sort parameter is specified, this is a indication to the datastore to
	//		sort the items in some manner before returning the items.  The array is an array of
	//		javascript objects that must conform to the following format to be applied to the
	//		fetching of items:
	// |	{
	// |		attribute: attribute || attribute-name-string,
	// |		descending: true|false;   // Optional.  Default is false.
	// |	}
	//		Note that when comparing attributes, if an item contains no value for the attribute
	//		(undefined), then it the default ascending sort logic should push it to the bottom
	//		of the list.  In the descending order case, it such items should appear at the top of the list.

	request = request || {};
	if(!request.store){
		request.store = this;
	}

	this._fetchItems(request, lang.hitch(this, "fetchHandler"), lang.hitch(this, "errorHandler"));
	return request;	// Object
};

return simpleFetch;
});

},
'dojo/data/util/sorter':function(){
define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/sorter
	// summary:
	//		TODOC

var sorter = {};
lang.setObject("dojo.data.util.sorter", sorter);

sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	// summary:
	//		Basic comparison function that compares if an item is greater or less than another item
	// description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.

	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

sorter.createSortFunction = function(	/* attributes[] */sortSpec, /*dojo/data/api/Read*/ store){
	// summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	// description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	// sortSpec:
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	// |	{
	// |		attribute: "attributeName-string" || attribute,
	// |		descending: true|false;   // Default is false.
	// |	}
	// store:
	//		The datastore object to look up item values from.

	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

return sorter;
});

},
'dojo/date':function(){
define(["./has", "./_base/lang"], function(has, lang){
// module:
//		dojo/date

var date = {
	// summary:
	//		Date manipulation utilities
};

date.getDaysInMonth = function(/*Date*/dateObject){
	// summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

date.isLeapYear = function(/*Date*/dateObject){
	// summary:
	//		Determines if the year of the dateObject is a leap year
	// description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
date.getTimezoneName = function(/*Date*/dateObject){
	// summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	// description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	// summary:
	//		Compare two date objects by date, time, or both.
	// description:
	//		Returns 0 if equal, positive if a > b, else negative.
	// date1:
	//		Date object
	// date2:
	//		Date object.  If not specified, the current Date is used.
	// portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}

	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	// summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	// date: Date
	//		Date object to start with
	// interval:
	//		A string representing the interval.  One of the following:
	//		"year", "month", "day", "hour", "minute", "second",
	//		"millisecond", "quarter", "week", "weekday"
	// amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accommodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo/cldr/supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	// summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	// date1:
	//		Date object
	// date2:
	//		Date object.  If not specified, the current Date is used.
	// interval:
	//		A string representing the interval.  One of the following:
	//		"year", "month", "day", "hour", "minute", "second",
	//		"millisecond", "quarter", "week", "weekday"
	//
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(date.difference(date1, date2, "day"));
			var weeks = parseInt(date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

// Don't use setObject() because it may overwrite dojo/date/stamp (if that has already been loaded)
 1  && lang.mixin(lang.getObject("dojo.date", true), date);

return date;
});

},
'dojo/date/locale':function(){
define([
	"../_base/lang",
	"../_base/array",
	"../date",
	/*===== "../_base/declare", =====*/
	"../cldr/supplemental",
	"../i18n",
	"../regexp",
	"../string",
	"../i18n!../cldr/nls/gregorian",
	"module"
], function(lang, array, date, /*===== declare, =====*/ supplemental, i18n, regexp, string, gregorian, module){

// module:
//		dojo/date/locale

var exports = {
	// summary:
	//		This modules defines dojo/date/locale, localization methods for Date.
};
lang.setObject(module.id.replace(/\//g, "."), exports);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.

// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
				case 'L':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = [
							"months",
							c == 'L' ? "standAlone" : "format",
							widthList[l-3]
						].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = exports._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = exports._getDayOfYear(dateObject); pad = true;
					break;
				case 'e':
				case 'c':
					var d = dateObject.getDay();
					if(l<2){
						s = (d - supplemental.getFirstDayOfWeek(options.locale) + 8) % 7
						break;
					}
					// fallthrough
				case 'E':
					d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = [
							"days",
							c == 'c' ? "standAlone" : "format",
							widthList[l-3]
						].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = dateObject.getHours() < 12 ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = exports._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = exports._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						string.pad(Math.floor(Math.abs(offset)/60), 2),
						string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = string.pad(s, l); }
			return s;
		});
	}

/*=====
var __FormatOptions = exports.__FormatOptions = declare(null, {
	// selector: String
	//		choice of 'time','date' (default: date and time)
	// formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	// datePattern:String
	//		override pattern with this string
	// timePattern:String
	//		override pattern with this string
	// am: String
	//		override strings for am in times
	// pm: String
	//		override strings for pm in times
	// locale: String
	//		override the locale used to determine formatting rules
	// fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	// strict: Boolean
	//		(parse only) strict parsing, off by default
});
=====*/

exports._getZone = function(/*Date*/ dateObject, /*boolean*/ getName, /*__FormatOptions?*/ options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


exports.format = function(/*Date*/ dateObject, /*__FormatOptions?*/ options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo/date/locale.addCustomFormats() method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = exports._getGregorianBundle(locale),
		str = [],
		sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\'/g,'').replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

exports.regexp = function(/*__FormatOptions?*/ options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return exports._parseInfo(options).regexp; // String
};

exports._parseInfo = function(/*__FormatOptions?*/ options){
	options = options || {};
	var locale = i18n.normalizeLocale(options.locale),
		bundle = exports._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

exports.parse = function(/*String*/ value, /*__FormatOptions?*/ options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo/date/locale.addCustomFormats() method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = exports._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = array.every(match, function(v, i){
		if(!i){return true;}
		var token = tokens[i-1],
			l = token.length,
			c = token.charAt(0);
		switch(c){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
						result[0] = (v < cutoff) ? century + v : century - 100 + v;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
			case 'L':
				if(l>2){
					var months = bundle['months-' +
							    (c == 'L' ? 'standAlone' : 'format') +
							    '-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = array.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = array.indexOf(months, v);
					if(v == -1){
//						console.log("dojo/date/locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
			case 'c':
				var days = bundle['days-' +
						  (c == 'c' ? 'standAlone' : 'format') +
						  '-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = array.map(days, function(d){return d.toLowerCase();});
				}
				v = array.indexOf(days, v);
				if(v == -1){
//					console.log("dojo/date/locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo/date/locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo/date/locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo/date/locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	array.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
			case 'L':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
			case 'e':
			case 'c':
				s = '.+?'; // match anything including spaces until the first pattern delimiter is found such as a comma or space
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
					s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}

var _customFormats = [];
exports.addCustomFormats = function(/*String*/ packageName, /*String*/ bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo/date/locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

exports._getGregorianBundle = function(/*String*/ locale){
	var gregorian = {};
	array.forEach(_customFormats, function(desc){
		var bundle = i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = lang.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};

exports.addCustomFormats(module.id.replace(/\/date\/locale$/, ".cldr"),"gregorian");

exports.getNames = function(/*String*/ item, /*String*/ type, /*String?*/ context, /*String?*/ locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = exports._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

exports.isWeekend = function(/*Date?*/ dateObject, /*String?*/ locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

exports._getDayOfYear = function(/*Date*/ dateObject){
	// summary:
	//		gets the day of the year as represented by dateObject
	return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

exports._getWeekOfYear = function(/*Date*/ dateObject, /*Number*/ firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((exports._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

return exports;
});

},
'dojo/date/stamp':function(){
define(["../_base/lang", "../_base/array"], function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
});

},
'dojo/DeferredList':function(){
define(["./_base/kernel", "./_base/Deferred", "./_base/array"], function(dojo, Deferred, darray){
	// module:
	//		dojo/DeferredList


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Deprecated, use dojo/promise/all instead.
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	// list:
	//		The list of deferreds to be synchronizied with this DeferredList
	// fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	// fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	// canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	darray.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}

		}
	});
};
dojo.DeferredList.prototype = new Deferred();

dojo.DeferredList.prototype.gatherResults = function(deferredList){
	// summary:
	//		Gathers the results of the deferreds for packaging
	//		as the parameters to the Deferred Lists' callback
	// deferredList: dojo/DeferredList
	//		The deferred list from which this function gathers results.
	// returns: dojo/DeferredList
	//		The newly created deferred list which packs results as
	//		parameters to its callback.

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		darray.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

return dojo.DeferredList;
});

},
'dojo/_firebug/firebug':function(){
define([
	"../_base/kernel",
	"require",
	"../_base/html",
	"../sniff",
	"../_base/array",
	"../_base/lang",
	"../_base/event",
	"../_base/unload"], function(dojo, require, html, has){

	// module:
	//		dojo/_firebug/firebug
	// summary:
	//		Firebug Lite, the baby brother to Joe Hewitt's Firebug for Mozilla Firefox
	// description:
	//		Opens a console for logging, debugging, and error messages.
	//		Contains partial functionality to Firebug. See function list below.
	//
	//		NOTE:
	//		Firebug is a Firefox extension created by Joe Hewitt (see license). You do not need Dojo to run Firebug.
	//		Firebug Lite is included in Dojo by permission from Joe Hewitt
	//		If you are new to Firebug, or used to the Dojo 0.4 dojo.debug, you can learn Firebug
	//		functionality by reading the function comments below or visiting http://www.getfirebug.com/docs.html
	//
	//		NOTE:
	//		To test Firebug Lite in Firefox:
	//
	//		- FF2: set "console = null" before loading dojo and set djConfig.isDebug=true
	//		- FF3: disable Firebug and set djConfig.isDebug=true
	//
	// example:
	//		Supports inline objects in object inspector window (only simple trace of dom nodes, however)
	//	|	console.log("my object", {foo:"bar"})
	// example:
	//		Option for console to open in popup window
	//	|	var djConfig = {isDebug: true, popup:true };
	// example:
	//		Option for console height (ignored for popup)
	//	|	var djConfig = {isDebug: true, debugHeight:100 }


	var isNewIE = (/Trident/.test(window.navigator.userAgent));
	if(isNewIE){
		// Fixing IE's console
		// IE doesn't insert space between arguments. How annoying.
		var calls = ["log", "info", "debug", "warn", "error"];
		for(var i=0;i<calls.length;i++){
			var m = calls[i];
			if(!console[m] ||console[m]._fake){
				// IE9 doesn't have console.debug method, a fake one is added later
				continue;
			}
			var n = "_"+calls[i];
			console[n] = console[m];
			console[m] = (function(){
				var type = n;
				return function(){
					console[type](Array.prototype.join.call(arguments, " "));
				};
			})();
		}
		// clear the console on load. This is more than a convenience - too many logs crashes it.
		// If closed it throws an error
		try{ console.clear(); }catch(e){}
	}

	if(
		has("ff") ||								// Firefox has Firebug
		has("chrome") ||							// Chrome 3+ has a console
		has("safari") ||							// Safari 4 has a console
		isNewIE ||									// Has the new IE console
		window.firebug ||							// Testing for mozilla firebug lite
		(typeof console != "undefined" && console.firebug) || //The firebug console
		dojo.config.useCustomLogger ||				// Allow custom loggers
		has("air")									// isDebug triggers AIRInsector, not Firebug
	){
		return;
	}

	// don't build firebug in iframes
	try{
		if(window != window.parent){
			// but if we've got a parent logger, connect to it
			if(window.parent["console"]){
				window.console = window.parent.console;
			}
			return;
		}
	}catch(e){/*squelch*/}

	// ***************************************************************************
	// Placing these variables before the functions that use them to avoid a
	// shrinksafe bug where variable renaming does not happen correctly otherwise.

	// most of the objects in this script are run anonomously
	var _firebugDoc = document;
	var _firebugWin = window;
	var __consoleAnchorId__ = 0;

	var consoleFrame = null;
	var consoleBody = null;
	var consoleObjectInspector = null;
	var fireBugTabs = null;
	var commandLine = null;
	var consoleToolbar = null;

	var frameVisible = false;
	var messageQueue = [];
	var groupStack = [];
	var timeMap = {};
	var countMap = {};

	var consoleDomInspector = null;
	var _inspectionMoveConnection;
	var _inspectionClickConnection;
	var _inspectionEnabled = false;
	var _inspectionTimer = null;
	var _inspectTempNode = document.createElement("div");


	var _inspectCurrentNode;
	var _restoreBorderStyle;

	// ***************************************************************************

	window.console = {
		_connects: [],
		log: function(){
			// summary:
			//		Sends arguments to console.
			logFormatted(arguments, "");
		},

		debug: function(){
			// summary:
			//		Sends arguments to console. Missing finctionality to show script line of trace.
			logFormatted(arguments, "debug");
		},

		info: function(){
			// summary:
			//		Sends arguments to console, highlighted with (I) icon.
			logFormatted(arguments, "info");
		},

		warn: function(){
			// summary:
			//		Sends warning arguments to console, highlighted with (!) icon and blue style.
			logFormatted(arguments, "warning");
		},

		error: function(){
			// summary:
			//		Sends error arguments (object) to console, highlighted with (X) icon and yellow style
			//		NEW: error object now displays in object inspector
			logFormatted(arguments, "error");
		},

		assert: function(truth, message){
			// summary:
			//		Tests for true. Throws exception if false.
			if(!truth){
				var args = [];
				for(var i = 1; i < arguments.length; ++i){
					args.push(arguments[i]);
				}

				logFormatted(args.length ? args : ["Assertion Failure"], "error");
				throw message ? message : "Assertion Failure";
			}
		},

		dir: function(obj){
			var str = printObject( obj );
			str = str.replace(/\n/g, "<br />");
			str = str.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
			logRow([str], "dir");
		},

		dirxml: function(node){
			var html = [];
			appendNode(node, html);
			logRow(html, "dirxml");
		},

		group: function(){
			// summary:
			//		collects log messages into a group, starting with this call and ending with
			//		groupEnd(). Missing collapse functionality
			logRow(arguments, "group", pushGroup);
		},

		groupEnd: function(){
			// summary:
			//		Closes group. See above
			logRow(arguments, "", popGroup);
		},

		time: function(name){
			// summary:
			//		Starts timers assigned to name given in argument. Timer stops and displays on timeEnd(title);
			// example:
			//	|	console.time("load");
			//	|	console.time("myFunction");
			//	|	console.timeEnd("load");
			//	|	console.timeEnd("myFunction");
			timeMap[name] = new Date().getTime();
		},

		timeEnd: function(name){
			// summary:
			//		See above.
			if(name in timeMap){
				var delta = (new Date()).getTime() - timeMap[name];
				logFormatted([name+ ":", delta+"ms"]);
				delete timeMap[name];
			}
		},

		count: function(name){
			// summary:
			//		Not supported
			if(!countMap[name]) countMap[name] = 0;
			countMap[name]++;
			logFormatted([name+": "+countMap[name]]);
		},

		trace: function(_value){
			var stackAmt = _value || 3;
			var f = console.trace.caller; //function that called trace
			console.log(">>> console.trace(stack)");
			for(var i=0;i<stackAmt;i++){
				var func = f.toString();
				var args=[];
				for (var a = 0; a < f.arguments.length; a++){
					args.push(f.arguments[a]);
				}
				if(f.arguments.length){
					console.dir({"function":func, "arguments":args});
				}else{
					console.dir({"function":func});
				}

				f = f.caller;
			}
		},

		profile: function(){
			// summary:
			//		Not supported
			this.warn(["profile() not supported."]);
		},

		profileEnd: function(){ },

		clear: function(){
			// summary:
			//		Clears message console. Do not call this directly
			if(consoleBody){
				while(consoleBody.childNodes.length){
					dojo.destroy(consoleBody.firstChild);
				}
			}
			dojo.forEach(this._connects,dojo.disconnect);
		},

		open: function(){
			// summary:
			//		Opens message console. Do not call this directly
			toggleConsole(true);
		},

		close: function(){
			// summary:
			//		Closes message console. Do not call this directly
			if(frameVisible){
				toggleConsole();
			}
		},
		_restoreBorder: function(){
			if(_inspectCurrentNode){
				_inspectCurrentNode.style.border = _restoreBorderStyle;
			}
		},
		openDomInspector: function(){
			_inspectionEnabled = true;
			consoleBody.style.display = "none";
			consoleDomInspector.style.display = "block";
			consoleObjectInspector.style.display = "none";
			document.body.style.cursor = "pointer";
			_inspectionMoveConnection = dojo.connect(document, "mousemove", function(evt){
				if(!_inspectionEnabled){ return; }
				if(!_inspectionTimer){
					_inspectionTimer = setTimeout(function(){ _inspectionTimer = null; }, 50);
				}else{
					return;
				}
				var node = evt.target;
				if(node && (_inspectCurrentNode !== node)){
					var parent = true;

					console._restoreBorder();
					var html = [];
					appendNode(node, html);
					consoleDomInspector.innerHTML = html.join("");

					_inspectCurrentNode = node;
					_restoreBorderStyle = _inspectCurrentNode.style.border;
					_inspectCurrentNode.style.border = "#0000FF 1px solid";
				}
			});
			setTimeout(function(){
				_inspectionClickConnection = dojo.connect(document, "click", function(evt){
					document.body.style.cursor = "";
					_inspectionEnabled = !_inspectionEnabled;
					dojo.disconnect(_inspectionClickConnection);
					// console._restoreBorder();
				});
			}, 30);
		},
		_closeDomInspector: function(){
			document.body.style.cursor = "";
			dojo.disconnect(_inspectionMoveConnection);
			dojo.disconnect(_inspectionClickConnection);
			_inspectionEnabled = false;
			console._restoreBorder();
		},
		openConsole:function(){
			// summary:
			//		Closes object inspector and opens message console. Do not call this directly
			consoleBody.style.display = "block";
			consoleDomInspector.style.display = "none";
			consoleObjectInspector.style.display = "none";
			console._closeDomInspector();
		},
		openObjectInspector:function(){
			consoleBody.style.display = "none";
			consoleDomInspector.style.display = "none";
			consoleObjectInspector.style.display = "block";
			console._closeDomInspector();
		},
		recss: function(){
			// this is placed in dojo since the console is most likely
			// in another window and dojo is easily accessible
			var i,a,s;a=document.getElementsByTagName('link');
			for(i=0;i<a.length;i++){
				s=a[i];
				if(s.rel.toLowerCase().indexOf('stylesheet')>=0&&s.href){
					var h=s.href.replace(/(&|%5C?)forceReload=\d+/,'');
					s.href=h+(h.indexOf('?')>=0?'&':'?')+'forceReload='+new Date().valueOf();
				}
			}
		}
	};

	// ***************************************************************************

	function toggleConsole(forceOpen){
		frameVisible = forceOpen || !frameVisible;
		if(consoleFrame){
			consoleFrame.style.display = frameVisible ? "block" : "none";
		}
	}

	function focusCommandLine(){
		toggleConsole(true);
		if(commandLine){
			commandLine.focus();
		}
	}

	function openWin(x,y,w,h){
		var win = window.open("","_firebug","status=0,menubar=0,resizable=1,top="+y+",left="+x+",width="+w+",height="+h+",scrollbars=1,addressbar=0");
		if(!win){
			var msg = "Firebug Lite could not open a pop-up window, most likely because of a blocker.\n" +
				"Either enable pop-ups for this domain, or change the djConfig to popup=false.";
			alert(msg);
		}
		createResizeHandler(win);
		var newDoc=win.document;
		//Safari needs an HTML height
		var HTMLstring=	'<html style="height:100%;"><head><title>Firebug Lite</title></head>\n' +
					'<body bgColor="#ccc" style="height:97%;" onresize="opener.onFirebugResize()">\n' +
					'<div id="fb"></div>' +
					'</body></html>';

		newDoc.write(HTMLstring);
		newDoc.close();
		return win;
	}

	function createResizeHandler(wn){
		// summary:
		//		Creates handle for onresize window. Called from script in popup's body tag (so that it will work with IE).
		//

		var d = new Date();
			d.setTime(d.getTime()+(60*24*60*60*1000)); // 60 days
			d = d.toUTCString();

			var dc = wn.document,
				getViewport;

			if (wn.innerWidth){
				getViewport = function(){
					return{w:wn.innerWidth, h:wn.innerHeight};
				};
			}else if (dc.documentElement && dc.documentElement.clientWidth){
				getViewport = function(){
					return{w:dc.documentElement.clientWidth, h:dc.documentElement.clientHeight};
				};
			}else if (dc.body){
				getViewport = function(){
					return{w:dc.body.clientWidth, h:dc.body.clientHeight};
				};
			}


		window.onFirebugResize = function(){

			//resize the height of the console log body
			layout(getViewport().h);

			clearInterval(wn._firebugWin_resize);
			wn._firebugWin_resize = setTimeout(function(){
				var x = wn.screenLeft,
					y = wn.screenTop,
					w = wn.outerWidth  || wn.document.body.offsetWidth,
					h = wn.outerHeight || wn.document.body.offsetHeight;

				document.cookie = "_firebugPosition=" + [x,y,w,h].join(",") + "; expires="+d+"; path=/";

			 }, 5000); //can't capture window.onMove - long timeout gives better chance of capturing a resize, then the move

		};
	}


	/*****************************************************************************/


	function createFrame(){
		if(consoleFrame){
			return;
		}
		toggleConsole(true);
		if(dojo.config.popup){
			var containerHeight = "100%";
			var cookieMatch = document.cookie.match(/(?:^|; )_firebugPosition=([^;]*)/);
			var p = cookieMatch ? cookieMatch[1].split(",") : [2,2,320,480];

			_firebugWin = openWin(p[0],p[1],p[2],p[3]);	// global
			_firebugDoc = _firebugWin.document;			// global

			dojo.config.debugContainerId = 'fb';

			// connecting popup
			_firebugWin.console = window.console;
			_firebugWin.dojo = window.dojo;
		}else{
			_firebugDoc = document;
			containerHeight = (dojo.config.debugHeight || 300) + "px";
		}

		var styleElement = _firebugDoc.createElement("link");
		styleElement.href = require.toUrl("./firebug.css");
		styleElement.rel = "stylesheet";
		styleElement.type = "text/css";
		var styleParent = _firebugDoc.getElementsByTagName("head");
		if(styleParent){
			styleParent = styleParent[0];
		}
		if(!styleParent){
			styleParent = _firebugDoc.getElementsByTagName("html")[0];
		}
		if(has("ie")){
			window.setTimeout(function(){ styleParent.appendChild(styleElement); }, 0);
		}else{
			styleParent.appendChild(styleElement);
		}

		if(dojo.config.debugContainerId){
			consoleFrame = _firebugDoc.getElementById(dojo.config.debugContainerId);
		}
		if(!consoleFrame){
			consoleFrame = _firebugDoc.createElement("div");
			_firebugDoc.body.appendChild(consoleFrame);
		}
		consoleFrame.className += " firebug";
		consoleFrame.id = "firebug";
		consoleFrame.style.height = containerHeight;
		consoleFrame.style.display = (frameVisible ? "block" : "none");

		var buildLink = function(label, title, method, _class){
			return '<li class="'+_class+'"><a href="javascript:void(0);" onclick="console.'+ method +'(); return false;" title="'+title+'">'+label+'</a></li>';
		};
		consoleFrame.innerHTML =
			  '<div id="firebugToolbar">'
			+ '  <ul id="fireBugTabs" class="tabs">'

			+ buildLink("Clear", "Remove All Console Logs", "clear", "")
			+ buildLink("ReCSS", "Refresh CSS without reloading page", "recss", "")

			+ buildLink("Console", "Show Console Logs", "openConsole", "gap")
			+ buildLink("DOM", "Show DOM Inspector", "openDomInspector", "")
			+ buildLink("Object", "Show Object Inspector", "openObjectInspector", "")
			+ ((dojo.config.popup) ? "" : buildLink("Close", "Close the console", "close", "gap"))

			+ '	</ul>'
			+ '</div>'
			+ '<input type="text" id="firebugCommandLine" />'
			+ '<div id="firebugLog"></div>'
			+ '<div id="objectLog" style="display:none;">Click on an object in the Log display</div>'
			+ '<div id="domInspect" style="display:none;">Hover over HTML elements in the main page. Click to hold selection.</div>';


		consoleToolbar = _firebugDoc.getElementById("firebugToolbar");

		commandLine = _firebugDoc.getElementById("firebugCommandLine");
		addEvent(commandLine, "keydown", onCommandLineKeyDown);

		addEvent(_firebugDoc, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);

		consoleBody = _firebugDoc.getElementById("firebugLog");
		consoleObjectInspector = _firebugDoc.getElementById("objectLog");
		consoleDomInspector = _firebugDoc.getElementById("domInspect");
		fireBugTabs = _firebugDoc.getElementById("fireBugTabs");
		layout();
		flush();
	}

	dojo.addOnLoad(createFrame);

	function clearFrame(){
		_firebugDoc = null;

		if(_firebugWin.console){
			_firebugWin.console.clear();
		}
		_firebugWin = null;
		consoleFrame = null;
		consoleBody = null;
		consoleObjectInspector = null;
		consoleDomInspector = null;
		commandLine = null;
		messageQueue = [];
		groupStack = [];
		timeMap = {};
	}


	function evalCommandLine(){
		var text = commandLine.value;
		commandLine.value = "";

		logRow([">  ", text], "command");

		var value;
		try{
			value = eval(text);
		}catch(e){
			console.debug(e); // put exception on the console
		}

		console.log(value);
	}

	function layout(h){
		var tHeight = 25; //consoleToolbar.offsetHeight; // tab style not ready on load - throws off layout
		var height = h ?
			h  - (tHeight + commandLine.offsetHeight +25 + (h*.01)) + "px" :
			(consoleFrame.offsetHeight - tHeight - commandLine.offsetHeight) + "px";

		consoleBody.style.top = tHeight + "px";
		consoleBody.style.height = height;
		consoleObjectInspector.style.height = height;
		consoleObjectInspector.style.top = tHeight + "px";
		consoleDomInspector.style.height = height;
		consoleDomInspector.style.top = tHeight + "px";
		commandLine.style.bottom = 0;

		dojo.addOnWindowUnload(clearFrame);
	}

	function logRow(message, className, handler){
		if(consoleBody){
			writeMessage(message, className, handler);
		}else{
			messageQueue.push([message, className, handler]);
		}
	}

	function flush(){
		var queue = messageQueue;
		messageQueue = [];

		for(var i = 0; i < queue.length; ++i){
			writeMessage(queue[i][0], queue[i][1], queue[i][2]);
		}
	}

	function writeMessage(message, className, handler){
		var isScrolledToBottom =
			consoleBody.scrollTop + consoleBody.offsetHeight >= consoleBody.scrollHeight;

		handler = handler||writeRow;

		handler(message, className);

		if(isScrolledToBottom){
			consoleBody.scrollTop = consoleBody.scrollHeight - consoleBody.offsetHeight;
		}
	}

	function appendRow(row){
		var container = groupStack.length ? groupStack[groupStack.length-1] : consoleBody;
		container.appendChild(row);
	}

	function writeRow(message, className){
		var row = consoleBody.ownerDocument.createElement("div");
		row.className = "logRow" + (className ? " logRow-"+className : "");
		row.innerHTML = message.join("");
		appendRow(row);
	}

	function pushGroup(message, className){
		logFormatted(message, className);

		//var groupRow = consoleBody.ownerDocument.createElement("div");
		//groupRow.className = "logGroup";
		var groupRowBox = consoleBody.ownerDocument.createElement("div");
		groupRowBox.className = "logGroupBox";
		//groupRow.appendChild(groupRowBox);
		appendRow(groupRowBox);
		groupStack.push(groupRowBox);
	}

	function popGroup(){
		groupStack.pop();
	}

	// ***************************************************************************

	function logFormatted(objects, className){
		var html = [];

		var format = objects[0];
		var objIndex = 0;

		if(typeof(format) != "string"){
			format = "";
			objIndex = -1;
		}

		var parts = parseFormat(format);

		for(var i = 0; i < parts.length; ++i){
			var part = parts[i];
			if(part && typeof part == "object"){
				part.appender(objects[++objIndex], html);
			}else{
				appendText(part, html);
			}
		}


		var ids = [];
		var obs = [];
		for(i = objIndex+1; i < objects.length; ++i){
			appendText(" ", html);

			var object = objects[i];
			if(object === undefined || object === null ){
				appendNull(object, html);

			}else if(typeof(object) == "string"){
				appendText(object, html);

			}else if(object instanceof Date){
				appendText(object.toString(), html);

			}else if(object.nodeType == 9){
				appendText("[ XmlDoc ]", html);

			}else{
				// Create link for object inspector
				// need to create an ID for this link, since it is currently text
				var id = "_a" + __consoleAnchorId__++;
				ids.push(id);
				// need to save the object, so the arrays line up
				obs.push(object);
				var str = '<a id="'+id+'" href="javascript:void(0);">'+getObjectAbbr(object)+'</a>';

				appendLink( str , html);
			}
		}

		logRow(html, className);

		// Now that the row is inserted in the DOM, loop through all of the links that were just created
		for(i=0; i<ids.length; i++){
			var btn = _firebugDoc.getElementById(ids[i]);
			if(!btn){ continue; }

			// store the object in the dom btn for reference later
			// avoid parsing these objects unless necessary
			btn.obj = obs[i];

			_firebugWin.console._connects.push(dojo.connect(btn, "onclick", function(){

				console.openObjectInspector();

				try{
					printObject(this.obj);
				}catch(e){
					this.obj = e;
				}
				consoleObjectInspector.innerHTML = "<pre>" + printObject( this.obj ) + "</pre>";
			}));
		}
	}

	function parseFormat(format){
		var parts = [];

		var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;
		var appenderMap = {s: appendText, d: appendInteger, i: appendInteger, f: appendFloat};

		for(var m = reg.exec(format); m; m = reg.exec(format)){
			var type = m[8] ? m[8] : m[5];
			var appender = type in appenderMap ? appenderMap[type] : appendObject;
			var precision = m[3] ? parseInt(m[3]) : (m[4] == "." ? -1 : 0);

			parts.push(format.substr(0, m[0][0] == "%" ? m.index : m.index+1));
			parts.push({appender: appender, precision: precision});

			format = format.substr(m.index+m[0].length);
		}

		parts.push(format);

		return parts;
	}

	function escapeHTML(value){
		function replaceChars(ch){
			switch(ch){
				case "<":
					return "&lt;";
				case ">":
					return "&gt;";
				case "&":
					return "&amp;";
				case "'":
					return "&#39;";
				case '"':
					return "&quot;";
			}
			return "?";
		}
		return String(value).replace(/[<>&"']/g, replaceChars);
	}

	function objectToString(object){
		try{
			return object+"";
		}catch(e){
			return null;
		}
	}

	// ***************************************************************************
	function appendLink(object, html){
		// needed for object links - no HTML escaping
		html.push( objectToString(object) );
	}

	function appendText(object, html){
		html.push(escapeHTML(objectToString(object)));
	}

	function appendNull(object, html){
		html.push('<span class="objectBox-null">', escapeHTML(objectToString(object)), '</span>');
	}

	function appendString(object, html){
		html.push('<span class="objectBox-string">&quot;', escapeHTML(objectToString(object)),
			'&quot;</span>');
	}

	function appendInteger(object, html){
		html.push('<span class="objectBox-number">', escapeHTML(objectToString(object)), '</span>');
	}

	function appendFloat(object, html){
		html.push('<span class="objectBox-number">', escapeHTML(objectToString(object)), '</span>');
	}

	function appendFunction(object, html){
		html.push('<span class="objectBox-function">', getObjectAbbr(object), '</span>');
	}

	function appendObject(object, html){
		try{
			if(object === undefined){
				appendNull("undefined", html);
			}else if(object === null){
				appendNull("null", html);
			}else if(typeof object == "string"){
				appendString(object, html);
			}else if(typeof object == "number"){
				appendInteger(object, html);
			}else if(typeof object == "function"){
				appendFunction(object, html);
			}else if(object.nodeType == 1){
				appendSelector(object, html);
			}else if(typeof object == "object"){
				appendObjectFormatted(object, html);
			}else{
				appendText(object, html);
			}
		}catch(e){
			/* squelch */
		}
	}

	function appendObjectFormatted(object, html){
		var text = objectToString(object);
		var reObject = /\[object (.*?)\]/;

		var m = reObject.exec(text);
		html.push('<span class="objectBox-object">', m ? m[1] : text, '</span>');
	}

	function appendSelector(object, html){
		html.push('<span class="objectBox-selector">');

		html.push('<span class="selectorTag">', escapeHTML(object.nodeName.toLowerCase()), '</span>');
		if(object.id){
			html.push('<span class="selectorId">#', escapeHTML(object.id), '</span>');
		}
		if(object.className){
			html.push('<span class="selectorClass">.', escapeHTML(object.className), '</span>');
		}

		html.push('</span>');
	}

	function appendNode(node, html){
		if(node.nodeType == 1){
			html.push(
				'<div class="objectBox-element">',
					'&lt;<span class="nodeTag">', node.nodeName.toLowerCase(), '</span>');

			for(var i = 0; i < node.attributes.length; ++i){
				var attr = node.attributes[i];
				if(!attr.specified){ continue; }

				html.push('&nbsp;<span class="nodeName">', attr.nodeName.toLowerCase(),
					'</span>=&quot;<span class="nodeValue">', escapeHTML(attr.nodeValue),
					'</span>&quot;');
			}

			if(node.firstChild){
				html.push('&gt;</div><div class="nodeChildren">');

				for(var child = node.firstChild; child; child = child.nextSibling){
					appendNode(child, html);
				}

				html.push('</div><div class="objectBox-element">&lt;/<span class="nodeTag">',
					node.nodeName.toLowerCase(), '&gt;</span></div>');
			}else{
				html.push('/&gt;</div>');
			}
		}else if (node.nodeType == 3){
			html.push('<div class="nodeText">', escapeHTML(node.nodeValue),
				'</div>');
		}
	}

	// ***************************************************************************

	function addEvent(object, name, handler){
		if(document.all){
			object.attachEvent("on"+name, handler);
		}else{
			object.addEventListener(name, handler, false);
		}
	}

	function removeEvent(object, name, handler){
		if(document.all){
			object.detachEvent("on"+name, handler);
		}else{
			object.removeEventListener(name, handler, false);
		}
	}

	function cancelEvent(event){
		if(document.all){
			event.cancelBubble = true;
		}else{
			event.stopPropagation();
		}
	}

	function onError(msg, href, lineNo){
		var lastSlash = href.lastIndexOf("/");
		var fileName = lastSlash == -1 ? href : href.substr(lastSlash+1);

		var html = [
			'<span class="errorMessage">', msg, '</span>',
			'<div class="objectBox-sourceLink">', fileName, ' (line ', lineNo, ')</div>'
		];

		logRow(html, "error");
	}


	//After converting to div instead of iframe, now getting two keydowns right away in IE 6.
	//Make sure there is a little bit of delay.
	var onKeyDownTime = new Date().getTime();

	function onKeyDown(event){
		var timestamp = (new Date()).getTime();
		if(timestamp > onKeyDownTime + 200){
			event = dojo.fixEvent(event);
			var keys = dojo.keys;
			var ekc = event.keyCode;
			onKeyDownTime = timestamp;
			if(ekc == keys.F12){
				toggleConsole();
			}else if(
				(ekc == keys.NUMPAD_ENTER || ekc == 76) &&
				event.shiftKey &&
				(event.metaKey || event.ctrlKey)
			){
				focusCommandLine();
			}else{
				return;
			}
			cancelEvent(event);
		}
	}

	function onCommandLineKeyDown(e){
		var dk = dojo.keys;
		if(e.keyCode == 13 && commandLine.value){
			addToHistory(commandLine.value);
			evalCommandLine();
		}else if(e.keyCode == 27){
			commandLine.value = "";
		}else if(e.keyCode == dk.UP_ARROW || e.charCode == dk.UP_ARROW){
			navigateHistory("older");
		}else if(e.keyCode == dk.DOWN_ARROW || e.charCode == dk.DOWN_ARROW){
			navigateHistory("newer");
		}else if(e.keyCode == dk.HOME || e.charCode == dk.HOME){
			historyPosition = 1;
			navigateHistory("older");
		}else if(e.keyCode == dk.END || e.charCode == dk.END){
			historyPosition = 999999;
			navigateHistory("newer");
		}
	}

	var historyPosition = -1;
	var historyCommandLine = null;

	function addToHistory(value){
		var history = cookie("firebug_history");
		history = (history) ? dojo.fromJson(history) : [];
		var pos = dojo.indexOf(history, value);
		if (pos != -1){
			history.splice(pos, 1);
		}
		history.push(value);
		cookie("firebug_history", dojo.toJson(history), 30);
		while(history.length && !cookie("firebug_history")){
			history.shift();
			cookie("firebug_history", dojo.toJson(history), 30);
		}
		historyCommandLine = null;
		historyPosition = -1;
	}

	function navigateHistory(direction){
		var history = cookie("firebug_history");
		history = (history) ? dojo.fromJson(history) : [];
		if(!history.length){
			return;
		}

		if(historyCommandLine === null){
			historyCommandLine = commandLine.value;
		}

		if(historyPosition == -1){
			historyPosition = history.length;
		}

		if(direction == "older"){
			--historyPosition;
			if(historyPosition < 0){
				historyPosition = 0;
			}
		}else if(direction == "newer"){
			++historyPosition;
			if(historyPosition > history.length){
				historyPosition = history.length;
			}
		}

		if(historyPosition == history.length){
			commandLine.value = historyCommandLine;
			historyCommandLine = null;
		}else{
			commandLine.value = history[historyPosition];
		}
	}

	function cookie(name, value){
		var c = document.cookie;
		if(arguments.length == 1){
			var matches = c.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
			return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
		}else{
			var d = new Date();
			d.setMonth(d.getMonth()+1);
			document.cookie = name + "=" + encodeURIComponent(value) + ((d.toUtcString) ? "; expires=" + d.toUTCString() : "");
		}
	}

	function isArray(it){
		return it && it instanceof Array || typeof it == "array";
	}

	//***************************************************************************************************
	// Print Object Helpers
	function objectLength(o){
		var cnt = 0;
		for(var nm in o){
			cnt++;
		}
		return cnt;
	}

	function printObject(o, i, txt, used){
		// Recursively trace object, indenting to represent depth for display in object inspector
		var ind = " \t";
		txt = txt || "";
		i = i || ind;
		used = used || [];
		var opnCls;

		if(o && o.nodeType == 1){
			var html = [];
			appendNode(o, html);
			return html.join("");
		}

		var br=",\n", cnt = 0, length = objectLength(o);

		if(o instanceof Date){
			return i + o.toString() + br;
		}
		looking:
		for(var nm in o){
			cnt++;
			if(cnt==length){br = "\n";}
			if(o[nm] === window || o[nm] === document){
				// do nothing
			}else if(o[nm] === null){
				txt += i+nm + " : NULL" + br;
			}else if(o[nm] && o[nm].nodeType){
				if(o[nm].nodeType == 1){
					//txt += i+nm + " : < "+o[nm].tagName+" id=\""+ o[nm].id+"\" />" + br;
				}else if(o[nm].nodeType == 3){
					txt += i+nm + " : [ TextNode "+o[nm].data + " ]" + br;
				}

			}else if(typeof o[nm] == "object" && (o[nm] instanceof String || o[nm] instanceof Number || o[nm] instanceof Boolean)){
				txt += i+nm + " : " + o[nm] + "," + br;

			}else if(o[nm] instanceof Date){
				txt += i+nm + " : " + o[nm].toString() + br;

			}else if(typeof(o[nm]) == "object" && o[nm]){
				for(var j = 0, seen; seen = used[j]; j++){
					if(o[nm] === seen){
						txt += i+nm + " : RECURSION" + br;
						continue looking;
					}
				}
				used.push(o[nm]);

				opnCls = (isArray(o[nm]))?["[","]"]:["{","}"];
				txt += i+nm +" : " + opnCls[0] + "\n";//non-standard break, (no comma)
				txt += printObject(o[nm], i+ind, "", used);
				txt += i + opnCls[1] + br;

			}else if(typeof o[nm] == "undefined"){
				txt += i+nm + " : undefined" + br;
			}else if(nm == "toString" && typeof o[nm] == "function"){
				var toString = o[nm]();
				if(typeof toString == "string" && toString.match(/function ?(.*?)\(/)){
					toString = escapeHTML(getObjectAbbr(o[nm]));
				}
				txt += i+nm +" : " + toString + br;
			}else{
				txt += i+nm +" : "+ escapeHTML(getObjectAbbr(o[nm])) + br;
			}
		}
		return txt;
	}

	function getObjectAbbr(obj){
		// Gets an abbreviation of an object for display in log
		// X items in object, including id
		// X items in an array
		// TODO: Firebug Sr. actually goes by char count
		var isError = (obj instanceof Error);
		if(obj.nodeType == 1){
			return escapeHTML('< '+obj.tagName.toLowerCase()+' id=\"'+ obj.id+ '\" />');
		}
		if(obj.nodeType == 3){
			return escapeHTML('[TextNode: "'+obj.nodeValue+'"]');
		}
		var nm = (obj && (obj.id || obj.name || obj.ObjectID || obj.widgetId));
		if(!isError && nm){ return "{"+nm+"}";	}

		var obCnt = 2;
		var arCnt = 4;
		var cnt = 0;

		if(isError){
			nm = "[ Error: "+(obj.message || obj.description || obj)+" ]";
		}else if(isArray(obj)){
			nm = "[" + obj.slice(0,arCnt).join(",");
			if(obj.length > arCnt){
				nm += " ... ("+obj.length+" items)";
			}
			nm += "]";
		}else if(typeof obj == "function"){
			nm = obj + "";
			var reg = /function\s*([^\(]*)(\([^\)]*\))[^\{]*\{/;
			var m = reg.exec(nm);
			if(m){
				if(!m[1]){
					m[1] = "function";
				}
				nm = m[1] + m[2];
			}else{
				nm = "function()";
			}
		}else if(typeof obj != "object" || typeof obj == "string"){
			nm = obj + "";
		}else{
			nm = "{";
			for(var i in obj){
				cnt++;
				if(cnt > obCnt){ break; }
				nm += i+":"+escapeHTML(obj[i])+"  ";
			}
			nm+="}";
		}

		return nm;
	}

	//*************************************************************************************

	//window.onerror = onError;

	addEvent(document, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);

	if(	(document.documentElement.getAttribute("debug") == "true")||
		(dojo.config.isDebug)
	){
		toggleConsole(true);
	}

	dojo.addOnWindowUnload(function(){
		// Erase the globals and event handlers I created, to prevent spurious leak warnings
		removeEvent(document, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);
		window.onFirebugResize = null;
		window.console = null;
	});

});

},
'dojo/fx/easing':function(){
define(["../_base/lang"], function(lang){

// module:
//		dojo/fx/easing

var easingFuncs = {
	// summary:
	//		Collection of easing functions to use beyond the default
	//		`dojo._defaultEasing` function.
	// description:
	//		Easing functions are used to manipulate the iteration through
	//		an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	//		and the easing function progresses through that Line determining
	//		how quickly (or slowly) it should go. Or more accurately: modify
	//		the value of the _Line based on the percentage of animation completed.
	//
	//		All functions follow a simple naming convention of "ease type" + "when".
	//		If the name of the function ends in Out, the easing described appears
	//		towards the end of the animation. "In" means during the beginning,
	//		and InOut means both ranges of the Animation will applied, both
	//		beginning and end.
	//
	//		One does not call the easing function directly, it must be passed to
	//		the `easing` property of an animation.
	// example:
	//	|	dojo.require("dojo.fx.easing");
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',
	//	|		duration: 2000,
	//	|		//	note there is no ()
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//

	linear: function(/* Decimal? */n){
		// summary:
		//		A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; }
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that starts away from the target,
		//		and quickly accelerates towards the end value.
		//
		//		Use caution when the easing will cause values to become
		//		negative as some properties cannot be set to negative values.
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that pops past the range briefly, and slowly comes back.
		// description:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		//		Use caution when the easing will cause values to become negative as some
		//		properties cannot be set to negative values.

		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function combining the effects of `backIn` and `backOut`
		// description:
		//		An easing function combining the effects of `backIn` and `backOut`.
		//		Use caution when the easing will cause values to become negative
		//		as some properties cannot be set to negative values.
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary:
		//		An easing function the elastically snaps from the start value
		// description:
		//		An easing function the elastically snaps from the start value
		//
		//		Use caution when the elasticity will cause values to become negative
		//		as some properties cannot be set to negative values.
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		// description:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		// description:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the beginning of an Animation
		return (1 - easingFuncs.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l;
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' at the beginning and end of the Animation
		if(n < 0.5){ return easingFuncs.bounceIn(n * 2) / 2; }
		return (easingFuncs.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

lang.setObject("dojo.fx.easing", easingFuncs);

return easingFuncs;
});

},
'dojo/hash':function(){
define(["./_base/kernel", "require", "./_base/config", "./aspect", "./_base/lang", "./topic", "./domReady", "./sniff"],
	function(dojo, require, config, aspect, lang, topic, domReady, has){

	// module:
	//		dojo/hash

	dojo.hash = function(/* String? */ hash, /* Boolean? */ replace){
		// summary:
		//		Gets or sets the hash string in the browser URL.
		// description:
		//		Handles getting and setting of location.hash.
		//
		//		 - If no arguments are passed, acts as a getter.
		//		 - If a string is passed, acts as a setter.
		// hash:
		//		the hash is set - #string.
		// replace:
		//		If true, updates the hash value in the current history
		//		state instead of creating a new history state.
		// returns:
		//		when used as a getter, returns the current hash string.
		//		when used as a setter, returns the new hash string.
		// example:
		//	|	topic.subscribe("/dojo/hashchange", context, callback);
		//	|
		//	|	function callback (hashValue){
		//	|		// do something based on the hash value.
		//	|	}

		// getter
		if(!arguments.length){
			return _getHash();
		}
		// setter
		if(hash.charAt(0) == "#"){
			hash = hash.substring(1);
		}
		if(replace){
			_replace(hash);
		}else{
			location.href = "#" + hash;
		}
		return hash; // String
	};

	// Global vars
	var _recentHash, _ieUriMonitor, _connect,
		_pollFrequency = config.hashPollFrequency || 100;

	//Internal functions
	function _getSegment(str, delimiter){
		var i = str.indexOf(delimiter);
		return (i >= 0) ? str.substring(i+1) : "";
	}

	function _getHash(){
		return _getSegment(location.href, "#");
	}

	function _dispatchEvent(){
		topic.publish("/dojo/hashchange", _getHash());
	}

	function _pollLocation(){
		if(_getHash() === _recentHash){
			return;
		}
		_recentHash = _getHash();
		_dispatchEvent();
	}

	function _replace(hash){
		if(_ieUriMonitor){
			if(_ieUriMonitor.isTransitioning()){
				setTimeout(lang.hitch(null,_replace,hash), _pollFrequency);
				return;
			}
			var href = _ieUriMonitor.iframe.location.href;
			var index = href.indexOf('?');
			// main frame will detect and update itself
			_ieUriMonitor.iframe.location.replace(href.substring(0, index) + "?" + hash);
			return;
		}
		location.replace("#"+hash);
		!_connect && _pollLocation();
	}

	function IEUriMonitor(){
		// summary:
		//		Determine if the browser's URI has changed or if the user has pressed the
		//		back or forward button. If so, call _dispatchEvent.
		//
		// description:
		//		IE doesn't add changes to the URI's hash into the history unless the hash
		//		value corresponds to an actual named anchor in the document. To get around
		//		this IE difference, we use a background IFrame to maintain a back-forward
		//		history, by updating the IFrame's query string to correspond to the
		//		value of the main browser location's hash value.
		//
		//		E.g. if the value of the browser window's location changes to
		//
		//		#action=someAction
		//
		//		... then we'd update the IFrame's source to:
		//
		//		?action=someAction
		//
		//		This design leads to a somewhat complex state machine, which is
		//		described below:
		//
		//		####s1
		//
		//		Stable state - neither the window's location has changed nor
		//		has the IFrame's location. Note that this is the 99.9% case, so
		//		we optimize for it.
		//
		//		Transitions: s1, s2, s3
		//
		//		####s2
		//
		//		Window's location changed - when a user clicks a hyperlink or
		//		code programmatically changes the window's URI.
		//
		//		Transitions: s4
		//
		//		####s3
		//
		//		Iframe's location changed as a result of user pressing back or
		//		forward - when the user presses back or forward, the location of
		//		the background's iframe changes to the previous or next value in
		//		its history.
		//
		//		Transitions: s1
		//
		//		####s4
		//
		//		IEUriMonitor has programmatically changed the location of the
		//		background iframe, but it's location hasn't yet changed. In this
		//		case we do nothing because we need to wait for the iframe's
		//		location to reflect its actual state.
		//
		//		Transitions: s4, s5
		//
		//		####s5
		//
		//		IEUriMonitor has programmatically changed the location of the
		//		background iframe, and the iframe's location has caught up with
		//		reality. In this case we need to transition to s1.
		//
		//		Transitions: s1
		//
		//		The hashchange event is always dispatched on the transition back to s1.


		// create and append iframe
		var ifr = document.createElement("iframe"),
			IFRAME_ID = "dojo-hash-iframe",
			ifrSrc = config.dojoBlankHtmlUrl || require.toUrl("./resources/blank.html");

		if(config.useXDomain && !config.dojoBlankHtmlUrl){
			console.warn("dojo/hash: When using cross-domain Dojo builds,"
				+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
				+ " to the path on your domain to blank.html");
		}

		ifr.id = IFRAME_ID;
		ifr.src = ifrSrc + "?" + _getHash();
		ifr.style.display = "none";
		document.body.appendChild(ifr);

		this.iframe = dojo.global[IFRAME_ID];
		var recentIframeQuery, transitioning, expectedIFrameQuery, docTitle, ifrOffline,
			iframeLoc = this.iframe.location;

		function resetState(){
			_recentHash = _getHash();
			recentIframeQuery = ifrOffline ? _recentHash : _getSegment(iframeLoc.href, "?");
			transitioning = false;
			expectedIFrameQuery = null;
		}

		this.isTransitioning = function(){
			return transitioning;
		};

		this.pollLocation = function(){
			if(!ifrOffline){
				try{
					//see if we can access the iframe's location without a permission denied error
					var iframeSearch = _getSegment(iframeLoc.href, "?");
					//good, the iframe is same origin (no thrown exception)
					if(document.title != docTitle){ //sync title of main window with title of iframe.
						docTitle = this.iframe.document.title = document.title;
					}
				}catch(e){
					//permission denied - server cannot be reached.
					ifrOffline = true;
					console.error("dojo/hash: Error adding history entry. Server unreachable.");
				}
			}
			var hash = _getHash();
			if(transitioning && _recentHash === hash){
				// we're in an iframe transition (s4 or s5)
				if(ifrOffline || iframeSearch === expectedIFrameQuery){
					// s5 (iframe caught up to main window or iframe offline), transition back to s1
					resetState();
					_dispatchEvent();
				}else{
					// s4 (waiting for iframe to catch up to main window)
					setTimeout(lang.hitch(this,this.pollLocation),0);
					return;
				}
			}else if(_recentHash === hash && (ifrOffline || recentIframeQuery === iframeSearch)){
				// we're in stable state (s1, iframe query == main window hash), do nothing
			}else{
				// the user has initiated a URL change somehow.
				// sync iframe query <-> main window hash
				if(_recentHash !== hash){
					// s2 (main window location changed), set iframe url and transition to s4
					_recentHash = hash;
					transitioning = true;
					expectedIFrameQuery = hash;
					ifr.src = ifrSrc + "?" + expectedIFrameQuery;
					ifrOffline = false; //we're updating the iframe src - set offline to false so we can check again on next poll.
					setTimeout(lang.hitch(this,this.pollLocation),0); //yielded transition to s4 while iframe reloads.
					return;
				}else if(!ifrOffline){
					// s3 (iframe location changed via back/forward button), set main window url and transition to s1.
					location.href = "#" + iframeLoc.search.substring(1);
					resetState();
					_dispatchEvent();
				}
			}
			setTimeout(lang.hitch(this,this.pollLocation), _pollFrequency);
		};
		resetState(); // initialize state (transition to s1)
		setTimeout(lang.hitch(this,this.pollLocation), _pollFrequency);
	}
	domReady(function(){
		if("onhashchange" in dojo.global && (!has("ie") || (has("ie") >= 8 && document.compatMode != "BackCompat"))){	//need this IE browser test because "onhashchange" exists in IE8 in IE7 mode
			_connect = aspect.after(dojo.global,"onhashchange",_dispatchEvent, true);
		}else{
			if(document.addEventListener){ // Non-IE
				_recentHash = _getHash();
				setInterval(_pollLocation, _pollFrequency); //Poll the window location for changes
			}else if(document.attachEvent){ // IE7-
				//Use hidden iframe in versions of IE that don't have onhashchange event
				_ieUriMonitor = new IEUriMonitor();
			}
			// else non-supported browser, do nothing.
		}
	});

	return dojo.hash;

});

},
'dojo/io/iframe':function(){
define([
	"../_base/config", "../_base/json", "../_base/kernel", /*===== "../_base/declare", =====*/ "../_base/lang",
	"../_base/xhr", "../sniff", "../_base/window",
	"../dom", "../dom-construct", "../query", "require", "../aspect", "../request/iframe"
], function(config, json, kernel, /*===== declare, =====*/ lang, xhr, has, win, dom, domConstruct, query, require, aspect, _iframe){

// module:
//		dojo/io/iframe

kernel.deprecated("dojo/io/iframe", "Use dojo/request/iframe.", "2.0");

/*=====
var __ioArgs = declare(kernel.__IoArgs, {
	// method: String?
	//		The HTTP method to use. "GET" or "POST" are the only supported
	//		values.  It will try to read the value from the form node's
	//		method, then try this argument. If neither one exists, then it
	//		defaults to POST.
	// handleAs: String?
	//		Specifies what format the result data should be given to the
	//		load/handle callback. Valid values are: text, html, xml, json,
	//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
	//		server response should be an HTML file with a textarea element.
	//		The response data should be inside the textarea element. Using an
	//		HTML document the only reliable, cross-browser way this
	//		transport can know when the response has loaded. For the html
	//		handleAs value, just return a normal HTML document.  NOTE: xml
	//		is now supported with this transport (as of 1.1+); a known issue
	//		is if the XML document in question is malformed, Internet Explorer
	//		will throw an uncatchable error.
	// content: Object?
	//		If "form" is one of the other args properties, then the content
	//		object properties become hidden form form elements. For
	//		instance, a content object of {name1 : "value1"} is converted
	//		to a hidden form element with a name of "name1" and a value of
	//		"value1". If there is not a "form" property, then the content
	//		object is converted into a name=value&name=value string, by
	//		using xhr.objectToQuery().
});
=====*/

/*=====
return kernel.io.iframe = {
	// summary:
	//		Deprecated, use dojo/request/iframe instead.
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)

	create: function(fname, onloadstr, uri){
		// summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo/io/iframe request. Just call send().
		// fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		// onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		// uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
	},
	setSrc: function(iframe, src, replace){
		// summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
	},
	doc: function(iframeNode){
		// summary:
		//		Returns the document object associated with the iframe DOM Node argument.
	}
};
=====*/


var mid = _iframe._iframeName;
mid = mid.substring(0, mid.lastIndexOf('_'));

var iframe = lang.delegate(_iframe, {
	// summary:
	//		Deprecated, use dojo/request/iframe instead.
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)

	create: function(){
		return iframe._frame = _iframe.create.apply(_iframe, arguments);
	},

	// cover up delegated methods
	get: null,
	post: null,

	send: function(/*__ioArgs*/args){
		// summary:
		//		Function that sends the request to the server.
		//		This transport can only process one send() request at a time, so if send() is called
		//		multiple times, it will queue up the calls and only process one at a time.
		var rDfd;

		//Set up the deferred.
		var dfd = xhr._ioSetArgs(args,
			function(/*Deferred*/dfd){
				// summary:
				//		canceller function for xhr._ioSetArgs call.
				rDfd && rDfd.cancel();
			},
			function(/*Deferred*/dfd){
				// summary:
				//		okHandler function for xhr._ioSetArgs call.
				var value = null,
					ioArgs = dfd.ioArgs;
				try{
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					if(handleAs === "xml" || handleAs === "html"){
						value = rDfd.response.data;
					}else{
						value = rDfd.response.text;
						if(handleAs === "json"){
							value = json.fromJson(value);
						}else if(handleAs === "javascript"){
							value = kernel.eval(value);
						}
					}
				}catch(e){
					value = e;
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				// summary:
				//		errHandler function for xhr._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				return error;
			}
		);

		var ioArgs = dfd.ioArgs;

		var method = "GET",
			form = dom.byId(args.form);
		if(args.method && args.method.toUpperCase() === "POST" && form){
			method = "POST";
		}

		var options = {
			method: method,
			handleAs: args.handleAs === "json" || args.handleAs === "javascript" ? "text" : args.handleAs,
			form: args.form,
			query: form ? null : args.content,
			data: form ? args.content : null,
			timeout: args.timeout,
			ioArgs: ioArgs
		};

		if(options.method){
			options.method = options.method.toUpperCase();
		}

		if(config.ioPublish && kernel.publish && ioArgs.args.ioPublish !== false){
			var start = aspect.after(_iframe, "_notifyStart", function(data){
				if(data.options.ioArgs === ioArgs){
					start.remove();
					xhr._ioNotifyStart(dfd);
				}
			}, true);
		}
		rDfd = _iframe(ioArgs.url, options, true);

		ioArgs._callNext = rDfd._callNext;

		rDfd.then(function(){
			dfd.resolve(dfd);
		}).otherwise(function(error){
			dfd.ioArgs.error = error;
			dfd.reject(error);
		});

		return dfd;
	},

	_iframeOnload: win.global[mid + '_onload']
});

lang.setObject("dojo.io.iframe", iframe);

return iframe;
});

},
'dojo/request/iframe':function(){
define([
	'module',
	'require',
	'./watch',
	'./util',
	'./handlers',
	'../_base/lang',
	'../io-query',
	'../query',
	'../has',
	'../dom',
	'../dom-construct',
	'../_base/window',
	'../NodeList-dom'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, require, watch, util, handlers, lang, ioQuery, query, has, dom, domConstruct, win/*=====, NodeList, request, declare =====*/){
	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		onload = mid + '_onload';

	if(!win.global[onload]){
		win.global[onload] = function(){
			var dfd = iframe._currentDfd;
			if(!dfd){
				iframe._fireNextRequest();
				return;
			}

			var response = dfd.response,
				options = response.options,
				formNode = dom.byId(options.form) || dfd._tmpForm;

			if(formNode){
				// remove all the hidden content inputs
				var toClean = dfd._contentToClean;
				for(var i=0; i<toClean.length; i++){
					var key = toClean[i];
					//Need to cycle over all nodes since we may have added
					//an array value which means that more than one node could
					//have the same .name value.
					for(var j=0; j<formNode.childNodes.length; j++){
						var childNode = formNode.childNodes[j];
						if(childNode.name === key){
							domConstruct.destroy(childNode);
							break;
						}
					}
				}

				// restore original action + target
				dfd._originalAction && formNode.setAttribute('action', dfd._originalAction);
				if(dfd._originalMethod){
					formNode.setAttribute('method', dfd._originalMethod);
					formNode.method = dfd._originalMethod;
				}
				if(dfd._originalTarget){
					formNode.setAttribute('target', dfd._originalTarget);
					formNode.target = dfd._originalTarget;
				}
			}

			if(dfd._tmpForm){
				domConstruct.destroy(dfd._tmpForm);
				delete dfd._tmpForm;
			}

			dfd._finished = true;
		};
	}

	function create(name, onloadstr, uri){
		if(win.global[name]){
			return win.global[name];
		}

		if(win.global.frames[name]){
			return win.global.frames[name];
		}

		if(!uri){
			if(has('config-useXDomain') && !has('config-dojoBlankHtmlUrl')){
				console.warn('dojo/request/iframe: When using cross-domain Dojo builds,' +
					' please save dojo/resources/blank.html to your domain and set dojoConfig.dojoBlankHtmlUrl' +
					' to the path on your domain to blank.html');
			}
			uri = (has('config-dojoBlankHtmlUrl')||require.toUrl('dojo/resources/blank.html'));
		}

		var frame = domConstruct.place(
			'<iframe id="'+name+'" name="'+name+'" src="'+uri+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
			win.body());

		win.global[name] = frame;

		return frame;
	}

	function setSrc(_iframe, src, replace){
		var frame = win.global.frames[_iframe.name];

		if(frame.contentWindow){
			// We have an iframe node instead of the window
			frame = frame.contentWindow;
		}

		try{
			if(!replace){
				frame.location = src;
			}else{
				frame.location.replace(src);
			}
		}catch(e){
			console.log('dojo/request/iframe.setSrc: ', e);
		}
	}

	function doc(iframeNode){
		if(iframeNode.contentDocument){
			return iframeNode.contentDocument;
		}
		var name = iframeNode.name;
		if(name){
			var iframes = win.doc.getElementsByTagName('iframe');
			if(iframeNode.document && iframes[name].contentWindow && iframes[name].contentWindow.document){
				return iframes[name].contentWindow.document;
			}else if(win.doc.frames[name] && win.doc.frames[name].document){
				return win.doc.frames[name].document;
			}
		}
		return null;
	}

	function createForm(){
		return domConstruct.create('form', {
			name: mid + '_form',
			style: {
				position: 'absolute',
				top: '-1000px',
				left: '-1000px'
			}
		}, win.body());
	}

	function fireNextRequest(){
		// summary:
		//		Internal method used to fire the next request in the queue.
		var dfd;
		try{
			if(iframe._currentDfd || !iframe._dfdQueue.length){
				return;
			}
			do{
				dfd = iframe._currentDfd = iframe._dfdQueue.shift();
			}while(dfd && (dfd.canceled || (dfd.isCanceled && dfd.isCanceled())) && iframe._dfdQueue.length);

			if(!dfd || dfd.canceled || (dfd.isCanceled && dfd.isCanceled())){
				iframe._currentDfd = null;
				return;
			}

			var response = dfd.response,
				options = response.options,
				c2c = dfd._contentToClean = [],
				formNode = dom.byId(options.form),
				notify = util.notify,
				data = options.data || null,
				queryStr;

			if(!dfd._legacy && options.method === 'POST' && !formNode){
				formNode = dfd._tmpForm = createForm();
			}else if(options.method === 'GET' && formNode && response.url.indexOf('?') > -1){
				queryStr = response.url.slice(response.url.indexOf('?') + 1);
				data = lang.mixin(ioQuery.queryToObject(queryStr), data);
			}

			if(formNode){
				if(!dfd._legacy){
					var parentNode = formNode;
					do{
						parentNode = parentNode.parentNode;
					}while(parentNode && parentNode !== win.doc.documentElement);

					// Append the form node or some browsers won't work
					if(!parentNode){
						formNode.style.position = 'absolute';
						formNode.style.left = '-1000px';
						formNode.style.top = '-1000px';
						win.body().appendChild(formNode);
					}

					if(!formNode.name){
						formNode.name = mid + '_form';
					}
				}

				// if we have things in data, we need to add them to the form
				// before submission
				if(data){
					var createInput = function(name, value){
						domConstruct.create('input', {
							type: 'hidden',
							name: name,
							value: value
						}, formNode);
						c2c.push(name);
					};
					for(var x in data){
						var val = data[x];
						if(lang.isArray(val) && val.length > 1){
							for(var i=0; i<val.length; i++){
								createInput(x, val[i]);
							}
						}else{
							if(!formNode[x]){
								createInput(x, val);
							}else{
								formNode[x].value = val;
							}
						}
					}
				}

				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actionNode = formNode.getAttributeNode('action'),
					methodNode = formNode.getAttributeNode('method'),
					targetNode = formNode.getAttributeNode('target');

				if(response.url){
					dfd._originalAction = actionNode ? actionNode.value : null;
					if(actionNode){
						actionNode.value = response.url;
					}else{
						formNode.setAttribute('action', response.url);
					}
				}

				if(!dfd._legacy){
					dfd._originalMethod = methodNode ? methodNode.value : null;
					if(methodNode){
						methodNode.value = options.method;
					}else{
						formNode.setAttribute('method', options.method);
					}
				}else{
					if(!methodNode || !methodNode.value){
						if(methodNode){
							methodNode.value = options.method;
						}else{
							formNode.setAttribute('method', options.method);
						}
					}
				}

				dfd._originalTarget = targetNode ? targetNode.value : null;
				if(targetNode){
					targetNode.value = iframe._iframeName;
				}else{
					formNode.setAttribute('target', iframe._iframeName);
				}
				formNode.target = iframe._iframeName;

				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				formNode.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe

				var extra = '';
				if(response.options.data){
					extra = response.options.data;
					if(typeof extra !== 'string'){
						extra = ioQuery.objectToQuery(extra);
					}
				}
				var tmpUrl = response.url + (response.url.indexOf('?') > -1 ? '&' : '?') + extra;
				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				iframe.setSrc(iframe._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.reject(e);
		}
	}

	// dojo/request/watch handlers
	function isValid(response){
		return !this.isFulfilled();
	}
	function isReady(response){
		return !!this._finished;
	}
	function handleResponse(response, error){
		if(!error){
			try{
				var options = response.options,
					doc = iframe.doc(iframe._frame),
					handleAs = options.handleAs;

				if(handleAs !== 'html'){
					if(handleAs === 'xml'){
						// IE6-8 have to parse the XML manually. See http://bugs.dojotoolkit.org/ticket/6334
						if(doc.documentElement.tagName.toLowerCase() === 'html'){
							query('a', doc.documentElement).orphan();
							var xmlText = doc.documentElement.innerText;
							xmlText = xmlText.replace(/>\s+</g, '><');
							response.text = lang.trim(xmlText);
						}else{
							response.data = doc;
						}
					}else{
						// 'json' and 'javascript' and 'text'
						response.text = doc.getElementsByTagName('textarea')[0].value; // text
					}
					handlers(response);
				}else{
					response.data = doc;
				}
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(this._finished){
			this.resolve(response);
		}else{
			this.reject(new Error('Invalid dojo/request/iframe request state'));
		}
	}
	function last(response){
		this._callNext();
	}

	var defaultOptions = {
		method: 'POST'
	};
	function iframe(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), true);
		url = response.url;
		options = response.options;

		if(options.method !== 'GET' && options.method !== 'POST'){
			throw new Error(options.method + ' not supported by dojo/request/iframe');
		}

		if(!iframe._frame){
			iframe._frame = iframe.create(iframe._iframeName, onload + '();');
		}

		var dfd = util.deferred(response, null, isValid, isReady, handleResponse, last);
		dfd._callNext = function(){
			if(!this._calledNext){
				this._calledNext = true;
				iframe._currentDfd = null;
				iframe._fireNextRequest();
			}
		};
		dfd._legacy = returnDeferred;

		iframe._dfdQueue.push(dfd);
		iframe._fireNextRequest();

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	iframe = function(url, options){
		// summary:
		//		Sends a request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.__BaseOptions = declare(request.__BaseOptions, {
		// form: DOMNode?
		//		A form node to use to submit data to the server.
		// data: String|Object?
		//		Data to transfer. When making a GET request, this will
		//		be converted to key=value parameters and appended to the
		//		URL.
	});
	iframe.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Only `"GET"` and `"POST"` are accepted.
		//		Default is `"POST"`.
	});
	iframe.__Options = declare([iframe.__BaseOptions, iframe.__MethodOptions]);

	iframe.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	iframe.create = create;
	iframe.doc = doc;
	iframe.setSrc = setSrc;

	// TODO: Make these truly private in 2.0
	iframe._iframeName = mid + '_IoIframe';
	iframe._notifyStart = function(){};
	iframe._dfdQueue = [];
	iframe._currentDfd = null;
	iframe._fireNextRequest = fireNextRequest;

	util.addCommonMethods(iframe, ['GET', 'POST']);

	return iframe;
});

},
'dojo/io/script':function(){
define([
	"../_base/connect", /*===== "../_base/declare", =====*/ "../_base/kernel", "../_base/lang",
	"../sniff", "../_base/window","../_base/xhr",
	"../dom", "../dom-construct", "../request/script", "../aspect"
], function(connect, /*===== declare, =====*/ kernel, lang, has, win, xhr, dom, domConstruct, _script, aspect){

	// module:
	//		dojo/io/script

	kernel.deprecated("dojo/io/script", "Use dojo/request/script.", "2.0");

	/*=====
	var __ioArgs = declare(kernel.__IoArgs, {
		// summary:
		//		All the properties described in the dojo.__ioArgs type, apply to this
		//		type as well, EXCEPT "handleAs". It is not applicable to
		//		dojo/io/script.get() calls, since it is implied by the usage of
		//		"jsonp" (response will be a JSONP call returning JSON)
		//		or the response is pure JavaScript defined in
		//		the body of the script that was attached.
		// callbackParamName: String
		//		Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported for
		//		legacy code. See notes for jsonp property.
		// jsonp: String
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		// checkString: String
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use callbackParamName instead).
		// frameDoc: Document
		//		The Document object for a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
	});
	=====*/

	var script = {
		// summary:
		//		TODOC

		get: function(/*__ioArgs*/ args){
			// summary:
			//		sends a get request using a dynamically created script tag.
			var rDfd;
			var dfd = this._makeScriptDeferred(args, function(dfd){
				rDfd && rDfd.cancel();
			});
			var ioArgs = dfd.ioArgs;
			xhr._ioAddQueryToUrl(ioArgs);

			xhr._ioNotifyStart(dfd);

			rDfd = _script.get(ioArgs.url, {
				timeout: args.timeout,
				jsonp: ioArgs.jsonp,
				checkString: args.checkString,
				ioArgs: ioArgs,
				frameDoc: args.frameDoc,
				canAttach: function(rDfd){
					// sync values
					ioArgs.requestId = rDfd.id;
					ioArgs.scriptId = rDfd.scriptId;
					ioArgs.canDelete = rDfd.canDelete;

					return script._canAttach(ioArgs);
				}
			}, true);

			// Run _validCheck at the same time dojo/request/watch runs the
			// rDfd.isValid function
			aspect.around(rDfd, "isValid", function(isValid){
				return function(response){
					script._validCheck(dfd);
					return isValid.call(this, response);
				};
			});

			rDfd.then(function(){
				dfd.resolve(dfd);
			}).otherwise(function(error){
				dfd.ioArgs.error = error;
				dfd.reject(error);
			});

			return dfd;
		},

		attach: _script._attach,
		remove: _script._remove,

		_makeScriptDeferred: function(/*Object*/ args, /*Function?*/ cancel){
			// summary:
			//		sets up a Deferred object for an IO request.
			var dfd = xhr._ioSetArgs(args, cancel || this._deferredCancel, this._deferredOk, this._deferredError);

			var ioArgs = dfd.ioArgs;
			ioArgs.id = kernel._scopeName + "IoScript" + (this._counter++);
			ioArgs.canDelete = false;

			//Special setup for jsonp case
			ioArgs.jsonp = args.callbackParamName || args.jsonp;
			if(ioArgs.jsonp){
				//Add the jsonp parameter.
				ioArgs.query = ioArgs.query || "";
				if(ioArgs.query.length > 0){
					ioArgs.query += "&";
				}
				ioArgs.query += ioArgs.jsonp +
					"=" + (args.frameDoc ? "parent." : "") +
					kernel._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";

				ioArgs.frameDoc = args.frameDoc;

				//Setup the Deferred to have the jsonp callback.
				ioArgs.canDelete = true;
				dfd._jsonpCallback = this._jsonpCallback;
				this["jsonp_" + ioArgs.id] = dfd;
			}
			// Make sure this runs no matter what happens to clean things up if need be
			dfd.addBoth(function(value){
				if(ioArgs.canDelete){
					if(value instanceof Error){
						// Set up a callback that will clean things up for timeouts and cancels
						script["jsonp_" + ioArgs.id]._jsonpCallback = function(){
							// Delete the cached deferred
							delete script["jsonp_" + ioArgs.id];
							if(ioArgs.requestId){
								// Call the dojo/request/script callback to clean itself up as well
								kernel.global[_script._callbacksProperty][ioArgs.requestId]();
							}
						};
					}else{
						script._addDeadScript(ioArgs);
					}
				}
			});
			return dfd; // dojo/_base/Deferred
		},

		_deferredCancel: function(/*Deferred*/ dfd){
			// summary:
			//		canceller function for xhr._ioSetArgs call.

			//DO NOT use "this" and expect it to be script.
			dfd.canceled = true;
		},

		_deferredOk: function(/*Deferred*/ dfd){
			// summary:
			//		okHandler function for xhr._ioSetArgs call.

			//DO NOT use "this" and expect it to be script.
			var ioArgs = dfd.ioArgs;

			//Favor JSONP responses, script load events then lastly ioArgs.
			//The ioArgs are goofy, but cannot return the dfd since that stops
			//the callback chain in Deferred. The return value is not that important
			//in that case, probably a checkString case.
			return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
		},

		_deferredError: function(/*Error*/ error, /*Deferred*/ dfd){
			// summary:
			//		errHandler function for xhr._ioSetArgs call.

			console.log("dojo.io.script error", error);
			return error;
		},

		_deadScripts: [],
		_counter: 1,

		_addDeadScript: function(/*Object*/ ioArgs){
			// summary:
			//		sets up an entry in the deadScripts array.
			script._deadScripts.push({id: ioArgs.id, frameDoc: ioArgs.frameDoc});
			//Being extra paranoid about leaks:
			ioArgs.frameDoc = null;
		},

		_validCheck: function(/*Deferred*/ dfd){
			// summary:
			//		inflight check function to see if dfd is still valid.

			// TODO: why isn't dfd accessed?

			//Do script cleanup here. We wait for one inflight pass
			//to make sure we don't get any weird things by trying to remove a script
			//tag that is part of the call chain (IE 6 has been known to
			//crash in that case).
			var deadScripts = script._deadScripts;
			if(deadScripts && deadScripts.length > 0){
				for(var i = 0; i < deadScripts.length; i++){
					//Remove the script tag
					script.remove(deadScripts[i].id, deadScripts[i].frameDoc);
					//Clean up the deferreds
					delete script["jsonp_" + deadScripts[i].id];
					deadScripts[i].frameDoc = null;
				}
				script._deadScripts = [];
			}

			return true;
		},

		_ioCheck: function(dfd){
			// summary:
			//		inflight check function to see if IO finished.
			// dfd: Deferred
			var ioArgs = dfd.ioArgs;
			//Check for finished jsonp
			if(ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)){
				return true;
			}

			//Check for finished "checkString" case.
			var checkString = ioArgs.args.checkString;
			return checkString && eval("typeof(" + checkString + ") != 'undefined'");


		},

		_resHandle: function(/*Deferred*/ dfd){
			// summary:
			//		inflight function to handle a completed response.
			if(script._ioCheck(dfd)){
				dfd.callback(dfd);
			}else{
				//This path should never happen since the only way we can get
				//to _resHandle is if _ioCheck is true.
				dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
			}
		},

		_canAttach: function(/*===== ioArgs =====*/ ){
			// summary:
			//		A method that can be overridden by other modules
			//		to control when the script attachment occurs.
			// ioArgs: Object
			return true;
		},

		_jsonpCallback: function(/*JSON Object*/ json){
			// summary:
			//		generic handler for jsonp callback. A pointer to this function
			//		is used for all jsonp callbacks.  NOTE: the "this" in this
			//		function will be the Deferred object that represents the script
			//		request.
			this.ioArgs.json = json;
			if(this.ioArgs.requestId){
				kernel.global[_script._callbacksProperty][this.ioArgs.requestId](json);
			}
		}
	};

	lang.setObject("dojo.io.script", script);

	/*=====
	script.attach = function(id, url, frameDocument){
		// summary:
		//		creates a new `<script>` tag pointing to the specified URL and
		//		adds it to the document.
		// description:
		//		Attaches the script element to the DOM. Use this method if you
		//		just want to attach a script to the DOM and do not care when or
		//		if it loads.
	};
	script.remove = function(id, frameDocument){
		// summary:
		//		removes the script element with the given id, from the given frameDocument.
		//		If no frameDocument is passed, the current document is used.
	};
	=====*/

	return script;
});

},
'dojo/request/script':function(){
define([
	'module',
	'./watch',
	'./util',
	'../_base/kernel',
	'../_base/array',
	'../_base/lang',
	'../on',
	'../dom',
	'../dom-construct',
	'../has',
	'../_base/window'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, watch, util, kernel, array, lang, on, dom, domConstruct, has, win/*=====, request, declare =====*/){
	has.add('script-readystatechange', function(global, document){
		var script = document.createElement('script');
		return typeof script['onreadystatechange'] !== 'undefined' &&
			(typeof global['opera'] === 'undefined' || global['opera'].toString() !== '[object Opera]');
	});

	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		counter = 0,
		loadEvent = has('script-readystatechange') ? 'readystatechange' : 'load',
		readyRegExp = /complete|loaded/,
		callbacks = kernel.global[mid + '_callbacks'] = {},
		deadScripts = [];

	function attach(id, url, frameDoc){
		var doc = (frameDoc || win.doc),
			element = doc.createElement('script');

		element.type = 'text/javascript';
		element.src = url;
		element.id = id;
		element.async = true;
		element.charset = 'utf-8';

		return doc.getElementsByTagName('head')[0].appendChild(element);
	}

	function remove(id, frameDoc, cleanup){
		domConstruct.destroy(dom.byId(id, frameDoc));

		if(callbacks[id]){
			if(cleanup){
				// set callback to a function that deletes itself so requests that
				// are in-flight don't error out when returning and also
				// clean up after themselves
				callbacks[id] = function(){
					delete callbacks[id];
				};
			}else{
				delete callbacks[id];
			}
		}
	}

	function _addDeadScript(dfd){
		// Be sure to check ioArgs because it can dynamically change in the dojox/io plugins.
		// See http://bugs.dojotoolkit.org/ticket/15890.
		var options = dfd.response.options,
			frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;

		deadScripts.push({ id: dfd.id, frameDoc: frameDoc });

		if(options.ioArgs){
			options.ioArgs.frameDoc = null;
		}
		options.frameDoc = null;
	}

	function canceler(dfd, response){
		if(dfd.canDelete){
			//For timeouts and cancels, remove the script element immediately to
			//avoid a response from it coming back later and causing trouble.
			script._remove(dfd.id, response.options.frameDoc, true);
		}
	}
	function isValid(response){
		//Do script cleanup here. We wait for one inflight pass
		//to make sure we don't get any weird things by trying to remove a script
		//tag that is part of the call chain (IE 6 has been known to
		//crash in that case).
		if(deadScripts && deadScripts.length){
			array.forEach(deadScripts, function(_script){
				script._remove(_script.id, _script.frameDoc);
				_script.frameDoc = null;
			});
			deadScripts = [];
		}

		return response.options.jsonp ? !response.data : true;
	}
	function isReadyScript(response){
		return !!this.scriptLoaded;
	}
	function isReadyCheckString(response){
		var checkString = response.options.checkString;

		return checkString && eval('typeof(' + checkString + ') !== "undefined"');
	}
	function handleResponse(response, error){
		if(this.canDelete){
			_addDeadScript(this);
		}
		if(error){
			this.reject(error);
		}else{
			this.resolve(response);
		}
	}

	function script(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCopy({}, options));
		url = response.url;
		options = response.options;

		var dfd = util.deferred(
			response,
			canceler,
			isValid,
			options.jsonp ? null : (options.checkString ? isReadyCheckString : isReadyScript),
			handleResponse
		);

		lang.mixin(dfd, {
			id: mid + (counter++),
			canDelete: false
		});

		if(options.jsonp){
			var queryParameter = new RegExp('[?&]' + options.jsonp + '=');
			if(!queryParameter.test(url)){
				url += (~url.indexOf('?') ? '&' : '?') +
					options.jsonp + '=' +
					(options.frameDoc ? 'parent.' : '') +
					mid + '_callbacks.' + dfd.id;
			}

			dfd.canDelete = true;
			callbacks[dfd.id] = function(json){
				response.data = json;
				dfd.handleResponse(response);
			};
		}

		if(util.notify){
			util.notify.emit('send', response, dfd.promise.cancel);
		}

		if(!options.canAttach || options.canAttach(dfd)){
			var node = script._attach(dfd.id, url, options.frameDoc);

			if(!options.jsonp && !options.checkString){
				var handle = on(node, loadEvent, function(evt){
					if(evt.type === 'load' || readyRegExp.test(node.readyState)){
						handle.remove();
						dfd.scriptLoaded = evt;
					}
				});
			}
		}

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}
	script.get = script;
	/*=====
	script = function(url, options){
		// summary:
		//		Sends a request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	script.__BaseOptions = declare(request.__BaseOptions, {
		// jsonp: String?
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		// checkString: String?
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use `jsonp` instead).
		// frameDoc: Document?
		//		The Document object of a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
	});
	script.__MethodOptions = declare(null, {
		// method: String?
		//		This option is ignored. All requests using this transport are
		//		GET requests.
	});
	script.__Options = declare([script.__BaseOptions, script.__MethodOptions]);

	script.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/

	// TODO: Remove in 2.0
	script._attach = attach;
	script._remove = remove;
	script._callbacksProperty = mid + '_callbacks';

	return script;
});

},
'dojo/main':function(){
define([
	"./_base/kernel",	// kernel.isAsync
	"./has",
	"require",
	"./sniff",
	"./_base/lang",
	"./_base/array",
	"./_base/config",
	"./ready",
	"./_base/declare",
	"./_base/connect",
	"./_base/Deferred",
	"./_base/json",
	"./_base/Color",
	"./has!dojo-firebug?./_firebug/firebug",
	"./_base/browser",
	"./_base/loader"
], function(kernel, has, require, sniff, lang, array, config, ready){
	// module:
	//		dojo/main
	// summary:
	//		This is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.

	// the preferred way to load the dojo firebug console is by setting has("dojo-firebug") true in dojoConfig
	// the isDebug config switch is for backcompat and will work fine in sync loading mode; it works in
	// async mode too, but there's no guarantee when the module is loaded; therefore, if you need a firebug
	// console guaranteed at a particular spot in an app, either set config.has["dojo-firebug"] true before
	// loading dojo.js or explicitly include dojo/_firebug/firebug in a dependency list.
	if(config.isDebug){
		require(["./_firebug/firebug"]);
	}

	// dojoConfig.require is deprecated; use the loader configuration property deps
	 1 || has.add("dojo-config-require", 1);
	if( 1 ){
		var deps= config.require;
		if(deps){
			// config.require may be dot notation
			deps= array.map(lang.isArray(deps) ? deps : [deps], function(item){ return item.replace(/\./g, "/"); });
			if(kernel.isAsync){
				require(deps);
			}else{
				// this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+
				// dojo isn't defined until returning from this module; this is only a problem in sync mode
				// since we're in sync mode, we know we've got our loader with its priority ready queue
				ready(1, function(){require(deps);});
			}
		}
	}

	return kernel;
});

},
'dojo/parser':function(){
define([
	"require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window",
		"./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./query", "./on", "./ready"
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval("(" + text + ")");
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
	var _ctorMap = {};

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		var ts = types.join();
		if(!_ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					(contextRequire ? contextRequire(t) : require(t)))));
			}
			var ctor = mixins.shift();
			_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return _ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojoType";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			var root;
			if(!options && rootNode && rootNode.rootNode){
				options = rootNode;
				root = options.rootNode;
			}else if(rootNode && dlang.isObject(rootNode) && !("nodeType" in rootNode)){
				options = rootNode;
			}else{
				root = rootNode;
			}
			root = root ? dom.byId(root) : dwindow.body();

			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if( 1 ){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
});

},
'dojo/promise/all':function(){
define([
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

},
'dojo/request/notify':function(){
define(['../Evented', '../_base/lang', './util'], function(Evented, lang, util){
	// module:
	//		dojo/request/notify
	// summary:
	//		Global notification API for dojo/request. Notifications will
	//		only be emitted if this module is required.
	//
	//		| require('dojo/request', 'dojo/request/notify',
	//		|     function(request, notify){
	//		|         notify('load', function(response){
	//		|             if(response.url === 'someUrl.html'){
	//		|                 console.log('Loaded!');
	//		|             }
	//		|         });
	//		|         request.get('someUrl.html');
	//		|     }
	//		| );

	var pubCount = 0,
		slice = [].slice;

	var hub = lang.mixin(new Evented, {
		onsend: function(data){
			if(!pubCount){
				this.emit('start');
			}
			pubCount++;
		},
		_onload: function(data){
			this.emit('done', data);
		},
		_onerror: function(data){
			this.emit('done', data);
		},
		_ondone: function(data){
			if(--pubCount <= 0){
				pubCount = 0;
				this.emit('stop');
			}
		},
		emit: function(type, event){
			var result = Evented.prototype.emit.apply(this, arguments);

			// After all event handlers have run, run _on* handler
			if(this['_on' + type]){
				this['_on' + type].apply(this, slice.call(arguments, 1));
			}
			return result;
		}
	});

	function notify(type, listener){
		// summary:
		//		Register a listener to be notified when an event
		//		in dojo/request happens.
		// type: String?
		//		The event to listen for. Events emitted: "start", "send",
		//		"load", "error", "done", "stop".
		// listener: Function?
		//		A callback to be run when an event happens.
		// returns:
		//		A signal object that can be used to cancel the listener.
		//		If remove() is called on this signal object, it will
		//		stop the listener from being executed.
		return hub.on(type, listener);
	}
	notify.emit = function(type, event, cancel){
		return hub.emit(type, event, cancel);
	};

	// Attach notify to dojo/request/util to avoid
	// try{ require('./notify'); }catch(e){}
	return util.notify = notify;
});

},
'dojo/router':function(){
define([
	"./router/RouterBase"
], function(RouterBase){

	// module:
	//		dojo/router

/*=====
return {
	// summary:
	//		A singleton-style instance of dojo/router/RouterBase. See that
	//		module for specifics.
	// example:
	//	|	router.register("/widgets/:id", function(evt){
	//	|		// If "/widgets/3" was matched,
	//	|		// evt.params.id === "3"
	//	|		xhr.get({
	//	|			url: "/some/path/" + evt.params.id,
	//	|			load: function(data){
	//	|				// ...
	//	|			}
	//	|		});
	//	|	});
};
=====*/

	return new RouterBase({});
});

},
'dojo/router/RouterBase':function(){
define([
	"dojo/_base/declare",
	"dojo/hash",
	"dojo/topic"
], function(declare, hash, topic){

	// module:
	//		dojo/router/RouterBase

	// Creating a basic trim to avoid needing the full dojo/string module
	// similarly to dojo/_base/lang's trim
	var trim;
	if(String.prototype.trim){
		trim = function(str){ return str.trim(); };
	}else{
		trim = function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };
	}

	// Firing of routes on the route object is always the same,
	// no clean way to expose this on the prototype since it's for the
	// internal router objects.
	function fireRoute(params, currentPath, newPath){
		var queue, isStopped, isPrevented, eventObj, callbackArgs, i, l;

		queue = this.callbackQueue;
		isStopped = false;
		isPrevented = false;
		eventObj = {
			stopImmediatePropagation: function(){ isStopped = true; },
			preventDefault: function(){ isPrevented = true; },
			oldPath: currentPath,
			newPath: newPath,
			params: params
		};

		callbackArgs = [eventObj];

		if(params instanceof Array){
			callbackArgs = callbackArgs.concat(params);
		}else{
			for(var key in params){
				callbackArgs.push(params[key]);
			}
		}

		for(i=0, l=queue.length; i<l; ++i){
			if(!isStopped){
				queue[i].apply(null, callbackArgs);
			}
		}

		return !isPrevented;
	}

	// Our actual class-like object
	var RouterBase = declare(null, {
		// summary:
		//		A module that allows one to easily map hash-based structures into
		//		callbacks. The router module is a singleton, offering one central
		//		point for all registrations of this type.
		// example:
		//	|	var router = new RouterBase({});
		//	|	router.register("/widgets/:id", function(evt){
		//	|		// If "/widgets/3" was matched,
		//	|		// evt.params.id === "3"
		//	|		xhr.get({
		//	|			url: "/some/path/" + evt.params.id,
		//	|			load: function(data){
		//	|				// ...
		//	|			}
		//	|		});
		//	|	});

		_routes: null,
		_routeIndex: null,
		_started: false,
		_currentPath: "",

		idMatch: /:(\w[\w\d]*)/g,
		idReplacement: "([^\\/]+)",
		globMatch: /\*(\w[\w\d]*)/,
		globReplacement: "(.+)",

		constructor: function(kwArgs){
			// A couple of safety initializations
			this._routes = [];
			this._routeIndex = {};

			// Simple constructor-style "Decorate myself all over" for now
			for(var i in kwArgs){
				if(kwArgs.hasOwnProperty(i)){
					this[i] = kwArgs[i];
				}
			}
		},

		register: function(/*String|RegExp*/ route, /*Function*/ callback){
			// summary:
			//		Registers a route to a handling callback
			// description:
			//		Given either a string or a regular expression, the router
			//		will monitor the page's hash and respond to changes that
			//		match the string or regex as provided.
			//
			//		When provided a regex for the route:
			//
			//		- Matching is performed, and the resulting capture groups
			//		are passed through to the callback as an array.
			//
			//		When provided a string for the route:
			//
			//		- The string is parsed as a URL-like structure, like
			//		"/foo/bar"
			//		- If any portions of that URL are prefixed with a colon
			//		(:), they will be parsed out and provided to the callback
			//		as properties of an object.
			//		- If the last piece of the URL-like structure is prefixed
			//		with a star (*) instead of a colon, it will be replaced in
			//		the resulting regex with a greedy (.+) match and
			//		anything remaining on the hash will be provided as a
			//		property on the object passed into the callback. Think of
			//		it like a basic means of globbing the end of a route.
			// example:
			//	|	router.register("/foo/:bar/*baz", function(object){
			//	|		// If the hash was "/foo/abc/def/ghi",
			//	|		// object.bar === "abc"
			//	|		// object.baz === "def/ghi"
			//	|	});
			// returns: Object
			//		A plain JavaScript object to be used as a handle for
			//		either removing this specific callback's registration, as
			//		well as to add new callbacks with the same route initially
			//		used.
			// route: String|RegExp
			//		A string or regular expression which will be used when
			//		monitoring hash changes.
			// callback: Function
			//		When the hash matches a pattern as described in the route,
			//		this callback will be executed. It will receive an event
			//		object that will have several properties:
			//
			//		- params: Either an array or object of properties pulled
			//		from the new hash
			//		- oldPath: The hash in its state before the change
			//		- newPath: The new hash being shifted to
			//		- preventDefault: A method that will stop hash changes
			//		from being actually applied to the active hash. This only
			//		works if the hash change was initiated using `router.go`,
			//		as changes initiated more directly to the location.hash
			//		property will already be in place
			//		- stopImmediatePropagation: When called, will stop any
			//		further bound callbacks on this particular route from
			//		being executed. If two distinct routes are bound that are
			//		different, but both happen to match the current hash in
			//		some way, this will *not* keep other routes from receiving
			//		notice of the change.

			return this._registerRoute(route, callback);
		},

		registerBefore: function(/*String|RegExp*/ route, /*Function*/ callback){
			// summary:
			//		Registers a route to a handling callback, except before
			//		any previously registered callbacks
			// description:
			//		Much like the `register` method, `registerBefore` allows
			//		us to register route callbacks to happen before any
			//		previously registered callbacks. See the documentation for
			//		`register` for more details and examples.

			return this._registerRoute(route, callback, true);
		},

		go: function(path, replace){
			// summary:
			//		A simple pass-through to make changing the hash easy,
			//		without having to require dojo/hash directly. It also
			//		synchronously fires off any routes that match.
			// example:
			//	|	router.go("/foo/bar");

			var applyChange;

			if(typeof path !== "string"){return false;}

			path = trim(path);
			applyChange = this._handlePathChange(path);

			if(applyChange){
				hash(path, replace);
			}

			return applyChange;
		},

		startup: function(defaultPath){
			// summary:
			//		This method must be called to activate the router. Until
			//		startup is called, no hash changes will trigger route
			//		callbacks.

			if(this._started){ return; }

			var self = this,
				startingPath = hash();

			this._started = true;
			this._hashchangeHandle = topic.subscribe("/dojo/hashchange", function(){
				self._handlePathChange.apply(self, arguments);
			});

			if(!startingPath){
				// If there is no initial starting point, push our defaultPath into our
				// history as the starting point
				this.go(defaultPath, true);
			}else{
				// Handle the starting path
				this._handlePathChange(startingPath);
			}
		},

		destroy: function(){
			if(this._hashchangeHandle){
				this._hashchangeHandle.remove();
			} 			
			this._routes = null;
			this._routeIndex = null;
		},

		_handlePathChange: function(newPath){
			var i, j, li, lj, routeObj, result,
				allowChange, parameterNames, params,
				routes = this._routes,
				currentPath = this._currentPath;

			if(!this._started || newPath === currentPath){ return allowChange; }

			allowChange = true;

			for(i=0, li=routes.length; i<li; ++i){
				routeObj = routes[i];
				result = routeObj.route.exec(newPath);

				if(result){
					if(routeObj.parameterNames){
						parameterNames = routeObj.parameterNames;
						params = {};

						for(j=0, lj=parameterNames.length; j<lj; ++j){
							params[parameterNames[j]] = result[j+1];
						}
					}else{
						params = result.slice(1);
					}
					allowChange = routeObj.fire(params, currentPath, newPath);
				}
			}

			if(allowChange){
				this._currentPath = newPath;
			}

			return allowChange;
		},

		_convertRouteToRegExp: function(route){
			// Sub in based on IDs and globs
			route = route.replace(this.idMatch, this.idReplacement);
			route = route.replace(this.globMatch, this.globReplacement);
			// Make sure it's an exact match
			route = "^" + route + "$";

			return new RegExp(route);
		},

		_getParameterNames: function(route){
			var idMatch = this.idMatch,
				globMatch = this.globMatch,
				parameterNames = [], match;

			idMatch.lastIndex = 0;

			while((match = idMatch.exec(route)) !== null){
				parameterNames.push(match[1]);
			}
			if((match = globMatch.exec(route)) !== null){
				parameterNames.push(match[1]);
			}

			return parameterNames.length > 0 ? parameterNames : null;
		},

		_indexRoutes: function(){
			var i, l, route, routeIndex, routes = this._routes;

			// Start a new route index
			routeIndex = this._routeIndex = {};

			// Set it up again
			for(i=0, l=routes.length; i<l; ++i){
				route = routes[i];
				routeIndex[route.route] = i;
			}
		},

		_registerRoute: function(/*String|RegExp*/route, /*Function*/callback, /*Boolean?*/isBefore){
			var index, exists, routeObj, callbackQueue, removed,
				self = this, routes = this._routes,
				routeIndex = this._routeIndex;

			// Try to fetch the route if it already exists.
			// This works thanks to stringifying of regex
			index = this._routeIndex[route];
			exists = typeof index !== "undefined";
			if(exists){
				routeObj = routes[index];
			}

			// If we didn't get one, make a default start point
			if(!routeObj){
				routeObj = {
					route: route,
					callbackQueue: [],
					fire: fireRoute
				};
			}

			callbackQueue = routeObj.callbackQueue;

			if(typeof route == "string"){
				routeObj.parameterNames = this._getParameterNames(route);
				routeObj.route = this._convertRouteToRegExp(route);
			}

			if(isBefore){
				callbackQueue.unshift(callback);
			}else{
				callbackQueue.push(callback);
			}

			if(!exists){
				index = routes.length;
				routeIndex[route] = index;
				routes.push(routeObj);
			}

			// Useful in a moment to keep from re-removing routes
			removed = false;

			return { // Object
				remove: function(){
					var i, l;

					if(removed){ return; }

					for(i=0, l=callbackQueue.length; i<l; ++i){
						if(callbackQueue[i] === callback){
							callbackQueue.splice(i, 1);
						}
					}


					if(callbackQueue.length === 0){
						routes.splice(index, 1);
						self._indexRoutes();
					}

					removed = true;
				},
				register: function(callback, isBefore){
					return self.register(route, callback, isBefore);
				}
			};
		}
	});

	return RouterBase;
});

},
'dojo/selector/lite':function(){
define(["../has", "../_base/kernel"], function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		// fast path regardless of whether or not querySelectorAll exists
		if(match[2]){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
});

},
'dojo/store/Memory':function(){
define(["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine" /*=====, "./api/Store" =====*/],
function(declare, QueryResults, SimpleQueryEngine /*=====, Store =====*/){

// module:
//		dojo/store/Memory

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

return declare("dojo.store.Memory", base, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo/store/api/Store.
	constructor: function(options){
		// summary:
		//		Creates a memory object store.
		// options: dojo/store/Memory
		//		This provides any configuration information that will be mixed into the store.
		//		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		// summary:
		//		Retrieves an object by its identity
		// id: Number
		//		The identity to use to lookup the object
		// returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// summary:
		//		Stores an object
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// summary:
		//		Creates an object, throws an error if the object already exists
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// summary:
		//		Deletes an object by its identity
		// id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		//		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// summary:
		//		Queries the store for objects.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: dojo/store/api/Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// example:
		//		Given the following store:
		//
		// 	|	var store = new Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// summary:
		//		Sets the given data as the source for this store, and indexes it
		// data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier || this.idProperty;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

},
'dojo/store/util/QueryResults':function(){
define(["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}

	var isPromise = !!results.then;
	// if it is a promise it may be frozen
	if(isPromise){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		// Always add the iterative methods so a QueryResults is
		// returned whether the environment is ES3 or ES5
		results[method] = function(){
			var args = arguments;
			var result = when(results, function(results){
				Array.prototype.unshift.call(args, results);
				return QueryResults(array[method].apply(array, args));
			});
			// forEach should only return the result of when()
			// when we're wrapping a promise
			if(method !== "forEach" || isPromise){
				return result;
			}
		};
	}

	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(results.total == null){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});

},
'dojo/store/util/SimpleQueryEngine':function(){
define(["../../_base/array" /*=====, "../api/Store" =====*/], function(arrayUtil /*=====, Store =====*/){

// module:
//		dojo/store/util/SimpleQueryEngine

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	//		used to match strings by more complex expressions
	//		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo/store/api/Store.QueryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						// an object can provide a test method, which makes it work with regex
						if(!required.test(object[key], object)){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		var sortSet = options && options.sort;
		if(sortSet){
			results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
				for(var sort, i=0; sort = sortSet[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					// valueOf enables proper comparison of dates
					aValue = aValue != null ? aValue.valueOf() : aValue;
					bValue = bValue != null ? bValue.valueOf() : bValue;
					if (aValue != bValue){
						return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};

});

},
'dojo/store/Observable':function(){
define(["../_base/kernel", "../_base/lang", "../when", "../_base/array" /*=====, "./api/Store" =====*/
], function(kernel, lang, when, array /*=====, Store =====*/){

// module:
//		dojo/store/Observable

var Observable = function(/*Store*/ store){
	// summary:
	//		The Observable store wrapper takes a store and sets an observe method on query()
	//		results that can be used to monitor results for changes.
	//
	// description:
	//		Observable wraps an existing store so that notifications can be made when a query
	//		is performed.
	//
	// example:
	//		Create a Memory store that returns an observable query, and then log some
	//		information about that query.
	//
	//	|	var store = Observable(new Memory({
	//	|		data: [
	//	|			{id: 1, name: "one", prime: false},
	//	|			{id: 2, name: "two", even: true, prime: true},
	//	|			{id: 3, name: "three", prime: true},
	//	|			{id: 4, name: "four", even: true, prime: false},
	//	|			{id: 5, name: "five", prime: true}
	//	|		]
	//	|	}));
	//	|	var changes = [], results = store.query({ prime: true });
	//	|	var observer = results.observe(function(object, previousIndex, newIndex){
	//	|		changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
	//	|	});
	//
	//		See the Observable tests for more information.

	var undef, queryUpdaters = [], revision = 0;
	// a Comet driven store could directly call notify to notify observers when data has
	// changed on the backend
	// create a new instance
	store = lang.delegate(store);
	
	store.notify = function(object, existingId){
		revision++;
		var updaters = queryUpdaters.slice();
		for(var i = 0, l = updaters.length; i < l; i++){
			updaters[i](object, existingId);
		}
	};
	var originalQuery = store.query;
	store.query = function(query, options){
		options = options || {};
		var results = originalQuery.apply(this, arguments);
		if(results && results.forEach){
			var nonPagedOptions = lang.mixin({}, options);
			delete nonPagedOptions.start;
			delete nonPagedOptions.count;

			var queryExecutor = store.queryEngine && store.queryEngine(query, nonPagedOptions);
			var queryRevision = revision;
			var listeners = [], queryUpdater;
			results.observe = function(listener, includeObjectUpdates){
				if(listeners.push(listener) == 1){
					// first listener was added, create the query checker and updater
					queryUpdaters.push(queryUpdater = function(changed, existingId){
						when(results, function(resultsArray){
							var atEnd = resultsArray.length != options.count;
							var i, l, listener;
							if(++queryRevision != revision){
								throw new Error("Query is out of date, you must observe() the query prior to any data modifications");
							}
							var removedObject, removedFrom = -1, insertedInto = -1;
							if(existingId !== undef){
								// remove the old one
								for(i = 0, l = resultsArray.length; i < l; i++){
									var object = resultsArray[i];
									if(store.getIdentity(object) == existingId){
										removedObject = object;
										removedFrom = i;
										if(queryExecutor || !changed){// if it was changed and we don't have a queryExecutor, we shouldn't remove it because updated objects would be eliminated
											resultsArray.splice(i, 1);
										}
										break;
									}
								}
							}
							if(queryExecutor){
								// add the new one
								if(changed &&
										// if a matches function exists, use that (probably more efficient)
										(queryExecutor.matches ? queryExecutor.matches(changed) : queryExecutor([changed]).length)){

									var firstInsertedInto = removedFrom > -1 ? 
										removedFrom : // put back in the original slot so it doesn't move unless it needs to (relying on a stable sort below)
										resultsArray.length;
									resultsArray.splice(firstInsertedInto, 0, changed); // add the new item
									insertedInto = array.indexOf(queryExecutor(resultsArray), changed); // sort it
									// we now need to push the change back into the original results array
									resultsArray.splice(firstInsertedInto, 1); // remove the inserted item from the previous index
									
									if((options.start && insertedInto == 0) ||
										(!atEnd && insertedInto == resultsArray.length)){
										// if it is at the end of the page, assume it goes into the prev or next page
										insertedInto = -1;
									}else{
										resultsArray.splice(insertedInto, 0, changed); // and insert into the results array with the correct index
									}
								}
							}else if(changed){
								// we don't have a queryEngine, so we can't provide any information
								// about where it was inserted or moved to. If it is an update, we leave it's position alone, other we at least indicate a new object
								if(existingId !== undef){
									// an update, keep the index the same
									insertedInto = removedFrom;
								}else if(!options.start){
									// a new object
									insertedInto = store.defaultIndex || 0;
									resultsArray.splice(insertedInto, 0, changed);
								}
							}
							if((removedFrom > -1 || insertedInto > -1) &&
									(includeObjectUpdates || !queryExecutor || (removedFrom != insertedInto))){
								var copyListeners = listeners.slice();
								for(i = 0;listener = copyListeners[i]; i++){
									listener(changed || removedObject, removedFrom, insertedInto);
								}
							}
						});
					});
				}
				var handle = {};
				// TODO: Remove cancel in 2.0.
				handle.remove = handle.cancel = function(){
					// remove this listener
					var index = array.indexOf(listeners, listener);
					if(index > -1){ // check to make sure we haven't already called cancel
						listeners.splice(index, 1);
						if(!listeners.length){
							// no more listeners, remove the query updater too
							queryUpdaters.splice(array.indexOf(queryUpdaters, queryUpdater), 1);
						}
					}
				};
				return handle;
			};
		}
		return results;
	};
	var inMethod;
	function whenFinished(method, action){
		var original = store[method];
		if(original){
			store[method] = function(value){
				var originalId;
				if(method === 'put'){
					originalId = store.getIdentity(value);
				}
				if(inMethod){
					// if one method calls another (like add() calling put()) we don't want two events
					return original.apply(this, arguments);
				}
				inMethod = true;
				try{
					var results = original.apply(this, arguments);
					when(results, function(results){
						action((typeof results == "object" && results) || value, originalId);
					});
					return results;
				}finally{
					inMethod = false;
				}
			};
		}
	}
	// monitor for updates by listening to these methods
	whenFinished("put", function(object, originalId){
		store.notify(object, originalId);
	});
	whenFinished("add", function(object){
		store.notify(object);
	});
	whenFinished("remove", function(id){
		store.notify(undefined, id);
	});

	return store;
};

lang.setObject("dojo.store.Observable", Observable);

return Observable;
});

},
'dojo/store/JsonRest':function(){
define(["../_base/xhr", "../_base/lang", "../json", "../_base/declare", "./util/QueryResults" /*=====, "./api/Store" =====*/
], function(xhr, lang, JSON, declare, QueryResults /*=====, Store =====*/){

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

/*=====
var __HeaderOptions = {
		// headers: Object?
		//		Additional headers to send along with the request.
	},
	__PutDirectives = declare(Store.PutDirectives, __HeaderOptions),
	__QueryOptions = declare(Store.QueryOptions, __HeaderOptions);
=====*/

return declare("dojo.store.JsonRest", base, {
	// summary:
	//		This is a basic store for RESTful communicating with a server through JSON
	//		formatted data. It implements dojo/store/api/Store.

	constructor: function(options){
		// summary:
		//		This is a basic store for RESTful communicating with a server through JSON
		//		formatted data.
		// options: dojo/store/JsonRest
		//		This provides any configuration information that will be mixed into the store
		this.headers = {};
		declare.safeMixin(this, options);
	},

	// headers: Object
	//		Additional headers to pass in all requests to the server. These can be overridden
	//		by passing additional headers to calls to the store.
	headers: {},

	// target: String
	//		The target base URL to use for all requests to the server. This string will be
	//		prepended to the id to generate the URL (relative or absolute) for requests
	//		sent to the server
	target: "",

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// rangeParam: String
	//		Use a query parameter for the requested range. If this is omitted, than the
	//		Range header will be used. Independent of this, the X-Range header is always set.

	// sortParam: String
	//		The query parameter to used for holding sort information. If this is omitted, than
	//		the sort information is included in a functional query token to avoid colliding
	//		with the set of name/value pairs.

	// ascendingPrefix: String
	//		The prefix to apply to sort attribute names that are ascending
	ascendingPrefix: "+",

	// descendingPrefix: String
	//		The prefix to apply to sort attribute names that are ascending
	descendingPrefix: "-",
	 
	_getTarget: function(id){
		// summary:
		//		If the target has no trailing '/', then append it.
		// id: Number
		//		The identity of the requested target
		var target = this.target;
		if(typeof id != "undefined"){
			if(target.charAt(target.length-1) == '/'){
				target += id;
			}else{
				target += '/' + id;
			}
		}
		return target;
	},
					
	get: function(id, options){
		// summary:
		//		Retrieves an object by its identity. This will trigger a GET request to the server using
		//		the url `this.target + id`.
		// id: Number
		//		The identity to use to lookup the object
		// options: Object?
		//		HTTP headers. For consistency with other methods, if a `headers` key exists on this object, it will be
		//		used to provide HTTP headers instead.
		// returns: Object
		//		The object in the store that matches the given id.
		options = options || {};
		var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers || options);
		return xhr("GET", {
			url: this._getTarget(id),
			handleAs: "json",
			headers: headers
		});
	},

	// accepts: String
	//		Defines the Accept header to use on HTTP requests
	accepts: "application/javascript, application/json",

	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},

	put: function(object, options){
		// summary:
		//		Stores an object. This will trigger a PUT request to the server
		//		if the object has an id, otherwise it will trigger a POST request.
		// object: Object
		//		The object to store.
		// options: __PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: dojo/_base/Deferred
		options = options || {};
		var id = ("id" in options) ? options.id : this.getIdentity(object);
		var hasId = typeof id != "undefined";
		return xhr(hasId && !options.incremental ? "PUT" : "POST", {
				url: this._getTarget(id),
				postData: JSON.stringify(object),
				handleAs: "json",
				headers: lang.mixin({
					"Content-Type": "application/json",
					Accept: this.accepts,
					"If-Match": options.overwrite === true ? "*" : null,
					"If-None-Match": options.overwrite === false ? "*" : null
				}, this.headers, options.headers)
			});
	},

	add: function(object, options){
		// summary:
		//		Adds an object. This will trigger a PUT request to the server
		//		if the object has an id, otherwise it will trigger a POST request.
		// object: Object
		//		The object to store.
		// options: __PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		options = options || {};
		options.overwrite = false;
		return this.put(object, options);
	},

	remove: function(id, options){
		// summary:
		//		Deletes an object by its identity. This will trigger a DELETE request to the server.
		// id: Number
		//		The identity to use to delete the object
		// options: __HeaderOptions?
		//		HTTP headers.
		options = options || {};
		return xhr("DELETE", {
			url: this._getTarget(id),
			headers: lang.mixin({}, this.headers, options.headers)
		});
	},

	query: function(query, options){
		// summary:
		//		Queries the store for objects. This will trigger a GET request to the server, with the
		//		query added as a query string.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: __QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		options = options || {};

		var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers);

		var hasQuestionMark = this.target.indexOf("?") > -1;
		if(query && typeof query == "object"){
			query = xhr.objectToQuery(query);
			query = query ? (hasQuestionMark ? "&" : "?") + query: "";
		}
		if(options.start >= 0 || options.count >= 0){
			headers["X-Range"] = "items=" + (options.start || '0') + '-' +
				(("count" in options && options.count != Infinity) ?
					(options.count + (options.start || 0) - 1) : '');
			if(this.rangeParam){
				query += (query || hasQuestionMark ? "&" : "?") + this.rangeParam + "=" + headers["X-Range"];
				hasQuestionMark = true;
			}else{
				headers.Range = headers["X-Range"];
			}
		}
		if(options && options.sort){
			var sortParam = this.sortParam;
			query += (query || hasQuestionMark ? "&" : "?") + (sortParam ? sortParam + '=' : "sort(");
			for(var i = 0; i<options.sort.length; i++){
				var sort = options.sort[i];
				query += (i > 0 ? "," : "") + (sort.descending ? this.descendingPrefix : this.ascendingPrefix) + encodeURIComponent(sort.attribute);
			}
			if(!sortParam){
				query += ")";
			}
		}
		var results = xhr("GET", {
			url: this.target + (query || ""),
			handleAs: "json",
			headers: headers
		});
		results.total = results.then(function(){
			var range = results.ioArgs.xhr.getResponseHeader("Content-Range");
			if (!range){
				// At least Chrome drops the Content-Range header from cached replies.
				range = results.ioArgs.xhr.getResponseHeader("X-Content-Range");
			}
			return range && (range = range.match(/\/(.*)/)) && +range[1];
		});
		return QueryResults(results);
	}
});

});
},
'dojo/uacss':function(){
define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"],
	function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'dojo/window':function(){
define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident")) && ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
						if(elPos.x < 0 || !isIE || isIE >= 9 || has("trident")){ elPos.x = 0; } // older IE can have values > 0
						if(elPos.y < 0 || !isIE || isIE >= 9 || has("trident")){ elPos.y = 0; }
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9 || has("trident"))){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	 1  && lang.setObject("dojo.window", window);

	return window;
});

},
'dijit/_WidgetBase':function(){
define([
	"require", // require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/has",
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.body()
	"./Destroyable",
	"dojo/has!dojo-bidi?./_BidiMixin",
	"./registry"    // registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,

		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
});

},
'dojo/Stateful':function(){
define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});

},
'dijit/Destroyable':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/declare"
], function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
});

},
'dijit/registry':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
	"./main"	// dijit._scopeName
], function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'dijit/main':function(){
define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'dijit/_Widget':function(){
define([
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(has("dijit-legacy-requires")){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dijit/_OnDijitClickMixin':function(){
define([
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/has", // has("dom-addeventlistener")
	"./a11yclick"
], function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
});

},
'dijit/a11yclick':function(){
define([
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/mouse",
	"dojo/on",
	"dojo/touch" // touch support for click is now there
], function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
});

},
'dojo/touch':function(){
define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"],
function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			}
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			}
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}
	
	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.
		
		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other 
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				}

				win.doc.addEventListener(moveType, function(e){
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						//create the synthetic event.
						//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
						var clickEvt = document.createEvent("MouseEvents");
						clickEvt._dojo_click = true;
						clickEvt.initMouseEvent("click",
							true, //bubbles
							true, //cancelable
							e.view,
							e.detail,
							src.screenX,
							src.screenY,
							src.clientX,
							src.clientY,
							e.ctrlKey,
							e.altKey,
							e.shiftKey,
							e.metaKey,
							0, //button
							null //related target
						);
						setTimeout(function(){
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
							if(!e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox")
								&& e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO"){
								 // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								 // but it is still needed for checkboxes and radio buttons, otherwise in some cases
								 // the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(hasPointer){
		 // MSPointer (IE10+) already has support for over and out, so we just need to init click support
		domReady(function(){
			win.doc.addEventListener(pointer.down, function(evt){
				doClicks(evt, pointer.move, pointer.up);
			}, true);
		});
	}else if(hasTouch){
		domReady(function(){
			// Keep track of currently hovered node
			hoveredNode = win.body();	// currently hovered node

			win.doc.addEventListener("touchstart", function(evt){
					lastTouch = (new Date()).getTime();

				// Precede touchstart event with touch.over event.  DnD depends on this.
				// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
				// and to ensure this code runs even if the listener on the node does event.stop().
				var oldNode = hoveredNode;
				hoveredNode = evt.target;
				on.emit(oldNode, "dojotouchout", {
					relatedTarget: hoveredNode,
					bubbles: true
				});
				on.emit(hoveredNode, "dojotouchover", {
					relatedTarget: oldNode,
					bubbles: true
				});

				doClicks(evt, "touchmove", "touchend"); // init click generation
			}, true);

			function copyEventProps(evt){
				// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
				var props = lang.delegate(evt, {
					bubbles: true
				});

				if(has("ios") >= 6){
					// On iOS6 "touches" became a non-enumerable property, which
					// is not hit by for...in.  Ditto for the other properties below.
					props.touches = evt.touches;
					props.altKey = evt.altKey;
					props.changedTouches = evt.changedTouches;
					props.ctrlKey = evt.ctrlKey;
					props.metaKey = evt.metaKey;
					props.shiftKey = evt.shiftKey;
					props.targetTouches = evt.targetTouches;
				}

				return props;
			}

			on(win.doc, "touchmove", function(evt){
				lastTouch = (new Date()).getTime();

				var newNode = win.doc.elementFromPoint(
					evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
					evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
				);

				if(newNode){
					// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
					if(hoveredNode !== newNode){
						// touch out on the old node
						on.emit(hoveredNode, "dojotouchout", {
							relatedTarget: newNode,
							bubbles: true
						});

						// touchover on the new node
						on.emit(newNode, "dojotouchover", {
							relatedTarget: hoveredNode,
							bubbles: true
						});

						hoveredNode = newNode;
					}

					// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
					// drags over the specified node, regardless of which node the touch started on.
					if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
						// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
						// default behavior of the underlying native event "touchmove".
						evt.preventDefault();
					}
				}
			});

			// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
			// This is different than the native touchend, which fires on the node where the drag started.
			on(win.doc, "touchend", function(evt){
					lastTouch = (new Date()).getTime();
				var node = win.doc.elementFromPoint(
					evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
					evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
				) || win.body(); // if out of the screen

				on.emit(node, "dojotouchend", copyEventProps(evt));
			});
		});
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	 1  && (dojo.touch = touch);

	return touch;
});

},
'dijit/_FocusMixin':function(){
define([
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/focus':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-class",
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"./main"		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'dijit/a11y':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // domStyle.style
	"dojo/_base/lang", // lang.mixin()
	"dojo/sniff", // has("ie")  1 
	"./main"	// for exporting methods to dijit namespace
], function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	 1  && lang.mixin(dijit, a11y);

	return a11y;
});

},
'dijit/hccss':function(){
define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
});

},
'dojo/hccss':function(){
define([
	"require",			// require, require.toUrl
	"./_base/config", // config.blankGif
	"./dom-class", // domClass.add
	"./dom-style", // domStyle.getComputedStyle
	"./has",
	"./domReady",
	"./_base/window" // win.body
], function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
			"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
		win.body().appendChild(div);

		var cs = domStyle.getComputedStyle(div),
			bkImg = cs.backgroundImage,
			hc = (cs.borderTopColor == cs.borderRightColor) ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));

		if(has("ie") <= 8){
			div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
		}else{
			win.body().removeChild(div);
		}

		return hc;
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
});

},
'dijit/_Templated':function(){
define([
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

	// module:
	//		dijit/_Templated

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_processNode: function(baseNode, getAttrFunc){
			var ret = this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var role = getAttrFunc(baseNode, "waiRole");
			if(role){
				baseNode.setAttribute("role", role);
			}
			var values = getAttrFunc(baseNode, "waiState");
			if(values){
				array.forEach(values.split(/\s*,\s*/), function(stateValue){
					if(stateValue.indexOf('-') != -1){
						var pair = stateValue.split('-');
						baseNode.setAttribute("aria-"+pair[0], pair[1]);
					}
				});
			}

			return ret;
		}
	});
});

},
'dijit/_TemplatedMixin':function(){
define([
	"dojo/cache",	// dojo.cache
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/string", // string.substitute string.trim
	"./_AttachMixin"
], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
});

},
'dijit/_AttachMixin':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect",	// remove for 2.0
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"dojo/mouse",
	"dojo/on",
	"dojo/touch",
	"./_WidgetBase"
], function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent; ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
});

},
'dijit/_WidgetsInTemplateMixin':function(){
define([
	"dojo/_base/array", // forEach()
	"dojo/aspect", // after()
	"dojo/_base/declare", // declare()
	"dojo/_base/lang",	// hitch()
	"dojo/parser" // parse()
], function(array, aspect, declare, lang, parser){

	// module:
	//		dijit/_WidgetsInTemplateMixin

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		// contextRequire: Function
		//		Used to provide a context require to the dojo/parser in order to be
		//		able to use relative MIDs (e.g. `./Widget`) in the widget's template.
		contextRequire: null,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				if(this.containerNode && !this.searchContainerNode){
					// Tell parse call below not to look for widgets inside of this.containerNode
					this.containerNode.stopParser = true;
				}

				parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					contextRequire: this.contextRequire,
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}).then(lang.hitch(this, function(widgets){
					this._startupWidgets = widgets;

					// _WidgetBase::destroy() will destroy any supporting widgets under this.domNode.
					// If we wanted to, we could call this.own() on anything in this._startupWidgets that was moved outside
					// of this.domNode (like Dialog, which is moved to <body>).

					// Hook up attach points and events for nodes that were converted to widgets
					for(var i = 0; i < widgets.length; i++){
						this._processTemplateNode(widgets[i], function(n,p){
							// callback to get a property of a widget
							return n[p];
						}, function(widget, type, callback){
							// callback to do data-dojo-attach-event to a widget
							if(type in widget){
								// back-compat, remove for 2.0
								return widget.connect(widget, type, callback);
							}else{
								// 1.x may never hit this branch, but it's the default for 2.0
								return widget.on(type, callback, true);
							}
						});
					}

					// Cleanup flag set above, just in case
					if(this.containerNode && this.containerNode.stopParser){
						delete this.containerNode.stopParser;
					}
				}));

				if(!this._startupWidgets){
					throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " +
						"unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// Override _AttachMixin._processNode to skip DOMNodes with data-dojo-type set.   They are handled separately
			// in the _beforeFillContent() code above.

			if(getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")){
				return true;
			}

			return this.inherited(arguments);
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this._startupWidgets = null;
			this.inherited(arguments);
		}
	});
});

},
'dojox/validate':function(){
define(["./validate/_base"], function(validate){

	/*=====
	 return {
	 // summary:
	 //		Deprecated.  Should require dojox/validate modules directly rather than trying to access them through
	 //		this module.
	 };
	 =====*/

	return validate;
});

},
'dojox/validate/_base':function(){
define([
	"dojo/_base/lang",
	"dojo/regexp", // dojo core expressions
	"dojo/number", // dojo number expressions
	"./regexp" // additional expressions
], function(lang, regexp, number, xregexp) {

var validate = lang.getObject("dojox.validate", true);

validate.isText = function(value, flags){
	// summary:
	//		Checks if a string has non whitespace characters.
	//		Parameters allow you to constrain the length.
	// value: String
	// flags: Object?
	//		{length: Number, minlength: Number, maxlength: Number}
	//
	//		- flags.length  If set, checks if there are exactly flags.length number of characters.
	//		- flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	//		- flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
	
	flags = (typeof flags == "object") ? flags : {};
	
	// test for text
	if(/^\s*$/.test(value)){ return false; } // Boolean
	
	// length tests
	if(typeof flags.length == "number" && flags.length != value.length){ return false; } // Boolean
	if(typeof flags.minlength == "number" && flags.minlength > value.length){ return false; } // Boolean
	if(typeof flags.maxlength == "number" && flags.maxlength < value.length){ return false; } // Boolean
	
	return true; // Boolean

};

validate._isInRangeCache = {};
validate.isInRange = function(value, flags){
	// summary:
	//		Validates whether a string denoting a number
	//		is between a max and min.
	// value: String
	// flags: Object?
	//		{max:Number, min:Number, decimal:String}
	//
	//		- flags.max  A number, which the value must be less than or equal to for the validation to be true.
	//		- flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	//		- flags.decimal  The character used for the decimal point.  Default is ".".
	
	value = number.parse(value, flags);
	if(isNaN(value)){
		return false; // Boolean
	}
    
	// assign default values to missing parameters
	flags = (typeof flags == "object") ? flags : {};
	var max = (typeof flags.max == "number") ? flags.max : Infinity,
		min = (typeof flags.min == "number") ? flags.min : -Infinity,
		dec = (typeof flags.decimal == "string") ? flags.decimal : ".",
	
		cache = validate._isInRangeCache,
		cacheIdx = value + "max" + max + "min" + min + "dec" + dec
	;
	if(typeof cache[cacheIdx] != "undefined"){
		return cache[cacheIdx];
	}

	cache[cacheIdx] = !(value < min || value > max);
	return cache[cacheIdx]; // Boolean

};

validate.isNumberFormat = function(value, flags){
	// summary:
	//		Validates any sort of number based format
	// description:
	//		Validates any sort of number based format. Use it for phone numbers,
	//		social security numbers, zip-codes, etc. The value can be validated
	//		against one format or one of multiple formats.
	//
	//		Format Definition
	//		|   #        Stands for a digit, 0-9.
	//		|   ?        Stands for an optional digit, 0-9 or nothing.
	//		All other characters must appear literally in the expression.
	// example:
	// |  "(###) ###-####"       ->   (510) 542-9742
	// |  "(###) ###-#### x#???" ->   (510) 542-9742 x153
	// |  "###-##-####"          ->   506-82-1089       i.e. social security number
	// |  "#####-####"           ->   98225-1649        i.e. zip code
	// value: String
	// flags: Object?
	//		- flags.format  A string or an Array of strings for multiple formats.
	// example:
	// |	require(["dojox/validate/_base"], function(validate){
	// |		// returns true:
	// |		validate.isNumberFormat("123-45", { format:"###-##" });
	// |	});		
	// example:
	//		Check Multiple formats:
	// |	require(["dojox/validate/_base"], function(validate){
	// |		validate.isNumberFormat("123-45", {
	// |			format:["### ##","###-##","## ###"]
	// |	});
	//

	var re = new RegExp("^" + xregexp.numberFormat(flags) + "$", "i");
	return re.test(value); // Boolean
};

validate.isValidLuhn = function(/* String */value){
	// summary:
	//		Validate a String value against the Luhn algorithm.
	// description:
	//		Validate a String value against the Luhn algorithm to verify
	//		its integrity.
	
	var sum = 0, parity, curDigit;
	if(!lang.isString(value)){
		value = String(value);
	}
	value = value.replace(/[- ]/g,''); //ignore dashes and whitespaces
	parity = value.length % 2;

	for(var i = 0; i < value.length; i++){
		curDigit = parseInt(value.charAt(i));
		if(i % 2 == parity){
			curDigit *= 2;
		}
		if(curDigit > 9){
			curDigit -= 9;
		}
		sum += curDigit;
	}
	return !(sum % 10); // Boolean
};

return validate;

});

},
'dojox/validate/regexp':function(){
define(["dojo/_base/lang", "dojo/regexp", "dojox/main"], 
  function(lang, regexp, dojox){

var dxregexp = lang.getObject("validate.regexp", true, dojox);
dxregexp = dojox.validate.regexp = {
	
	ipAddress: function(flags){
		// summary:
		//		Builds a RE that matches an IP Address
		// description:
		//		Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
		//		Supports 2 formats for Ipv6.
		// flags: Object?
		//		All flags are boolean with default = true.
		//
		//		- flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
		//		- flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
		//		- flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
		//		- flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
		//		- flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
		//		  Case insensitive.  Zero padding allowed.
		//		- flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
		
		//	FIXME: ipv6 can be written multiple ways IIRC
		//		- flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
		//		-   followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowDottedDecimal != "boolean"){ flags.allowDottedDecimal = true; }
		if(typeof flags.allowDottedHex != "boolean"){ flags.allowDottedHex = true; }
		if(typeof flags.allowDottedOctal != "boolean"){ flags.allowDottedOctal = true; }
		if(typeof flags.allowDecimal != "boolean"){ flags.allowDecimal = true; }
		if(typeof flags.allowHex != "boolean"){ flags.allowHex = true; }
		if(typeof flags.allowIPv6 != "boolean"){ flags.allowIPv6 = true; }
		if(typeof flags.allowHybrid != "boolean"){ flags.allowHybrid = true; }

		// decimal-dotted IP address RE.
		var dottedDecimalRE =
			// Each number is between 0-255.  Zero padding is not allowed.
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
		var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";

		// dotted octal IP address RE.  Each number is between 0000-0377.
		// Zero padding is allowed, but each number must have at least 4 characters.
		var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";

		// decimal IP address RE.  A decimal number between 0-4294967295.
		var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
			"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";

		// hexadecimal IP address RE.
		// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
		var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";

		// IPv6 address RE.
		// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
		// where x is between 0000-ffff. Zero padding is optional. Case insensitive.
		var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";

		// IPv6/IPv4 Hybrid address RE.
		// The format is written as six groups of four hexadecimal digits,
		// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
		var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" +
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// Build IP Address RE
		var a = [];
		if(flags.allowDottedDecimal){ a.push(dottedDecimalRE); }
		if(flags.allowDottedHex){ a.push(dottedHexRE); }
		if(flags.allowDottedOctal){ a.push(dottedOctalRE); }
		if(flags.allowDecimal){ a.push(decimalRE); }
		if(flags.allowHex){ a.push(hexRE); }
		if(flags.allowIPv6){ a.push(ipv6RE); }
		if(flags.allowHybrid){ a.push(hybridRE); }

		var ipAddressRE = "";
		if(a.length > 0){
			ipAddressRE = "(" + a.join("|") + ")";
		}
		return ipAddressRE; // String
	},

	host: function(flags){
		// summary:
		//		Builds a RE that matches a host
		// description:
		//		A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.
		// flags: Object?
		//		- flags.allowNamed Allow a named host for local networks. Default is false.
		//		- flags.allowIP  Allow an IP address for hostname.  Default is true.
		//		- flags.allowLocal  Allow the host to be "localhost".  Default is false.
		//		- flags.allowPort  Allow a port number to be present.  Default is true.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};

		if(typeof flags.allowIP != "boolean"){ flags.allowIP = true; }
		if(typeof flags.allowLocal != "boolean"){ flags.allowLocal = false; }
		if(typeof flags.allowPort != "boolean"){ flags.allowPort = true; }
		if(typeof flags.allowNamed != "boolean"){ flags.allowNamed = false; }

		//TODO: support unicode hostnames?
		// Domain name labels can not end with a dash.
		var domainLabelRE = "(?:[\\da-zA-Z](?:[-\\da-zA-Z]{0,61}[\\da-zA-Z])?)";
		var domainNameRE = "(?:[a-zA-Z](?:[-\\da-zA-Z]{0,6}[\\da-zA-Z])?)"; // restricted version to allow backwards compatibility with allowLocal, allowIP

		// port number RE
		var portRE = flags.allowPort ? "(\\:\\d+)?" : "";

		// build host RE
		var hostNameRE = "((?:" + domainLabelRE + "\\.)+" + domainNameRE + "\\.?)";
		if(flags.allowIP){ hostNameRE += "|" +  dxregexp.ipAddress(flags); }
		if(flags.allowLocal){ hostNameRE += "|localhost"; }
		if(flags.allowNamed){ hostNameRE += "|^[^-][a-zA-Z0-9_-]*"; }
		return "(" + hostNameRE + ")" + portRE; // String

	},

	url: function(flags){
		// summary:
		//		Builds a regular expression that matches a URL
		// flags: Object?
		//		- flags.scheme  Can be true, false, or [true, false].
		//		-   This means: required, not allowed, or match either one.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(!("scheme" in flags)){ flags.scheme = [true, false]; }

		// Scheme RE
		var protocolRE = regexp.buildGroupRE(flags.scheme,
			function(q){ if(q){ return "(https?|ftps?)\\://"; } return ""; }
		);

		// Path and query and anchor RE
		var pathRE = "(/(?:[^?#\\s/]+/)*(?:[^?#\\s/]+(?:\\?[^?#\\s/]*)?(?:#[A-Za-z][\\w.:-]*)?)?)?";

		return protocolRE + dxregexp.host(flags) + pathRE;
	},

	emailAddress: function(flags){
		// summary:
		//		Builds a regular expression that matches an email address
		// flags: Object?
		//		- flags.allowCruft  Allow address like `<mailto:foo@yahoo.com>`.  Default is false.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
		flags.allowPort = false; // invalid in email addresses

		// user name RE per rfc5322
		var usernameRE = "([!#-'*+\\-\\/-9=?A-Z^-~]+[.])*[!#-'*+\\-\\/-9=?A-Z^-~]+";

		// build emailAddress RE
		var emailAddressRE = usernameRE + "@" + dxregexp.host(flags);

		// Allow email addresses with cruft
		if ( flags.allowCruft ) {
			emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
		}

		return emailAddressRE; // String
	},

	emailAddressList: function(flags){
		// summary:
		//		Builds a regular expression that matches a list of email addresses.
		// flags: Object?
		//		- flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
		//		- flags in regexp.emailAddress can be applied.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.listSeparator != "string"){ flags.listSeparator = "\\s;,"; }

		// build a RE for an Email Address List
		var emailAddressRE = dxregexp.emailAddress(flags);
		var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" +
			emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";

		return emailAddressListRE; // String
	},
	
	numberFormat: function(flags){
		// summary:
		//		Builds a regular expression to match any sort of number based format
		// description:
		//		Use this method for phone numbers, social security numbers, zip-codes, etc.
		//		The RE can match one format or one of multiple formats.
		//
		//		Format:
		//
		//		- #        Stands for a digit, 0-9.
		//		- ?        Stands for an optional digit, 0-9 or nothing.
		//		- All other characters must appear literally in the expression.
		//
		// example:
		//		- "(###) ###-####"		-    ->   (510) 542-9742
		//		- "(###) ###-#### x#???" ->   (510) 542-9742 x153
		//		- "###-##-####"		- 		-   ->   506-82-1089		-    i.e. social security number
		//		- "#####-####"		- 		-    ->   98225-1649		- 		- i.e. zip code
		//
		// flags:  Object?
		//		- flags.format  A string or an Array of strings for multiple formats.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.format == "undefined"){ flags.format = "###-###-####"; }

		// Converts a number format to RE.
		var digitRE = function(format){
			// escape all special characters, except '?'
			return regexp.escapeString(format, "?")
				// Now replace '?' with Regular Expression
				.replace(/\?/g, "\\d?")
				// replace # with Regular Expression
				.replace(/#/g, "\\d")
			;
		};

		// build RE for multiple number formats
		return regexp.buildGroupRE(flags.format, digitRE); //String
	},
	
	ca: {

		postalCode: function(){
			// summary:
			//		String regular Express to match Canadain Postal Codes
			return "([A-Z][0-9][A-Z] [0-9][A-Z][0-9])";
		},

		province: function(){
			// summary:
			//		a regular expression to match Canadian Province Abbreviations
			return "(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)";
		}

	},
	
	us:{
		state: function(flags){
			// summary:
			//		A regular expression to match US state and territory abbreviations
			// flags: Object?
			//		- flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
			//		- flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.

			// assign default values to missing parameters
			flags = (typeof flags == "object") ? flags : {};
			if(typeof flags.allowTerritories != "boolean"){ flags.allowTerritories = true; }
			if(typeof flags.allowMilitary != "boolean"){ flags.allowMilitary = true; }

			// state RE
			var statesRE =
				"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" +
				"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";

			// territories RE
			var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";

			// military states RE
			var militaryRE = "AA|AE|AP";

			// Build states and territories RE
			if(flags.allowTerritories){ statesRE += "|" + territoriesRE; }
			if(flags.allowMilitary){ statesRE += "|" + militaryRE; }

			return "(" + statesRE + ")"; // String
		}

	}
	
};

return dxregexp;

});

},
'dojox/main':function(){
define(["dojo/_base/kernel"], function(dojo) {
	// module:
	//		dojox/main

	/*=====
	return {
		// summary:
		//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.
		//		Apps should require modules from the dojox packages directly, rather than loading this module.
	};
	=====*/

	return dojo.dojox;
});
},
'dojox/validate/web':function(){
define(["./_base", "./regexp"], function(validate, xregexp){

validate.isIpAddress = function(value, flags) {
	// summary:
	//		Validates an IP address
	// description:
	//		Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	//		Supports 2 formats for Ipv6.
	// value: String
	// flags: Object?
	//		All flags are boolean with default = true.
	//
	//		- flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	//		- flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	//		- flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	//		- flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	//		- flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	//		  Case insensitive.  Zero padding allowed.
	//		- flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	//		- flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	//		  followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

	var re = new RegExp("^" + xregexp.ipAddress(flags) + "$", "i");
	return re.test(value); // Boolean
};


validate.isUrl = function(value, flags) {
	// summary:
	//		Checks if a string could be a valid URL
	// value: String
	// flags: Object?
	//		- flags.scheme  Can be true, false, or [true, false].
	//		  This means: required, not allowed, or either.
	//		- flags in regexp.host can be applied.
	//		- flags in regexp.ipAddress can be applied.
	//		- flags in regexp.tld can be applied.

	var re = new RegExp("^" + xregexp.url(flags) + "$", "i");
	return re.test(value); // Boolean
};

validate.isEmailAddress = function(value, flags) {
	// summary:
	//		Checks if a string could be a valid email address
	// value: String
	// flags: Object?
	//		- flags.allowCruft  Allow address like `<mailto:foo@yahoo.com>`.  Default is false.
	//		- flags in regexp.host can be applied.
	//		- flags in regexp.ipAddress can be applied.
	//		- flags in regexp.tld can be applied.

	var re = new RegExp("^" + xregexp.emailAddress(flags) + "$", "i");
	return re.test(value); // Boolean
};

validate.isEmailAddressList = function(value, flags) {
	// summary:
	//		Checks if a string could be a valid email address list.
	// value: String
	// flags: Object?
	//		- flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
	//		- flags in regexp.emailAddress can be applied.
	//		- flags in regexp.host can be applied.
	//		- flags in regexp.ipAddress can be applied.
	//		- flags in regexp.tld can be applied.

	var re = new RegExp("^" + xregexp.emailAddressList(flags) + "$", "i");
	return re.test(value); // Boolean
};

validate.getEmailAddressList = function(value, flags) {
	// summary:
	//		Check if value is an email address list. If an empty list
	//		is returned, the value didn't pass the test or it was empty.
	// value: String
	// flags: Object?
	//		An object (same as dojo.validate.isEmailAddressList)

	if(!flags) { flags = {}; }
	if(!flags.listSeparator) { flags.listSeparator = "\\s;,"; }

	if ( validate.isEmailAddressList(value, flags) ) {
		return value.split(new RegExp("\\s*[" + flags.listSeparator + "]\\s*")); // Array
	}
	return []; // Array
};

return validate;
});

},
'dojox/xml/parser':function(){
define(['dojo/_base/kernel', 'dojo/_base/lang', 'dojo/_base/array', 'dojo/_base/window', 'dojo/_base/sniff'], function(dojo){

dojo.getObject("xml.parser", true, dojox);

//DOM type to int value for reference.
//Ints make for more compact code than full constant names.
//ELEMENT_NODE                  = 1;
//ATTRIBUTE_NODE                = 2;
//TEXT_NODE                     = 3;
//CDATA_SECTION_NODE            = 4;
//ENTITY_REFERENCE_NODE         = 5;
//ENTITY_NODE                   = 6;
//PROCESSING_INSTRUCTION_NODE   = 7;
//COMMENT_NODE                  = 8;
//DOCUMENT_NODE                 = 9;
//DOCUMENT_TYPE_NODE            = 10;
//DOCUMENT_FRAGMENT_NODE        = 11;
//NOTATION_NODE                 = 12;

dojox.xml.parser.parse = function(/*String?*/ str, /*String?*/ mimetype){
	// summary:
	//		cross-browser implementation of creating an XML document object from null, empty string, and XML text..
	//
	// str:
	//		Optional text to create the document from.  If not provided, an empty XML document will be created.
	//		If str is empty string "", then a new empty document will be created.
	// mimetype:
	//		Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.
	var _document = dojo.doc;
	var doc;

	mimetype = mimetype || "text/xml";
	if(str && dojo.trim(str) && "DOMParser" in dojo.global){
		//Handle parsing the text on Mozilla based browsers etc..
		var parser = new DOMParser();
		doc = parser.parseFromString(str, mimetype);
		var de = doc.documentElement;
		var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
		if(de.nodeName == "parsererror" && de.namespaceURI == errorNS){
			var sourceText = de.getElementsByTagNameNS(errorNS, 'sourcetext')[0];
			if(sourceText){
				sourceText = sourceText.firstChild.data;
			}
        	throw new Error("Error parsing text " + de.firstChild.data + " \n" + sourceText);
		}
		return doc;

	}else if("ActiveXObject" in dojo.global){
		//Handle IE.
		var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
		var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
		dojo.some(dp, function(p){
			try{
				doc = new ActiveXObject(p);
			}catch(e){ return false; }
			return true;
		});
		if(str && doc){
			doc.async = false;
			doc.loadXML(str);
			var pe = doc.parseError;
			if(pe.errorCode !== 0){
				throw new Error("Line: " + pe.line + "\n" +
					"Col: " + pe.linepos + "\n" +
					"Reason: " + pe.reason + "\n" +
					"Error Code: " + pe.errorCode + "\n" +
					"Source: " + pe.srcText);
			}
		}
		if(doc){
			return doc; //DOMDocument
		}
	}else if(_document.implementation && _document.implementation.createDocument){
		if(str && dojo.trim(str) && _document.createElement){
			//Everyone else that we couldn't get to work.  Fallback case.
			// FIXME: this may change all tags to uppercase!
			var tmp = _document.createElement("xml");
			tmp.innerHTML = str;
			var xmlDoc = _document.implementation.createDocument("foo", "", null);
			dojo.forEach(tmp.childNodes, function(child){
				xmlDoc.importNode(child, true);
			});
			return xmlDoc;	//	DOMDocument
		}else{
			return _document.implementation.createDocument("", "", null); // DOMDocument
		}
	}
	return null;	//	null
};

dojox.xml.parser.textContent = function(/*Node*/node, /*String?*/text){
	// summary:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	// description:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//		This function can also update the text of a node by replacing all child
	//		content of the node.
	// node:
	//		The node to get the text off of or set the text on.
	// text:
	//		Optional argument of the text to apply to the node.
	if(arguments.length>1){
		var _document = node.ownerDocument || dojo.doc;  //Preference is to get the node owning doc first or it may fail
		dojox.xml.parser.replaceChildren(node, _document.createTextNode(text));
		return text;	//	String
	}else{
		if(node.textContent !== undefined){ //FF 1.5 -- remove?
			return node.textContent;	//	String
		}
		var _result = "";
		if(node){
			dojo.forEach(node.childNodes, function(child){
				switch(child.nodeType){
					case 1: // ELEMENT_NODE
					case 5: // ENTITY_REFERENCE_NODE
						_result += dojox.xml.parser.textContent(child);
						break;
					case 3: // TEXT_NODE
					case 2: // ATTRIBUTE_NODE
					case 4: // CDATA_SECTION_NODE
						_result += child.nodeValue;
				}
			});
		}
		return _result;	//	String
	}
};

dojox.xml.parser.replaceChildren = function(/*Element*/node, /*Node|Array*/ newChildren){
	// summary:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// description:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// node:
	//		The node to modify the children on
	// newChildren:
	//		The children to add to the node.  It can either be a single Node or an
	//		array of Nodes.
	var nodes = [];

	if(dojo.isIE){
		dojo.forEach(node.childNodes, function(child){
			nodes.push(child);
		});
	}

	dojox.xml.parser.removeChildren(node);
	dojo.forEach(nodes, dojo.destroy);

	if(!dojo.isArray(newChildren)){
		node.appendChild(newChildren);
	}else{
		dojo.forEach(newChildren, function(child){
			node.appendChild(child);
		});
	}
};

dojox.xml.parser.removeChildren = function(/*Element*/node){
	// summary:
	//		removes all children from node and returns the count of children removed.
	//		The children nodes are not destroyed. Be sure to call dojo.destroy on them
	//		after they are not used anymore.
	// node:
	//		The node to remove all the children from.
	var count = node.childNodes.length;
	while(node.hasChildNodes()){
		node.removeChild(node.firstChild);
	}
	return count; // int
};


dojox.xml.parser.innerXML = function(/*Node*/node){
	// summary:
	//		Implementation of MS's innerXML function.
	// node:
	//		The node from which to generate the XML text representation.
	if(node.innerXML){
		return node.innerXML;	//	String
	}else if(node.xml){
		return node.xml;		//	String
	}else if(typeof XMLSerializer != "undefined"){
		return (new XMLSerializer()).serializeToString(node);	//	String
	}
	return null;
};

return dojox.xml.parser;

});

},
'jquery/jquery':function(){
/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function(global, factory) {

    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

    // Can't do this because several apps including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    // Support: Firefox 18+
    //

    var arr = [];

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};



    var
    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,

        version = "2.1.1",

        // Define a local copy of jQuery
        jQuery = function(selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        },

        // Support: Android<4.1
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function(all, letter) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            return num != null ?

            // Return just the one element from the set
            (num < 0 ? this[num + this.length] : this[num]) :

            // Return all the elements in a clean array
            slice.call(this);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },

        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function() {
            return this.eq(0);
        },

        last: function() {
            return this.eq(-1);
        },

        eq: function(i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function() {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function(msg) {
            throw new Error(msg);
        },

        noop: function() {},

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray,

        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },

        isNumeric: function(obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
        },

        isPlainObject: function(obj) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }

            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },

        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            // Support: Android < 4.0, iOS < 6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },

        // Evaluates a script in a global context
        globalEval: function(code) {
            var script,
            indirect = eval;

            code = jQuery.trim(code);

            if (code) {
                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval
                    indirect(code);
                }
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },

        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function(obj, callback, args) {
            var value,
            i = 0,
                length = obj.length,
                isArray = isArraylike(obj);

            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1
        trim: function(text) {
            return text == null ?
                "" : (text + "").replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret,
                    typeof arr === "string" ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        merge: function(first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function(elems, callback, invert) {
            var callbackInverse,
            matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var value,
            i = 0,
                length = elems.length,
                isArray = isArraylike(elems),
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var tmp, args, proxy;

            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: Date.now,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArraylike(obj) {
        var length = obj.length,
            type = jQuery.type(obj);

        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }

        if (obj.nodeType === 1 && length) {
            return true;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
    }
    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v1.10.19
     * http://sizzlejs.com/
     *
     * Copyright 2013 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2014-04-18
     */ (function(window) {

        var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,

        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,

        // Instance-specific data
        expando = "sizzle" + -(new Date()),
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            },

            // General-purpose constants
            strundefined = typeof undefined,
            MAX_NEGATIVE = 1 << 31,

            // Instance methods
            hasOwn = ({}).hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            // Use a stripped-down indexOf if we can't use a native one
            indexOf = arr.indexOf || function(elem) {
                var i = 0,
                    len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            },

            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

            // Regular expressions

            // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
            whitespace = "[\\x20\\t\\r\\n\\f]",
            // http://www.w3.org/TR/css3-syntax/#characters
            characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

            // Loosely modeled on CSS identifier characters
            // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
            // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
            identifier = characterEncoding.replace("w", "w#"),

            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
            // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace +
            // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                "*\\]",

            pseudos = ":(" + characterEncoding + ")(?:\\((" +
            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
            // 1. quoted (capture 3; capture 4 or capture 5)
            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
            // 2. simple (capture 6)
            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
            // 3. anything else (capture 2)
            ".*" +
                ")\\)|)",

            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),

            matchExpr = {
                "ID": new RegExp("^#(" + characterEncoding + ")"),
                "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                "ATTR": new RegExp("^" + attributes),
                "PSEUDO": new RegExp("^" + pseudos),
                "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                    "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                // For use in libraries implementing .is()
                // We use this for POS matching in `select`
                "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },

            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,

            rnative = /^[^{]+\{\s*\[native \w/,

            // Easily-parseable/retrievable ID or TAG or CLASS selectors
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

            rsibling = /[+~]/,
            rescape = /'|\\/g,

            // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 0x10000;
                // NaN means non-codepoint
                // Support: Firefox<24
                // Workaround erroneous numeric interpretation of +"0x"
                return high !== high || escapedWhitespace ? escaped : high < 0 ?
                // BMP codepoint
                String.fromCharCode(high + 0x10000) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
            };

        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(
            (arr = slice.call(preferredDoc.childNodes)),
            preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ?

                // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                } :

                // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length,
                        i = 0;
                    // Can't trust NodeList.length
                    while ((target[j++] = els[i++])) {}
                    target.length = j - 1;
                }
            };
        }

        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType,
            // QSA vars
            i, groups, old, nid, newContext, newSelector;

            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }

            context = context || document;
            results = results || [];

            if (!selector || typeof selector !== "string") {
                return results;
            }

            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }

            if (documentIsHTML && !seed) {

                // Shortcuts
                if ((match = rquickExpr.exec(selector))) {
                    // Speed-up: Sizzle("#ID")
                    if ((m = match[1])) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document (jQuery #6963)
                            if (elem && elem.parentNode) {
                                // Handle the case where IE, Opera, and Webkit return items
                                // by name instead of ID
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            // Context is not a document
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }

                        // Speed-up: Sizzle("TAG")
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;

                        // Speed-up: Sizzle(".CLASS")
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }

                // QSA path
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;

                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);

                        if ((old = context.getAttribute("id"))) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";

                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }

                    if (newSelector) {
                        try {
                            push.apply(results,
                            newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }

            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }

        /**
         * Create key-value caches of limited size
         * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
         *	deleting the oldest entry
         */
        function createCache() {
            var keys = [];

            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()];
                }
                return (cache[key + " "] = value);
            }
            return cache;
        }

        /**
         * Mark a function for special use by Sizzle
         * @param {Function} fn The function to mark
         */
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }

        /**
         * Support testing using an element
         * @param {Function} fn Passed the created div and expects a boolean result
         */
        function assert(fn) {
            var div = document.createElement("div");

            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                // Remove from its parent by default
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                // release memory in IE
                div = null;
            }
        }

        /**
         * Adds the same handler for all of the specified attrs
         * @param {String} attrs Pipe-separated list of attributes
         * @param {Function} handler The method that will be applied
         */
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"),
                i = attrs.length;

            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }

        /**
         * Checks document order of two siblings
         * @param {Element} a
         * @param {Element} b
         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
         */
        function siblingCheck(a, b) {
            var cur = b && a,
                diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

            // Use IE sourceIndex if available on both nodes
            if (diff) {
                return diff;
            }

            // Check if b follows a
            if (cur) {
                while ((cur = cur.nextSibling)) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }

            return a ? 1 : -1;
        }

        /**
         * Returns a function to use in pseudos for input types
         * @param {String} type
         */
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }

        /**
         * Returns a function to use in pseudos for buttons
         * @param {String} type
         */
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }

        /**
         * Returns a function to use in pseudos for positionals
         * @param {Function} fn
         */
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j,
                    matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length;

                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[(j = matchIndexes[i])]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }

        /**
         * Checks a node for validity as a Sizzle context
         * @param {Element|Object=} context
         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
         */
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }

        // Expose support vars for convenience
        support = Sizzle.support = {};

        /**
         * Detects XML nodes
         * @param {Element|Object} elem An element or a document
         * @returns {Boolean} True iff elem is a non-HTML XML node
         */
        isXML = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        /**
         * Sets document-related variables once based on the current document
         * @param {Element|Object} [doc] An element or document object to use to set the document
         * @returns {Object} Returns the current document
         */
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare,
            doc = node ? node.ownerDocument || node : preferredDoc,
                parent = doc.defaultView;

            // If no document and documentElement is available, return
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }

            // Set our document
            document = doc;
            docElem = doc.documentElement;

            // Support tests
            documentIsHTML = !isXML(doc);

            // Support: IE>8
            // If iframe document is assigned to "document" variable and if iframe has been reloaded,
            // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
            // IE6-8 do not support the defaultView property so parent will be undefined
            if (parent && parent !== parent.top) {
                // IE11 does not have attachEvent, so all must suffer
                if (parent.addEventListener) {
                    parent.addEventListener("unload", function() {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", function() {
                        setDocument();
                    });
                }
            }

            /* Attributes
	---------------------------------------------------------------------- */

            // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });

            /* getElement(s)By*
	---------------------------------------------------------------------- */

            // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });

            // Check if getElementsByClassName can be trusted
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                // Support: Safari<4
                // Catch class over-caching
                div.firstChild.className = "i";
                // Support: Opera<10
                // Catch gEBCN failure to find non-leading classes
                return div.getElementsByClassName("i").length === 2;
            });

            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });

            // ID find and filter
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                // Support: IE6/7
                // getElementById is not reliable as a find shortcut
                delete Expr.find["ID"];

                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }

            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function(tag, context) {
                var elem,
                tmp = [],
                    i = 0,
                    results = context.getElementsByTagName(tag);

                // Filter out possible comments
                if (tag === "*") {
                    while ((elem = results[i++])) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }

                    return tmp;
                }
                return results;
            };

            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };

            /* QSA/matchesSelector
	---------------------------------------------------------------------- */

            // QSA and matchesSelector support

            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];

            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See http://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];

            if ((support.qsa = rnative.test(doc.querySelectorAll))) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (div.querySelectorAll("[msallowclip^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }

                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });

                assert(function(div) {
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");

                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }

                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }

            if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {

                assert(function(div) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(div, "div");

                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }

            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

            /* Contains
	---------------------------------------------------------------------- */
            hasCompare = rnative.test(docElem.compareDocumentPosition);

            // Element contains another
            // Purposefully does not implement inclusive descendent
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !! (bup && bup.nodeType === 1 && (
                adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while ((b = b.parentNode)) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };

            /* Sorting
	---------------------------------------------------------------------- */

            // Document order sorting
            sortOrder = hasCompare ? function(a, b) {

                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }

                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

                // Otherwise we know they are disconnected
                1;

                // Disconnected nodes
                if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                    // Choose the first element that is related to our preferred document
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }

                    // Maintain original order
                    return sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0;
                }

                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                var cur,
                i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [a],
                    bp = [b];

                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0;

                    // If the nodes are siblings, we can do a quick check
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }

                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while ((cur = cur.parentNode)) {
                    ap.unshift(cur);
                }
                cur = b;
                while ((cur = cur.parentNode)) {
                    bp.unshift(cur);
                }

                // Walk down the tree looking for a discrepancy
                while (ap[i] === bp[i]) {
                    i++;
                }

                return i ?
                // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) :

                // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };

            return doc;
        };

        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };

        Sizzle.matchesSelector = function(elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");

            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                try {
                    var ret = matches.call(elem, expr);

                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }

            return Sizzle(expr, document, null, [elem]).length > 0;
        };

        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };

        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            var fn = Expr.attrHandle[name.toLowerCase()],
                // Don't get fooled by Object.prototype properties (jQuery #13807)
                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };

        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        /**
         * Document sorting and removing duplicates
         * @param {ArrayLike} results
         */
        Sizzle.uniqueSort = function(results) {
            var elem,
            duplicates = [],
                j = 0,
                i = 0;

            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);

            if (hasDuplicate) {
                while ((elem = results[i++])) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }

            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;

            return results;
        };

        /**
         * Utility function for retrieving the text value of an array of DOM nodes
         * @param {Array|Element} elem
         */
        getText = Sizzle.getText = function(elem) {
            var node,
            ret = "",
                i = 0,
                nodeType = elem.nodeType;

            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while ((node = elem[i++])) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    // Traverse its children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes

            return ret;
        };

        Expr = Sizzle.selectors = {

            // Can be adjusted by the user
            cacheLength: 50,

            createPseudo: markFunction,

            match: matchExpr,

            attrHandle: {},

            find: {},

            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },

            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }

                    return match.slice(0, 4);
                },

                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                    match[1] = match[1].toLowerCase();

                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +((match[7] + match[8]) || match[3] === "odd");

                        // other types prohibit arguments
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }

                    return match;
                },

                "PSEUDO": function(match) {
                    var excess,
                    unquoted = !match[6] && match[2];

                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }

                    // Accept quoted arguments as-is
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";

                        // Strip excess characters from unquoted arguments
                    } else if (unquoted && rpseudo.test(unquoted) &&
                    // Get excess from tokenize (recursively)
                    (excess = tokenize(unquoted, true)) &&
                    // advance to the next closing parenthesis
                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },

            filter: {

                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },

                "CLASS": function(className) {
                    var pattern = classCache[className + " "];

                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                    });
                },

                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }

                        result += "";

                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },

                "CHILD": function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth",
                        forward = type.slice(-4) !== "last",
                        ofType = what === "of-type";

                    return first === 1 && last === 0 ?

                    // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    } :

                    function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType;

                        if (parent) {

                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while ((node = node[dir])) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }

                            start = [forward ? parent.firstChild : parent.lastChild];

                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];

                                while ((node = ++nodeIndex && node && node[dir] ||

                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop())) {

                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                        break;
                                    }
                                }

                                // Use previously-cached element index if available
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];

                                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                            } else {
                                // Use the same loop as above to seek `elem` from the start
                                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {

                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                        }

                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        }
                    };
                },

                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
                    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx,
                            matched = fn(seed, argument),
                                i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }

                    return fn;
                }
            },

            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));

                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem,
                        unmatched = matcher(seed, null, xml, []),
                            i = seed.length;

                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if ((elem = unmatched[i])) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),

                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),

                "contains": markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),

                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),

                // Miscellaneous
                "target": function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },

                "root": function(elem) {
                    return elem === docElem;
                },

                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !! (elem.type || elem.href || ~elem.tabIndex);
                },

                // Boolean properties
                "enabled": function(elem) {
                    return elem.disabled === false;
                },

                "disabled": function(elem) {
                    return elem.disabled === true;
                },

                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return (nodeName === "input" && !! elem.checked) || (nodeName === "option" && !! elem.selected);
                },

                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },

                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },

                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },

                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },

                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },

                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" &&

                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },

                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [0];
                }),

                "last": createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1];
                }),

                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),

                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };

        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        // Add button/input type pseudos
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }

        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();

        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type,
            soFar, groups, preFilters,
            cached = tokenCache[selector + " "];

            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }

            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;

            while (soFar) {

                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push((tokens = []));
                }

                matched = false;

                // Combinators
                if ((match = rcombinators.exec(soFar))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }

                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }

                if (!matched) {
                    break;
                }
            }

            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
            // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };

        function toSelector(tokens) {
            var i = 0,
                len = tokens.length,
                selector = "";
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                checkNonElements = base && dir === "parentNode",
                doneName = done++;

            return combinator.first ?
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while ((elem = elem[dir])) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } :

            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, outerCache,
                newCache = [dirruns, doneName];

                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                if (xml) {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

                                // Assign to newCache so results back-propagate to previous elements
                                return (newCache[2] = oldCache[2]);
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                outerCache[dir] = newCache;

                                // A match means we're done; a fail means we have to keep checking
                                if ((newCache[2] = matcher(elem, context, xml))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }

        function multipleContexts(selector, contexts, results) {
            var i = 0,
                len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem,
            newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null;

            for (; i < len; i++) {
                if ((elem = unmatched[i])) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }

            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem,
                preMap = [],
                    postMap = [],
                    preexisting = results.length,

                    // Get initial elements from seed or context
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                    matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,

                    matcherOut = matcher ?
                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                    postFinder || (seed ? preFilter : preexisting || postFilter) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results : matcherIn;

                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }

                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if ((elem = temp[i])) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }

                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i])) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push((matcherIn[i] = elem));
                                }
                            }
                            postFinder(null, (matcherOut = []), temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }

                    // Add elements to results, through postFinder if defined
                } else {
                    matcherOut = condense(
                    matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j,
            len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "],
                i = leadingRelative ? 1 : 0,

                // The foundational matcher ensures that elements are reachable from top-level context(s)
                matchContext = addCombinator(function(elem) {
                    return elem === checkContext;
                }, implicitRelative, true),
                matchAnyContext = addCombinator(function(elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true),
                matchers = [function(elem, context, xml) {
                    return (!leadingRelative && (xml || context !== outermostContext)) || (
                    (checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                }];

            for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(
                        i > 1 && elementMatcher(matchers),
                        i > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"),
                        matcher,
                        i < j && matcherFromTokens(tokens.slice(i, j)),
                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                        j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }

            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function(seed, context, xml, results, outermost) {
                    var elem, j, matcher,
                    matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        // We must always have either seed elements or outermost context
                        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                        // Use integer dirruns iff this is the outermost matcher
                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                        len = elems.length;

                    if (outermost) {
                        outermostContext = context !== document && context;
                    }

                    // Add elements passing elementMatchers directly to results
                    // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                    // Support: IE<9, Safari
                    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while ((matcher = elementMatchers[j++])) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }

                        // Track unmatched elements for set filters
                        if (bySet) {
                            // They will have gone through all possible matchers
                            if ((elem = !matcher && elem)) {
                                matchedCount--;
                            }

                            // Lengthen the array for every element, matched or not
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }

                    // Apply set filters to unmatched elements
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while ((matcher = setMatchers[j++])) {
                            matcher(unmatched, setMatched, context, xml);
                        }

                        if (seed) {
                            // Reintegrate element matches to eliminate the need for sorting
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }

                            // Discard index placeholder values to get only actual matches
                            setMatched = condense(setMatched);
                        }

                        // Add matches to results
                        push.apply(results, setMatched);

                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                        if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {

                            Sizzle.uniqueSort(results);
                        }
                    }

                    // Override manipulation of globals by nested matchers
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }

                    return unmatched;
                };

            return bySet ? markFunction(superMatcher) : superMatcher;
        }

        compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
            var i,
            setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[selector + " "];

            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }

                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };

        /**
         * A low-level selection function that works with Sizzle's compiled
         *  selector functions
         * @param {String|Function} selector A selector or a pre-compiled
         *  selector function built with Sizzle.compile
         * @param {Element} context
         * @param {Array} [results]
         * @param {Array} [seed] A set of elements to match against
         */
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find,
            compiled = typeof selector === "function" && selector,
                match = !seed && tokenize((selector = compiled.selector || selector));

            results = results || [];

            // Try to minimize operations if there is no seed and only one group
            if (match.length === 1) {

                // Take a shortcut and set the context if the root selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;

                        // Precompiled matchers will still verify ancestry, so step up a level
                    } else if (compiled) {
                        context = context.parentNode;
                    }

                    selector = selector.slice(tokens.shift().value.length);
                }

                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];

                    // Abort if we hit a combinator
                    if (Expr.relative[(type = token.type)]) {
                        break;
                    }
                    if ((find = Expr.find[type])) {
                        // Search, expanding context for leading sibling combinators
                        if ((seed = find(
                        token.matches[0].replace(runescape, funescape),
                        rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {

                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }

                            break;
                        }
                    }
                }
            }

            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(
            seed,
            context, !documentIsHTML,
            results,
            rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };

        // One-time assignments

        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

        // Support: Chrome<14
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !! hasDuplicate;

        // Initialize against the default document
        setDocument();

        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(div1) {
            // Should return 1, but returns 4 (following)
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });

        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }

        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }

        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }

        return Sizzle;

    })(window);



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;



    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



    var risSimple = /^.[^:#\[\.,]*$/;

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });

        }

        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return (elem === qualifier) !== not;
            });

        }

        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }

            qualifier = jQuery.filter(qualifier, elements);
        }

        return jQuery.grep(elements, function(elem) {
            return (indexOf.call(qualifier, elem) >= 0) !== not;
        });
    }

    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };

    jQuery.fn.extend({
        find: function(selector) {
            var i,
            len = this.length,
                ret = [],
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
            false).length;
        }
    });


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

        init = jQuery.fn.init = function(selector, context) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(
                        match[1],
                        context && context.nodeType ? context.ownerDocument || context : document,
                        true));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                // Properties of context are called as methods if possible
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if (elem && elem.parentNode) {
                            // Inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) :
                // Execute immediately if ready is not present
                selector(jQuery);
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray(selector, this);
        };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [],
                truncate = until !== undefined;

            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },

        sibling: function(n, elem) {
            var matched = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }

            return matched;
        }
    });

    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function() {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function(selectors, context) {
            var cur,
            i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    // Always skip document fragments
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

                        matched.push(cur);
                        break;
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function(elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }

            // index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },

        add: function(selector, context) {
            return this.pushStack(
            jQuery.unique(
            jQuery.merge(this.get(), jQuery(selector, context))));
        },

        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }

    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnotwhite = (/\S+/g);



    // String to Object options format cache
    var optionsCache = {};

    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function(options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);

        var // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to know if list is currently firing
        firing,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // Actual callback list
        list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if (list) {
                        // First, we save the current length
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function(_, arg) {
                                var type = jQuery.type(arg);
                                if (type === "function") {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== "string") {
                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if (firing) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if (list) {
                        jQuery.each(arguments, function(_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function(fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !! (list && list.length);
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith(this, arguments);
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };


    jQuery.extend({

        Deferred: function(func) {
            var tuples = [
            // action, add listener, listener list, final state
            ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                ["notify", "progress", jQuery.Callbacks("memory")]
            ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[tuple[1]](function() {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise()
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject)
                                            .progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function(subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = slice.call(arguments),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function(i, contexts, values) {
                    return function(value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!(--remaining)) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise()
                            .done(updateFunc(i, resolveContexts, resolveValues))
                            .fail(deferred.reject)
                            .progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
    });


    // The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function(fn) {
        // Add the callback
        jQuery.ready.promise().done(fn);

        return this;
    };

    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function(wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }

    jQuery.ready.promise = function(obj) {
        if (!readyList) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready);

            } else {

                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed, false);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };

    // Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();




    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!jQuery.isFunction(value)) {
                raw = true;
            }

            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }

        return chainable ? elems :

        // Gets
        bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };


    /**
     * Determines whether an object can have data
     */
    jQuery.acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };


    function Data() {
        // Support: Android < 4,
        // Old WebKit does not have Object.preventExtensions/freeze method,
        // return new empty object instead with no [[set]] accessor
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });

        this.expando = jQuery.expando + Math.random();
    }

    Data.uid = 1;
    Data.accepts = jQuery.acceptData;

    Data.prototype = {
        key: function(owner) {
            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return the key for a frozen object.
            if (!Data.accepts(owner)) {
                return 0;
            }

            var descriptor = {},
            // Check if the owner object already has a cache key
            unlock = owner[this.expando];

            // If not, create one
            if (!unlock) {
                unlock = Data.uid++;

                // Secure it in a non-enumerable, non-writable property
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);

                    // Support: Android < 4
                    // Fallback to a less secure definition
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }

            // Ensure the cache object
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }

            return unlock;
        },
        set: function(owner, data, value) {
            var prop,
            // There may be an unlock assigned to this node,
            // if there is no entry for this "owner", create one inline
            // and set the unlock as though an owner entry had always existed
            unlock = this.key(owner),
                cache = this.cache[unlock];

            // Handle: [ owner, key, value ] args
            if (typeof data === "string") {
                cache[data] = value;

                // Handle: [ owner, { properties } ] args
            } else {
                // Fresh assignments by object are shallow copied
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                    // Otherwise, copy the properties one-by-one to the cache object
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            // Either a valid cache is found, or will be created.
            // New caches will be created and the unlock returned,
            // allowing direct access to the newly created
            // empty data object. A valid owner object must be provided.
            var cache = this.cache[this.key(owner)];

            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || ((key && typeof key === "string") && value === undefined)) {

                stored = this.get(owner, key);

                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }

            // [*]When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel,
            unlock = this.key(owner),
                cache = this.cache[unlock];

            if (key === undefined) {
                this.cache[unlock] = {};

            } else {
                // Support array or space separated string of keys
                if (jQuery.isArray(key)) {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    // Try the string as a key before any manipulation
                    if (key in cache) {
                        name = [key, camel];
                    } else {
                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ? [name] : (name.match(rnotwhite) || []);
                    }
                }

                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(
            this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();

    var data_user = new Data();



    /*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
                    +
                    data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },

        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },

        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to data_priv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },

        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data,
            elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);

                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }

            return access(this, function(value) {
                var data,
                camelKey = jQuery.camelCase(key);

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // with the key as-is
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to get data from the cache
                    // with the key camelized
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function() {
                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = data_user.get(this, camelKey);

                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    data_user.set(this, camelKey, value);

                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });


    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function(elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function() {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);

                // ensure a hooks for this queue
                jQuery._queueHooks(this, type);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp,
            count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHidden = function(elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };

    var rcheckableType = (/^(?:checkbox|radio)$/i);



    (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // #11217 - WebKit loses check when the name is after the checked attribute
        // Support: Windows Web Apps (WWA)
        // `name` and `type` need .setAttribute for WWA
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE9-IE11+
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !! div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;



    support.focusinBubbles = "onfocusin" in window;


    var
    rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

        global: {},

        add: function(elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = data_priv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = data_priv.hasData(elem) && data_priv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },

        trigger: function(event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special,
            eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [event] : jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                event.type = i > 1 ? bubbleType : special.bindType || type;

                // jQuery handler
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function(event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);

            var i, j, ret, matched, handleObj,
            handlerQueue = [],
                args = slice.call(arguments),
                handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                    // Triggered event must either 1) have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
                            .apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function(event, handlers) {
            var i, matches, sel, handleObj,
            handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }

            return handlerQueue;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body,
                button = original.button;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
            }
        },

        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
            type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome < 28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function(event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },

        simulate: function(type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
            new jQuery.Event(),
            event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };

    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };

    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
            // Support: Android < 4.0
            src.returnValue === false ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // Support: Chrome 15+
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function(event) {
                var ret,
                target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    // Create "bubbling" focus and blur events
    // Support: Firefox, Chrome, Safari
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };

            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);

                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
            var origFn, type;

            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });


    var
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

        // We have to close these tags to support XHTML (#13200)
        wrapMap = {

            // Support: IE 9
            option: [1, "<select multiple='multiple'>", "</select>"],

            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

            _default: [0, "", ""]
        };

    // Support: IE 9
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // Support: 1.x compatibility
    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

        elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);

        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            data_priv.set(
            elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);

            data_user.set(dest, udataCur);
        }
    }

    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];

        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }

    // Support: IE >= 9
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements,
            clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);

            // Support: IE >= 9
            // Fix Cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j,
            fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;

            for (; i < l; i++) {
                elem = elems[i];

                if (elem || elem === 0) {

                    // Add nodes directly
                    if (jQuery.type(elem) === "object") {
                        // Support: QtWebKit
                        // jQuery.merge because push.apply(_, arraylike) throws
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                        // Convert non-html into a text node
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));

                        // Convert html into DOM nodes
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));

                        // Deserialize a standard representation
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }

                        // Support: QtWebKit
                        // jQuery.merge because push.apply(_, arraylike) throws
                        jQuery.merge(nodes, tmp.childNodes);

                        // Remember the top-level container
                        tmp = fragment.firstChild;

                        // Fixes #12346
                        // Support: Webkit, IE
                        tmp.textContent = "";
                    }
                }
            }

            // Remove wrapper from fragment
            fragment.textContent = "";

            i = 0;
            while ((elem = nodes[i++])) {

                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }

                contains = jQuery.contains(elem.ownerDocument, elem);

                // Append to fragment
                tmp = getAll(fragment.appendChild(elem), "script");

                // Preserve script evaluation history
                if (contains) {
                    setGlobalEval(tmp);
                }

                // Capture executables
                if (scripts) {
                    j = 0;
                    while ((elem = tmp[j++])) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }

            return fragment;
        },

        cleanData: function(elems) {
            var data, elem, type, key,
            special = jQuery.event.special,
                i = 0;

            for (;
            (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];

                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            // Discard any remaining `private` data
                            delete data_priv.cache[key];
                        }
                    }
                }
                // Discard any remaining `user` data
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });

    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },

        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        remove: function(selector, keepData /* Internal Use Only */ ) {
            var elem,
            elems = selector ? jQuery.filter(selector, this) : this,
                i = 0;

            for (;
            (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }

                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }

            return this;
        },

        empty: function() {
            var elem,
            i = 0;

            for (;
            (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {},
                i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = value.replace(rxhtmlTag, "<$1></$2>");

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function() {
            var arg = arguments[0];

            // Make the changes, replacing each context element with the new content
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;

                jQuery.cleanData(getAll(this));

                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });

            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },

        detach: function(selector) {
            return this.remove(selector, true);
        },

        domManip: function(args, callback) {

            // Flatten any nested arrays
            args = concat.apply([], args);

            var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction(value);

            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }

            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }

                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for (; i < l; i++) {
                        node = fragment;

                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);

                            // Keep references to cloned scripts for later restoration
                            if (hasScripts) {
                                // Support: QtWebKit
                                // jQuery.merge because push.apply(_, arraylike) throws
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }

                        callback.call(this[i], node, i);
                    }

                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;

                        // Reenable scripts
                        jQuery.map(scripts, restoreScript);

                        // Evaluate executable scripts on first document insertion
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                                if (node.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }

            return this;
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems,
            ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });


    var iframe,
    elemdisplay = {};

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),

            // getDefaultComputedStyle might be reliably used only on attached element
            display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?

            // Use of this method is a temporary fix (more like optmization) until something better comes along,
            // since it was removed from specification and supported only in FF
            style.display : jQuery.css(elem[0], "display");

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];

        if (!display) {
            display = actualDisplay(nodeName, doc);

            // If the simple way fails, read from inside an iframe
            if (display === "none" || !display) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[0].contentDocument;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return display;
    }
    var rmargin = (/^margin/);

    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function(elem) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    };



    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret,
        style = elem.style;

        computed = computed || getStyles(elem);

        // Support: IE9
        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }

        if (computed) {

            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }

            // Support: iOS < 6
            // A tribute to the "awesome hack by Dean Edwards"
            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if (rnumnonpx.test(ret) && rmargin.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?
        // Support: IE
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }


    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due to missing dependency),
                    // remove it.
                    // Since there are no other hooks for marginRight, remove the whole object.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.

                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }


    (function() {
        var pixelPositionVal, boxSizingReliableVal,
        docElem = document.documentElement,
            container = document.createElement("div"),
            div = document.createElement("div");

        if (!div.style) {
            return;
        }

        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
            "position:absolute";
        container.appendChild(div);

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText =
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);

            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";

            docElem.removeChild(container);
        }

        // Support: node.js jsdom
        // Don't assume that getComputedStyle is a property of the global object
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    // This test is executed only once but we still do memoizing
                    // since we can use the boxSizingReliable pre-computing.
                    // No need to check if the test was already performed, though.
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    // Support: Android 2.3
                    // Check if div with explicit width and no margin-right incorrectly
                    // gets computed margin-right based on width of container. (#3333)
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // This support function is only executed once so no memoizing is needed.
                    var ret,
                    marginDiv = div.appendChild(document.createElement("div"));

                    // Reset CSS: box-sizing; display; margin; border; padding
                    marginDiv.style.cssText = div.style.cssText =
                    // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                        "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);

                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

                    docElem.removeChild(container);

                    return ret;
                }
            });
        }
    })();


    // A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name,
        old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };


    var
    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
        rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),

        cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = ["Webkit", "O", "Moz", "ms"];

    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {

        // shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }

        return origName;
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ?
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0,

            val = 0;

        for (; i < 4; i += 2) {
            // both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }

            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // at this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // at this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return (val + augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles)) + "px";
    }

    function showHide(elements, show) {
        var display, elem, hidden,
        values = [],
            index = 0,
            length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);

                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": "cssFloat"
        },

        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
            origName = jQuery.camelCase(name),
                style = elem.style;

            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set. See: #7116
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function(elem, name, extra, styles) {
            var val, num, hooks,
            origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            //convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });

    jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },

            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(
                elem,
                name,
                extra,
                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                styles) : 0);
            }
        };
    });

    // Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,

    function(elem, computed) {
        if (computed) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap(elem, {
                "display": "inline-block"
            },
            curCSS, [elem, "marginRight"]);
        }
    });

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0,
                    expanded = {},

                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len,
                map = {},
                i = 0;

                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });


    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased,
            hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;

                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }

                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Support: IE9
    // Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };

    jQuery.fx = Tween.prototype.init;

    // Back Compat <1.8 extension point
    jQuery.fx.step = {};




    var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function(prop, value) {
                var tween = this.createTween(prop, value),
                    target = tween.cur(),
                    parts = rfxnum.exec(value),
                    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

                    // Starting value computation is required for potential unit mismatches
                    start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                    scale = 1,
                    maxIterations = 20;

                if (start && start[3] !== unit) {
                    // Trust units reported by jQuery.css
                    unit = unit || start[3];

                    // Make sure we update the tween properties later on
                    parts = parts || [];

                    // Iteratively approximate from a nonzero starting point
                    start = +target || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*
                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery.style(tween.elem, prop, start + unit);

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                }

                // Update tween properties
                if (parts) {
                    start = tween.start = +start || +target || 0;
                    tween.unit = unit;
                    // If a +=/-= token was provided, we're doing a relative animation
                    tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                }

                return tween;
            }]
        };

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return (fxNow = jQuery.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
        i = 0,
            attrs = {
                height: type
            };

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // we're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
        anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = data_priv.get(elem, "fxshow");

        // handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, "display");

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;

                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
        stopped,
        index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function() {
                // don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function() {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {}
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                    animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function(gotoEnd) {
                    var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // resolve when we played the last frame
                    // otherwise, reject
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(
        jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));

        // attach callbacks from options
        return animation.progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.split(" ");
            }

            var prop,
            index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },

        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });

    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {

            // show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show()

            // animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function() {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || data_priv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = data_priv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index,
                data = data_priv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // enable finishing flag on private data
                data.finish = true;

                // empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
        i = 0,
            timers = jQuery.timers;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };

    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };


    (function() {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: iOS 5.1, Android 4.x, Android 2.3
        // Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
        support.checkOn = input.value !== "";

        // Must access the parent to make an option select properly
        // Support: IE9, IE10
        support.optSelected = opt.selected;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Check if an input maintains its value after becoming a radio
        // Support: IE9, IE10
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret,
            nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);

                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }

            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {
                ret = jQuery.find.attr(elem, name);

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
            }
        },

        removeAttr: function(elem, value) {
            var name, propName,
            i = 0,
                attrNames = value && value.match(rnotwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;

                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                        // Set corresponding property to false
                        elem[propName] = false;
                    }

                    elem.removeAttribute(name);
                }
            }
        },

        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });

    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });




    var rfocusable = /^(?:input|select|textarea|button)$/i;

    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },

        prop: function(elem, name, value) {
            var ret, hooks, notxml,
            nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);

            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },

        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });

    // Support: IE9+
    // Selectedness for an option in an optgroup can be inaccurate
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });




    var rclass = /[\t\r\n\f]/g;

    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue,
            proceed = typeof value === "string" && value,
                i = 0,
                len = this.length;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (proceed) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = (value || "").match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") :
                        " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue,
            proceed = arguments.length === 0 || typeof value === "string" && value,
                i = 0,
                len = this.length;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") :
                        "");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function(value, stateVal) {
            var type = typeof value;

            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function() {
                if (type === "string") {
                    // toggle individual class names
                    var className,
                    i = 0,
                        self = jQuery(this),
                        classNames = value.match(rnotwhite) || [];

                    while ((className = classNames[i++])) {
                        // check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        data_priv.set(this, "__className__", this.className);
                    }

                    // If the element has a class name or if we're passed "false",
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },

        hasClass: function(selector) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }

            return false;
        }
    });




    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction,
            elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function(i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val :
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option,
                    options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ? max : one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // IE6-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&
                        // Don't return options that are disabled or in a disabled optgroup
                        (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function(elem, value) {
                    var optionSet, option,
                    options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];
                        if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
                            optionSet = true;
                        }
                    }

                    // force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                // Support: Webkit
                // "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });




    // Return jQuery for attributes-only inclusion


    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });

    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },

        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });


    var nonce = jQuery.now();

    var rquery = (/\?/);



    // Support: Android 2.3
    // Workaround failure to string-cast null input
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };


    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE9
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };


    var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*");

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
            i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {
                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
        seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
        contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return {
            state: "success",
            data: response
        };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ?

            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function(url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,
            // URL without anti-cache param
            cacheURL,
            // Response headers
            responseHeadersString,
            responseHeaders,
            // timeout handle
            timeoutTimer,
            // Cross-domain detection vars
            parts,
            // To know if global events are to be dispatched
            fireGlobals,
            // Loop variable
            i,
            // Create the final options object
            s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = "canceled",
                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function(key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function(name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function(type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function(map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            } else {
                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function(statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
                .replace(rprotocol, ajaxLocParts[1] + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !! (parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ?

                    // If there is already a '_' parameter, set its value
                    cacheURL.replace(rts, "$1_=" + nonce++) :

                    // Otherwise add one to the end
                    cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
            s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();
            }

            // aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });


    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };


    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;

            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function() {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function() {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });


    jQuery.expr.filters.hidden = function(elem) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix,
        s = [],
            add = function(key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
            // Serialize the form elements
            jQuery.each(a, function() {
                add(this.name, this.value);
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };

    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function() {
                var type = this.type;

                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            })
                .map(function(i, elem) {
                var val = jQuery(this).val();

                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });


    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };

    var xhrId = 0,
        xhrCallbacks = {},
        xhrSuccessStatus = {
            // file protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

    // Support: IE9
    // Open requests must be manually aborted on unload (#5280)
    if (window.ActiveXObject) {
        jQuery(window).on("unload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }

    support.cors = !! xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !! xhrSupported;

    jQuery.ajaxTransport(function(options) {
        var callback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i,
                    xhr = options.xhr(),
                        id = ++xhrId;

                    xhr.open(options.type, options.url, options.async, options.username, options.password);

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(
                                    // file: protocol always yields status 0; see #8605, #14207
                                    xhr.status,
                                    xhr.statusText);
                                } else {
                                    complete(
                                    xhrSuccessStatus[xhr.status] || xhr.status,
                                    xhr.statusText,
                                    // Support: IE9
                                    // Accessing binary-data responseText throws an exception
                                    // (#11426)
                                    typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined,
                                    xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    xhr.onerror = callback("error");

                    // Create the abort callback
                    callback = xhrCallbacks[id] = callback("abort");

                    try {
                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on(
                        "load error",
                    callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
            "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[callbackName] = overwritten;

                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });




    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = jQuery.buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };


    // Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }

        var selector, type, response,
        self = this,
            off = url.indexOf(" ");

        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                // Otherwise use the full result
                responseText);

            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
            });
        }

        return this;
    };




    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };




    var docElem = window.document.documentElement;

    /**
     * Gets a window from an element
     */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);

            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            var docElem, win,
            elem = this[0],
                box = {
                    top: 0,
                    left: 0
                },
                doc = elem && elem.ownerDocument;

            if (!doc) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }

            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },

        position: function() {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset,
            elem = this[0],
                parentOffset = {
                    top: 0,
                    left: 0
                };

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") {
                // We assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();

            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;

                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || docElem;
            });
        }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset,
                    top ? val : window.pageYOffset);

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });

    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,

        function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                return access(this, function(elem, type, value) {
                    var doc;

                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(
                        elem.body["scroll" + name], doc["scroll" + name],
                        elem.body["offset" + name], doc["offset" + name],
                        doc["client" + name]);
                    }

                    return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) :

                    // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });


    // The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    };

    jQuery.fn.andSelf = jQuery.fn.addBack;




    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }




    var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in
    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }




    return jQuery;

}));

},
'bootstrap/bootstrap':function(){
// wrapped by build app
define(["dojo","dijit","dojox"], function(dojo,dijit,dojox){
/*!
 * Bootstrap v3.3.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.0'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.0
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.0'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', e.type == 'focus')
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.0'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var delta = direction == 'prev' ? -1 : 1
    var activeIndex = this.getItemIndex(active)
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.0
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.0'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true,
    trigger: '[data-toggle="collapse"]'
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.find('> .panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && option == 'show') options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $.extend({}, $this.data(), { trigger: this })

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.0'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.divider):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.0'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .prependTo(this.$element)
        .on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus.call(this.$element[0])
            : this.hide.call(this)
        }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    if (document.body.clientWidth >= window.innerWidth) return 0
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.0
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.0'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.0
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.0'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var process  = $.proxy(this.process, this)

    this.$body          = $('body')
    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', process)
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.0'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = 'offset'
    var offsetBase   = 0

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()

    var self     = this

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.0
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.0'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      =
    this.unpin        =
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.0'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && colliderTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $('body').height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

});

},
'moment/moment':function(){
//! moment.js
//! version : 2.9.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.9.0',
        // the global-scope this is NOT the global object in Node.js
        globalScope = (typeof global !== 'undefined' && (typeof window === 'undefined' || window === global.window)) ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-', '15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = this.utcOffset(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = this.utcOffset(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            x    : function () {
                return this.valueOf();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'],

        updateInProgress = false;

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // thie is not supposed to happen
            return hour;
        }
    }

    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            moment.updateOffset(this);
            updateInProgress = false;
        }
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
                                           m._a[SECOND] !== 0 ||
                                           m._a[MILLISECOND] !== 0)) ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/utcOffset equivalent to
    // model.
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ?
                    +input : +moment(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName, format, strict) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = moment.utc([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LTS : 'h:mm:ss A',
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },


        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom, [now]) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',
        _ordinalParse : /\d{1,2}/,

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        firstDayOfWeek : function () {
            return this._week.dow;
        },

        firstDayOfYear : function () {
            return this._week.doy;
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'x':
            return parseTokenOffsetMs;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function utcOffsetFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(
                            input.match(/\d{1,2}/)[0], 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._meridiem = input;
            // config._isPm = config._locale.isPM(input);
            break;
        // HOUR
        case 'h' : // fall through to hh
        case 'hh' :
            config._pf.bigHour = true;
            /* falls through */
        case 'H' : // fall through to HH
        case 'HH' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX OFFSET (MILLISECONDS)
        case 'x':
            config._d = new Date(toInt(input));
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = utcOffsetFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day || normalizedInput.date,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR],
                config._meridiem);
        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        res = new Moment(config);
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    moment.isDate = isDate;

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d - ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(this._dateUtcOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4,
                anchor, diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month' || units === 'quarter') {
                output = monthDiff(this, that);
                if (units === 'quarter') {
                    output = output / 3;
                } else if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're locat/utc/offset
            // or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },

        isBefore: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },

        isBetween: function (from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        },

        isSame: function (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        zone : deprecate(
                'moment().zone is deprecated, use moment().utcOffset instead. ' +
                'https://github.com/moment/moment/issues/1779',
                function (input, keepLocalTime) {
                    if (input != null) {
                        if (typeof input !== 'string') {
                            input = -input;
                        }

                        this.utcOffset(input, keepLocalTime);

                        return this;
                    } else {
                        return -this.utcOffset();
                    }
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        utcOffset : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = utcOffsetFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateUtcOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(input - offset, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }

                return this;
            } else {
                return this._isUTC ? offset : this._dateUtcOffset();
            }
        },

        isLocal : function () {
            return !this._isUTC;
        },

        isUtcOffset : function () {
            return this._isUTC;
        },

        isUtc : function () {
            return this._isUTC && this._offset === 0;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.utcOffset(this._tzm);
            } else if (typeof this._i === 'string') {
                this.utcOffset(utcOffsetFromString(this._i));
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).utcOffset();
            }

            return (this.utcOffset() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            var unit;
            if (typeof units === 'object') {
                for (unit in units) {
                    this.set(unit, units[unit]);
                }
            }
            else {
                units = normalizeUnits(units);
                if (typeof this[units] === 'function') {
                    this[units](value);
                }
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateUtcOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }

    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    // alias isUtc for dev-friendliness
    moment.fn.isUTC = moment.fn.isUtc;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        },

        toJSON : function () {
            return this.toISOString();
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define(function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

},
'fastclick/fastclick':function(){

(function () {
	'use strict';
	
	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @version 1.0.3
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */
	
	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/
	
	
	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} options The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;
	
		options = options || {};
	
		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;
	
	
		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;
	
	
		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;
	
	
		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;
	
	
		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;
	
	
		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;
	
	
		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;
	
	
		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;
	
		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;
	
		if (FastClick.notNeeded(layer)) {
			return;
		}
	
		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}
	
	
		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}
	
		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}
	
		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);
	
		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};
	
			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}
	
		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {
	
			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}
	
	
	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;
	
	
	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);
	
	
	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
	
	
	/**
	 * iOS 6.0(+?) requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);
	
	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
	
	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {
	
		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}
	
			break;
		case 'input':
	
			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}
	
			break;
		case 'label':
		case 'video':
			return true;
		}
	
		return (/\bneedsclick\b/).test(target.className);
	};
	
	
	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}
	
			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};
	
	
	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;
	
		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}
	
		touch = event.changedTouches[0];
	
		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};
	
	FastClick.prototype.determineEventType = function(targetElement) {
	
		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}
	
		return 'click';
	};
	
	
	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;
	
		// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};
	
	
	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;
	
		scrollParent = targetElement.fastClickScrollParent;
	
		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}
	
				parentElement = parentElement.parentElement;
			} while (parentElement);
		}
	
		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};
	
	
	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	
		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}
	
		return eventTarget;
	};
	
	
	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;
	
		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}
	
		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];
	
		if (deviceIsIOS) {
	
			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}
	
			if (!deviceIsIOS4) {
	
				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}
	
				this.lastTouchIdentifier = touch.identifier;
	
				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}
	
		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;
	
		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;
	
		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}
	
		return true;
	};
	
	
	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;
	
		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}
	
		return false;
	};
	
	
	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}
	
		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}
	
		return true;
	};
	
	
	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {
	
		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}
	
		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}
	
		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};
	
	
	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
	
		if (!this.trackingClick) {
			return true;
		}
	
		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}
	
		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;
	
		this.lastClickTime = event.timeStamp;
	
		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;
	
		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];
	
			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}
	
		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}
	
				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {
	
			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}
	
			this.focus(targetElement);
			this.sendClick(targetElement, event);
	
			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}
	
			return false;
		}
	
		if (deviceIsIOS && !deviceIsIOS4) {
	
			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}
	
		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}
	
		return false;
	};
	
	
	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};
	
	
	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {
	
		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}
	
		if (event.forwardedTouchEvent) {
			return true;
		}
	
		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}
	
		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
	
			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {
	
				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}
	
			// Cancel the event
			event.stopPropagation();
			event.preventDefault();
	
			return false;
		}
	
		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};
	
	
	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;
	
		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}
	
		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}
	
		permitted = this.onMouse(event);
	
		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}
	
		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};
	
	
	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;
	
		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}
	
		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};
	
	
	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
	
		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}
	
		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
	
		if (chromeVersion) {
	
			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');
	
				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
	
			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}
	
		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
	
			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');
	
				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}
	
		// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none') {
			return true;
		}
	
		return false;
	};
	
	
	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} options The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};
	
	
	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
	
		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

},
'bootstrap-datetimepicker/bootstrap-datetimepicker':function(){
// wrapped by build app
define(["dojo","dijit","dojox"], function(dojo,dijit,dojox){
/**
 * @license
 * =========================================================
 * bootstrap-datetimepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Contributions:
 *  - Andrew Rowls
 *  - Thiago de Arruda
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================
 */

(function($) {

  // Picker object
  var smartPhone = (window.orientation != undefined);
  var DateTimePicker = function(element, options) {
    this.id = dpgId++;
    this.init(element, options);
  };

  var dateToDate = function(dt) {
    if (typeof dt === 'string') {
      return new Date(dt);
    }
    return dt;
  };

  DateTimePicker.prototype = {
    constructor: DateTimePicker,

    init: function(element, options) {
      var icon;
      if (!(options.pickTime || options.pickDate))
        throw new Error('Must choose at least one picker');
      this.options = options;
      this.$element = $(element);
      this.language = options.language in dates ? options.language : 'en'
      this.pickDate = options.pickDate;
      this.pickTime = options.pickTime;
      this.isInput = this.$element.is('input');
      this.component = false;
      if (this.$element.find('.input-append') || this.$element.find('.input-prepend'))
          this.component = this.$element.find('.add-on');
      this.format = options.format;
      if (!this.format) {
        if (this.isInput) this.format = this.$element.data('format');
        else this.format = this.$element.find('input').data('format');
        if (!this.format) this.format = 'MM/dd/yyyy';
      }
      this._compileFormat();
      if (this.component) {
        icon = this.component.find('i');
      }
      if (this.pickTime) {
        if (icon && icon.length) this.timeIcon = icon.data('time-icon');
        if (!this.timeIcon) this.timeIcon = 'icon-time';
        icon.addClass(this.timeIcon);
      }
      if (this.pickDate) {
        if (icon && icon.length) this.dateIcon = icon.data('date-icon');
        if (!this.dateIcon) this.dateIcon = 'icon-calendar';
        icon.removeClass(this.timeIcon);
        icon.addClass(this.dateIcon);
      }
      this.widget = $(getTemplate(this.timeIcon, options.pickDate, options.pickTime, options.pick12HourFormat, options.pickSeconds, options.collapse)).appendTo('body');
      this.minViewMode = options.minViewMode||this.$element.data('date-minviewmode')||0;
      if (typeof this.minViewMode === 'string') {
        switch (this.minViewMode) {
          case 'months':
            this.minViewMode = 1;
          break;
          case 'years':
            this.minViewMode = 2;
          break;
          default:
            this.minViewMode = 0;
          break;
        }
      }
      this.viewMode = options.viewMode||this.$element.data('date-viewmode')||0;
      if (typeof this.viewMode === 'string') {
        switch (this.viewMode) {
          case 'months':
            this.viewMode = 1;
          break;
          case 'years':
            this.viewMode = 2;
          break;
          default:
            this.viewMode = 0;
          break;
        }
      }
      this.startViewMode = this.viewMode;
      this.weekStart = options.weekStart||this.$element.data('date-weekstart')||0;
      this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
      this.setStartDate(options.startDate || this.$element.data('date-startdate'));
      this.setEndDate(options.endDate || this.$element.data('date-enddate'));
      this.fillDow();
      this.fillMonths();
      this.fillHours();
      this.fillMinutes();
      this.fillSeconds();
      this.update();
      this.showMode();
      this._attachDatePickerEvents();
    },

    show: function(e) {
      this.widget.show();
      this.height = this.component ? this.component.outerHeight() : this.$element.outerHeight();
      this.place();
      this.$element.trigger({
        type: 'show',
        date: this._date
      });
      this._attachDatePickerGlobalEvents();
      if (e) {
        e.stopPropagation();
        e.preventDefault();
      }
    },

    disable: function(){
          this.$element.find('input').prop('disabled',true);
          this._detachDatePickerEvents();
    },
    enable: function(){
          this.$element.find('input').prop('disabled',false);
          this._attachDatePickerEvents();
    },

    hide: function() {
      // Ignore event if in the middle of a picker transition
      var collapse = this.widget.find('.collapse')
      for (var i = 0; i < collapse.length; i++) {
        var collapseData = collapse.eq(i).data('collapse');
        if (collapseData && collapseData.transitioning)
          return;
      }
      this.widget.hide();
      this.viewMode = this.startViewMode;
      this.showMode();
      this.set();
      this.$element.trigger({
        type: 'hide',
        date: this._date
      });
      this._detachDatePickerGlobalEvents();
    },

    set: function() {
      var formatted = '';
      if (!this._unset) formatted = this.formatDate(this._date);
      if (!this.isInput) {
        if (this.component){
          var input = this.$element.find('input');
          input.val(formatted);
          this._resetMaskPos(input);
        }
        this.$element.data('date', formatted);
      } else {
        this.$element.val(formatted);
        this._resetMaskPos(this.$element);
      }
    },

    setValue: function(newDate) {
      if (!newDate) {
        this._unset = true;
      } else {
        this._unset = false;
      }
      if (typeof newDate === 'string') {
        this._date = this.parseDate(newDate);
      } else if(newDate) {
        this._date = new Date(newDate);
      }
      this.set();
      this.viewDate = UTCDate(this._date.getUTCFullYear(), this._date.getUTCMonth(), 1, 0, 0, 0, 0);
      this.fillDate();
      this.fillTime();
    },

    getDate: function() {
      if (this._unset) return null;
      return new Date(this._date.valueOf());
    },

    setDate: function(date) {
      if (!date) this.setValue(null);
      else this.setValue(date.valueOf());
    },

    setStartDate: function(date) {
      if (date instanceof Date) {
        this.startDate = date;
      } else if (typeof date === 'string') {
        this.startDate = new UTCDate(date);
        if (! this.startDate.getUTCFullYear()) {
          this.startDate = -Infinity;
        }
      } else {
        this.startDate = -Infinity;
      }
      if (this.viewDate) {
        this.update();
      }
    },

    setEndDate: function(date) {
      if (date instanceof Date) {
        this.endDate = date;
      } else if (typeof date === 'string') {
        this.endDate = new UTCDate(date);
        if (! this.endDate.getUTCFullYear()) {
          this.endDate = Infinity;
        }
      } else {
        this.endDate = Infinity;
      }
      if (this.viewDate) {
        this.update();
      }
    },

    getLocalDate: function() {
      if (this._unset) return null;
      var d = this._date;
      return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(),
                      d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    },

    setLocalDate: function(localDate) {
      if (!localDate) this.setValue(null);
      else
        this.setValue(Date.UTC(
          localDate.getFullYear(),
          localDate.getMonth(),
          localDate.getDate(),
          localDate.getHours(),
          localDate.getMinutes(),
          localDate.getSeconds(),
          localDate.getMilliseconds()));
    },

    place: function(){
      var position = 'absolute';
      var offset = this.component ? this.component.offset() : this.$element.offset();
      this.width = this.component ? this.component.outerWidth() : this.$element.outerWidth();
      offset.top = offset.top + this.height;

      var $window = $(window);
      
      if ( this.options.width != undefined ) {
        this.widget.width( this.options.width );
      }
      
      if ( this.options.orientation == 'left' ) {
        this.widget.addClass( 'left-oriented' );
        offset.left   = offset.left - this.widget.width() + 20;
      }
      
      if (this._isInFixed()) {
        position = 'fixed';
        offset.top -= $window.scrollTop();
        offset.left -= $window.scrollLeft();
      }

      if ($window.width() < offset.left + this.widget.outerWidth()) {
        offset.right = $window.width() - offset.left - this.width;
        offset.left = 'auto';
        this.widget.addClass('pull-right');
      } else {
        offset.right = 'auto';
        this.widget.removeClass('pull-right');
      }

      this.widget.css({
        position: position,
        top: offset.top,
        left: offset.left,
        right: offset.right
      });
    },

    notifyChange: function(){
      this.$element.trigger({
        type: 'changeDate',
        date: this.getDate(),
        localDate: this.getLocalDate()
      });
    },

    update: function(newDate){
      var dateStr = newDate;
      if (!dateStr) {
        if (this.isInput) {
          dateStr = this.$element.val();
        } else {
          dateStr = this.$element.find('input').val();
        }
        if (dateStr) {
          this._date = this.parseDate(dateStr);
        }
        if (!this._date) {
          var tmp = new Date()
          this._date = UTCDate(tmp.getFullYear(),
                              tmp.getMonth(),
                              tmp.getDate(),
                              tmp.getHours(),
                              tmp.getMinutes(),
                              tmp.getSeconds(),
                              tmp.getMilliseconds())
        }
      }
      this.viewDate = UTCDate(this._date.getUTCFullYear(), this._date.getUTCMonth(), 1, 0, 0, 0, 0);
      this.fillDate();
      this.fillTime();
    },

    fillDow: function() {
      var dowCnt = this.weekStart;
      var html = $('<tr>');
      while (dowCnt < this.weekStart + 7) {
        html.append('<th class="dow">' + dates[this.language].daysMin[(dowCnt++) % 7] + '</th>');
      }
      this.widget.find('.datepicker-days thead').append(html);
    },

    fillMonths: function() {
      var html = '';
      var i = 0
      while (i < 12) {
        html += '<span class="month">' + dates[this.language].monthsShort[i++] + '</span>';
      }
      this.widget.find('.datepicker-months td').append(html);
    },

    fillDate: function() {
      var year = this.viewDate.getUTCFullYear();
      var month = this.viewDate.getUTCMonth();
      var currentDate = UTCDate(
        this._date.getUTCFullYear(),
        this._date.getUTCMonth(),
        this._date.getUTCDate(),
        0, 0, 0, 0
      );
      var startYear  = typeof this.startDate === 'object' ? this.startDate.getUTCFullYear() : -Infinity;
      var startMonth = typeof this.startDate === 'object' ? this.startDate.getUTCMonth() : -1;
      var endYear  = typeof this.endDate === 'object' ? this.endDate.getUTCFullYear() : Infinity;
      var endMonth = typeof this.endDate === 'object' ? this.endDate.getUTCMonth() : 12;

      this.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
      this.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
      this.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

      this.widget.find('.datepicker-days th:eq(1)').text(
        dates[this.language].months[month] + ' ' + year);

      var prevMonth = UTCDate(year, month-1, 28, 0, 0, 0, 0);
      var day = DPGlobal.getDaysInMonth(
        prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
      prevMonth.setUTCDate(day);
      prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.weekStart + 7) % 7);
      if ((year == startYear && month <= startMonth) || year < startYear) {
        this.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
      }
      if ((year == endYear && month >= endMonth) || year > endYear) {
        this.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
      }

      var nextMonth = new Date(prevMonth.valueOf());
      nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
      nextMonth = nextMonth.valueOf();
      var html = [];
      var row;
      var clsName;
      while (prevMonth.valueOf() < nextMonth) {
        if (prevMonth.getUTCDay() === this.weekStart) {
          row = $('<tr>');
          html.push(row);
        }
        clsName = '';
        if (prevMonth.getUTCFullYear() < year ||
            (prevMonth.getUTCFullYear() == year &&
             prevMonth.getUTCMonth() < month)) {
          clsName += ' old';
        } else if (prevMonth.getUTCFullYear() > year ||
                   (prevMonth.getUTCFullYear() == year &&
                    prevMonth.getUTCMonth() > month)) {
          clsName += ' new';
        }
        if (prevMonth.valueOf() === currentDate.valueOf()) {
          clsName += ' active';
        }
        if ((prevMonth.valueOf() + 86400000) <= this.startDate) {
          clsName += ' disabled';
        }
        if (prevMonth.valueOf() > this.endDate) {
          clsName += ' disabled';
        }
        row.append('<td class="day' + clsName + '">' + prevMonth.getUTCDate() + '</td>');
        prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
      }
      this.widget.find('.datepicker-days tbody').empty().append(html);
      var currentYear = this._date.getUTCFullYear();

      var months = this.widget.find('.datepicker-months').find(
        'th:eq(1)').text(year).end().find('span').removeClass('active');
      if (currentYear === year) {
        months.eq(this._date.getUTCMonth()).addClass('active');
      }
      if (currentYear - 1 < startYear) {
        this.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
      }
      if (currentYear + 1 > endYear) {
        this.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
      }
      for (var i = 0; i < 12; i++) {
        if ((year == startYear && startMonth > i) || (year < startYear)) {
          $(months[i]).addClass('disabled');
        } else if ((year == endYear && endMonth < i) || (year > endYear)) {
          $(months[i]).addClass('disabled');
        }
      }

      html = '';
      year = parseInt(year/10, 10) * 10;
      var yearCont = this.widget.find('.datepicker-years').find(
        'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
      this.widget.find('.datepicker-years').find('th').removeClass('disabled');
      if (startYear > year) {
        this.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
      }
      if (endYear < year+9) {
        this.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
      }
      year -= 1;
      for (var i = -1; i < 11; i++) {
        html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
        year += 1;
      }
      yearCont.html(html);
    },

    fillHours: function() {
      var table = this.widget.find(
        '.timepicker .timepicker-hours table');
      table.parent().hide();
      var html = '';
      if (this.options.pick12HourFormat) {
        var current = 1;
        for (var i = 0; i < 3; i += 1) {
          html += '<tr>';
          for (var j = 0; j < 4; j += 1) {
             var c = current.toString();
             html += '<td class="hour">' + padLeft(c, 2, '0') + '</td>';
             current++;
          }
          html += '</tr>'
        }
      } else {
        var current = 0;
        for (var i = 0; i < 6; i += 1) {
          html += '<tr>';
          for (var j = 0; j < 4; j += 1) {
             var c = current.toString();
             html += '<td class="hour">' + padLeft(c, 2, '0') + '</td>';
             current++;
          }
          html += '</tr>'
        }
      }
      table.html(html);
    },

    fillMinutes: function() {
      var table = this.widget.find(
        '.timepicker .timepicker-minutes table');
      table.parent().hide();
      var html = '';
      var current = 0;
      for (var i = 0; i < 5; i++) {
        html += '<tr>';
        for (var j = 0; j < 4; j += 1) {
          var c = current.toString();
          html += '<td class="minute">' + padLeft(c, 2, '0') + '</td>';
          current += 3;
        }
        html += '</tr>';
      }
      table.html(html);
    },

    fillSeconds: function() {
      var table = this.widget.find(
        '.timepicker .timepicker-seconds table');
      table.parent().hide();
      var html = '';
      var current = 0;
      for (var i = 0; i < 5; i++) {
        html += '<tr>';
        for (var j = 0; j < 4; j += 1) {
          var c = current.toString();
          html += '<td class="second">' + padLeft(c, 2, '0') + '</td>';
          current += 3;
        }
        html += '</tr>';
      }
      table.html(html);
    },

    fillTime: function() {
      if (!this._date)
        return;
      var timeComponents = this.widget.find('.timepicker span[data-time-component]');
      var table = timeComponents.closest('table');
      var is12HourFormat = this.options.pick12HourFormat;
      var hour = this._date.getUTCHours();
      var period = 'AM';
      if (is12HourFormat) {
        if (hour >= 12) period = 'PM';
        if (hour === 0) hour = 12;
        else if (hour != 12) hour = hour % 12;
        this.widget.find(
          '.timepicker [data-action=togglePeriod]').text(period);
      }
      hour = padLeft(hour.toString(), 2, '0');
      var minute = padLeft(this._date.getUTCMinutes().toString(), 2, '0');
      var second = padLeft(this._date.getUTCSeconds().toString(), 2, '0');
      timeComponents.filter('[data-time-component=hours]').text(hour);
      timeComponents.filter('[data-time-component=minutes]').text(minute);
      timeComponents.filter('[data-time-component=seconds]').text(second);
    },

    click: function(e) {
      e.stopPropagation();
      e.preventDefault();
      this._unset = false;
      var target = $(e.target).closest('span, td, th');
      if (target.length === 1) {
        if (! target.is('.disabled')) {
          switch(target[0].nodeName.toLowerCase()) {
            case 'th':
              switch(target[0].className) {
                case 'switch':
                  this.showMode(1);
                  break;
                case 'prev':
                case 'next':
                  var vd = this.viewDate;
                  var navFnc = DPGlobal.modes[this.viewMode].navFnc;
                  var step = DPGlobal.modes[this.viewMode].navStep;
                  if (target[0].className === 'prev') step = step * -1;
                  vd['set' + navFnc](vd['get' + navFnc]() + step);
                  this.fillDate();
                  this.set();
                  break;
              }
              break;
            case 'span':
              if (target.is('.month')) {
                var month = target.parent().find('span').index(target);
                this.viewDate.setUTCMonth(month);
              } else {
                var year = parseInt(target.text(), 10) || 0;
                this.viewDate.setUTCFullYear(year);
              }
              if (this.viewMode !== 0) {
                this._date = UTCDate(
                  this.viewDate.getUTCFullYear(),
                  this.viewDate.getUTCMonth(),
                  this.viewDate.getUTCDate(),
                  this._date.getUTCHours(),
                  this._date.getUTCMinutes(),
                  this._date.getUTCSeconds(),
                  this._date.getUTCMilliseconds()
                );
                this.notifyChange();
              }
              this.showMode(-1);
              this.fillDate();
              this.set();
              break;
            case 'td':
              if (target.is('.day')) {
                var day = parseInt(target.text(), 10) || 1;
                var month = this.viewDate.getUTCMonth();
                var year = this.viewDate.getUTCFullYear();
                if (target.is('.old')) {
                  if (month === 0) {
                    month = 11;
                    year -= 1;
                  } else {
                    month -= 1;
                  }
                } else if (target.is('.new')) {
                  if (month == 11) {
                    month = 0;
                    year += 1;
                  } else {
                    month += 1;
                  }
                }
                this._date = UTCDate(
                  year, month, day,
                  this._date.getUTCHours(),
                  this._date.getUTCMinutes(),
                  this._date.getUTCSeconds(),
                  this._date.getUTCMilliseconds()
                );
                this.viewDate = UTCDate(
                  year, month, Math.min(28, day) , 0, 0, 0, 0);
                this.fillDate();
                this.set();
                this.notifyChange();
              }
              break;
          }
        }
      }
    },

    actions: {
      incrementHours: function(e) {
        this._date.setUTCHours(this._date.getUTCHours() + 1);
      },

      incrementMinutes: function(e) {
        this._date.setUTCMinutes(this._date.getUTCMinutes() + 1);
      },

      incrementSeconds: function(e) {
        this._date.setUTCSeconds(this._date.getUTCSeconds() + 1);
      },

      decrementHours: function(e) {
        this._date.setUTCHours(this._date.getUTCHours() - 1);
      },

      decrementMinutes: function(e) {
        this._date.setUTCMinutes(this._date.getUTCMinutes() - 1);
      },

      decrementSeconds: function(e) {
        this._date.setUTCSeconds(this._date.getUTCSeconds() - 1);
      },

      togglePeriod: function(e) {
        var hour = this._date.getUTCHours();
        if (hour >= 12) hour -= 12;
        else hour += 12;
        this._date.setUTCHours(hour);
      },

      showPicker: function() {
        this.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
        this.widget.find('.timepicker .timepicker-picker').show();
      },

      showHours: function() {
        this.widget.find('.timepicker .timepicker-picker').hide();
        this.widget.find('.timepicker .timepicker-hours').show();
      },

      showMinutes: function() {
        this.widget.find('.timepicker .timepicker-picker').hide();
        this.widget.find('.timepicker .timepicker-minutes').show();
      },

      showSeconds: function() {
        this.widget.find('.timepicker .timepicker-picker').hide();
        this.widget.find('.timepicker .timepicker-seconds').show();
      },

      selectHour: function(e) {
        var tgt = $(e.target);
        var value = parseInt(tgt.text(), 10);
        if (this.options.pick12HourFormat) {
          var current = this._date.getUTCHours();
          if (current >= 12) {
            if (value != 12) value = (value + 12) % 24;
          } else {
            if (value === 12) value = 0;
            else value = value % 12;
          }
        }
        this._date.setUTCHours(value);
        this.actions.showPicker.call(this);
      },

      selectMinute: function(e) {
        var tgt = $(e.target);
        var value = parseInt(tgt.text(), 10);
        this._date.setUTCMinutes(value);
        this.actions.showPicker.call(this);
      },

      selectSecond: function(e) {
        var tgt = $(e.target);
        var value = parseInt(tgt.text(), 10);
        this._date.setUTCSeconds(value);
        this.actions.showPicker.call(this);
      }
    },

    doAction: function(e) {
      e.stopPropagation();
      e.preventDefault();
      if (!this._date) this._date = UTCDate(1970, 0, 0, 0, 0, 0, 0);
      var action = $(e.currentTarget).data('action');
      var rv = this.actions[action].apply(this, arguments);
      this.set();
      this.fillTime();
      this.notifyChange();
      return rv;
    },

    stopEvent: function(e) {
      e.stopPropagation();
      e.preventDefault();
    },

    // part of the following code was taken from
    // http://cloud.github.com/downloads/digitalBush/jquery.maskedinput/jquery.maskedinput-1.3.js
    keydown: function(e) {
      var self = this, k = e.which, input = $(e.target);
      if (k == 8 || k == 46) {
        // backspace and delete cause the maskPosition
        // to be recalculated
        setTimeout(function() {
          self._resetMaskPos(input);
        });
      }
    },

    keypress: function(e) {
      var k = e.which;
      if (k == 8 || k == 46) {
        // For those browsers which will trigger
        // keypress on backspace/delete
        return;
      }
      var input = $(e.target);
      var c = String.fromCharCode(k);
      var val = input.val() || '';
      val += c;
      var mask = this._mask[this._maskPos];
      if (!mask) {
        return false;
      }
      if (mask.end != val.length) {
        return;
      }
      if (!mask.pattern.test(val.slice(mask.start))) {
        val = val.slice(0, val.length - 1);
        while ((mask = this._mask[this._maskPos]) && mask.character) {
          val += mask.character;
          // advance mask position past static
          // part
          this._maskPos++;
        }
        val += c;
        if (mask.end != val.length) {
          input.val(val);
          return false;
        } else {
          if (!mask.pattern.test(val.slice(mask.start))) {
            input.val(val.slice(0, mask.start));
            return false;
          } else {
            input.val(val);
            this._maskPos++;
            return false;
          }
        }
      } else {
        this._maskPos++;
      }
    },

    change: function(e) {
      var input = $(e.target);
      var val = input.val();
      if (this._formatPattern.test(val)) {
        this.update();
        this.setValue(this._date.getTime());
        this.notifyChange();
        this.set();
      } else if (val && val.trim()) {
        this.setValue(this._date.getTime());
        if (this._date) this.set();
        else input.val('');
      } else {
        if (this._date) {
          this.setValue(null);
          // unset the date when the input is
          // erased
          this.notifyChange();
          this._unset = true;
        }
      }
      this._resetMaskPos(input);
    },

    showMode: function(dir) {
      if (dir) {
        this.viewMode = Math.max(this.minViewMode, Math.min(
          2, this.viewMode + dir));
      }
      this.widget.find('.datepicker > div').hide().filter(
        '.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();
    },

    destroy: function() {
      this._detachDatePickerEvents();
      this._detachDatePickerGlobalEvents();
      this.widget.remove();
      this.$element.removeData('datetimepicker');
      this.component.removeData('datetimepicker');
    },

    formatDate: function(d) {
      return this.format.replace(formatReplacer, function(match) {
        var methodName, property, rv, len = match.length;
        if (match === 'ms')
          len = 1;
        property = dateFormatComponents[match].property
        if (property === 'Hours12') {
          rv = d.getUTCHours();
          if (rv === 0) rv = 12;
          else if (rv !== 12) rv = rv % 12;
        } else if (property === 'Period12') {
          if (d.getUTCHours() >= 12) return 'PM';
          else return 'AM';
	} else if (property === 'UTCYear') {
          rv = d.getUTCFullYear();
          rv = rv.toString().substr(2);   
        } else {
          methodName = 'get' + property;
          rv = d[methodName]();
        }
        if (methodName === 'getUTCMonth') rv = rv + 1;
        return padLeft(rv.toString(), len, '0');
      });
    },

    parseDate: function(str) {
      var match, i, property, methodName, value, parsed = {};
      if (!(match = this._formatPattern.exec(str)))
        return null;
      for (i = 1; i < match.length; i++) {
        property = this._propertiesByIndex[i];
        if (!property)
          continue;
        value = match[i];
        if (/^\d+$/.test(value))
          value = parseInt(value, 10);
        parsed[property] = value;
      }
      return this._finishParsingDate(parsed);
    },

    _resetMaskPos: function(input) {
      var val = input.val();
      for (var i = 0; i < this._mask.length; i++) {
        if (this._mask[i].end > val.length) {
          // If the mask has ended then jump to
          // the next
          this._maskPos = i;
          break;
        } else if (this._mask[i].end === val.length) {
          this._maskPos = i + 1;
          break;
        }
      }
    },

    _finishParsingDate: function(parsed) {
      var year, month, date, hours, minutes, seconds, milliseconds;
      year = parsed.UTCFullYear;
      if (parsed.UTCYear) year = 2000 + parsed.UTCYear;
      if (!year) year = 1970;
      if (parsed.UTCMonth) month = parsed.UTCMonth - 1;
      else month = 0;
      date = parsed.UTCDate || 1;
      hours = parsed.UTCHours || 0;
      minutes = parsed.UTCMinutes || 0;
      seconds = parsed.UTCSeconds || 0;
      milliseconds = parsed.UTCMilliseconds || 0;
      if (parsed.Hours12) {
        hours = parsed.Hours12;
      }
      if (parsed.Period12) {
        if (/pm/i.test(parsed.Period12)) {
          if (hours != 12) hours = (hours + 12) % 24;
        } else {
          hours = hours % 12;
        }
      }
      return UTCDate(year, month, date, hours, minutes, seconds, milliseconds);
    },

    _compileFormat: function () {
      var match, component, components = [], mask = [],
      str = this.format, propertiesByIndex = {}, i = 0, pos = 0;
      while (match = formatComponent.exec(str)) {
        component = match[0];
        if (component in dateFormatComponents) {
          i++;
          propertiesByIndex[i] = dateFormatComponents[component].property;
          components.push('\\s*' + dateFormatComponents[component].getPattern(
            this) + '\\s*');
          mask.push({
            pattern: new RegExp(dateFormatComponents[component].getPattern(
              this)),
            property: dateFormatComponents[component].property,
            start: pos,
            end: pos += component.length
          });
        }
        else {
          components.push(escapeRegExp(component));
          mask.push({
            pattern: new RegExp(escapeRegExp(component)),
            character: component,
            start: pos,
            end: ++pos
          });
        }
        str = str.slice(component.length);
      }
      this._mask = mask;
      this._maskPos = 0;
      this._formatPattern = new RegExp(
        '^\\s*' + components.join('') + '\\s*$');
      this._propertiesByIndex = propertiesByIndex;
    },

    _attachDatePickerEvents: function() {
      var self = this;
      // this handles date picker clicks
      this.widget.on('click', '.datepicker *', $.proxy(this.click, this));
      // this handles time picker clicks
      this.widget.on('click', '[data-action]', $.proxy(this.doAction, this));
      this.widget.on('mousedown', $.proxy(this.stopEvent, this));
      if (this.pickDate && this.pickTime) {
        this.widget.on('click.togglePicker', '.accordion-toggle', function(e) {
          e.stopPropagation();
          var $this = $(this);
          var $parent = $this.closest('ul');
          var expanded = $parent.find('.collapse.in');
          var closed = $parent.find('.collapse:not(.in)');

          if (expanded && expanded.length) {
            var collapseData = expanded.data('collapse');
            if (collapseData && collapseData.transitioning) return;
            expanded.collapse('hide');
            closed.collapse('show')
            $this.find('i').toggleClass(self.timeIcon + ' ' + self.dateIcon);
            self.$element.find('.add-on i').toggleClass(self.timeIcon + ' ' + self.dateIcon);
          }
        });
      }
      if (this.isInput) {
        this.$element.on({
          'focus': $.proxy(this.show, this),
          'change': $.proxy(this.change, this)
        });
        if (this.options.maskInput) {
          this.$element.on({
            'keydown': $.proxy(this.keydown, this),
            'keypress': $.proxy(this.keypress, this)
          });
        }
      } else {
        this.$element.on({
          'change': $.proxy(this.change, this)
        }, 'input');
        if (this.options.maskInput) {
          this.$element.on({
            'keydown': $.proxy(this.keydown, this),
            'keypress': $.proxy(this.keypress, this)
          }, 'input');
        }
        if (this.component){
          this.component.on('click', $.proxy(this.show, this));
        } else {
          this.$element.on('click', $.proxy(this.show, this));
        }
      }
    },

    _attachDatePickerGlobalEvents: function() {
      $(window).on(
        'resize.datetimepicker' + this.id, $.proxy(this.place, this));
      if (!this.isInput) {
        $(document).on(
          'mousedown.datetimepicker' + this.id, $.proxy(this.hide, this));
      }
    },

    _detachDatePickerEvents: function() {
      this.widget.off('click', '.datepicker *', this.click);
      this.widget.off('click', '[data-action]');
      this.widget.off('mousedown', this.stopEvent);
      if (this.pickDate && this.pickTime) {
        this.widget.off('click.togglePicker');
      }
      if (this.isInput) {
        this.$element.off({
          'focus': this.show,
          'change': this.change
        });
        if (this.options.maskInput) {
          this.$element.off({
            'keydown': this.keydown,
            'keypress': this.keypress
          });
        }
      } else {
        this.$element.off({
          'change': this.change
        }, 'input');
        if (this.options.maskInput) {
          this.$element.off({
            'keydown': this.keydown,
            'keypress': this.keypress
          }, 'input');
        }
        if (this.component){
          this.component.off('click', this.show);
        } else {
          this.$element.off('click', this.show);
        }
      }
    },

    _detachDatePickerGlobalEvents: function () {
      $(window).off('resize.datetimepicker' + this.id);
      if (!this.isInput) {
        $(document).off('mousedown.datetimepicker' + this.id);
      }
    },

    _isInFixed: function() {
      if (this.$element) {
        var parents = this.$element.parents();
        var inFixed = false;
        for (var i=0; i<parents.length; i++) {
            if ($(parents[i]).css('position') == 'fixed') {
                inFixed = true;
                break;
            }
        };
        return inFixed;
      } else {
        return false;
      }
    }
  };

  $.fn.datetimepicker = function ( option, val ) {
    return this.each(function () {
      var $this = $(this),
      data = $this.data('datetimepicker'),
      options = typeof option === 'object' && option;
      if (!data) {
        $this.data('datetimepicker', (data = new DateTimePicker(
          this, $.extend({}, $.fn.datetimepicker.defaults,options))));
      }
      if (typeof option === 'string') data[option](val);
    });
  };

  $.fn.datetimepicker.defaults = {
    maskInput: false,
    pickDate: true,
    pickTime: true,
    pick12HourFormat: false,
    pickSeconds: true,
    startDate: -Infinity,
    endDate: Infinity,
    collapse: true
  };
  $.fn.datetimepicker.Constructor = DateTimePicker;
  var dpgId = 0;
  var dates = $.fn.datetimepicker.dates = {
    en: {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
        "Friday", "Saturday", "Sunday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
      daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
      months: ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
        "Aug", "Sep", "Oct", "Nov", "Dec"]
    }
  };

  var dateFormatComponents = {
    dd: {property: 'UTCDate', getPattern: function() { return '(0?[1-9]|[1-2][0-9]|3[0-1])\\b';}},
    MM: {property: 'UTCMonth', getPattern: function() {return '(0?[1-9]|1[0-2])\\b';}},
    yy: {property: 'UTCYear', getPattern: function() {return '(\\d{2})\\b'}},
    yyyy: {property: 'UTCFullYear', getPattern: function() {return '(\\d{4})\\b';}},
    hh: {property: 'UTCHours', getPattern: function() {return '(0?[0-9]|1[0-9]|2[0-3])\\b';}},
    mm: {property: 'UTCMinutes', getPattern: function() {return '(0?[0-9]|[1-5][0-9])\\b';}},
    ss: {property: 'UTCSeconds', getPattern: function() {return '(0?[0-9]|[1-5][0-9])\\b';}},
    ms: {property: 'UTCMilliseconds', getPattern: function() {return '([0-9]{1,3})\\b';}},
    HH: {property: 'Hours12', getPattern: function() {return '(0?[1-9]|1[0-2])\\b';}},
    PP: {property: 'Period12', getPattern: function() {return '(AM|PM|am|pm|Am|aM|Pm|pM)\\b';}}
  };

  var keys = [];
  for (var k in dateFormatComponents) keys.push(k);
  keys[keys.length - 1] += '\\b';
  keys.push('.');

  var formatComponent = new RegExp(keys.join('\\b|'));
  keys.pop();
  var formatReplacer = new RegExp(keys.join('\\b|'), 'g');

  function escapeRegExp(str) {
    // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function padLeft(s, l, c) {
    if (l < s.length) return s;
    else return Array(l - s.length + 1).join(c || ' ') + s;
  }

  function getTemplate(timeIcon, pickDate, pickTime, is12Hours, showSeconds, collapse) {
    if (pickDate && pickTime) {
      return (
        '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
          '<ul>' +
            '<li' + (collapse ? ' class="collapse in"' : '') + '>' +
              '<div class="datepicker">' +
                DPGlobal.template +
              '</div>' +
            '</li>' +
            '<li class="picker-switch accordion-toggle"><a><i class="' + timeIcon + '"></i></a></li>' +
            '<li' + (collapse ? ' class="collapse"' : '') + '>' +
              '<div class="timepicker">' +
                TPGlobal.getTemplate(is12Hours, showSeconds) +
              '</div>' +
            '</li>' +
          '</ul>' +
        '</div>'
      );
    } else if (pickTime) {
      return (
        '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
          '<div class="timepicker">' +
            TPGlobal.getTemplate(is12Hours, showSeconds) +
          '</div>' +
        '</div>'
      );
    } else {
      return (
        '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
          '<div class="datepicker">' +
            DPGlobal.template +
          '</div>' +
        '</div>'
      );
    }
  }

  function UTCDate() {
    return new Date(Date.UTC.apply(Date, arguments));
  }

  var DPGlobal = {
    modes: [
      {
      clsName: 'days',
      navFnc: 'UTCMonth',
      navStep: 1
    },
    {
      clsName: 'months',
      navFnc: 'UTCFullYear',
      navStep: 1
    },
    {
      clsName: 'years',
      navFnc: 'UTCFullYear',
      navStep: 10
    }],
    isLeapYear: function (year) {
      return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0))
    },
    getDaysInMonth: function (year, month) {
      return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
    },
    headTemplate:
      '<thead>' +
        '<tr>' +
          '<th class="prev">&lsaquo;</th>' +
          '<th colspan="5" class="switch"></th>' +
          '<th class="next">&rsaquo;</th>' +
        '</tr>' +
      '</thead>',
    contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
  };
  DPGlobal.template =
    '<div class="datepicker-days">' +
      '<table class="table-condensed">' +
        DPGlobal.headTemplate +
        '<tbody></tbody>' +
      '</table>' +
    '</div>' +
    '<div class="datepicker-months">' +
      '<table class="table-condensed">' +
        DPGlobal.headTemplate +
        DPGlobal.contTemplate+
      '</table>'+
    '</div>'+
    '<div class="datepicker-years">'+
      '<table class="table-condensed">'+
        DPGlobal.headTemplate+
        DPGlobal.contTemplate+
      '</table>'+
    '</div>';
  var TPGlobal = {
    hourTemplate: '<span data-action="showHours" data-time-component="hours" class="timepicker-hour"></span>',
    minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
    secondTemplate: '<span data-action="showSeconds" data-time-component="seconds" class="timepicker-second"></span>'
  };
  TPGlobal.getTemplate = function(is12Hours, showSeconds) {
    return (
    '<div class="timepicker-picker">' +
      '<table class="table-condensed"' +
        (is12Hours ? ' data-hour-format="12"' : '') +
        '>' +
        '<tr>' +
          '<td><a href="#" class="btn" data-action="incrementHours"><i class="icon-chevron-up"></i></a></td>' +
          '<td class="separator"></td>' +
          '<td><a href="#" class="btn" data-action="incrementMinutes"><i class="icon-chevron-up"></i></a></td>' +
          (showSeconds ?
          '<td class="separator"></td>' +
          '<td><a href="#" class="btn" data-action="incrementSeconds"><i class="icon-chevron-up"></i></a></td>': '')+
          (is12Hours ? '<td class="separator"></td>' : '') +
        '</tr>' +
        '<tr>' +
          '<td>' + TPGlobal.hourTemplate + '</td> ' +
          '<td class="separator">:</td>' +
          '<td>' + TPGlobal.minuteTemplate + '</td> ' +
          (showSeconds ?
          '<td class="separator">:</td>' +
          '<td>' + TPGlobal.secondTemplate + '</td>' : '') +
          (is12Hours ?
          '<td class="separator"></td>' +
          '<td>' +
          '<button type="button" class="btn btn-primary" data-action="togglePeriod"></button>' +
          '</td>' : '') +
        '</tr>' +
        '<tr>' +
          '<td><a href="#" class="btn" data-action="decrementHours"><i class="icon-chevron-down"></i></a></td>' +
          '<td class="separator"></td>' +
          '<td><a href="#" class="btn" data-action="decrementMinutes"><i class="icon-chevron-down"></i></a></td>' +
          (showSeconds ?
          '<td class="separator"></td>' +
          '<td><a href="#" class="btn" data-action="decrementSeconds"><i class="icon-chevron-down"></i></a></td>': '') +
          (is12Hours ? '<td class="separator"></td>' : '') +
        '</tr>' +
      '</table>' +
    '</div>' +
    '<div class="timepicker-hours" data-action="selectHour">' +
      '<table class="table-condensed">' +
      '</table>'+
    '</div>'+
    '<div class="timepicker-minutes" data-action="selectMinute">' +
      '<table class="table-condensed">' +
      '</table>'+
    '</div>'+
    (showSeconds ?
    '<div class="timepicker-seconds" data-action="selectSecond">' +
      '<table class="table-condensed">' +
      '</table>'+
    '</div>': '')
    );
  }


})(window.jQuery)

});

},
'bootstrap-jasny/bootstrap-jasny':function(){
// wrapped by build app
define(["dojo","dijit","dojox"], function(dojo,dijit,dojox){
/* ===========================================================
 * Bootstrap: fileinput.js v3.1.3
 * http://jasny.github.com/bootstrap/javascript/#fileinput
 * ===========================================================
 * Copyright 2012-2014 Arnold Daniels
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

+function ($) { "use strict";

  var isIE = window.navigator.appName == 'Microsoft Internet Explorer'

  // FILEUPLOAD PUBLIC CLASS DEFINITION
  // =================================

  var Fileinput = function (element, options) {
    this.$element = $(element)
    
    this.$input = this.$element.find(':file')
    if (this.$input.length === 0) return

    this.name = this.$input.attr('name') || options.name

    this.$hidden = this.$element.find('input[type=hidden][name="' + this.name + '"]')
    if (this.$hidden.length === 0) {
      this.$hidden = $('<input type="hidden">').insertBefore(this.$input)
    }

    this.$preview = this.$element.find('.fileinput-preview')
    var height = this.$preview.css('height')
    if (this.$preview.css('display') !== 'inline' && height !== '0px' && height !== 'none') {
      this.$preview.css('line-height', height)
    }
        
    this.original = {
      exists: this.$element.hasClass('fileinput-exists'),
      preview: this.$preview.html(),
      hiddenVal: this.$hidden.val()
    }
    
    this.listen()
  }
  
  Fileinput.prototype.listen = function() {
    this.$input.on('change.bs.fileinput', $.proxy(this.change, this))
    $(this.$input[0].form).on('reset.bs.fileinput', $.proxy(this.reset, this))
    
    this.$element.find('[data-trigger="fileinput"]').on('click.bs.fileinput', $.proxy(this.trigger, this))
    this.$element.find('[data-dismiss="fileinput"]').on('click.bs.fileinput', $.proxy(this.clear, this))
  },

  Fileinput.prototype.change = function(e) {
    var files = e.target.files === undefined ? (e.target && e.target.value ? [{ name: e.target.value.replace(/^.+\\/, '')}] : []) : e.target.files
    
    e.stopPropagation()

    if (files.length === 0) {
      this.clear()
      return
    }

    this.$hidden.val('')
    this.$hidden.attr('name', '')
    this.$input.attr('name', this.name)

    var file = files[0]

    if (this.$preview.length > 0 && (typeof file.type !== "undefined" ? file.type.match(/^image\/(gif|png|jpeg)$/) : file.name.match(/\.(gif|png|jpe?g)$/i)) && typeof FileReader !== "undefined") {
      var reader = new FileReader()
      var preview = this.$preview
      var element = this.$element

      reader.onload = function(re) {
        var $img = $('<img>')
        $img[0].src = re.target.result
        files[0].result = re.target.result
        
        element.find('.fileinput-filename').text(file.name)
        
        // if parent has max-height, using `(max-)height: 100%` on child doesn't take padding and border into account
        if (preview.css('max-height') != 'none') $img.css('max-height', parseInt(preview.css('max-height'), 10) - parseInt(preview.css('padding-top'), 10) - parseInt(preview.css('padding-bottom'), 10)  - parseInt(preview.css('border-top'), 10) - parseInt(preview.css('border-bottom'), 10))
        
        preview.html($img)
        element.addClass('fileinput-exists').removeClass('fileinput-new')

        element.trigger('change.bs.fileinput', files)
      }

      reader.readAsDataURL(file)
    } else {
      this.$element.find('.fileinput-filename').text(file.name)
      this.$preview.text(file.name)
      
      this.$element.addClass('fileinput-exists').removeClass('fileinput-new')
      
      this.$element.trigger('change.bs.fileinput')
    }
  },

  Fileinput.prototype.clear = function(e) {
    if (e) e.preventDefault()
    
    this.$hidden.val('')
    this.$hidden.attr('name', this.name)
    this.$input.attr('name', '')

    //ie8+ doesn't support changing the value of input with type=file so clone instead
    if (isIE) { 
      var inputClone = this.$input.clone(true);
      this.$input.after(inputClone);
      this.$input.remove();
      this.$input = inputClone;
    } else {
      this.$input.val('')
    }

    this.$preview.html('')
    this.$element.find('.fileinput-filename').text('')
    this.$element.addClass('fileinput-new').removeClass('fileinput-exists')
    
    if (e !== undefined) {
      this.$input.trigger('change')
      this.$element.trigger('clear.bs.fileinput')
    }
  },

  Fileinput.prototype.reset = function() {
    this.clear()

    this.$hidden.val(this.original.hiddenVal)
    this.$preview.html(this.original.preview)
    this.$element.find('.fileinput-filename').text('')

    if (this.original.exists) this.$element.addClass('fileinput-exists').removeClass('fileinput-new')
     else this.$element.addClass('fileinput-new').removeClass('fileinput-exists')
    
    this.$element.trigger('reset.bs.fileinput')
  },

  Fileinput.prototype.trigger = function(e) {
    this.$input.trigger('click')
    e.preventDefault()
  }

  
  // FILEUPLOAD PLUGIN DEFINITION
  // ===========================

  var old = $.fn.fileinput
  
  $.fn.fileinput = function (options) {
    return this.each(function () {
      var $this = $(this),
          data = $this.data('bs.fileinput')
      if (!data) $this.data('bs.fileinput', (data = new Fileinput(this, options)))
      if (typeof options == 'string') data[options]()
    })
  }

  $.fn.fileinput.Constructor = Fileinput


  // FILEINPUT NO CONFLICT
  // ====================

  $.fn.fileinput.noConflict = function () {
    $.fn.fileinput = old
    return this
  }


  // FILEUPLOAD DATA-API
  // ==================

  $(document).on('click.fileinput.data-api', '[data-provides="fileinput"]', function (e) {
    var $this = $(this)
    if ($this.data('bs.fileinput')) return
    $this.fileinput($this.data())
      
    var $target = $(e.target).closest('[data-dismiss="fileinput"],[data-trigger="fileinput"]');
    if ($target.length > 0) {
      e.preventDefault()
      $target.trigger('click.bs.fileinput')
    }
  })

}(window.jQuery);

});

},
'esri/arcgis/utils':function(){
//>>built
define(["require", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/Deferred", "dojo/_base/json", "dojo/_base/url", "dojo/on", "dojo/DeferredList", "dojo/dom-construct", "../kernel", "../config", "../lang", "../request", "../SpatialReference", "../map", "../urlUtils", "../geometry/ScreenPoint", "../geometry/Extent", "../geometry/webMercatorUtils", "../symbols/jsonUtils", "../renderers/jsonUtils", "../dijit/PopupTemplate", "../dijit/Popup", "../tasks/query", "../tasks/GeometryService", "../layers/ArcGISTiledMapServiceLayer", "../layers/FeatureLayer", "dojo/i18n!../nls/jsapi"], function(G, l, k, u, s, H, mb, xa, B, nb, F, I, g, y, z, ob, ya, za, C, pb, D, Aa, Ba, qb, rb, sb, tb, w, aa) {
    function E(a) {
        return y({
            url: p.arcgisUrl + "/" + a.itemId + "/data",
            content: {
                f: "json"
            },
            callbackParamName: "callback"
        }, {
            disableIdentityLookup: !0,
            _preLookup: !0
        })
    }

    function ba(a, f) {
        var b = {
            f: "json"
        };
        f && (b.token = f);
        return y({
            url: a,
            content: b,
            callbackParamName: "callback"
        }, {
            disableIdentityLookup: !0
        })
    }

    function ca(a) {
        a.itemProperties.layerDefinition && (a.layerDefinition ? (a.layerDefinition.drawingInfo || (a.layerDefinition.drawingInfo = a.itemProperties.layerDefinition.drawingInfo),
            g.isDefined(a.layerDefinition.definitionExpression) || (a.layerDefinition.definitionExpression = a.itemProperties.layerDefinition.definitionExpression), g.isDefined(a.layerDefinition.minScale) || (a.layerDefinition.minScale = a.itemProperties.layerDefinition.minScale), g.isDefined(a.layerDefinition.maxScale) || (a.layerDefinition.maxScale = a.itemProperties.layerDefinition.maxScale)) : a.layerDefinition = a.itemProperties.layerDefinition);
        a.itemProperties.popupInfo && (!a.popupInfo && !a.disablePopup) && (a.popupInfo = a.itemProperties.popupInfo);
        g.isDefined(a.itemProperties.showLabels) && !g.isDefined(a.showLabels) && (a.showLabels = a.itemProperties.showLabels);
        g.isDefined(a.itemProperties.showLegend) && !g.isDefined(a.showLegend) && (a.showLegend = a.itemProperties.showLegend);
        g.isDefined(a.itemProperties.refreshInterval) && !g.isDefined(a.refreshInterval) && (a.refreshInterval = a.itemProperties.refreshInterval)
    }

    function Ca(a) {
        ca(a);
        a.itemProperties.layerDefinition && a.layerDefinition && (!g.isDefined(a.layerDefinition.maximumTrackPoints) && g.isDefined(a.itemProperties.layerDefinition.maximumTrackPoints) &&
            (a.layerDefinition.maximumTrackPoints = a.itemProperties.layerDefinition.maximumTrackPoints), !a.layerDefinition.definitionGeometry && a.itemProperties.layerDefinition.definitionGeometry && (a.layerDefinition.definitionGeometry = a.itemProperties.layerDefinition.definitionGeometry));
        a.itemProperties.purgeOptions && !a.purgeOptions && (a.purgeOptions = a.itemProperties.purgeOptions)
    }

    function J(a, f) {
        var b = new s,
            c = a.itemData,
            d = [],
            e = [];
        k.forEach(c.operationalLayers, function(a) {
            if (a.itemId && !a.type) {
                var c = a.url.toLowerCase(); - 1 < c.indexOf("/featureserver") || -1 < c.indexOf("/mapserver/") ? (e.push(a), d.push(E(a))) : -1 < c.indexOf("/mapserver") && -1 === c.indexOf("/mapserver/") && (!a.layers || !g.isDefined(a.minScale) && !g.isDefined(a.maxScale)) ? (e.push(a), d.push(E(a))) : -1 < c.indexOf("/imageserver") && !g.isDefined(a.minScale) && !g.isDefined(a.maxScale) ? (e.push(a), d.push(E(a))) : -1 < c.indexOf("/streamserver") && (e.push(a), d.push(E(a)))
            }
        });
        c.baseMap && c.baseMap.baseMapLayers && k.forEach(c.baseMap.baseMapLayers, function(a) {
            a.itemId && (e.push(a),
                d.push(E(a)))
        });
        if (0 < d.length) {
            var h = {};
            (new B(d)).addCallback(function(c) {
                k.forEach(e, function(a, e) {
                    var b = c[e][1];
                    if (b && !(b instanceof Error) && (h[a.itemId] = b, !a.type)) {
                        var d = a.url.toLowerCase();
                        if ((-1 < d.indexOf("/featureserver") || -1 < d.indexOf("/mapserver/")) && b.layers) k.forEach(b.layers, function(b) {
                            if (d.endsWith("/featureserver/" + b.id) || d.endsWith("/mapserver/" + b.id)) a.itemProperties = b, ca(a)
                        });
                        else if (-1 < d.indexOf("/streamserver")) a.itemProperties = b, Ca(a);
                        else if (-1 < d.indexOf("/mapserver")) b.layers &&
                            !a.layers && (a.layers = b.layers), g.isDefined(b.minScale) && !g.isDefined(a.minScale) && (a.minScale = b.minScale), g.isDefined(b.maxScale) && !g.isDefined(a.maxScale) && (a.maxScale = b.maxScale), g.isDefined(b.refreshInterval) && !g.isDefined(a.refreshInterval) && (a.refreshInterval = b.refreshInterval), b.visibleLayers && !a.visibleLayers && (a.visibleLayers = b.visibleLayers);
                        else if (-1 < d.indexOf("/imageserver") && (g.isDefined(b.minScale) && !g.isDefined(a.minScale) && (a.minScale = b.minScale), g.isDefined(b.maxScale) && !g.isDefined(a.maxScale) &&
                                (a.maxScale = b.maxScale), g.isDefined(b.refreshInterval) && !g.isDefined(a.refreshInterval) && (a.refreshInterval = b.refreshInterval), b.popupInfo && (!a.popupInfo && !a.disablePopup) && (a.popupInfo = b.popupInfo), b.renderingRule && !a.renderingRule && (a.renderingRule = b.renderingRule, b.renderingRule.functionName && (a.renderingRule.rasterFunction = b.renderingRule.functionName)), b.bandIds && !a.bandIds && (a.bandIds = b.bandIds), b.mosaicRule && !a.mosaicRule && (a.mosaicRule = b.mosaicRule), b.format && !a.format && (a.format = b.format),
                                g.isDefined(b.compressionQuality) && !g.isDefined(a.compressionQuality) && (a.compressionQuality = b.compressionQuality), b.layerDefinition && b.layerDefinition.definitionExpression && (!g.isDefined(a.layerDefinition) || !g.isDefined(a.layerDefinition.definitionExpression)))) a.layerDefinition = a.layerDefinition || {}, a.layerDefinition.definitionExpression = b.layerDefinition.definitionExpression
                    }
                });
                a.relatedItemsData = h;
                b.callback(a)
            })
        } else b.callback(a);
        return b
    }

    function ub(a, f) {
        var b = new s,
            c = a.itemData,
            d = c.baseMap.baseMapLayers[0];
        if ("BingMapsAerial" === d.type || "BingMapsRoad" === d.type || "BingMapsHybrid" === d.type)
            if (d.portalUrl && F.id) delete f.bingMapsKey, F.id.checkSignInStatus(ya.urlToObject(p.arcgisUrl).path).then(l.hitch(null, function(a, b, e, c, f) {
                ba(d.portalUrl, f.token).then(l.hitch(null, da, a, b, e, c), l.hitch(null, K, a, b, e, c))
            }, a, f, c, b), l.hitch(null, function(a, b, e, c, f) {
                ba(d.portalUrl).then(l.hitch(null, da, a, b, e, c), l.hitch(null, K, a, b, e, c))
            }, a, f, c, b));
            else if (f.bingMapsKey) {
            var e = new t({
                bingMapsKey: f.bingMapsKey,
                mapStyle: t.MAP_STYLE_AERIAL
            });
            u.connect(e, "onLoad", l.hitch(this, function() {
                b.callback([a, f])
            }));
            u.connect(e, "onError", function(e) {
                delete f.bingMapsKey;
                a.itemData = L(c);
                d = a.itemData.baseMap.baseMapLayers[0];
                d.errors = [];
                d.errors.push({
                    message: "The owner of the application has not provided a valid Bing Key for the Bing Map it includes. Switching to Esri layers."
                });
                b.callback([a, f])
            })
        } else a.itemData = L(c), d = a.itemData.baseMap.baseMapLayers[0], d.errors = [], d.errors.push({
                message: "The owner of the application has not provided a Bing Key for the Bing Map it includes. Switching to Esri layers."
            }),
            b.callback([a, f]);
        else b.callback([a, f]);
        return b
    }

    function da(a, f, b, c, d) {
        d.bingKey ? (f.bingMapsKey = d.bingKey, d = new t({
            bingMapsKey: f.bingMapsKey,
            mapStyle: t.MAP_STYLE_AERIAL
        }), u.connect(d, "onLoad", l.hitch(this, function() {
            c.callback([a, f])
        })), u.connect(d, "onError", function(e) {
            delete f.bingMapsKey;
            a.itemData = L(b);
            e = a.itemData.baseMap.baseMapLayers[0];
            e.errors = [];
            e.errors.push({
                message: "The owner of the map has not provided a valid Bing Key for the Bing Map it includes. Switching to Esri layers."
            });
            c.callback([a,
                f
            ])
        })) : K(a, f, b, c)
    }

    function K(a, f, b, c) {
        delete f.bingMapsKey;
        a.itemData = L(b);
        b = a.itemData.baseMap.baseMapLayers[0];
        b.errors = [];
        b.errors.push({
            message: "The owner of the map has not provided a Bing Key for the Bing Map it includes. Switching to Esri layers."
        });
        c.callback([a, f])
    }

    function L(a) {
        a.baseMap = "BingMapsAerial" === a.baseMap.baseMapLayers[0].type ? {
                title: "Imagery",
                baseMapLayers: [{
                    id: "World_Imagery_2017",
                    visibility: !0,
                    opacity: 1,
                    url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
                }]
            } :
            "BingMapsRoad" === a.baseMap.baseMapLayers[0].type ? {
                title: "Streets",
                baseMapLayers: [{
                    id: "World_Street_Map_8421",
                    opacity: 1,
                    visibility: !0,
                    url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer"
                }]
            } : {
                title: "Imagery with Labels",
                baseMapLayers: [{
                    id: "World_Imagery_6611",
                    opacity: 1,
                    visibility: !0,
                    url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
                }, {
                    id: "World_Boundaries_and_Places_1145",
                    isReference: !0,
                    opacity: 1,
                    visibility: !0,
                    url: "http://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer"
                }]
            };
        return a
    }

    function ea(a, f, b, c) {
        var d = a.dynamicLayerInfos || a.layerInfos,
            e = f.layers;
        if (e && d)
            if (c.usePopupManager) {
                var h;
                k.forEach(d, function(a) {
                    var c = a.id;
                    if (!a.subLayerIds)
                        for (a = 0; a < e.length; a++) {
                            var d = e[a];
                            if (d.id === c && d.popupInfo) {
                                h || (h = {});
                                h[c] = {
                                    infoTemplate: new b(d.popupInfo),
                                    layerUrl: d.layerUrl
                                };
                                break
                            }
                        }
                });
                h && a.setInfoTemplates(h)
            } else {
                var m = [],
                    q = [],
                    r = [],
                    n = [],
                    v = [],
                    Da = [];
                k.forEach(d, function(b) {
                    var c = b.id;
                    if (!b.subLayerIds && -1 !== k.indexOf(a.visibleLayers, c))
                        for (b = 0; b < e.length; b++) {
                            var d = e[b];
                            if (d.id ===
                                c) {
                                q.push(c);
                                m.push(d.popupInfo);
                                r.push(d.layerUrl || "");
                                d.layerDefinition && d.layerDefinition.definitionExpression ? n.push(d.layerDefinition.definitionExpression) : n.push("");
                                v.push(g.isDefined(d.minScale) ? d.minScale : null);
                                Da.push(g.isDefined(d.maxScale) ? d.maxScale : null);
                                break
                            }
                        }
                });
                m.length && (a.__popups = m, a.__popupIds = q, a.__popupUrls = r, a.__popupWhereClauses = n, a.__popupMinScales = v, a.__popupMaxScales = Da, a.__resourceInfo = f.resourceInfo)
            }
    }

    function fa(a) {
        if (!a) return !1;
        var f = (new mb(p.arcgisUrl)).authority;
        return -1 !== a.indexOf(".arcgis.com/") || -1 !== a.indexOf(f)
    }

    function Ea(a) {
        return !a ? !1 : -1 !== a.indexOf("/services.arcgisonline.com/") || -1 !== a.indexOf("/server.arcgisonline.com/")
    }

    function A(a) {
        if ("https:" === location.protocol && (fa(a) || Ea(a))) a = a.replace("http:", "https:");
        return a
    }

    function ga(a, f, b) {
        var c = [],
            d;
        a.displayLevels || (c = k.map(a.resourceInfo.tileInfo.lods, function(a) {
            return a.level
        }));
        a.exclusionAreas && (d = l.clone(a.exclusionAreas), d = k.map(d, function(a) {
            a.geometry = new C(a.geometry);
            return a
        }));
        c =
            new tb(A(a.url), {
                resourceInfo: a.resourceInfo,
                opacity: a.opacity,
                visible: a.visibility,
                displayLevels: a.displayLevels || c,
                id: a.id,
                minScale: a.minScale,
                maxScale: a.maxScale,
                refreshInterval: a.refreshInterval,
                exclusionAreas: d
            });
        b.ignorePopups || ea(c, a, f, b);
        return c
    }

    function ha(a, f) {
        if (!a || !f || 0 === f.length) return [];
        var b = "," + f + ",",
            c = [],
            d, e = ",";
        for (d = 0; d < a.length; d++)
            if (null !== a[d].subLayerIds) {
                if (-1 === b.indexOf("," + a[d].id + ",") || -1 < e.indexOf("," + a[d].id + ",")) e += a[d].subLayerIds.toString() + ","
            } else -1 < b.indexOf("," +
                a[d].id + ",") && -1 === e.indexOf("," + a[d].id + ",") && c.push(a[d].id);
        return c
    }

    function Fa(a, f, b) {
        var c = new Ga;
        c.format = "png24";
        a.resourceInfo && (a.resourceInfo.supportedImageFormatTypes && -1 < a.resourceInfo.supportedImageFormatTypes.indexOf("PNG32")) && (c.format = "png32");
        var c = new Ha(A(a.url), {
                resourceInfo: a.resourceInfo,
                opacity: a.opacity,
                visible: a.visibility,
                id: a.id,
                imageParameters: c,
                minScale: a.minScale,
                maxScale: a.maxScale,
                refreshInterval: a.refreshInterval
            }),
            d = a.visibleLayers;
        if (!a.visibleLayers) {
            var e = "";
            k.forEach(c.layerInfos, function(a) {
                a.defaultVisibility && (e += (0 < e.length ? "," : "") + a.id)
            });
            d = e
        }
        if (a.layers && 0 < a.layers.length) {
            var h = [],
                m = [],
                q, g = [],
                n, v;
            k.forEach(a.layers, function(b) {
                b.layerDefinition && b.layerDefinition.definitionExpression && (h[b.id] = b.layerDefinition.definitionExpression);
                if (b.layerDefinition && b.layerDefinition.source) {
                    q = null;
                    v = b.layerDefinition.source;
                    if ("mapLayer" === v.type) {
                        var c = k.filter(a.resourceInfo.layers, function(a) {
                            return a.id === v.mapLayerId
                        });
                        c.length && (q = l.mixin(c[0], b))
                    } else q =
                        l.mixin({}, b);
                    q && (q.source = v, delete q.popupInfo, q = new Ia(q), a.visibleLayers && (c = "string" == typeof a.visibleLayers ? a.visibleLayers.split(",") : a.visibleLayers, -1 < k.indexOf(c, b.id) ? q.defaultVisibility = !0 : q.defaultVisibility = !1), m.push(q))
                }
                b.layerDefinition && (b.layerDefinition.source && b.layerDefinition.drawingInfo) && (n = new Ja(b.layerDefinition.drawingInfo), g[b.id] = n)
            }, this);
            0 < h.length && c.setLayerDefinitions(h);
            0 < m.length ? (c.setDynamicLayerInfos(m, !0), 0 < g.length && c.setLayerDrawingOptions(g, !0)) : (d = ha(c.layerInfos,
                d), c.setVisibleLayers(d))
        } else d = ha(c.layerInfos, d), c.setVisibleLayers(d);
        b.ignorePopups || ea(c, a, f, b);
        return c
    }

    function vb(a, f, b) {
        var c = new Ka;
        c.bandIds = a.bandIds;
        null != a.format && (c.format = a.format, null != a.compressionQuality && (c.compressionQuality = a.compressionQuality));
        if (a.renderingRule && a.renderingRule.rasterFunction) {
            var d = new La(a.renderingRule);
            c.renderingRule = d
        }
        a.mosaicRule && (d = new Ma(a.mosaicRule), c.mosaicRule = d);
        g.isDefined(a.noData) && (c.noData = a.noData);
        g.isDefined(a.noDataInterpretation) &&
            (c.noDataInterpretation = a.noDataInterpretation);
        g.isDefined(a.interpolation) && (c.interpolation = a.interpolation);
        c = new Na(A(a.url), {
            resourceInfo: a.resourceInfo,
            opacity: a.opacity,
            visible: a.visibility,
            id: a.id,
            imageServiceParameters: c,
            minScale: a.minScale,
            maxScale: a.maxScale,
            refreshInterval: a.refreshInterval
        });
        a.layerDefinition && a.layerDefinition.definitionExpression && c.setDefinitionExpression(a.layerDefinition.definitionExpression, !0);
        !b.ignorePopups && a.popupInfo && c.setInfoTemplate(new f(a.popupInfo));
        return c
    }

    function ia(a, f, b) {
        var c = [102113, 102100, 3857],
            d = b || new z(f[0].layerObject.fullExtent.spatialReference),
            e = new z(a.resourceInfo.fullExtent.spatialReference);
        return d.wkt == e.wkt && (d.wkid == e.wkid || g.isDefined(d.latestWkid) && d.latestWkid == e.wkid || g.isDefined(e.latestWkid) && d.wkid == e.latestWkid || g.isDefined(d.latestWkid) && d.latestWkid == e.latestWkid) || d.wkid && e.wkid && k.some(c, function(a) {
            return a === e.wkid
        }) && k.some(c, function(a) {
            return a === d.wkid
        }) ? !0 : !1
    }

    function ja(a, f) {
        if (!f[0].layerObject.tileInfo) return !1;
        var b = [];
        k.forEach(f, function(a) {
            a.baseMapLayer && a.layerObject.tileInfo && (b = b.concat(k.map(a.layerObject.tileInfo.lods, function(a) {
                return a.scale
            })))
        });
        return k.some(a.resourceInfo.tileInfo.lods, function(a) {
            return k.some(b, function(b) {
                return b === a.scale
            })
        })
    }

    function ka(a, f, b, c, d) {
        var e, h = b._clazz;
        if ("OpenStreetMap" === a.type) e = new Oa({
            id: a.id,
            opacity: a.opacity,
            visible: null !== a.visibility && void 0 !== a.visibility ? a.visibility : !0
        });
        else if ("WMS" === a.type) {
            var m = [],
                q = [];
            k.forEach(a.layers, function(a) {
                q.push(new Pa({
                    name: a.name,
                    title: a.title,
                    legendURL: a.legendURL
                }));
                m.push(a.name)
            }, this);
            a.visibleLayers && (m = a.visibleLayers);
            c = {
                extent: new C(a.extent[0][0], a.extent[0][1], a.extent[1][0], a.extent[1][1], new z({
                    wkid: 4326
                })),
                layerInfos: q,
                version: a.version,
                maxWidth: a.maxWidth,
                maxHeight: a.maxHeight,
                getMapURL: a.mapUrl,
                spatialReferences: a.spatialReferences,
                title: a.title,
                copyright: a.copyright,
                minScale: a.minScale || 0,
                maxScale: a.maxScale || 0,
                format: a.format
            };
            e = new Qa(a.url, {
                id: a.id,
                visibleLayers: m,
                format: "png",
                transparent: a.baseMapLayer ?
                    !1 : !0,
                opacity: a.opacity,
                visible: null !== a.visibility ? a.visibility : !0,
                resourceInfo: c,
                refreshInterval: a.refreshInterval
            });
            e.spatialReference.wkid = c.spatialReferences[0]
        } else if ("KML" === a.type) {
            b = a.url;
            if (F.id && (h = F.id.findCredential(ya.urlToObject(p.arcgisUrl).path))) {
                var r = p.arcgisUrl.substring(p.arcgisUrl.indexOf("//") + 2, p.arcgisUrl.indexOf("/", p.arcgisUrl.indexOf("//") + 3)),
                    n = r.split("."),
                    n = n[n.length - 2] + "." + n[n.length - 1];
                f = b.indexOf(n); - 1 < f && (b = "https://" + r + b.substring(f + n.length), b += "?token\x3d" +
                    h.token)
            }
            e = new Ra(b, {
                id: a.id,
                visible: null !== a.visibility ? a.visibility : !0,
                outSR: c,
                refreshInterval: a.refreshInterval
            });
            u.connect(e, "onLoad", function() {
                (a.opacity || 0 === a.opacity) && e.setOpacity(a.opacity);
                g.isDefined(a.minScale) && g.isDefined(a.maxScale) && e.setScaleRange(a.minScale, a.maxScale);
                a.visibleFolders && k.forEach(e.folders, function(b) {
                    -1 < k.indexOf(a.visibleFolders, b.id) ? e.setFolderVisibility(b, !0) : e.setFolderVisibility(b, !1)
                }, this)
            })
        } else "WebTiledLayer" === a.type ? (e = new Sa(a.templateUrl, {
            id: a.id,
            visible: null !== a.visibility ? a.visibility : !0,
            opacity: a.opacity,
            copyright: a.copyright,
            fullExtent: a.fullExtent && new C(a.fullExtent),
            initialExtent: a.fullExtent && new C(a.fullExtent),
            subDomains: a.subDomains,
            tileInfo: a.tileInfo ? new Ta(a.tileInfo) : null,
            refreshInterval: a.refreshInterval
        }), u.connect(e, "onLoad", function() {
            (g.isDefined(a.minScale) || g.isDefined(a.maxScale)) && e.setScaleRange(a.minScale, a.maxScale)
        })) : "GeoRSS" === a.type ? (e = new Ua(a.url, {
                id: a.id,
                opacity: a.opacity,
                outSpatialReference: c,
                refreshInterval: a.refreshInterval
            }),
            u.connect(e, "onLoad", function() {
                !1 === a.visibility && e.hide();
                g.isDefined(a.minScale) && g.isDefined(a.maxScale) && e.setScaleRange(a.minScale, a.maxScale);
                var b = e.getFeatureLayers();
                k.forEach(b, function(c) {
                    a.pointSymbol && "esriGeometryPoint" === c.geometryType ? (c.renderer.symbol = D.fromJson(a.pointSymbol), 1 === b.length && (e.pointSymbol = D.fromJson(a.pointSymbol))) : a.lineSymbol && "esriGeometryPolyline" === c.geometryType ? (c.renderer.symbol = D.fromJson(a.lineSymbol), 1 === b.length && (e.polylineSymbol = D.fromJson(a.lineSymbol))) :
                        a.polygonSymbol && "esriGeometryPolygon" === c.geometryType && (c.renderer.symbol = D.fromJson(a.polygonSymbol), 1 === b.length && (e.polygonSymbol = D.fromJson(a.polygonSymbol)))
                })
            })) : "CSV" == a.type && a.url ? (c = {
                layerDefinition: a.layerDefinition,
                columnDelimiter: a.columnDelimiter,
                id: a.id ? a.id : null,
                visible: null !== a.visibility ? a.visibility : !0,
                opacity: a.opacity,
                refreshInterval: a.refreshInterval
            }, a.locationInfo && (c.latitudeFieldName = a.locationInfo.latitudeFieldName, c.longitudeFieldName = a.locationInfo.longitudeFieldName),
            b.ignorePopups || (c.infoTemplate = new Ba(a.popupInfo ? a.popupInfo : Va.generateDefaultPopupInfo(a))), e = new Wa(a.url, c)) : a.layerDefinition && !a.url ? (c = H.fromJson(H.toJson(a)), delete c.id, delete c.opacity, delete c.visibility, e = new w(c, {
            id: a.id,
            opacity: a.opacity,
            visible: a.visibility,
            outFields: ["*"],
            autoGeneralize: !0
        }), !b.ignorePopups && c.popupInfo && e.setInfoTemplate(new h(c.popupInfo))) : "BingMapsAerial" === a.type || "BingMapsRoad" === a.type || "BingMapsHybrid" === a.type ? b.bingMapsKey ? (c = t.MAP_STYLE_AERIAL_WITH_LABELS,
            "BingMapsAerial" === a.type ? c = t.MAP_STYLE_AERIAL : "BingMapsRoad" === a.type && (c = t.MAP_STYLE_ROAD), e = new t({
                bingMapsKey: b.bingMapsKey,
                mapStyle: c,
                opacity: a.opacity,
                id: a.id
            }), u.connect(e, "onError", l.hitch(this, function(a) {
                a.errors = a.errors || [];
                a.errors.push({
                    message: "This application does not have a valid Bing Key for the Bing layer that is included in this map. [type:" + a.type + "]"
                })
            }, a))) : (a.errors = a.errors || [], a.errors.push({
            message: "This application does not provide a Bing Key for the Bing layer that is included in this map. [type:" +
                a.type + "]"
        })) : a.resourceInfo && a.resourceInfo.mapName ? e = !0 === a.resourceInfo.singleFusedMapCache && (a.baseMapLayer || ia(a, f, c) && ja(a, d)) ? ga(a, h, b) : Fa(a, h, b) : a.resourceInfo && a.resourceInfo.pixelSizeX ? e = !0 === a.resourceInfo.singleFusedMapCache && (a.baseMapLayer || ia(a, f, c) && ja(a, d)) ? ga(a, h, b) : vb(a, h, b) : a.resourceInfo && "Feature Layer" === a.resourceInfo.type ? (a.capabilities && (a.resourceInfo.capabilities = a.capabilities), e = new w(A(a.url), {
            resourceInfo: a.resourceInfo,
            opacity: a.opacity,
            visible: a.visibility,
            id: a.id,
            mode: fa(a.url) ? w.MODE_AUTO : g.isDefined(a.mode) ? a.mode : w.MODE_ONDEMAND,
            editable: !1 === b.editable ? !1 : void 0,
            outFields: ["*"],
            autoGeneralize: !0,
            refreshInterval: a.refreshInterval
        }), !b.ignorePopups && a.popupInfo && e.setInfoTemplate(new h(a.popupInfo)), a.layerDefinition && (a.layerDefinition.drawingInfo && a.layerDefinition.drawingInfo.renderer && (c = Aa.fromJson(a.layerDefinition.drawingInfo.renderer), c.isMaxInclusive = !0, e.setRenderer(c)), a.layerDefinition.drawingInfo && a.layerDefinition.drawingInfo.labelingInfo &&
            (c = k.map(a.layerDefinition.drawingInfo.labelingInfo, function(a) {
                return new Xa(a)
            }), e.setLabelingInfo(c)), a.layerDefinition.definitionExpression && e.setDefinitionExpression(a.layerDefinition.definitionExpression), g.isDefined(a.layerDefinition.minScale) && e.setMinScale(a.layerDefinition.minScale), g.isDefined(a.layerDefinition.maxScale) && e.setMaxScale(a.layerDefinition.maxScale))) : a.resourceInfo && a.resourceInfo.streamUrls && (c = {
                resourceInfo: a.resourceInfo,
                opacity: a.opacity,
                visible: a.visibility,
                id: a.id
            },
            a.layerDefinition && (n = a.layerDefinition.drawingInfo, a.layerDefinition.definitionGeometry && (r = r || {}, r.geometry = a.layerDefinition.definitionGeometry), g.isDefined(a.layerDefinition.definitionExpression) && (r = r || {}, r.where = a.layerDefinition.definitionExpression), g.isDefined(a.layerDefinition.maximumTrackPoints) && (c.maximumTrackPoints = a.layerDefinition.maximumTrackPoints)), r && (c.filter = r), a.purgeOptions && (c.purgeOptions = a.purgeOptions), e = new Ya(A(a.url), c), n && n.renderer && (c = n.renderer, e.setRenderer(Aa.fromJson(c))), !b.ignorePopups && a.popupInfo && e.setInfoTemplate(new h(a.popupInfo)), a.layerDefinition && (g.isDefined(a.layerDefinition.minScale) && e.setMinScale(a.layerDefinition.minScale), g.isDefined(a.layerDefinition.maxScale) && e.setMaxScale(a.layerDefinition.maxScale)), xa.once(e, "error", function(b) {
                a.errors.push({
                    message: "Error loading stream layer. Check websocket url"
                })
            }));
        e && (e.arcgisProps = {
            title: a.title
        }, a.baseMapLayer && (e._basemapGalleryLayerType = a.isReference ? "reference" : "basemap"));
        return e
    }

    function la(a,
        f, b, c) {
        k.forEach(a, function(e, d) {
            if (e.url && !e.type) {
                if (0 === d || a[0].layerObject) e.layerObject = ka(e, a, f, b, c)
            } else e.layerObject = ka(e, a, f, b, c)
        });
        var d = k.filter(a, function(a) {
                return !a.isReference
            }),
            e = k.filter(a, function(a) {
                return !!a.isReference
            });
        return a = d.concat(e)
    }

    function ma(a) {
        var f = null;
        a = a[0];
        a.url && !a.type ? a.resourceInfo.spatialReference && (f = new z, a.resourceInfo.spatialReference.wkid && (f.wkid = a.resourceInfo.spatialReference.wkid), a.resourceInfo.spatialReference.wkt && (f.wkt = a.resourceInfo.spatialReference.wkt)) :
            -1 < a.type.indexOf("BingMaps") || "OpenStreetMap" == a.type ? f = new z({
                wkid: 102100
            }) : "WMS" == a.type && (f = new z({
                wkid: a.spatialReferences[0]
            }));
        return f
    }

    function Za(a, f, b, c, d, e, h) {
        k.forEach(f, function(b, c) {
            b.url && !b.type && (b.resourceInfo = a[b.deferredsPos][1], delete b.deferredsPos)
        });
        e = e || ma(f);
        f = la(f, b, e, h);
        d.callback(f);
        return d
    }

    function $a(a, f) {
        var b = A(a);
        return y({
            url: b,
            content: {
                f: "json"
            },
            callbackParamName: "callback",
            error: function(a, d) {
                a.message = a.message ? a.message + (" [url:" + b + "]") : "[url:" + b + "]";
                f.push(a);
                I.defaults.io.errorHandler(a, d)
            }
        })
    }

    function ab(a) {
        var f = p.arcgisUrl + "/" + a.itemId + "/data";
        return y({
            url: f,
            content: {
                f: "json"
            },
            callbackParamName: "callback",
            error: function(b, c) {
                b.message = b.message ? b.message + (" [url:" + f + "]") : "[url:" + f + "]";
                a.errors = a.errors || [];
                a.errors.push(b);
                I.defaults.io.errorHandler(b, c)
            }
        })
    }

    function bb(a, f, b) {
        var c = new s;
        if ((!b.featureCollection || !b.featureCollection.layers) && !b.layers) return console.log("Invalid Feature Collection item data [item id: " + a.itemId + "]: ", b), a.errors =
            a.errors || [], a.errors.push({
                message: "Invalid Feature Collection item data. [item id: " + a.itemId + "]"
            }), c.errback(), c;
        b.layers && (b.featureCollection = {
            layers: b.layers
        }, delete b.layers, g.isDefined(b.showLegend) && (b.featureCollection.showLegend = b.showLegend, delete b.showLegend));
        cb(a, b.featureCollection, f).then(function(d) {
            b.featureCollection = d;
            a.featureCollection && a.featureCollection.layers ? k.forEach(b.featureCollection.layers, function(b, c) {
                var d = a.featureCollection.layers[c];
                if (!d.poupInfo && !d.layerDefinition) d.popupInfo =
                    b.popupInfo, d.layerDefinition = b.layerDefinition;
                else if (d.layerDefinition) {
                    if (g.isDefined(d.layerDefinition.minScale) && g.isDefined(d.layerDefinition.maxScale) && (d.layerDefinition.minScale !== b.layerDefinition.minScale || d.layerDefinition.maxScale !== b.layerDefinition.maxScale)) delete b.layerDefinition.minscale, delete b.layerDefinition.maxScale;
                    d.layerDefinition.drawingInfo && H.toJson(d.layerDefinition.drawingInfo) !== H.toJson(b.layerDefinition.drawingInfo) && delete b.layerDefinition.drawingInfo;
                    d.layerDefinition.showLegend !==
                        b.layerDefinition.showLegend && delete b.layerDefinition.showLegend;
                    d.layerDefinition = l.mixin(d.layerDefinition, b.layerDefinition)
                } else d.layerDefinition = b.layerDefinition;
                d.featureSet = b.featureSet;
                d.nextObjectId = b.nextObjectId
            }) : (a.featureCollection = a.featureCollection || {}, a.featureCollection = l.mixin(a.featureCollection, b.featureCollection));
            c.callback(a)
        });
        return c
    }

    function cb(a, f, b) {
        var c = new s;
        G(["./csv"], function(d) {
            var e = [];
            k.forEach(f.layers, function(a) {
                a.featureSet && (a.featureSet.features &&
                    a.featureSet.features.length && a.featureSet.features[0].geometry && a.featureSet.features[0].geometry.spatialReference) && (a.deferredsPos = e.length, e.push(d.projectFeatureCollection(a, b, a.featureSet.features[0].geometry.spatialReference)))
            });
            (new B(e)).addCallback(function() {
                k.forEach(f.layers, function(b) {
                    g.isDefined(b.deferredsPos) && (e[b.deferredsPos].results && e[b.deferredsPos].results.length ? b = e[b.deferredsPos].results[0] : (console.log("Errors projecting feature collection. [" + a.title + " - " + b.layerDefinition.name +
                        "]"), b.errors = b.errors || [], b.errors.push({
                        message: "Errors projecting feature collection. [" + a.title + " - " + b.layerDefinition.name + "]"
                    })), delete b.deferredsPos)
                });
                c.callback(f)
            })
        });
        return c
    }

    function M(a, f, b, c) {
        var d = new s,
            e = new s,
            h = [],
            m;
        k.forEach(a.operationalLayers, function(a) {
            a.itemId && "Feature Collection" == a.type && h.push(ab(a).then(l.hitch(null, bb, a, b)))
        });
        0 === h.length ? db(a, f, b, c, e) : (m = new B(h), m.addCallback(function(d) {
            db(a, f, b, c, e)
        }));
        e.then(function(a) {
            h = [];
            k.forEach(a, function(a) {
                a = a.layerObject;
                if (a instanceof w && !a.loaded && !a.loadError) {
                    var b = new s;
                    xa.once(a, "load, error", function() {
                        b.callback(a)
                    });
                    h.push(b)
                }
            });
            if (h.length) {
                var b = new s;
                m = new B(h);
                m.addCallback(function() {
                    b.callback(a)
                });
                return b.promise
            }
            return a
        }).then(function(a) {
            var b = [];
            k.forEach(a, function(a) {
                if (a.layerObject instanceof w) {
                    var c = a.layerObject;
                    c.loaded && (c.labelingInfo && (a.showLabels || c._collection)) && b.push(c)
                }
            });
            b.length ? G(["../layers/LabelLayer"], function(c) {
                var e = new c;
                k.forEach(b, function(a) {
                    e.addFeatureLayer(a)
                });
                a.push({
                    layerObject: e
                });
                d.callback(a)
            }) : d.callback(a)
        });
        return d
    }

    function db(a, f, b, c, d) {
        var e = [],
            h = [],
            m = [];
        k.forEach(a.operationalLayers, function(a, b) {
            a.featureCollection ? k.forEach(a.featureCollection.layers, function(c, d) {
                var e = !0;
                a.visibleLayers && -1 == k.indexOf(a.visibleLayers, d) && (e = !1);
                c.visibility = a.visibility && e;
                c.opacity = a.opacity;
                c.id = (a.id || "operational" + b) + "_" + d;
                m.push(c)
            }, this) : m.push(a)
        });
        k.forEach(a.baseMap.baseMapLayers, function(a, b) {
            a.baseMapLayer = !0;
            a.id = a.id || "base" + b;
            e.push(a)
        });
        k.forEach(m,
            function(a, b) {
                a.id = a.id || "operational" + b;
                e.push(a)
            });
        k.forEach(e, function(a) {
            a.url && !a.type && (a.deferredsPos = h.length, a.errors = a.errors || [], h.push($a(a.url, a.errors)))
        });
        0 === h.length ? (b = b || ma(e), e = la(e, f, b, c), d.callback(e)) : (new B(h)).addCallback(function(a) {
            Za(a, e, f, h, d, b, c)
        });
        return d
    }

    function N(a, f, b, c) {
        var d = a.minScale,
            e = a.maxScale;
        if (10.1 >= b.version && f)
            for (a = f.length - 1; 0 <= a; a--) {
                if (f[a].id == c)
                    if (0 == d && 0 < f[a].minScale ? d = f[a].minScale : 0 < d && 0 == f[a].minScale ? d = b.minScale : 0 < d && 0 < f[a].minScale && (d =
                            Math.min(d, f[a].minScale)), e = Math.max(b.maxScale || 0, f[a].maxScale || 0), b.setScaleRange(d, e), -1 < f[a].parentLayerId) c = f[a].parentLayerId;
                    else break
            } else 10.1 < b.version && (k.forEach(a.layerInfos, function(a) {
                a.id == c && (0 == d && 0 < a.minScale ? d = a.minScale : 0 < d && 0 == a.minScale || 0 < d && 0 < a.minScale && (d = Math.min(d, a.minScale)), e = Math.max(e || 0, a.maxScale || 0))
            }), b.setScaleRange(d, e))
    }

    function O(a, f, b, c) {
        var d = a.url,
            e = a.__popupIds,
            h = a.__popupUrls,
            m = a.__popupWhereClauses,
            q = a.__popupMinScales,
            r = a.__popupMaxScales,
            n = a.__resourceInfo,
            v = [];
        k.forEach(a.__popups, function(c, l) {
            if (c) {
                var p, s = [];
                k.forEach(c.fieldInfos, function(a) {
                    "shape" !== a.fieldName.toLowerCase() && s.push(a.fieldName)
                });
                if (a.dynamicLayerInfos && 0 < a.dynamicLayerInfos.length) {
                    var t = k.filter(a.dynamicLayerInfos, function(a) {
                        return e[l] == a.id
                    })[0].source;
                    p = new w(d + "/dynamicLayer", {
                        id: a.id + "_" + e[l],
                        source: t,
                        outFields: s,
                        mode: w.MODE_SELECTION,
                        infoTemplate: c && new b(c),
                        drawMode: !1,
                        visible: a.visible,
                        autoGeneralize: !0
                    });
                    var x = function(b, c) {
                        0 < m[b].length && c.setDefinitionExpression(m[b]);
                        if (!g.isDefined(q[b]) && !g.isDefined(r[b])) N(a, f || n.layers, c, e[b]);
                        else if (g.isDefined(a.minScale) || g.isDefined(a.maxScale)) {
                            var d = a.minScale,
                                h = a.maxScale;
                            0 == d && 0 < q[b] ? d = q[b] : 0 < d && 0 == q[b] || 0 < d && 0 < q[b] && (d = Math.min(d, q[b]));
                            h = Math.max(h || 0, r[b] || 0);
                            c.setScaleRange(d, h)
                        } else c.setScaleRange(q[b], r[b])
                    };
                    p.loaded ? x(l, p) : u.connect(p, "onLoad", function(a) {
                        x(l, p)
                    })
                } else {
                    var y = null,
                        z = d + "/" + e[l];
                    if (h[l].length) z = h[l];
                    else if (f)
                        for (t = 0; t < f.length; t++)
                            if (f[t].id === e[l]) {
                                y = f[t];
                                break
                            }
                    p = new w(A(z), {
                        id: a.id + "_" +
                            e[l],
                        outFields: s,
                        mode: w.MODE_SELECTION,
                        infoTemplate: c && new b(c),
                        drawMode: !1,
                        visible: a.visible,
                        resourceInfo: y,
                        autoGeneralize: !0
                    });
                    p.loaded ? (0 < m[l].length && p.setDefinitionExpression(m[l]), N(a, f || n.layers, p, e[l])) : u.connect(p, "onLoad", function(b) {
                        0 < m[l].length && p.setDefinitionExpression(m[l]);
                        N(a, f || n.layers, b, e[l])
                    })
                }
                v.push(p)
            }
        });
        0 < v.length && (u.connect(a, "onVisibilityChange", l.hitch(this, function(a, b) {
            k.forEach(a, function(a) {
                b ? a.show() : a.hide()
            })
        }, v)), u.connect(c, "onLayerRemove", l.hitch(this, function(a,
            b, d) {
            a.id === d.id && k.forEach(b, function(a) {
                c.removeLayer(a)
            })
        }, a, v)));
        delete a.__popups;
        delete a.__popupIds;
        delete a.__popupUrls;
        delete a.__popupWhereClauses;
        delete a.__popupMinScales;
        delete a.__popupMaxScales;
        delete a.__resourceInfo;
        return v
    }

    function eb(a) {
        return y({
            url: A(a.url + "/layers"),
            content: {
                f: "json"
            },
            callbackParamName: "callback",
            error: function() {}
        })
    }

    function fb(a, f, b) {
        var c = [];
        k.forEach(a, function(a) {
            var b = a.__popups;
            b && (1 < b.length && 10 <= a.version) && (a.__deferredsPos = c.length, c.push(eb(a)))
        });
        var d = [];
        0 < c.length ? (new B(c)).addCallback(function(c) {
            k.forEach(a, function(a) {
                a.__popups && 0 < a.__popups.length && (a.__deferredsPos || 0 === a.__deferredsPos ? (d = d.concat(O(a, c[a.__deferredsPos][1].layers, b, f)), delete a.__deferredsPos) : d = d.concat(O(a, null, b, f)))
            });
            f.addLayers(d)
        }) : (k.forEach(a, function(a) {
            a.__popups && 0 < a.__popups.length && (d = d.concat(O(a, null, b, f)))
        }), f.addLayers(d))
    }

    function gb(a) {
        k.forEach(a, function(a) {
            var b = a.layer;
            b.toJson && (a = b.toJson(), a.featureSet && (b.name && -1 < b.name.indexOf("Text")) &&
                k.forEach(a.featureSet.features, function(a, d) {
                    if (a.attributes.TEXT) {
                        var e = b.graphics[d];
                        e.symbol.setText(a.attributes.TEXT);
                        a.symbol.horizontalAlignment && (e.symbol.align = a.symbol.horizontalAlignment);
                        e.setSymbol(e.symbol);
                        e.setAttributes(a.attributes)
                    }
                }, this))
        })
    }

    function hb(a) {
        var f = 6;
        k.forEach(a, function(a) {
            if (a = a.renderer) "esri.renderer.SimpleRenderer" === a.declaredClass ? ((a = a.symbol) && a.xoffset && (f = Math.max(f, Math.abs(a.xoffset))), a && a.yoffset && (f = Math.max(f, Math.abs(a.yoffset)))) : ("esri.renderer.UniqueValueRenderer" ===
                a.declaredClass || "esri.renderer.ClassBreaksRenderer" === a.declaredClass) && k.forEach(a.infos, function(a) {
                (a = a.symbol) && a.xoffset && (f = Math.max(f, Math.abs(a.xoffset)));
                a && a.yoffset && (f = Math.max(f, Math.abs(a.yoffset)))
            })
        });
        return f
    }

    function na(a) {
        var f = this,
            b = f.infoWindow,
            c = a.graphic;
        if (f.loaded) {
            b.hide();
            b.clearFeatures();
            var d = [];
            k.forEach(f.graphicsLayerIds, function(a) {
                if ((a = f.getLayer(a)) && a instanceof w && a.loaded && a.visible) a.clearSelection(), a.infoTemplate && !a.suspended && d.push(a)
            });
            k.forEach(f.layerIds,
                function(a) {
                    (a = f.getLayer(a)) && (-1 !== a.declaredClass.indexOf("ArcGISImageServiceLayer") && a.loaded && a.visible && a.infoTemplate) && d.push(a)
                });
            c = c && c.getInfoTemplate() ? c : null;
            if (d.length || c) {
                var e = hb(d),
                    h = a.screenPoint,
                    m = f.toMap(new za(h.x - e, h.y + e)),
                    e = f.toMap(new za(h.x + e, h.y - e)),
                    m = new C(m.x, m.y, e.x, e.y, f.spatialReference),
                    g = new rb;
                g.geometry = m;
                g.timeExtent = f.timeExtent;
                var l = !0,
                    m = k.map(d, function(b) {
                        var c; - 1 !== b.declaredClass.indexOf("ArcGISImageServiceLayer") ? (g.geometry = a.mapPoint, l = !1, c = b.queryVisibleRasters(g, {
                            rasterAttributeTableFieldPrefix: "Raster.",
                            returnDomainValues: !0
                        }), c.addCallback(function() {
                            return b.getVisibleRasters()
                        })) : (c = b.selectFeatures(g), c.addCallback(function() {
                            return b.getSelectedFeatures()
                        }));
                        return c
                    });
                c && (e = new s, e.callback([c]), m.splice(0, 0, e));
                if (!k.some(m, function(a) {
                        return -1 === a.fired
                    })) {
                    var n = c ? 1 : 0;
                    k.forEach(d, function(a) {
                        n = -1 !== a.declaredClass.indexOf("ArcGISImageServiceLayer") ? n + a.getVisibleRasters().length : n + a.getSelectedFeatures().length
                    });
                    if (!n) return
                }
                b.setFeatures(m);
                b.show(a.mapPoint, {
                    closestFirst: l
                })
            }
        }
    }

    function wb(a, f) {
        var b = f.mapOptions || {},
            c;
        b.infoWindow || (c = new qb({
            visibleWhenEmpty: !1
        }, nb.create("div")), b.infoWindow = c);
        !g.isDefined(b.showInfoWindowOnClick) && !f.usePopupManager && (b.showInfoWindowOnClick = !1);
        b = new ob(a, b);
        u.connect(b, "onLayersAddResult", gb);
        return b
    }

    function x(a, f, b, c, d, e) {
        var h, g, q, l;
        c.map ? (h = c.map, g = c.clickEventHandle, q = c.clickEventListener, l = c.errors) : (h = wb(c, d), !d.ignorePopups && (!d.disableClickBehavior && !d.usePopupManager) && (g = u.connect(h, "onClick", na), q =
            na));
        h.addLayers(a);
        !d.ignorePopups && !d.usePopupManager && fb(a, h, d._clazz);
        var n = l || [];
        k.forEach(f, function(a) {
            a.errors && (n = n.concat(a.errors))
        }, this);
        h.loaded ? e.callback({
            map: h,
            itemInfo: b,
            errors: n,
            clickEventHandle: g,
            clickEventListener: q
        }) : u.connect(h, "onLoad", function() {
            e.callback({
                map: h,
                itemInfo: b,
                errors: n,
                clickEventHandle: g,
                clickEventListener: q
            })
        })
    }

    function P(a, f, b, c, d) {
        var e = [];
        k.forEach(d, function(a) {
            l.isArray(a.layerObject) ? k.forEach(a.layerObject, function(a) {
                e.push(a)
            }) : e.push(a.layerObject)
        });
        if ("BingMapsAerial" === d[0].type || "BingMapsRoad" === d[0].type || "BingMapsHybrid" === d[0].type) var h = setInterval(function() {
            if (d[0].layerObject && d[0].layerObject.loaded) clearInterval(h), ib(a, f, b, c, d, e);
            else if (d[0].errors) {
                clearInterval(h);
                var k = "";
                d[0].errors && d[0].errors.length && (k = " (" + d[0].errors[0].message + ")");
                c.errback(Error(aa.arcgis.utils.baseLayerError + k))
            }
        }, 10);
        else if (!e[0] && d[0].baseMapLayer) {
            var g = "";
            d[0].errors && d[0].errors.length && (g = " (" + d[0].errors[0].message + ")");
            c.errback(Error(aa.arcgis.utils.baseLayerError +
                g))
        } else ib(a, f, b, c, d, e)
    }

    function ib(a, f, b, c, d, e) {
        try {
            var h = b.mapOptions || {};
            b.mapOptions = h;
            var m = a.item;
            e = k.filter(e, g.isDefined);
            if (m)
                if (m.extent && m.extent.length)
                    if (h.extent) x(e, d, a, f, b, c);
                    else {
                        var l = new C(m.extent[0][0], m.extent[0][1], m.extent[1][0], m.extent[1][1], new z({
                                wkid: 4326
                            })),
                            r = e[0].spatialReference;
                        4326 === r.wkid ? (h.extent = l, x(e, d, a, f, b, c)) : 102100 === r.wkid || 102113 === r.wkid || 3857 === r.wkid ? (l.xmin = Math.max(l.xmin, -180), l.xmax = Math.min(l.xmax, 180), l.ymin = Math.max(l.ymin, -89.99), l.ymax = Math.min(l.ymax,
                            89.99), h.extent = pb.geographicToWebMercator(l), x(e, d, a, f, b, c)) : b.geometryServiceURL || I.defaults.geometryService ? (b.geometryServiceURL ? new sb(b.geometryServiceURL) : I.defaults.geometryService).project([l], r, function(k) {
                            k = k[0];
                            h.extent = h.extent || k;
                            x(e, d, a, f, b, c)
                        }, function() {
                            x(e, d, a, f, b, c)
                        }) : c.errback(Error(aa.arcgis.utils.geometryServiceError))
                    } else x(e, d, a, f, b, c);
            else x(e, d, a, f, b, c)
        } catch (n) {
            c.errback(n)
        }
    }

    function jb(a) {
        var f = [];
        a = a.baseMap.baseMapLayers.concat(a.operationalLayers);
        k.forEach(a, function(a) {
            var c = {};
            if (a.featureCollection && "CSV" !== a.type) !0 === a.featureCollection.showLegend && k.forEach(a.featureCollection.layers, function(d) {
                !1 !== d.showLegend && (c = {
                    layer: d.layerObject,
                    title: a.title,
                    defaultSymbol: d.renderer && d.renderer.defaultSymbol && d.renderer.defaultLabel ? !0 : !1
                }, 1 < a.featureCollection.layers.length && (c.title += " - " + d.layerDefinition.name), f.push(c))
            });
            else if (a.baseMapLayer && !0 === a.showLegend && a.layerObject || !a.baseMapLayer && !1 !== a.showLegend && a.layerObject) {
                var d = a.layerObject.renderer,
                    e = a.layerObject.declaredClass,
                    d = !d || d && d.defaultSymbol && d.defaultLabel ? !0 : !1;
                if (10.1 > a.layerObject.version && ("esri.layers.ArcGISDynamicMapServiceLayer" === e || "esri.layers.ArcGISTiledMapServiceLayer" === e) || "esri.layers.ArcGISImageServiceLayer" === e) d = !0;
                c = {
                    layer: a.layerObject,
                    title: a.title,
                    defaultSymbol: d
                };
                a.layers && (e = k.map(k.filter(a.layers, function(a) {
                    return !1 === a.showLegend
                }), function(a) {
                    return a.id
                }), e.length && (c.hideLayers = e));
                f.push(c)
            }
        });
        return f
    }

    function xb(a, f) {
        function b(a, b) {
            k.forEach(a, function(a, c) {
                switch (a) {
                    case Q:
                        Ha =
                            b[c];
                        break;
                    case R:
                        Na = b[c];
                        break;
                    case oa:
                        Va = b[c];
                        break;
                    case S:
                        Wa = b[c];
                        break;
                    case pa:
                        Ia = b[c];
                        break;
                    case T:
                        Ua = b[c];
                        break;
                    case qa:
                        Ga = b[c];
                        break;
                    case ra:
                        Ka = b[c];
                        break;
                    case U:
                        Ra = b[c];
                        break;
                    case V:
                        Xa = b[c];
                        break;
                    case sa:
                        Ja = b[c];
                        break;
                    case ta:
                        Ma = b[c];
                        break;
                    case W:
                        Oa = b[c];
                        break;
                    case ua:
                        La = b[c];
                        break;
                    case X:
                        Ya = b[c];
                        break;
                    case va:
                        Ta = b[c];
                        break;
                    case Y:
                        t = b[c];
                        break;
                    case Z:
                        Sa = b[c];
                        break;
                    case $:
                        Qa = b[c];
                        break;
                    case wa:
                        Pa = b[c]
                }
            })
        }
        var c = new s,
            d = a.itemData,
            e = [];
        d.baseMap && d.baseMap.baseMapLayers && (e = e.concat(d.baseMap.baseMapLayers));
        d.operationalLayers && (e = e.concat(d.operationalLayers));
        for (var d = k.map(e, function(a) {
                return a && a.layerType
            }), h = [], g = [], e = !1, l = 0; l < d.length; l++) {
            switch (d[l]) {
                case "ArcGISFeatureLayer":
                    -1 === k.indexOf(h, V) && h.push(V);
                    break;
                case "ArcGISImageServiceLayer":
                    -1 === k.indexOf(h, R) && (h.push(R), g.push(ra), g.push(ta), g.push(ua));
                    break;
                case "ArcGISMapServiceLayer":
                    -1 === k.indexOf(h, Q) && (h.push(Q), g.push(pa), g.push(qa), g.push(sa));
                    break;
                case "ArcGISStreamLayer":
                    -1 === k.indexOf(h, X) && h.push(X);
                    break;
                case "ArcGISTiledImageServiceLayer":
                case "ArcGISTiledMapServiceLayer":
                    break;
                case "BingMapsAerial":
                case "BingMapsHybrid":
                case "BingMapsRoad":
                    -1 === k.indexOf(h, Y) && h.push(Y);
                    break;
                case "CSV":
                    -1 === k.indexOf(h, S) && (h.push(S), g.push(oa));
                    break;
                case "GeoRSS":
                    -1 === k.indexOf(h, T) && h.push(T);
                    break;
                case "KML":
                    -1 === k.indexOf(h, U) && h.push(U);
                    break;
                case "OpenStreetMap":
                    -1 === k.indexOf(h, W) && h.push(W);
                    break;
                case "WebTiledLayer":
                    -1 === k.indexOf(h, Z) && (h.push(Z), g.push(va));
                    break;
                case "WMS":
                    -1 === k.indexOf(h, $) && (h.push($), g.push(wa));
                    break;
                default:
                    e = !0
            }
            if (e) break
        }
        e && (h = yb, g = zb);
        h.length ? G(h,
            function() {
                b(h, arguments);
                g.length ? G(g, function() {
                    b(g, arguments);
                    c.resolve()
                }) : c.resolve()
            }) : c.resolve();
        return c
    }

    function kb(a, f, b, c) {
        xb(c, f).then(function() {
            ub(c, f).then(function(c) {
                var e = c[0],
                    f = c[1];
                if (!e.itemData.operationalLayers || 0 === e.itemData.operationalLayers.length) J(e, f).addCallback(function(c) {
                    M(c.itemData, f).addCallback(l.hitch(null, P, c, a, f, b))
                });
                else {
                    var g = new s,
                        q = e.itemData.baseMap.baseMapLayers.slice(),
                        p = k.filter(e.itemData.baseMap.baseMapLayers, function(a) {
                            return !a.isReference
                        });
                    c = {
                        item: e.item,
                        itemData: {
                            baseMap: {
                                baseMapLayers: p
                            }
                        }
                    };
                    e.itemData.baseMap.baseMapLayers = k.filter(e.itemData.baseMap.baseMapLayers, function(a) {
                        return a.isReference
                    });
                    J(c, f).addCallback(function(b) {
                        M(b.itemData, f).addCallback(l.hitch(null, P, b, a, f, g))
                    });
                    g.then(function(a) {
                        J(e, f).addCallback(function(c) {
                            M(c.itemData, f, a.map.spatialReference, p).addCallback(function(d) {
                                c.itemData.baseMap.baseMapLayers = q;
                                P(c, a, f, b, d)
                            })
                        })
                    }, l.hitch(b, b.errback))
                }
            })
        })
    }

    function lb(a) {
        p._arcgisUrl && 0 < p._arcgisUrl.length && (p.arcgisUrl =
            p._arcgisUrl);
        var f = p.arcgisUrl + "/" + a,
            b = {},
            c = new s;
        y({
            url: f,
            content: {
                f: "json"
            },
            callbackParamName: "callback",
            load: function(a) {
                b.item = a;
                y({
                    url: f + "/data",
                    content: {
                        f: "json"
                    },
                    callbackParamName: "callback",
                    load: function(a) {
                        b.itemData = a;
                        c.callback(b)
                    },
                    error: function(a) {
                        c.errback(a)
                    }
                })
            },
            error: function(a) {
                c.errback(a)
            }
        });
        return c
    }
    String.prototype.endsWith = function(a) {
        return this.match(a + "$") == a
    };
    var p, Ha, Na, Va, Wa, Ia, Ua, Ga, Ka, Ra, Xa, Ja, Ma, Oa, La, Ya, Ta, t, Sa, Qa, Pa, Q = "../layers/ArcGISDynamicMapServiceLayer",
        R = "../layers/ArcGISImageServiceLayer",
        oa = "./csv",
        S = "../layers/CSVLayer",
        pa = "../layers/DynamicLayerInfo",
        T = "../layers/GeoRSSLayer",
        qa = "../layers/ImageParameters",
        ra = "../layers/ImageServiceParameters",
        U = "../layers/KMLLayer",
        V = "../layers/LabelClass",
        sa = "../layers/LayerDrawingOptions",
        ta = "../layers/MosaicRule",
        W = "../layers/OpenStreetMapLayer",
        ua = "../layers/RasterFunction",
        X = "../layers/StreamLayer",
        va = "../layers/TileInfo",
        Y = "../virtualearth/VETiledLayer",
        Z = "../layers/WebTiledLayer",
        $ = "../layers/WMSLayer",
        wa = "../layers/WMSLayerInfo",
        yb = [Q,
            R, S, T, U, V, W, X, Y, Z, $
        ],
        zb = [oa, pa, qa, ra, sa, ta, ua, va, wa];
    p = {
        arcgisUrl: location.protocol + "//www.arcgis.com/sharing/rest/content/items",
        getItem: lb,
        createMap: function(a, f, b) {
            var c = new s;
            b = b || {};
            var d = b.infoTemplateClass;
            b._clazz = d && (l.isObject(d) ? d : l.getObject(d)) || Ba;
            l.isString(a) ? lb(a).addCallback(l.hitch(null, kb, f, b, c)).addErrback(l.hitch(c, c.errback)) : kb(f, b, c, a);
            return c
        },
        getLegendLayers: function(a) {
            return a && a.itemInfo && a.itemInfo.itemData ? jb(a.itemInfo.itemData) : []
        },
        _arcgisUrl: null,
        _getItemProps: J,
        _getItemData: E,
        _getBingKey: ba,
        _portalUrlResponse: da,
        _portalUrlFailure: K,
        _processFSItemProperties: ca,
        _processSSItemProperties: Ca,
        _getLayers: M,
        _preBuildLayerObjects: Za,
        _buildLayerObjects: la,
        _preCreateMap: P,
        _getMapSR: ma,
        _createMap: x,
        _addSelectionLayers: fb,
        _createSelectionFeatureLayers: O,
        _getServiceInfo: $a,
        _getFeatureCollectionItem: ab,
        _mergeFeatureCollectionItem: bb,
        _projectFeatureCollection: cb,
        _getLayersInfo: eb,
        _initLayer: ka,
        _loadAsCached: ga,
        _loadAsDynamic: Fa,
        _processPopups: ea,
        _onLayersAddResult: gb,
        _sameSpatialReferenceAsBasemap: ia,
        _sameTilingSchemeAsBasemap: ja,
        _showPopup: na,
        _calculateClickTolerance: hb,
        _getVisibleFeatureLayers: ha,
        _updateLayerScaleInfo: N,
        _checkUrl: A,
        _isHostedService: fa,
        _isAgolService: Ea,
        _getLegendLayers: jb
    };
    l.setObject("arcgis.utils", p, F);
    return p
});
},
'esri/kernel':function(){
//>>built
define(["dojo/_base/kernel", "dojo/_base/config", "dojo/has"], function(b, c, a) {
    b = window.location;
    a = b.pathname;
    a = {
        version: "3.12",
        _appBaseUrl: b.protocol + "//" + b.host + a.substring(0, a.lastIndexOf(a.split("/")[a.split("/").length - 1]))
    };
    c.noGlobals || (window.esri = a);
    (a.dijit = a.dijit || {})._arcgisUrl = ("file:" === b.protocol ? "http:" : b.protocol) + "//www.arcgis.com/sharing/rest";
    return a
});
},
'esri/config':function(){
//>>built
define(["dojo/_base/config", "dojo/topic", "dojo/has", "./kernel"], function(b, c, a, d) {
    a = {
        defaults: {
            screenDPI: 96,
            geometryService: null,
            kmlService: null,
            map: {
                width: 400,
                height: 400,
                layerNamePrefix: "layer",
                graphicsLayerNamePrefix: "graphicsLayer",
                slider: {
                    left: "30px",
                    top: "30px",
                    width: null,
                    height: "200px"
                },
                sliderLabel: {
                    tick: 5,
                    labels: null,
                    style: "width:2em; font-family:Verdana; font-size:75%;"
                },
                sliderChangeImmediate: !0,
                zoomSymbol: {
                    color: [0, 0, 0, 64],
                    outline: {
                        color: [255, 0, 0, 255],
                        width: 1.25,
                        style: "esriSLSSolid"
                    },
                    style: "esriSFSSolid"
                },
                zoomDuration: 500,
                zoomRate: 25,
                panDuration: 350,
                panRate: 25,
                logoLink: "http://www.esri.com"
            },
            autoSpatialIndexing: window.Worker && !1,
            io: {
                errorHandler: function(a, b) {
                    c.publish("esri.Error", [a])
                },
                proxyUrl: null,
                alwaysUseProxy: !1,
                useCors: !0,
                corsEnabledServers: "server.arcgisonline.com services.arcgisonline.com www.arcgis.com tiles.arcgis.com tiles1.arcgis.com tiles2.arcgis.com tiles3.arcgis.com tiles4.arcgis.com services.arcgis.com services1.arcgis.com services2.arcgis.com services3.arcgis.com services4.arcgis.com services5.arcgis.com static.arcgis.com utility.arcgisonline.com geocode.arcgis.com geoenrich.arcgis.com qaext.arcgis.com tilesqa.arcgis.com servicesqa.arcgis.com servicesqa1.arcgis.com servicesqa2.arcgis.com servicesqa3.arcgis.com geocodeqa.arcgis.com geoenrichqa.arcgis.com dev.arcgis.com devext.arcgis.com tilesdevext.arcgis.com servicesdev.arcgis.com servicesdev1.arcgis.com servicesdev2.arcgis.com servicesdev3.arcgis.com geocodedev.arcgis.com geoenrichdev.arcgis.com".split(" "),
                corsDetection: window.cordova ? !1 : !0,
                corsStatus: {},
                webTierAuthServers: [],
                proxyRules: [],
                postLength: 2E3,
                timeout: 6E4,
                useWorkers: "on-request",
                maxRequestWorkers: 5
            }
        }
    };
    b.noGlobals || (window.esriConfig = a);
    return a
});
},
'esri/lang':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/json", "dojo/_base/kernel", "dojo/_base/lang", "dojo/date", "dojo/has", "dojo/number", "dojo/date/locale", "./kernel"], function(l, q, r, g, s, w, t, u, x) {
    function h(a) {
        return void 0 !== a && null !== a
    }

    function m(a, c, b) {
        var d = b.match(/([^\(]+)(\([^\)]+\))?/i),
            e = g.trim(d[1]);
        b = c[a];
        var d = q.fromJson((d[2] ? g.trim(d[2]) : "()").replace(/^\(/, "({").replace(/\)$/, "})")),
            f = d.utcOffset;
        if (-1 === l.indexOf(v, e)) e = g.getObject(e), g.isFunction(e) && (b = e(b, a, c, d));
        else if ("number" === typeof b || "string" ===
            typeof b && b && !isNaN(Number(b))) switch (b = Number(b), e) {
            case "NumberFormat":
                return t.format(b, d);
            case "DateString":
                a = new Date(b);
                if (d.local || d.systemLocale) return d.systemLocale ? a.toLocaleDateString() + (d.hideTime ? "" : " " + a.toLocaleTimeString()) : a.toDateString() + (d.hideTime ? "" : " " + a.toTimeString());
                a = a.toUTCString();
                d.hideTime && (a = a.replace(/\s+\d\d\:\d\d\:\d\d\s+(utc|gmt)/i, ""));
                return a;
            case "DateFormat":
                return a = new Date(b), h(f) && (a = s.add(a, "minute", a.getTimezoneOffset() - f)), u.format(a, d)
        }
        return h(b) ?
            b : ""
    }

    function n(a, c) {
        var b;
        if (c)
            for (b in a) a.hasOwnProperty(b) && (void 0 === a[b] ? delete a[b] : a[b] instanceof Object && n(a[b], !0));
        else
            for (b in a) a.hasOwnProperty(b) && void 0 === a[b] && delete a[b];
        return a
    }
    var v = ["NumberFormat", "DateString", "DateFormat"],
        p = /<\/?[^>]+>/g;
    return {
        valueOf: function(a, c) {
            for (var b in a)
                if (a[b] == c) return b;
            return null
        },
        stripTags: function(a) {
            if (a) {
                var c = typeof a;
                if ("string" === c) a = a.replace(p, "");
                else if ("object" === c)
                    for (var b in a)(c = a[b]) && "string" === typeof c && c.replace(p, "")
            }
            return a
        },
        substitute: function(a, c, b) {
            var d, e, f;
            h(b) && (g.isObject(b) ? (d = b.first, e = b.dateFormat, f = b.numberFormat) : d = b);
            if (!c || "${*}" === c) {
                c = [];
                for (var k in a) {
                    b = a[k];
                    if (e && -1 !== l.indexOf(e.properties || "", k)) b = m(k, a, e.formatter || "DateString");
                    else if (f && -1 !== l.indexOf(f.properties || "", k)) b = m(k, a, f.formatter || "NumberFormat");
                    c.push(k + " \x3d " + (h(b) ? b : "") + "\x3cbr/\x3e");
                    if (d) break
                }
                return c.join("")
            }
            return g.replace(c, g.hitch({
                obj: a
            }, function(a, b) {
                var c = b.split(":");
                return 1 < c.length ? (b = c[0], c.shift(), m(b, this.obj,
                    c.join(":"))) : e && -1 !== l.indexOf(e.properties || "", b) ? m(b, this.obj, e.formatter || "DateString") : f && -1 !== l.indexOf(f.properties || "", b) ? m(b, this.obj, f.formatter || "NumberFormat") : h(this.obj[b]) ? this.obj[b] : ""
            }), /\$\{([^\}]+)\}/g)
        },
        filter: function(a, c, b) {
            c = [g.isString(a) ? a.split("") : a, b || r.global, g.isString(c) ? new Function("item", "index", "array", c) : c];
            b = {};
            var d;
            a = c[0];
            for (d in a) c[2].call(c[d], a[d], d, a) && (b[d] = a[d]);
            return b
        },
        isDefined: h,
        fixJson: n
    }
});
},
'esri/request':function(){
//>>built
define(["require", "dojo/_base/array", "dojo/_base/config", "dojo/_base/Deferred", "dojo/_base/lang", "dojo/_base/url", "dojo/_base/xhr", "dojo/io/script", "dojo/io/iframe", "dojo/dom-construct", "dojo/io-query", "./kernel", "./config", "./sniff", "./lang", "./urlUtils", "./deferredUtils"], function(P, w, J, R, p, W, z, X, Y, S, T, l, Z, r, x, q, $) {
    function K(a) {
        a = new W(a);
        return (a.host + (a.port ? ":" + a.port : "")).toLowerCase()
    }

    function C(a, d, e, f) {
        var k = !1,
            n = !1,
            t;
        x.isDefined(d) && (p.isObject(d) ? (k = !!d.useProxy, n = !!d.usePost, t = d.crossOrigin) : k = !!d);
        a = p.mixin({},
            a);
        a._ssl && (a.url = a.url.replace(/^http:/i, "https:"));
        d = a.content;
        var h = a.url,
            g = e && a.form,
            s = m;
        t = x.isDefined(t) ? t : s.useCors;
        a.load = function(a) {
            var b;
            a && (a.error ? (b = p.mixin(Error(), a.error), b.log = J.isDebug) : "error" === a.status && (b = p.mixin(Error(), a), b.log = J.isDebug), b && !x.isDefined(b.httpCode) && (b.httpCode = b.code));
            return b || a
        };
        a.error = function(a, b) {
            b && b.xhr && b.xhr.abort();
            a instanceof Error || (a = p.mixin(Error(), a));
            a.log = J.isDebug;
            s.errorHandler(a, b);
            return a
        };
        a._token && (a.content = a.content || {}, a.content.token =
            a._token);
        var y = 0,
            A;
        d && h && (A = T.objectToQuery(d), y = A.length + h.length + 1, r("esri-url-encodes-apostrophe") && (y = A.replace(/'/g, "%27").length + h.length + 1));
        a.timeout = x.isDefined(a.timeout) ? a.timeout : s.timeout;
        a.handleAs = a.handleAs || "json";
        try {
            var u, v, b = t && q.canUseXhr(a.url) && !/https?:\/\/[^\/]+\/[^\/]+\/admin\/?(\/.*)?$/i.test(a.url),
                c = q.hasSameOrigin(a.url, window.location.href) || b,
                B = n || e || y > s.postLength ? !0 : !1,
                U = !c && -1 !== a.handleAs.indexOf("json") && a.callbackParamName && !e ? !0 : !1,
                D = q.getProxyRule(a.url) ||
                s.alwaysUseProxy || k || (!U || B) && !c ? !0 : !1;
            e && (!r("esri-file-upload") && !D && b) && (D = !0);
            if (D)
                if (u = q.getProxyUrl(h, t), v = u.path, u._xo && (b = !0), !B && v.length + 1 + y > s.postLength && (B = !0), a.url = v + "?" + h, B) a.content = p.mixin(u.query || {}, d);
                else {
                    var V = T.objectToQuery(p.mixin(u.query || {}, d));
                    V && (a.url += "?" + V);
                    a.content = null
                }
            if (U && !B) return !x.isDefined(a.isAsync) && 4 > r("ff") && (a.isAsync = !0), X.get(E ? E(a) : a);
            var F = a.headers;
            if (b && (!F || !F.hasOwnProperty("X-Requested-With"))) F = a.headers = F || {}, F["X-Requested-With"] = null;
            if (e) {
                var L =
                    a.callbackParamName || "callback.html",
                    C = a.callbackElementName || "textarea",
                    G, M, H, N, O = g.elements ? g.elements.length : 0,
                    Q;
                if (d = a.content)
                    for (G in d)
                        if (H = d[G], x.isDefined(H)) {
                            M = null;
                            for (N = 0; N < O; N++)
                                if (Q = g.elements[N], Q.name === G) {
                                    M = Q;
                                    break
                                }
                            M ? M.value = H : f ? g.append(G, H) : g.appendChild(S.create("input", {
                                type: "hidden",
                                name: G,
                                value: H
                            }))
                        }
                if (r("esri-file-upload")) w.forEach(g.elements, function(a) {
                    a.name === L && g.removeChild(a)
                }), a.contentType = !1, a.postData = f ? g : new FormData(g), delete a.form;
                else {
                    g.enctype = "multipart/form-data";
                    9 > r("ie") && (g.encoding = "multipart/form-data");
                    g.method = "post";
                    w.some(g.elements, function(a) {
                        return a.name === L
                    }) || g.appendChild(S.create("input", {
                        type: "hidden",
                        name: L,
                        value: C
                    }));
                    if (-1 !== h.toLowerCase().indexOf("addattachment") || -1 !== h.toLowerCase().indexOf("updateattachment")) a.url = h + (-1 === h.indexOf("?") ? "?" : "\x26") + L + "\x3d" + C, D && (a.url = v + "?" + a.url);
                    delete a.content
                }
            }
            if (b && !a.hasOwnProperty("withCredentials"))
                if (f = D ? v : h, -1 !== w.indexOf(m.webTierAuthServers, K(f))) a.withCredentials = !0;
                else if (l.id) {
                var I =
                    l.id.findServerInfo(f);
                I && I.webTierAuth && (a.withCredentials = !0)
            }
            a = E ? E(a) : a;
            return B ? e && !r("esri-file-upload") ? Y.send(a) : z.post(a) : z.get(a)
        } catch (P) {
            return e = new R, e.errback(a.error(P)), e
        }
    }

    function O(a) {
        var d = m.corsStatus,
            e = q.canUseXhr(a, !0); - 1 < e && m.corsEnabledServers.splice(e, 1);
        d[K(a)] = 1;
        return e
    }

    function I(a) {
        var d = m.corsStatus;
        if (m.corsDetection && m.useCors) try {
            var e = K(a);
            r("esri-cors") && (a && -1 !== a.toLowerCase().indexOf("/rest/services") && !q.hasSameOrigin(a, window.location.href) && !q.canUseXhr(a) &&
                !d[e]) && (d[e] = -1, z.get({
                url: a.substring(0, a.toLowerCase().indexOf("/rest/") + 6) + "info",
                content: {
                    f: "json"
                },
                failOk: !0,
                handleAs: "json",
                headers: {
                    "X-Requested-With": null
                }
            }).then(function(f) {
                f ? (d[e] = 2, q.canUseXhr(a) || m.corsEnabledServers.push(e)) : d[e] = 1
            }, function(a) {
                d[e] = 1
            }))
        } catch (f) {
            console.log("esri._detectCors: an unknown error occurred while detecting CORS support")
        }
    }

    function n(a, d) {
        function e(b) {
            b._pendingDfd = C(a, d, y, s);
            if (!b._pendingDfd) {
                b.ioArgs = b._pendingDfd && b._pendingDfd.ioArgs;
                var c = Error("Deferred object is missing");
                c.log = J.isDebug;
                a._usrDfd = null;
                b.errback(c);
                b._pendingDfd = null;
                return b
            }
            b._pendingDfd.addCallback(function(d) {
                b.ioArgs = b._pendingDfd && b._pendingDfd.ioArgs;
                a._usrDfd = null;
                b.callback(d);
                b._pendingDfd = null
            }).addErrback(function(c) {
                var e, f, g;
                c && (e = c.code, f = c.subcode, g = (g = c.messageCode) && g.toUpperCase());
                if (c && 403 == e && (4 == f || c.message && -1 < c.message.toLowerCase().indexOf("ssl") && -1 === c.message.toLowerCase().indexOf("permission"))) {
                    if (!a._ssl) {
                        a._ssl = a._sslFromServer = !0;
                        a._usrDfd = b;
                        n(a, d);
                        return
                    }
                } else if (c &&
                    415 == c.status) {
                    if (O(a.url), !a._err415) {
                        a._err415 = 1;
                        a._usrDfd = b;
                        n(a, d);
                        return
                    }
                } else if (l.id && -1 !== w.indexOf(l.id._errorCodes, e) && !l.id._isPublic(a.url) && !p && (403 != e || -1 === w.indexOf(aa, g) && (!x.isDefined(f) || 2 == f))) {
                    b._pendingDfd = l.id.getCredential(a.url, {
                        token: a._token,
                        error: c
                    });
                    b._pendingDfd.addCallback(function(c) {
                        a._token = c.token;
                        a._usrDfd = b;
                        a._credential = c;
                        a._ssl = a._sslFromServer || c.ssl;
                        n(a, d)
                    }).addErrback(function(c) {
                        a._usrDfd = null;
                        b.errback(c);
                        b._pendingDfd = null
                    });
                    return
                }
                b.ioArgs = b._pendingDfd &&
                    b._pendingDfd.ioArgs;
                a._usrDfd = null;
                b.errback(c);
                b._pendingDfd = null
            })
        }
        a.url = q.fixUrl(a.url);
        "file:" !== window.location.protocol && (a.url = q.getAbsoluteUrl(a.url));
        d = d || {};
        var f, k = a.form,
            p = d.disableIdentityLookup,
            t = d._preLookup,
            h = !1;
        if (r("esri-workers") && !1 !== m.useWorkers)
            if (!0 === d.useWorkers || !0 === m.useWorkers) h = !0;
            else if (d.workerOptions) {
            var g = d.workerOptions;
            if (g.callback || g.worker && g.worker.worker instanceof Worker) h = !0
        }
        var s = k && k.append,
            y = k && (k.elements ? w.some(k.elements, function(a) {
                return "file" ===
                    a.type
            }) : s),
            A = -1 !== a.url.toLowerCase().indexOf("token\x3d") || a.content && a.content.token || y && w.some(k.elements, function(a) {
                return "token" === a.name
            }) ? 1 : 0;
        I(a.url);
        if (a._usrDfd) f = a._usrDfd;
        else {
            f = new R($._dfdCanceller);
            f.addCallback(function(b) {
                /\/sharing\/rest\/accounts\/self/i.test(a.url) && (!A && !a._token && b.user && b.user.username) && m.webTierAuthServers.push(K(a.url));
                if (b = a._credential) {
                    var c = l.id.findServerInfo(b.server);
                    if (c = c && c.owningSystemUrl) c = c.replace(/\/?$/, "/sharing"), (b = l.id.findCredential(c,
                        b.userId)) && -1 === l.id._getIdenticalSvcIdx(c, b) && b.resources.splice(0, 0, c)
                }
            });
            f.addBoth(function(b) {
                delete a._credential;
                if (b && (!r("ie") || !b.nodeType)) b._ssl = a._ssl
            });
            var u = a.load,
                v = a.error;
            u && f.addCallback(function(a) {
                var c = f._pendingDfd,
                    c = c && c.ioArgs;
                return u.call(c && c.args, a, c)
            });
            v && f.addErrback(function(a) {
                var c = f._pendingDfd,
                    c = c && c.ioArgs;
                return v.call(c && c.args, a, c)
            })
        }
        if (l.id && !A && !a._token && !l.id._isPublic(a.url) && (!p || t))
            if (k = l.id.findCredential(a.url)) a._token = k.token, a._ssl = k.ssl;
        h ? d.workerOptions &&
            d.workerOptions.worker ? (z = d.workerOptions.worker, e(f)) : P(["./workers/RequestClient"], function(a) {
                if (d.workerOptions) {
                    var c = d.workerOptions;
                    z = a.getClient(c.callback, c.cbFunction)
                } else z = a.getClient();
                e(f)
            }) : e(f);
        return f
    }
    var E, m = Z.defaults.io,
        aa = ["COM_0056", "COM_0057"];
    n._request = C;
    n._disableCors = O;
    n._detectCors = I;
    n.setRequestPreCallback = function(a) {
        E = a
    };
    return n
});
},
'esri/sniff':function(){
//>>built
define(["dojo/_base/sniff", "./kernel"], function(a, m) {
    var c = a("ff"),
        e = a("ie"),
        k = void 0 === e && 7 <= a("trident"),
        g = a("webkit"),
        f = a("opera"),
        l = a("chrome"),
        n = a("safari"),
        h = navigator.userAgent,
        d;
    (d = h.match(/(iPhone|iPad|CPU)\s+OS\s+(\d+\_\d+)/i)) && a.add("esri-iphone", parseFloat(d[2].replace("_", ".")));
    (d = h.match(/Android\s+(\d+\.\d+)/i)) && a.add("esri-android", parseFloat(d[1]));
    (d = h.match(/Fennec\/(\d+\.\d+)/i)) && a.add("esri-fennec", parseFloat(d[1]));
    0 <= h.indexOf("BlackBerry") && 0 <= h.indexOf("WebKit") && a.add("esri-blackberry",
        1);
    a.add("esri-touch", a("esri-iphone") || a("esri-android") || a("esri-blackberry") || 6 <= a("esri-fennec") || (c || g) && document.createTouch ? !0 : !1);
    a.add("esri-pointer", navigator.pointerEnabled || navigator.msPointerEnabled);
    m._getDOMAccessor = function(a) {
        var b = "";
        c ? b = "Moz" : g ? b = "Webkit" : e ? b = "ms" : f && (b = "O");
        return b + a.charAt(0).toUpperCase() + a.substr(1)
    };
    a.add("esri-phonegap", !!window.cordova);
    a.add("esri-cors", a("esri-phonegap") || "XMLHttpRequest" in window && "withCredentials" in new XMLHttpRequest);
    a.add("esri-file-upload",
        window.FormData && window.FileList ? !0 : !1);
    a.add("esri-workers", window.Worker ? !0 : !1);
    a.add("esri-transforms", k || 9 <= e || 3.5 <= c || 4 <= l || 3.1 <= n || 10.5 <= f || 3.2 <= a("esri-iphone") || 2.1 <= a("esri-android"));
    a.add("esri-transitions", k || 10 <= e || 4 <= c || 4 <= l || 3.1 <= n || 10.5 <= f || 3.2 <= a("esri-iphone") || 2.1 <= a("esri-android"));
    a.add("esri-transforms3d", k || 10 <= c || 12 <= l || 4 <= n || 3.2 <= a("esri-iphone") || 3 <= a("esri-android"));
    a.add("esri-url-encodes-apostrophe", function() {
        var a = window.document.createElement("a");
        a.href = "?'";
        return -1 <
            a.href.indexOf("?%27")
    });
    3 > a("esri-android") && (a.add("esri-transforms", !1, !1, !0), a.add("esri-transitions", !1, !1, !0), a.add("esri-transforms3d", !1, !1, !0));
    m._css = function(d) {
        var b = a("esri-transforms3d");
        if (void 0 !== d && null !== d) b = d;
        else if (b && (l || n && !a("esri-iphone"))) b = !1;
        var h = b ? "translate3d(" : "translate(",
            k = b ? l ? ",-1px)" : ",0px)" : ")",
            m = b ? "scale3d(" : "scale(",
            p = b ? ",1)" : ")",
            q = b ? "rotate3d(0,0,1," : "rotate(",
            r = b ? "matrix3d(" : "matrix(",
            s = b ? ",0,0," : ",",
            t = b ? ",0,0,0,0,1,0," : ",",
            u = b ? ",0,1)" : ")";
        return {
            names: {
                transition: g &&
                    "-webkit-transition" || c && "MozTransition" || f && "OTransition" || e && "msTransition" || "transition",
                transform: g && "-webkit-transform" || c && "MozTransform" || f && "OTransform" || e && "msTransform" || "transform",
                transformName: g && "-webkit-transform" || c && "-moz-transform" || f && "-o-transform" || e && "-ms-transform" || "transform",
                origin: g && "-webkit-transform-origin" || c && "MozTransformOrigin" || f && "OTransformOrigin" || e && "msTransformOrigin" || "transformOrigin",
                endEvent: g && "webkitTransitionEnd" || c && "transitionend" || f && "oTransitionEnd" ||
                    e && "MSTransitionEnd" || "transitionend"
            },
            translate: function(a, b) {
                return h + a + "px," + b + "px" + k
            },
            scale: function(a) {
                return m + a + "," + a + p
            },
            rotate: function(a) {
                return q + a + "deg)"
            },
            matrix: function(a) {
                return r + a.xx + "," + a.xy + s + a.yx + "," + a.yy + t + a.dx.toFixed(10) + (c ? "px," : ",") + a.dy.toFixed(10) + (c ? "px" : "") + u
            },
            getScaleFromMatrix: function(a) {
                if (!a) return 1;
                a = a.toLowerCase();
                var b = -1 < a.indexOf("matrix3d") ? "matrix3d(" : "matrix(";
                return Number(a.substring(b.length, a.indexOf(",")))
            }
        }
    };
    return a
});
},
'esri/urlUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/_base/array", "dojo/_base/url", "dojo/io-query", "./kernel", "./config", "./sniff", "dojo/i18n!./nls/jsapi"], function(k, r, l, p, s, t, q, u) {
    var e = {},
        m = t.defaults.io,
        n = window.location.protocol;
    "file:" === n && (n = "http:");
    e.urlToObject = function(a) {
        var c = {},
            b = new l(a),
            d = a.indexOf("?");
        null === b.query ? c = {
            path: a,
            query: null
        } : (c.path = a.substring(0, d), c.query = p.queryToObject(b.query));
        b.fragment && (c.hash = b.fragment, null === b.query && (c.path = c.path.substring(0, c.path.length - (b.fragment.length + 1))));
        return c
    };
    e.getProxyUrl = function(a, c) {
        var b = k.isString(a) ? 0 === k.trim(a).toLowerCase().indexOf("https:") : a,
            d = m.proxyUrl,
            f, g, h = u.io.proxyNotSet;
        if (k.isString(a) && (g = e.getProxyRule(a))) d = g.proxyUrl;
        if (!d) throw console.log(h), Error(h);
        b && (!1 !== c && 0 !== window.location.href.toLowerCase().indexOf("https:")) && (b = d, 0 !== b.toLowerCase().indexOf("http") && (b = e.getAbsoluteUrl(b)), b = b.replace(/^http:/i, "https:"), e.canUseXhr(b) && (d = b, f = 1));
        d = e.urlToObject(d);
        d._xo = f;
        return d
    };
    e.addProxy = function(a) {
        var c = e.getProxyRule(a),
            b;
        c ? b = e.urlToObject(c.proxyUrl) : m.alwaysUseProxy && (b = e.getProxyUrl());
        b && (c = e.urlToObject(a), a = b.path + "?" + c.path, (b = p.objectToQuery(k.mixin(b.query || {}, c.query))) && (a += "?" + b));
        return a
    };
    e.addProxyRule = function(a) {
        var c = a.urlPrefix = e.urlToObject(a.urlPrefix).path.replace(/([^\/])$/, "$1/").replace(/^https?:\/\//ig, "").toLowerCase(),
            b = m.proxyRules,
            d, f = b.length,
            g, h = f;
        for (d = 0; d < f; d++)
            if (g = b[d].urlPrefix, 0 === c.indexOf(g)) {
                if (c.length === g) return -1;
                h = d;
                break
            } else 0 === g.indexOf(c) && (h = d + 1);
        b.splice(h, 0, a);
        return h
    };
    e.getProxyRule = function(a) {
        var c = m.proxyRules,
            b = c.length,
            d = e.urlToObject(a).path.replace(/([^\/])$/, "$1/").replace(/^https?:\/\//ig, "").toLowerCase(),
            f;
        for (a = 0; a < b; a++)
            if (0 === d.indexOf(c[a].urlPrefix)) {
                f = c[a];
                break
            }
        return f
    };
    e.hasSameOrigin = function(a, c, b) {
        a = a.toLowerCase();
        c = c.toLowerCase();
        var d = window.location.href.toLowerCase();
        a = 0 === a.indexOf("http") ? new l(a) : d = new l(d);
        c = 0 === c.indexOf("http") ? new l(c) : k.isString(d) ? new l(d) : d;
        return (b || a.scheme === c.scheme) && a.host === c.host && a.port ===
            c.port
    };
    e.canUseXhr = function(a, c) {
        var b = q("esri-phonegap") ? !0 : !1,
            d = e.hasSameOrigin,
            f = m.corsEnabledServers,
            g, h = -1;
        !b && (q("esri-cors") && f && f.length) && (b = r.some(f, function(b, c) {
            g = 0 !== k.trim(b).toLowerCase().indexOf("http");
            return d(a, g ? "http://" + b : b) || g && d(a, "https://" + b) ? (h = c, !0) : !1
        }));
        return c ? h : b
    };
    e.getAbsoluteUrl = function(a) {
        return k.isString(a) && !/^https?:\/\//i.test(a) ? 0 === a.indexOf("//") ? n + a : 0 === a.indexOf("/") ? n + "//" + window.location.host + a : s._appBaseUrl + a : a
    };
    e.fixUrl = function(a) {
        /^\/\//i.test(a) &&
            (a = n + a);
        return a = a.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2")
    };
    return e
});
},
'esri/nls/jsapi':function(){
//>>built
define({
    root: {
        io: {
            proxyNotSet: "esri.config.defaults.io.proxyUrl is not set. If making a request to a CORS enabled server, please push the domain into esri.config.defaults.io.corsEnabledServers."
        },
        map: {
            deprecateReorderLayerString: "Map.reorderLayer(/*String*/ id, /*Number*/ index) deprecated. Use Map.reorderLayer(/*Layer*/ layer, /*Number*/ index).",
            deprecateShiftDblClickZoom: "Map.(enable/disable)ShiftDoubleClickZoom deprecated. Shift-Double-Click zoom behavior will not be supported."
        },
        basemaps: {
            streets: "Streets",
            satellite: "Imagery",
            hybrid: "Imagery with Labels",
            terrain: "Terrain with Labels",
            topo: "Topographic",
            gray: "Light Gray Canvas",
            "dark-gray": "Dark Gray Canvas",
            oceans: "Oceans",
            "national-geographic": "National Geographic",
            osm: "OpenStreetMap"
        },
        geometry: {
            deprecateToScreenPoint: "esri.geometry.toScreenPoint deprecated. Use esri.geometry.toScreenGeometry.",
            deprecateToMapPoint: "esri.geometry.toMapPoint deprecated. Use esri.geometry.toMapGeometry."
        },
        layers: {
            tiled: {
                tileError: "Unable to load tile"
            },
            dynamic: {
                imageError: "Unable to load image"
            },
            graphics: {
                drawingError: "Unable to draw graphic "
            },
            agstiled: {
                deprecateRoundrobin: "Constructor option 'roundrobin' deprecated. Use option 'tileServers'."
            },
            imageParameters: {
                deprecateBBox: "Property 'bbox' deprecated. Use property 'extent'."
            },
            FeatureLayer: {
                noOIDField: "objectIdField is not set [url: ${url}]",
                fieldNotFound: "unable to find '${field}' field in the layer 'fields' information [url: ${url}]",
                noGeometryField: "unable to find a field of type 'esriFieldTypeGeometry' in the layer 'fields' information. If you are using a map service layer, features will not have geometry [url: ${url}]",
                invalidParams: "query contains one or more unsupported parameters",
                updateError: "an error occurred while updating the layer",
                createUserSeconds: "Created by ${userId} seconds ago",
                createUserMinute: "Created by ${userId} a minute ago",
                editUserSeconds: "Edited by ${userId} seconds ago",
                editUserMinute: "Edited by ${userId} a minute ago",
                createSeconds: "Created seconds ago",
                createMinute: "Created a minute ago",
                editSeconds: "Edited seconds ago",
                editMinute: "Edited a minute ago",
                createUserMinutes: "Created by ${userId} ${minutes} minutes ago",
                createUserHour: "Created by ${userId} an hour ago",
                createUserHours: "Created by ${userId} ${hours} hours ago",
                createUserWeekDay: "Created by ${userId} on ${weekDay} at ${formattedTime}",
                createUserFull: "Created by ${userId} on ${formattedDate} at ${formattedTime}",
                editUserMinutes: "Edited by ${userId} ${minutes} minutes ago",
                editUserHour: "Edited by ${userId} an hour ago",
                editUserHours: "Edited by ${userId} ${hours} hours ago",
                editUserWeekDay: "Edited by ${userId} on ${weekDay} at ${formattedTime}",
                editUserFull: "Edited by ${userId} on ${formattedDate} at ${formattedTime}",
                createUser: "Created by ${userId}",
                editUser: "Edited by ${userId}",
                createMinutes: "Created ${minutes} minutes ago",
                createHour: "Created an hour ago",
                createHours: "Created ${hours} hours ago",
                createWeekDay: "Created on ${weekDay} at ${formattedTime}",
                createFull: "Created on ${formattedDate} at ${formattedTime}",
                editMinutes: "Edited ${minutes} minutes ago",
                editHour: "Edited an hour ago",
                editHours: "Edited ${hours} hours ago",
                editWeekDay: "Edited on ${weekDay} at ${formattedTime}",
                editFull: "Edited on ${formattedDate} at ${formattedTime}"
            }
        },
        tasks: {
            gp: {
                gpDataTypeNotHandled: "GP Data type not handled."
            },
            na: {
                route: {
                    routeNameNotSpecified: "'RouteName' not specified for at least 1 stop in stops FeatureSet."
                }
            },
            query: {
                invalid: "Unable to perform query. Please check your parameters."
            }
        },
        toolbars: {
            draw: {
                convertAntiClockwisePolygon: "Polygons drawn in anti-clockwise direction will be reversed to be clockwise.",
                addPoint: "Click to add a point",
                addShape: "Click to add a shape, or press down to start and let go to finish",
                addMultipoint: "Click to start adding points",
                freehand: "Press down to start and let go to finish",
                start: "Click to start drawing",
                resume: "Click to continue drawing",
                complete: "Double-click to complete",
                finish: "Double-click to finish",
                invalidType: "Unsupported geometry type"
            },
            edit: {
                invalidType: "Unable to activate the tool. Check if the tool is valid for the given geometry type.",
                deleteLabel: "Delete"
            }
        },
        virtualearth: {
            vetiledlayer: {
                bingMapsKeyNotSpecified: "BingMapsKey must be provided."
            },
            vegeocode: {
                bingMapsKeyNotSpecified: "BingMapsKey must be provided.",
                requestQueued: "Server token not retrieved. Queing request to be executed after server token retrieved."
            }
        },
        widgets: {
            attributeInspector: {
                NLS_first: "First",
                NLS_previous: "Previous",
                NLS_next: "Next",
                NLS_last: "Last",
                NLS_deleteFeature: "Delete",
                NLS_title: "Edit Attributes",
                NLS_errorInvalid: "Invalid",
                NLS_validationInt: "Value must be an integer.",
                NLS_validationFlt: "Value must be a float.",
                NLS_of: "of",
                NLS_noFeaturesSelected: "No features selected"
            },
            basemapToggle: {
                toggle: "Toggle basemap"
            },
            homeButton: {
                home: {
                    button: "Home",
                    title: "Default extent"
                }
            },
            layerSwipe: {
                title: "Drag to see underlying layer"
            },
            locateButton: {
                locate: {
                    button: "My Location",
                    title: "Find my location",
                    tracking: "Track location",
                    stopTracking: "Stop tracking location"
                }
            },
            overviewMap: {
                NLS_drag: "Drag To Change The Map Extent",
                NLS_show: "Show Map Overview",
                NLS_hide: "Hide Map Overview",
                NLS_maximize: "Maximize",
                NLS_restore: "Restore",
                NLS_noMap: "'map' not found in input parameters",
                NLS_noLayer: "main map does not have a base layer",
                NLS_invalidSR: "spatial reference of the given layer is not compatible with the main map",
                NLS_invalidType: "unsupported layer type. Valid types are 'TiledMapServiceLayer' and 'DynamicMapServiceLayer'"
            },
            timeSlider: {
                NLS_first: "First",
                NLS_previous: "Previous",
                NLS_next: "Next",
                NLS_play: "Play/Pause",
                NLS_invalidTimeExtent: "TimeExtent not specified, or in incorrect format."
            },
            attachmentEditor: {
                NLS_attachments: "Attachments:",
                NLS_add: "Add",
                NLS_none: "None",
                NLS_error: "There was an error.",
                NLS_fileNotSupported: "This file type is not supported."
            },
            directions: {
                error: {
                    notEnoughStops: "Enter an origin and a destination.",
                    unknownStop: "Location '\x3cname\x3e' could not be found.",
                    routeTask: "Unable to route to these addresses.",
                    locator: "Location could not be found.",
                    invalidStopType: "Invalid stop type",
                    locatorUndefined: "Unable to reverse geocode. Locator URL is undefined.",
                    noAddresses: "No addresses were returned.",
                    noStops: "No stops were given to be added.",
                    maximumStops: "The maximum number of stops has been reached",
                    cantFindRouteServiceDescription: "Route service description was not reached or recognized. Please check service URL and/or user credentials, if specified.",
                    maxWalkingDistance: "The distance between any inputs must be less than 50 miles (80 kilometers) when walking.",
                    nonNAmTruckingMode: "Calculating trucking routes outside of North and Central America is not currently supported.",
                    cantRemoveStop: "Failed to remove stop."
                },
                time: {
                    minute: "minute",
                    minutes: "minutes",
                    hour: "hour",
                    hours: "hours"
                },
                units: {
                    KILOMETERS: {
                        name: "kilometers",
                        abbr: "km"
                    },
                    METERS: {
                        name: "meters",
                        abbr: "m"
                    },
                    MILES: {
                        name: "miles",
                        abbr: "mi"
                    },
                    NAUTICAL_MILES: {
                        name: "nautical miles",
                        abbr: "nm"
                    }
                },
                travelMode: {
                    car: "By Car",
                    truck: "By Truck",
                    walking: "Walking"
                },
                impedance: {
                    fastest: "Fastest",
                    shortest: "Shortest"
                },
                unlocatedStop: "\x3cunknown location\x3e",
                showOptions: "Show more options",
                hideOptions: "Hide options",
                findOptimalOrder: "Optimize order",
                useTraffic: "Use traffic",
                returnToStart: "Return to start",
                addDestination: "Add destination",
                viewFullRoute: "Zoom to full route",
                getDirections: "Get Directions",
                clearDirections: "Clear",
                reverseDirections: "Reverse directions",
                activate: "Add destinations by clicking on the map",
                print: "Print",
                printNotes: "Enter notes here",
                printDisclaimer: "Directions are provided for planning purposes only and are subject to \x3ca href\x3d'http://www.esri.com/legal/software-license' target\x3d'_blank'\x3eEsri's terms of use\x3c/a\x3e. Dynamic road conditions can exist that cause accuracy to differ from your directions and must be taken into account along with signs and legal restrictions. You assume all risk of use."
            },
            editor: {
                tools: {
                    NLS_attributesLbl: "Attributes",
                    NLS_cutLbl: "Cut",
                    NLS_deleteLbl: "Delete",
                    NLS_extentLbl: "Extent",
                    NLS_freehandPolygonLbl: "Freehand Polygon",
                    NLS_freehandPolylineLbl: "Freehand Polyline",
                    NLS_pointLbl: "Point",
                    NLS_polygonLbl: "Polygon",
                    NLS_polylineLbl: "Polyline",
                    NLS_reshapeLbl: "Reshape",
                    NLS_selectionNewLbl: "New selection",
                    NLS_selectionAddLbl: "Add to selection",
                    NLS_selectionClearLbl: "Clear selection",
                    NLS_selectionRemoveLbl: "Subtract from selection",
                    NLS_selectionUnionLbl: "Union",
                    NLS_autoCompleteLbl: "Auto Complete",
                    NLS_unionLbl: "Union",
                    NLS_rectangleLbl: "Rectangle",
                    NLS_circleLbl: "Circle",
                    NLS_ellipseLbl: "Ellipse",
                    NLS_triangleLbl: "Triangle",
                    NLS_arrowLbl: "Arrow",
                    NLS_arrowLeftLbl: "Left Arrow",
                    NLS_arrowUpLbl: "Up Arrow",
                    NLS_arrowDownLbl: "Down Arrow",
                    NLS_arrowRightLbl: "Right Arrow",
                    NLS_undoLbl: "Undo",
                    NLS_redoLbl: "Redo"
                }
            },
            Search: {
                main: {
                    clearButtonTitle: "Clear Search",
                    searchButtonTitle: "Search",
                    placeholderAll: "Search All",
                    searchIn: "Search in",
                    all: "All",
                    noResults: "No Results",
                    noResultsFound: "There were no results found for ${value}.",
                    nwyw: "Not what you wanted?",
                    location: "Location",
                    currentLocation: "Current location",
                    selectAnother: "Select another location",
                    placeholder: "Find address or place",
                    untitledSource: "Untitled source"
                },
                esriLocatorName: "Esri World Geocoder"
            },
            Geocoder: {
                main: {
                    clearButtonTitle: "Clear Search",
                    searchButtonTitle: "Search",
                    geocoderMenuButtonTitle: "Change Geocoder",
                    geocoderMenuHeader: "Search in",
                    geocoderMenuCloseTitle: "Close Menu",
                    untitledGeocoder: "Untitled geocoder"
                },
                esriGeocoderName: "Esri World Geocoder"
            },
            geocodeMatch: {
                match: {
                    mapAllCandidatesLabel: "Map All Suggestions",
                    defaultSortOrderLabel: "Default Sort Order",
                    tableOptionsLabel: "Options",
                    columnLabelAddress: "Address",
                    columnLabelType: "Type",
                    columnLabelScore: "Score",
                    noDataMsg: "No Results.",
                    userCreatedLabel: "User Created",
                    defaultMatchType: "DefaultMatch"
                },
                popup: {
                    noAddress: "No Address Found.",
                    matchButtonLabel: "Match",
                    discardButtonLabel: "Discard",
                    checkBoxLocation: "Location (X, Y)",
                    checkBoxAddress: "Suggested Address",
                    addressTitle: "Suggested Address",
                    optionsTitle: "Match Options:",
                    loadingPH: "Searching...",
                    locationTitle: "Location",
                    xTitle: "X: ",
                    yTitle: "Y: "
                },
                customLabel: "Custom",
                idProperty: "id",
                gridTitle: "Suggestions",
                matchedLC: "matched",
                matchedUC: "Matched",
                unmatchedLC: "unmatched",
                unmatchedUC: "Unmatched"
            },
            geocodeReview: {
                review: {
                    noDataMsg1: "No Unmatched Features",
                    noDataMsg2: "No Matched Features",
                    noDataMsg3: "No Reviewed Features",
                    columnOriginalLocation: "Original Location",
                    columnSelectedLocation: "Selected Location",
                    columnOriginalAddress: "Original Address",
                    columnSelectedAddress: "Selected Address"
                },
                customLabel: "Custom",
                unmatchedLC: "unmatched",
                matchedLC: "matched",
                unmatchedUC: "Unmatched",
                matchedUC: "Matched",
                totalUC: "Total",
                remainingUC: "Remaining",
                idProperty: "id",
                reviewedUC: "Reviewed",
                columnLabelAddress: "Address",
                of: "of",
                unmatchedTotal: "Unmatched (${count} Total)",
                unmatchedRemaining: "Unmatched (${count1} of ${count2} Remaining)",
                matchedTotal: "Matched (${count} Total)",
                reviewedTotal: "Reviewed (${count} Total)"
            },
            HistogramTimeSlider: {
                NLS_range: "Range",
                NLS_cumulative: "Cumulative",
                NLS_play: "Play/Pause",
                NLS_invalidTimeExtent: "TimeExtent not specified, or in incorrect format.",
                NLS_overview: "OVERVIEW",
                NLS_fullRange: "full range"
            },
            legend: {
                NLS_points: "Points",
                NLS_lines: "Lines",
                NLS_polygons: "Polygons",
                NLS_creatingLegend: "Creating legend",
                NLS_noLegend: "No legend",
                NLS_dotValue: "1 Dot \x3d ${value} ${unit}",
                NLS_currentObservations: "Current observations",
                NLS_previousObservations: "Previous observations",
                high: "High",
                low: "Low"
            },
            popup: {
                NLS_moreInfo: "More info",
                NLS_searching: "Searching",
                NLS_prevFeature: "Previous feature",
                NLS_nextFeature: "Next feature",
                NLS_close: "Close",
                NLS_prevMedia: "Previous media",
                NLS_nextMedia: "Next media",
                NLS_noInfo: "No information available",
                NLS_noAttach: "No attachments found",
                NLS_maximize: "Maximize",
                NLS_restore: "Restore",
                NLS_zoomTo: "Zoom to",
                NLS_pagingInfo: "(${index} of ${total})",
                NLS_attach: "Attachments"
            },
            measurement: {
                NLS_distance: "Distance",
                NLS_area: "Area",
                NLS_location: "Location",
                NLS_resultLabel: "Measurement Result",
                NLS_length_miles: "Miles",
                NLS_length_kilometers: "Kilometers",
                NLS_length_feet: "Feet",
                NLS_length_meters: "Meters",
                NLS_length_yards: "Yards",
                NLS_length_nautical_miles: "Nautical Miles",
                NLS_area_acres: "Acres",
                NLS_area_sq_miles: "Sq Miles",
                NLS_area_sq_kilometers: "Sq Kilometers",
                NLS_area_hectares: "Hectares",
                NLS_area_sq_yards: "Sq Yards",
                NLS_area_sq_feet: "Sq Feet",
                NLS_area_sq_meters: "Sq Meters",
                NLS_area_sq_nautical_miles: "Sq Nautical Miles",
                NLS_deg_min_sec: "DMS",
                NLS_decimal_degrees: "Degrees",
                NLS_map_coordinate: "Map Coordinate",
                NLS_longitude: "Longitude",
                NLS_latitude: "Latitude",
                NLS_MGRS: "MGRS",
                NLS_USNG: "USNG",
                NLS_UTM: "UTM",
                NLS_GeoRef: "GeoRef",
                NLS_GARS: "GARS",
                NLS_geometry_service_error: "Geometry Service Error",
                NLS_calculating: "Calculating..."
            },
            bookmarks: {
                NLS_add_bookmark: "Add Bookmark",
                NLS_new_bookmark: "Untitled",
                NLS_bookmark_edit: "Edit",
                NLS_bookmark_remove: "Remove"
            },
            print: {
                NLS_print: "Print",
                NLS_printing: "Printing",
                NLS_printout: "Printout"
            },
            textSymbolEditor: {
                symbolConfiguration: "Symbol Configuration",
                alignment: "Alignment",
                color: "Color"
            },
            scalebar: {
                km: "km",
                mi: "mi",
                ft: "ft",
                m: "m"
            },
            templatePicker: {
                creationDisabled: "Feature creation is disabled for all layers.",
                loading: "Loading.."
            },
            renderingRule: {
                rendererLabelTitle: "Renderer",
                bandCombinationLabelTitle: "RGB composite",
                userDefinedRendererTitle: "User Defined Renderer",
                userDefinedRendererDesc: "A user defined renderer. Use different bands for inputs to the Red, Green, and Blue channels (multi-band services only). Apply different radiometric enhancement algorithms to make image look better.",
                imageEnhancementLabelTitle: "Image Enhancement",
                stretchDescLabel: "Apply contrast enhancements to improve the image display.",
                stretchMethodLabel: "Stretch Type:",
                stretchMethodNoneDesc: "No additional enhancements applied.",
                stretchMethodMinMaxDesc: "Stretch to the entire range of pixel values.",
                numStdDevLabelTitle: "Trim extreme pixel values beyond",
                numStdDevEndLabelTitle: "standard deviations.",
                draLabelTitle: "Dynamic range adjustment",
                minMaxDescLabelTitle: "Trim extreme pixel values",
                minPercentLabelTitle: "Exclude bottom:",
                maxPercentLabelTitle: "Exclude top:",
                percentLabelTitle: "%",
                gammaLabelTitle: "Gamma:",
                bandNamesRequestMsg: "Requesting band information...",
                noneStretchAlias: "None",
                minMaxStretchAlias: "Minimum and Maximum",
                stdDevStretchAlias: "Standard Deviation",
                percentClipStretchAlias: "Percent Clip",
                minGammaLabel: "0.1",
                maxGammaLabel: "10"
            },
            mosaicRule: {
                mosaicMethodLabel: "Prioritize imagery based on:",
                orderFieldLabel: "Attribute:",
                orderValueLabel: "Highest priority value:",
                lockRasterIdLabel: "Image IDs:",
                mosaicOperatorLabel: "Resolve overlapping pixels by:",
                descendingLabel: "Reverse the order",
                queryLabel: "Filter your images:",
                queryFieldLabel: "Field:",
                queryOperatorLabel: "Operator:",
                queryValueLabel: "Value:",
                selectAllLabel: "Select All",
                mosaicruleNotApplicable: "The image layer contains only one image and does not support changing image display order.",
                lockRasterRequestMsg: "Searching...",
                lockRasterRequestDoneMsg: "Done...",
                lockRasterRequestErrorMsg: "Error searching...",
                lockRasterRequestNoRasterMsg: "No rasters found...",
                refreshLockRasterIdsLabel: "Refresh",
                orderFieldNotFound: "Not Available",
                byAttributeAlias: "An attribute",
                centerAlias: "Image center closest to view center",
                lockRasterAlias: "A list of images",
                nadirAlias: "Sensor location closest to view center",
                northWestAlias: "Fixed order with most North West on top",
                seamlineAlias: "Defined Seamlines",
                viewPointAlias: "View point",
                noneAlias: "Only scale",
                firstAlias: "Only highest priority",
                lastAlias: "Only Lowest priority",
                minAlias: "Minimum of pixel values",
                maxAlias: "Maximum of pixel values",
                averageAlias: "Average of pixel values",
                blendAlias: "Blend pixel values"
            },
            tags: {
                addTags: "Add tag(s)",
                noTagsFound: "No existing tags match."
            },
            rendererSlider: {
                color: {
                    changeMinMaxToolTIp: "Type in a value.",
                    handleToolTip: "Match data values to colors.",
                    maxValueToolTip: "Type in the largest expected data value.",
                    minValueToolTip: "Type in the smallest expected data value.",
                    changeSymbol: "Change symbol"
                },
                size: {
                    handleToolTip: "Match data values to symbol size.",
                    sizeInputBoxLines: "Set line thickness from 0 to 18 pixels.",
                    sizeInputBoxPoints: "Set symbol size from 1 to 120 pixels"
                }
            }
        },
        arcgis: {
            utils: {
                baseLayerError: "Unable to load the base map layer",
                geometryServiceError: "Provide a geometry service to open Web Map.",
                showing: "Showing ${fieldAlias}"
            }
        },
        identity: {
            lblItem: "item",
            title: "Sign In",
            info: "Please sign in to access the item on ${server} ${resource}",
            lblUser: "Username:",
            lblPwd: "Password:",
            lblOk: "OK",
            lblSigning: "Signing in...",
            lblCancel: "Cancel",
            errorMsg: "Invalid username/password. Please try again.",
            invalidUser: "The username or password you entered is incorrect.",
            forbidden: "The username and password are valid, but you don't have access to this resource.",
            noAuthService: "Unable to access the authentication service."
        },
        common: {
            cancel: "Cancel",
            ok: "OK",
            create: "Create",
            close: "Close",
            done: "Done",
            apply: "Apply",
            remove: "Remove",
            open: "Open",
            edit: "Edit",
            share: "Share",
            save: "Save",
            help: "Help",
            warning: "Warning",
            deleteLabel: "Delete",
            titleLabel: "Title:",
            newLabel: "New",
            arcgis: "ArcGIS",
            previous: "Previous",
            submit: "Submit",
            next: "Next",
            yesLabel: "Yes",
            noLabel: "No",
            errorTitle: "Error",
            upload: "Upload",
            sum: "Sum",
            minimum: "Minimum",
            maximum: "Maximum",
            average: "Average",
            standardDev: "Std Deviation",
            statistic: "Statistic",
            attribute: "Field",
            selectAttribute: "Select attribute",
            runAnalysis: "Run Analysis",
            oneLabel: "1.",
            twoLabel: "2.",
            threeLabel: "3.",
            fourLabel: "4.",
            fiveLabel: "5.",
            sixLabel: "6.",
            sevenLabel: "7.",
            eightLabel: "8.",
            outputnameMissingMsg: "Output name is required",
            miles: "Miles",
            kilometers: "Kilometers",
            meters: "Meters",
            feet: "Feet",
            degree: "Decimal Degree(s)",
            inches: "Inch(es)",
            nautMiles: "Nautical Miles",
            pointsUnit: "Point(s)",
            yards: "Yards",
            comingSoonLabel: "Coming Soon!",
            sqMiles: "Square Miles",
            sqFeet: "Square Feet",
            sqKm: "Square Kilometers",
            sqMeters: "Square Meters",
            hectares: "Hectares",
            acres: "Acres",
            seconds: "Seconds",
            minutes: "Minutes",
            hours: "Hours",
            today: "Today",
            monday: "Monday",
            tuesday: "Tuesday",
            wednesday: "Wednesday",
            thursday: "Thursday",
            friday: "Friday",
            saturday: "Saturday",
            sunday: "Sunday",
            chooseSummarizeLabel: "Choose layer to summarize",
            creditTitle: "Credit Usage Report",
            analysisLayers: "Analysis layers:",
            showCredits: "Show credits",
            learnMore: "Learn More",
            hoursSmall: "hr",
            minutesSmall: "min",
            secondsSmall: "sec",
            statsRequiredMsg: "At least one of the statistics parameters is required.",
            nowLabel: "Now",
            hrsLabel: "hrs",
            groupLabel: "Group",
            ungroupLabel: "Ungroup",
            and: "and",
            or: "or",
            add: "Add",
            polygons: "Polygons",
            points: "Points",
            lines: "Lines",
            input: "Input",
            areas: "Areas",
            validateRouteIdMsg: "Layers must have the same number of records, or one layer must have one record only.",
            straightLineDistance: "Line distance",
            outputLabel: "Output:",
            addPoint: "Click to add a point",
            movePoint: "Click to move the point",
            selectAll: "Select All",
            unselectAll: "Unselect All",
            selectLabel: "Select",
            queryLabel: "Query",
            drawnBoundary: "Drawn Boundary",
            basic: "Basic",
            intermediate: "Intermediate",
            advanced: "Advanced",
            majority: "Majority",
            minority: "Minority",
            addMinMajorityLable: "Add minority, majority",
            addPercentageLabel: "Add percentages",
            drivingMode: "Driving",
            truckingMode: "Trucking",
            walkingMode: "Walking",
            distanceMsg: "Only numeric values are allowed"
        },
        analysisTools: {
            performAnalysis: "Perform Analysis",
            summarizeData: "Summarize Data",
            findLocations: "Find Locations",
            aggregateTool: "Aggregate Points",
            bufferTool: "Buffer Data",
            dataEnrichment: "Data Enrichment",
            analyzePatterns: "Analyze Patterns",
            useProximity: "Use Proximity",
            manageData: "Manage Data",
            aggregateToolName: "Aggregate Points",
            bufferToolName: "Create Buffers",
            aggregatePoints: "Aggregate Points",
            summarizeWithin: "Summarize Within",
            summarizeNearby: "Summarize Nearby",
            enrichLayer: "Enrich Layer",
            findNearest: "Find Nearest",
            findHotSpots: "Find Hot Spots",
            createBuffers: "Create Buffers",
            dissolveBoundaries: "Dissolve Boundaries",
            mergeLayers: "Merge Layers",
            extractData: "Extract Data",
            overlayLayers: "Overlay Layers",
            fieldCalculator: "Field Calculator",
            createDriveTimeAreas: "Create Drive-Time Areas",
            deriveNewLocations: "Derive New Locations",
            findExistingLocations: "Find Existing Locations",
            findSimilarLocations: "Find Similar Locations",
            exploreCorrelations: "Explore Correlations",
            findRoute: "Find Route",
            generateFleetPlan: "Generate Fleet-routing plan",
            createDensitySurface: "Create density surface",
            interpolatePoints: "Interpolate Points",
            orgUsrMsg: "You must be a member of an organization to run this service.",
            pubRoleMsg: "Your online account has not been assigned to the Publisher role.",
            servNameExists: "A result layer already exists with this name. Result layers must be named uniquely across the organization. Please use a different name.",
            outputLayerLabel: "Result layer name",
            outputFileName: "Output file name",
            emptyResultInfoMsg: "The result of your analysis did not return any features. No layer will be created.",
            invalidServiceName: 'The result layer name contains one or more invalid characters (\x3c, \x3e, #, %, :, ", ?, \x26, +, /, or \\).',
            invalidServiceNameLength: "The result layer name length should be less than 98 characters.",
            requiredValue: "This value is required.",
            saveResultIn: "Save result in",
            useMapExtent: "Use current map extent",
            connectOriginsToDestinations: "Connect Origins to Destinations",
            planRoutes: "Plan Routes",
            calculateDensity: "Calculate Density",
            traceDownstream: "Trace Downstream",
            createWatershed: "Create Watersheds",
            createViewshed: "Create Viewshed"
        },
        aggregatePointsTool: {
            aggregateDefine: "Count \x3cb\x3e${layername}\x3c/b\x3e within",
            outputLayerName: "Aggregation of ${pointlayername} to ${polygonlayername}",
            groupByLabel: "Choose field to group by (optional)",
            itemDescription: "Feature Service generated from running the Aggregate Points solutions. Points from ${pointlayername} were aggregated to ${polygonlayername}",
            itemTags: "Analysis Result, Aggregate Points, ${pointlayername}, ${polygonlayername}",
            itemSnippet: "Analysis Feature Service generated from Aggregate Points",
            removeAttrStats: "Remove Attribute Statistics",
            keepPolygonLabel: "Keep areas with no points",
            addStatsLabel: "Add statistic (optional)",
            chooseAreaLabel: "Choose area"
        },
        findHotSpotsTool: {
            hotspotsPolyDefine: "Analyze \x3cb\x3e${layername}\x3c/b\x3e  to find statistically significant hot and cold spots of ",
            hotspotsPointDefine: "Analyze \x3cb\x3e${layername}\x3c/b\x3e  to find statistically significant hot and cold spots ",
            fieldLabel: "with or without an analysis field",
            noAnalysisField: "No Analysis Field",
            hotspots: "Hot Spots",
            outputLayerName: "Hot Spots ${layername}",
            Options: "Options",
            defineBoundingLabel: "Define where incidents are possible",
            provideAggLabel: "Provide aggregation areas for summing incidents",
            defaultBoundingOption: "Select bounding areas",
            defaultAggregationOption: "Select aggregation areas",
            itemDescription: "Feature Service generated from running the Find Hot Spots solution.",
            itemTags: "Analysis Result, Hot Spots, ${layername}, ${fieldname}",
            itemSnippet: "Analysis Feature Service generated from Find Hot Spots",
            chooseAttributeLabel: "Choose an analysis field",
            blayerName: "Drawn Boundaries"
        },
        overlayLayersTool: {
            overlayDefine: "Overlay \x3cb\x3e${layername}\x3c/b\x3e with",
            chooseOverlayLayer: "Choose overlay layer",
            chooseOverlayMethod: "Choose overlay method",
            chooseOutputType: "Choose output type",
            itemDescription: "Feature Service generated from running the Overlay layers solution.",
            itemTags: "Analysis Result, Overlay layers, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Overlay layers",
            unionOutputLyrName: "Union of ${layername} and ${overlayname}",
            intersectOutputLyrName: "Intersect of ${layername} and ${overlayname}",
            eraseOutputLyrName: "Erase ${layername} with ${overlayname}",
            overlayLayerPolyMsg: "The Overlay layer should be a Polygon Layer for Union overlay",
            notSupportedEraseOverlayMsg: "This Overlay layer is not supported for Erase overlay. Defaults to Intersect overlay.",
            intersect: "Intersect",
            union: "Union",
            erase: "Erase"
        },
        bufferTool: {
            bufferDefine: "Create buffers from \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "Buffer of ${layername}",
            sizeLabel: "Enter buffer size",
            sizeHelp: "To create multiple buffers, enter distances separated by spaces (2 3 5).",
            typeLabel: "Buffer type",
            resultLabel: "Result layer name",
            optionsLabel: "Options",
            itemDescription: "Feature Service generated from running the Buffer Features solution. Input from ${layername} were buffered by ${distance_field} ${units}",
            itemTags: "Analysis Result, Buffer, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Buffer",
            overlap: "Overlap",
            dissolve: "Dissolve",
            include: "Include",
            exclude: "Exclude",
            around: "Around",
            sideType: "Side type",
            endType: "End type",
            left: "Left",
            right: "Right",
            round: "Round",
            flat: "Flat",
            multipleDistance: "Multiple distance buffers should be",
            rings: "Rings",
            disks: "Disks",
            areaofInputPoly: "Area of input polygons in buffer polygons",
            distance: "Distance",
            field: "Field"
        },
        driveTimes: {
            toolDefine: "Create areas around \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "Drive from ${layername} (${breakValues} ${breakUnits})",
            outputModeLayerName: "${mode} from ${layername} (${breakValues} ${breakUnits})",
            driving: "Drive",
            trucking: "Truck",
            walking: "Walk",
            measureLabel: "Measure",
            measureHelp: "To output multiple areas for each point, type sizes separated by spaces (2 3.5 5).",
            areaLabel: "Areas from different points",
            trafficLabel: "Use traffic",
            typicalTraffCdtnLabel: "Traffic based on typical conditions for",
            resultLabel: "Result layer name",
            liveTrafficLabel: "Live traffic",
            itemDescription: "Feature Service generated from running the Create Drive Times solution.",
            itemTags: "Analysis Result, Drive Times, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Create Drive Times",
            split: "Split",
            seeAvailability: "See availability.",
            timeOfDeparture: "Time of departure",
            drivingDistance: "Driving Distance",
            drivingTime: "Driving Time",
            truckingTime: "Trucking Time",
            truckingDistance: "Trucking Distance",
            walkingDistance: "Walking Distance",
            walkingTime: "Walking Time",
            liveSingularTimeLabel: "Live traffic +1 hr ${minute} min",
            liveSingularHourTimeLabel: "Live traffic +1 hr",
            liveTimeLabel: "Live traffic +${hour} hr ${minute} min",
            liveTimeHoursLabel: "Live traffic +${hour} hr",
            liveTimeMinutesLabel: "Live traffic +${minute} min"
        },
        routeOriginDestinationPairsTool: {
            toolDefine: "Route between pairs of points originating from \x3cb\x3e${layername}\x3c/b\x3e",
            labelOne: "Route to destinations in",
            pairPoints: "Points with matching IDs will connect:",
            originTripId: "ID field in origins",
            destnTripId: "Matching ID field in destinations",
            includeSegments: "Include individual road segments.",
            inValidNumberRecordsMsg: "Layers must have the same number of records, or one layer must have one record only.",
            outputLayerName: "${layername} to ${destnlayername}",
            itemDescription: "Feature Service generated from running the Connect Origins to Destinations solution.",
            itemTags: "Analysis Result, Connect Origins to Destinations, ${layername}, ${destnlayername}",
            itemSnippet: "Analysis Feature Service generated from Connect Origins to Destinations"
        },
        planRoutesTool: {
            toolDefine: "Route vehicles to stops in \x3cb\x3e${layername}\x3c/b\x3e",
            timeSpentLabel: "Time spent at each stop",
            defineRoutesLabel: "Define routes",
            startRoutesLabel: "Routes begin at",
            endRoutesLabel: "Routes end at",
            routes: "Routes",
            stops: "Stops",
            numRoutes: "Maximum number of vehicles to route",
            maxPtsRoute: "Maximum number of stops per vehicle",
            limitMaxTime: "Limit the total route time per vehicle",
            returnToStart: "Return to start",
            specifyStartTime: "Start time for all routes",
            createStartLoc: "Add point to map",
            createEndLoc: "Add point to map",
            selectStartLoc: "Select starting location",
            selectEndLoc: "Select ending location",
            vehicles: "Vehicles",
            routeId: "Route ID field",
            selectRouteId: "Select RouteID",
            stopsLabel: "Your layer has ${numStops} stops.",
            stopsLabelByExtent: "The current map extent shows ${numStops} stops.",
            outputLayerName: "Routes to ${layername}",
            itemDescription: "Feature Service generated from running the Plan Routes solution.",
            itemTags: "Analysis Result, Plan Routes, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Plan Routes",
            startEndPtsValidMsg: "Start or end points not set",
            travelModeLabel: "Travel mode for routes"
        },
        extractDataTool: {
            layersToExtract: "Layers to extract",
            studyArea: "Study area",
            outputDataFormat: "Output data format",
            filegdb: "File Geodatabase (.zip)",
            shpFile: "Shapefile (.zip)",
            lyrpkg: "Layer Package (.lpk)",
            selectFtrs: "Select features",
            clipFtrs: "Clip features",
            sameAsDisplay: "Same as Display",
            sameAsLayer: "Same as ${layername}",
            outputfileName: "Extract Data ${datetime}",
            itemDescription: "File generated from running the Extract Data solution.",
            itemTags: "Analysis Result, Extract Data",
            itemSnippet: "Analysis File item generated from Extract Data",
            kml: "KML (.kmz or .zip)",
            csvPoints: "CSV (.csv or .zip)  ",
            linesCSVValidationMsg: "Line and area layers cannot be extracted to CSV.  Choose a different format or uncheck all line and area layers.",
            runAnalysisMsg: "Data is being extracted and will be available in My Content."
        },
        summarizeWithinTool: {
            summarizeDefine: "For Features within \x3cb\x3e${sumWithinLayerName}\x3c/b\x3e",
            outputLayerName: "Summarize ${summaryLayerName} within ${sumWithinLayerName}",
            groupByLabel: "Choose field to group by (optional)",
            itemDescription: "Feature Service generated from running the Summarize Within solution. ${summaryLayerName} were summarized within ${sumWithinLayerName}",
            itemTags: "Analysis Result, Summarize Within, ${sumWithinLayerName}, ${summaryLayerName}",
            itemSnippet: "Analysis Feature Service generated from Summarize Within",
            removeAttrStats: "Remove Attribute Statistics",
            summarizeMetricPoint: "Count of points",
            summarizeMetricLine: "Length of lines in",
            summarizeMetricPoly: "Sum Area in",
            addStatsLabel: "Attribute statistics",
            addStats: "Add statistics from \x3cb\x3e${summaryLayerName}\x3c/b\x3e",
            sumLabel: "Summarize"
        },
        summarizeNearbyTool: {
            summarizeDefine: "Summarize what is nearby \x3cb\x3e${sumNearbyLayerName}\x3c/b\x3e",
            findNearLabel: "Summarize nearest features using a",
            outputLayerName: "Summarize ${summaryLayerName} in ${sumNearbyLayerName}",
            groupByLabel: "Choose field to group by (optional)",
            itemDescription: "Feature Service generated from running the Summarize Nearby solution. ${sumNearbyLayerName} were summarized nearby ${summaryLayerName}",
            itemTags: "Analysis Result, Summarize Nearby, ${sumNearbyLayerName}, ${summaryLayerName}",
            itemSnippet: "Analysis Feature Service generated from Summarize Nearby",
            removeAttrStats: "Remove Attribute Statistics",
            summarizeMetricPoint: "Count of points",
            summarizeMetricLine: "Total Length",
            summarizeMetricPoly: "Total Area",
            addStatsLabel: "Attribute statistics",
            addStats: "Add statistics from \x3cb\x3e${summaryLayerName}\x3c/b\x3e",
            sumLabel: "Summarize",
            chooseLayer: "Choose layer to summarize",
            returnBdrycCheckLabel: "Return bounding areas"
        },
        creditEstimator: {
            analysisLayersLabel: "Analysis layers:",
            totalRecordsLabel: "Total records:",
            creditsAvailLabel: "Credits available:",
            creditsReqLabel: "Credits required:",
            ntwCreditsReqLabel: "Network credits required:",
            EnrichCreditsLabel: "Enrichment credits required"
        },
        enrichLayerTool: {
            selectCountryLabel: "Select country",
            enrichDefine: "Enrich \x3cb\x3e${inputLayerName}\x3c/b\x3e",
            chooseDataCollectionLabel: "Show available data for:",
            defAreasLabel: "Define areas to enrich",
            outputLayerName: "Enriched ${layername}",
            itemDescription: "Feature Service generated from running the Enrich layer solution. ${inputLayerName} were enriched",
            itemTags: "Analysis Result, Enrich Layer, ${inputLayerName}",
            itemSnippet: "Analysis Feature Service generated from Enrich layer",
            straightLineDistance: "Line distance",
            selectDataVar: "Select Variables",
            clickDataVar: "Click Select Variables to open Data Browser and browse for variables",
            selectedVars: "Selected Variables",
            usCountryCode: "United States",
            canadaCountryCode: "Canada",
            albaniaCountryCode: "Albania",
            australiaCountryCode: "Australia",
            austriaCountryCode: "Austria",
            bahrainCountryCode: "Bahrain",
            belarusCountryCode: "Belarus",
            bosniaCountryCode: "Bosnia and Herzegovina",
            botswanaCountryCode: "Botswana",
            belgiumCountryCode: "Belgium",
            brazilCountryCode: "Brazil",
            bulgariaCountryCode: "Bulgaria",
            chinaCountryCode: "China",
            colombiaCountryCode: "Colombia",
            croatiaCountryCode: "Croatia",
            cyprusCountryCode: "Cyprus",
            czechCountryCode: "Czech Republic",
            coteCountryCode: "Cote d'Ivoire",
            denmarkCountryCode: "Denmark",
            finlandCountryCode: "Finland",
            franceCountryCode: "France",
            germanyCountryCode: "Germany",
            ghanaCountryCode: "Ghana",
            greeceCountryCode: "Greece",
            hungaryCountryCode: "Hungary",
            icelandCountryCode: "Iceland",
            indiaCountryCode: "India",
            indonesiaCountryCode: "Indonesia",
            irelandCountryCode: "Ireland",
            israelCountryCode: "Israel",
            italyCountryCode: "Italy",
            japanCountryCode: "Japan",
            kazakhstanCountryCode: "Kazakhstan",
            kenyaCountryCode: "Kenya",
            latviaCountryCode: "Latvia",
            liechtensteinCountryCode: "Liechtenstein",
            lithuaniaCountryCode: "Lithuania",
            luxembourgCountryCode: "Luxembourg",
            malawiCountryCode: "Malawi",
            malaysiaCountryCode: "Malaysia",
            maltaCountryCode: "Malta",
            mauritiusCountryCode: "Mauritius",
            mexicoCountryCode: "Mexico",
            moldovaCountryCode: "Moldova",
            montenegroCountryCode: "Montenegro",
            mozambiqueCountryCode: "Mozambique",
            namibiaCountryCode: "Namibia",
            netherlandsCountryCode: "Netherlands",
            nzCountryCode: "New Zealand",
            nigeriaCountryCode: "Nigeria",
            norwayCountryCode: "Norway",
            peruCountryCode: "Peru",
            polandCountryCode: "Poland",
            portugalCountryCode: "Portugal",
            puertoCountryCode: "Puerto Rico",
            romaniaCountryCode: "Romania",
            reunionCountryCode: "Reunion",
            spainCountryCode: "Spain",
            switzerlandCountryCode: "Switzerland",
            swedenCountryCode: "Sweden",
            turkeyCountryCode: "Turkey",
            ukCountryCode: "United Kingdom",
            zmCountryCode: "Zambia",
            ugandaCountryCode: "Uganda",
            mkCountryCode: "The Former Yugoslav Republic of Macedonia",
            uaeCountryCode: "United Arab Emirates",
            thCountryCode: "Thailand",
            twCountryCode: "Taiwan",
            szCountryCode: "Swaziland",
            krCountryCode: "South Korea",
            siCountryCode: "Slovenia",
            sgCountryCode: "Singapore",
            rsCountryCode: "Serbia",
            saCountryCode: "Saudi Arabia",
            tzCountryCode: "Tanzania",
            ukrCountryCode: "Ukraine",
            globalCode: "Global",
            russiaCountryCode: "Russia",
            algCountryCode: "Algeria",
            andCountryCode: "Andorra",
            argCountryCode: "Argentina",
            azCountryCode: "Azerbaijan",
            baCountryCode: "Bangladesh",
            chCountryCode: "Chile",
            coCountryCode: "Costa Rica",
            egCountryCode: "Egypt",
            elCountryCode: "El Salvador",
            eeCountryCode: "Estonia",
            grCountryCode: "Georgia",
            gtCountryCode: "Guatemala",
            hoCountryCode: "Honduras",
            joCountryCode: "Jordan",
            kwCountryCode: "Kuwait",
            kzCountryCode: "Kyrgyzstan",
            lbCountryCode: "Lebanon",
            leCountryCode: "Lesotho",
            mgCountryCode: "Mongolia",
            moCountryCode: "Morocco",
            niCountryCode: "Nicaragua",
            omCountryCode: "Oman",
            pkCountryCode: "Pakistan",
            phCountryCode: "Philippines",
            qaCountryCode: "Qatar",
            slCountryCode: "Slovakia",
            safCountryCode: "South Africa",
            sriCountryCode: "Sri Lanka",
            sdCountryCode: "Sudan",
            tnCountryCode: "Tunisia",
            ugCountryCode: "Uruguay",
            syCountryCode: "Syria",
            vzCountryCode: "Venezuela",
            vtCountryCode: "Vietnam",
            keyGlobalFacts: "Key Global Facts",
            age: "Age",
            husByOccupancy: "Housing Units By Occupancy",
            householdsByIncome: "Households by Income",
            keyUSFacts: "Key US Facts",
            policy: "Policy Facts",
            raceAndEthnicity: "Race And Ethnicity",
            wealth: "Wealth Facts",
            keyCanFacts: "Key Canada Facts",
            aTSpend: "Austria Spending",
            aTFacts: "Austria Facts",
            bESpend: "Belgium Spending",
            bEFacts: "Belgium Facts",
            bRSpend: "Brazil Spending",
            bRFacts: "Brazil Facts",
            dKSpend: "Denmark Spending",
            dKFacts: "Denmark Facts",
            fISpend: "Finland Spending",
            fIFacts: "Finland Facts",
            fRSpend: "France Spending",
            fRFacts: "France Facts",
            dESpend: "Germany Spending",
            dEFacts: "Germany Facts",
            gRSpend: "Greece Spending",
            gRFacts: "Greece Facts",
            iEFacts: "Ireland Facts",
            iESpend: "Ireland Spending",
            iNFacts: "India Facts",
            iNSpend: "India Spending",
            iTFacts: "Italy Facts",
            iTSpend: "Italy Spending",
            keyWEFacts: "Key Western Europe Facts",
            keyWESpend: "Key Western Europe Spending",
            jPFacts: "Japan Facts",
            jPSpend: "Japan Spending",
            lIFacts: "Liechtenstein Facts",
            lISpend: "Liechtenstein Spending",
            lUFacts: "Luxembourg Facts",
            lUSpend: "Luxembourg Spending",
            nLFacts: "Netherlands Facts",
            nLSpend: "Netherlands Spending",
            nOFacts: "Norway Facts",
            nOSpend: "Norway Spending",
            pTFacts: "Portugal Facts",
            pTSpend: "Portugal Spending",
            eSSpend: "Spain Spending",
            eSFacts: "Spain Facts",
            sEFacts: "Sweden Facts",
            sESpend: "Sweden Spending",
            cHFacts: "Switzerland Facts",
            cHSpend: "Switzerland Spending",
            tRFacts: "Turkey Facts",
            tRSpend: "Turkey Spending",
            gBFacts: "United Kingdom Facts",
            gBSpend: "United Kigdom Spending",
            tapestry: "Tapestry",
            infrastructure: "Infrastructure",
            landCover: "Land Cover",
            landscapeFacts: "Landscape Facts",
            publicLands: "Public Lands",
            soils: "Soils",
            waterWetlands: "Water Wetlands",
            rUFacts: "Russia Facts",
            rUSpend: "Russia Spending"
        },
        dissolveBoundaries: {
            dissolveBoundariesDefine: "Dissolve \x3cb\x3e${layername}\x3c/b\x3e",
            chooseDissolveLabel: "Choose dissolve method",
            overlappingAreasLabel: "Areas that overlap or are adjacent",
            sameAttributeAreasLabel: "Areas with same field value",
            summarizeLabel: "Add statistic (optional)",
            itemDescription: "Feature Service generated from running the Dissolve Boundaries solution.",
            itemTags: "Analysis Result, Dissolve Boundaries, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Dissolve Boundaries",
            resultLabel: "Result layer name",
            outputLayerName: "Dissolve ${layername}"
        },
        FindNearestTool: {
            summarizeDefine: "For each location in \x3cb\x3e${sumNearbyLayerName}\x3c/b\x3e, find its nearest locations.",
            findNearLabel: "Find the nearest locations by measuring",
            outputLayerName: "Nearest ${layer} to ${sumNearbyLayerName}",
            groupByLabel: "Choose field to group by (optional)",
            itemDescription: "Feature Service generated from running the Find Nearest solution. Nearest ${sumNearbyLayerName}",
            itemTags: "Analysis Result, Find Nearest, ${sumNearbyLayerName}, ${summaryLayerName}",
            itemSnippet: "Analysis Feature Service generated from Find Nearest",
            removeAttrStats: "Remove Attribute Statistics",
            forEachLocationLabel: "For each location in \x3cb\x3e${sumNearbyLayerName}\x3c/b\x3e",
            findNearestLabel: "Limit the number of nearest locations to:",
            limitSearchRangeCheck: "Limit the search range to",
            addStats: "For each location in \x3cb\x3e${summaryLayerName}\x3c/b\x3e",
            chooseLayer: "Choose a layer",
            findLocationsIn: "Find the nearest locations in:",
            outputLayersLabel: "Result layer names",
            straightLineDistance: "Line distance",
            resultLabel1: "Nearest locations layer",
            resultLabel2: "Connecting lines layer",
            outputConnectingLayerName: "Nearest ${layer} to ${sumNearbyLayerName} (Lines)",
            chooseLayerInfoLabel: "Both input layers must contain points to enable Driving distance and Driving time options"
        },
        mergeLayers: {
            mergeLayersDefine: "Merge \x3cb\x3e${layername}\x3c/b\x3e with",
            outputLayerName: "Merge ${layername} ${mergelayername}",
            chooseMergeLayer: "Choose layer",
            mergeFieldsLabel: "Modify merging fields (optional)",
            itemDescription: "Feature Service generated from running the Merge Layers solution.",
            itemTags: "Analysis Result, Merge Layers, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Merge Layers",
            resultLabel: "Result layer name",
            rename: "Rename",
            remove: "Remove",
            match: "Match",
            operation: "Operation",
            fieldTypeMatchValidationMsg: "Fields to be matched must have the same type.  Transformation of types is supported (for example, double to integer, integer to string) except for string to numeric."
        },
        findExistingLocations: {
            findExpLabel: "Find the \x3cb\x3e${analysisLayerName}\x3c/b\x3e features that match the following expression(s)",
            outputLayerName: "Find Locations in ${analysisLayerName}",
            itemDescription: "Feature Service generated from running the Find Existing Locations solutions for  ${analysisLayerName}.",
            itemTags: "Analysis Result, Find Existing Locations, ${analysisLayerName}",
            itemSnippet: "Analysis Feature Service generated from Find Existing Locations"
        },
        deriveNewLocations: {
            findExpLabel: "Derive new locations that match the following expression(s)",
            outputLayerName: "New Locations",
            itemDescription: "Feature Service generated from running the Derive New Locations solutions.",
            itemTags: "Analysis Result, Derive New Locations, ${analysisLayerName}",
            itemSnippet: "Analysis Feature Service generated from Find Existing Locations"
        },
        findSimilarLocations: {
            toolDefine: "Find locations that are similar to: \x3cb\x3e${layername}\x3c/b\x3e",
            labelOneText: "You may use all locations or make a selection",
            labelTwoText: "Search for similar locations in",
            labelThreeText: "Base similarity on",
            labelFourText: "Show me:",
            outputLayerName: "Most Similar ${analysisLayerName}",
            selectTargetFtrs: "Select one or more target features",
            useAllFtrs: "Use all features",
            itemDescription: "Feature Service generated from running the Find Similar Locations solutions for  ${analysisLayerName}.",
            itemTags: "Analysis Result, Find Similar Locations, ${analysisLayerName}",
            itemSnippet: "Analysis Feature Service generated from Find Similar Locations",
            allResults: "all locations from most to least similar",
            justShowTop: "the top",
            selectSearchLayer: "Select the search layer",
            query: "Query",
            noFieldMatchMsg: "Search layer and input layer do not have any fields in common.",
            reqSelectionMsg: "You must select the feature(s) to match by making an interactive selection or by constructing a query.",
            selectedFeaturesLabel: "${total} feature(s) selected"
        },
        expressionGrid: {
            addExpr: "Add Expression",
            expression: "Expression",
            editExpr: "Edit Expression",
            viewText: "View Text",
            viewGrid: "View Grid",
            addExprDescription: "Click Add Expression to begin building your query.",
            duplicateExpression: "This Expression already exists"
        },
        expressionForm: {
            where: "where (attribute query)",
            whereLabel: "where",
            intersects: "intersects",
            notIntersects: "does not intersect",
            withinDistance: "within a distance of",
            notWithinDistance: "not within a distance of",
            contains: "completely contains",
            notContains: "does not completely contain",
            completelyContains: "completely contains",
            notCompletelyContains: "does not completely contain",
            within: "completely within",
            notWithin: "not completely within",
            completelyWithin: "completely within",
            notCompletelyWithin: "not completely within",
            identical: "are identical to",
            notIdentical: "are not identical to",
            touches: "touches",
            notTouches: "does not touch",
            crossesOutline: "crossed by the outline of",
            notCrossesOutline: "not crossed by the outline of",
            from: "from",
            inValidAttributeFilterMessage: "Layer ${layername} does not contain any attributes that can be used in an attribute query."
        },
        interpolatePointsTool: {
            toolDefine: "Interpolate values from \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "${layername} Prediction",
            interpolationMethod: "Interpolation method",
            optimizeFor: "Optimize for",
            selectAttributesLabel: "Choose field to interpolate",
            classifyLabel: "Classify by",
            classesCountLabel: "Number of classes",
            equalInterval: "Equal Interval",
            manual: "Manual",
            quantile: "Equal Area",
            geometricInterval: "Geometric Interval",
            outputPredictionErrors: "Output prediction errors",
            interpolateWithin: "Clip output to",
            predictLocLabel: "Predict at these locations",
            choosePointLayer: "Choose point layer",
            pointlayerName: "Drawn Prediction Points",
            classBreakValues: "Class break values",
            defaultBoundingOption: "Choose study area",
            classBreaksHelp: "Enter break values spearated by spaces: (10 20 30)",
            itemDescription: "Feature Service generated from running the Interpolate Points solution.",
            itemTags: "Analysis Result, Interpolate Points, ${layername}, ${fieldname}",
            itemSnippet: "Analysis Feature Service generated from Interpolate Points",
            speed: "Speed",
            accuracy: "Accuracy"
        },
        calculateDensityTool: {
            toolDefine: "Calculate density values from \x3cb\x3e${layername}\x3c/b\x3e",
            selectAttributesLabel: "Use a count field (optional)",
            outputAerealUnits: "Output area units",
            itemDescription: "Feature Service generated from running the Calculate Density solution.",
            itemTags: "Analysis Result, Calculate Density, ${layername}, ${fieldname}",
            itemSnippet: "Analysis Feature Service generated from Calculate Density",
            outputLayerName: "${layername} Density",
            searchDistance: "Search Distance",
            naturalBreaks: "Natural Breaks",
            standardDeviation: "Standard Deviation",
            chooseCountField: "No count field"
        },
        traceDownstreamTool: {
            toolDefine: "Trace downstream from \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "${layername} Trace",
            choosePointLayer: "Choose point layer",
            pointlayerName: "Drawn Prediction Points",
            defaultBoundingOption: "Choose study area",
            itemDescription: "Feature Service generated from running the Trace Downstream solution.",
            itemTags: "Analysis Result, Trace Downstream, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Trace Downstream",
            clipOutputToLabel: "Clip output to",
            traceOptionsLabel: "Trace downstream settings (optional)",
            splitTraceLabel: "Split the trace into line segments",
            maxTraceLabel: "Maximum distance of the trace"
        },
        createWatershedTool: {
            toolDefine: "Create Watersheds from \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "${layername} Watersheds",
            choosePointLayer: "Choose point layer",
            pointlayerName: "Drawn Prediction Points",
            defaultBoundingOption: "Choose study area",
            itemDescription: "Feature Service generated from running the Create Watershed solution.",
            itemTags: "Analysis Result, Create Watersheds, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Create Watershed",
            searchDistanceLabel: "Search distance to nearest drainage (optional)"
        },
        createViewshedTool: {
            toolDefine: "Create areas that are visible from \x3cb\x3e${layername}\x3c/b\x3e",
            outputLayerName: "${layername} visible areas",
            itemDescription: "Feature Service generated from running the Create Viewshed solution.",
            itemTags: "Analysis Result, Create Viewshed, ${layername}",
            itemSnippet: "Analysis Feature Service generated from Create Viewshed",
            maxDistanceLabel: "Maximum viewing distance",
            observerHghtLabel: "Height of ${layername}",
            targetHghtLabel: "Height of other objects on the ground",
            viewshedOptionlabel: "Visibility settings (optional)",
            maxDistanceValidMsg: "The maximum viewing distance cannot be more than ${limit} ${units}.",
            maxdistanceInValidMsg: "Only integer values are allowed"
        },
        analysisMsgCodes: {
            SS_84493: "There was 1 outlier location; it was not used to compute ${AggregationType}.",
            SS_84492: "The total study area was ${Area}.",
            SS_84491: "There were ${NumFeatures} valid input aggregation areas.",
            SS_84490: "The aggregation process resulted in ${AggNumFeatures} weighted areas.",
            SS_84489: "Analysis was performed on all aggregation areas.",
            SS_84485: "There were ${NumFeatures} valid input features.",
            SS_84477: "Blue output features represent cold spots where low ${FieldName} cluster.",
            SS_84476: "Red output features represent hot spots where high ${FieldName} cluster.",
            SS_84471: "Output",
            SS_84470: "${NumSignificant} output features are statistically significant based on a FDR correction for multiple testing and spatial dependence.",
            SS_84466: "Hot Spot Analysis",
            SS_84465: "The optimal fixed distance band was based on one standard distance of the features from the geometric mean: ${DistanceInfo}.",
            SS_84464: "The optimal fixed distance band was based on the average distance to ${NumNeighs} nearest neighbors: ${DistanceInfo}.",
            SS_84461: "The optimal fixed distance band selected was based on peak clustering found at ${DistanceInfo}.",
            SS_84459: "Scale of Analysis",
            SS_84458: "Analysis was based on the number of points in each polygon cell.",
            SS_84457: "Points were aggregated to the fishnet polygon cells falling within the bounding areas provided.",
            SS_84453: "Analysis was performed on all fishnet polygon cells within the bounding area layer.",
            SS_84452: "Analysis was performed on all fishnet polygon cells containing at least one point.",
            SS_84451: "Analysis was based on the number of points in each fishnet polygon cell.",
            SS_84450: "The polygon cell size was ${SnapInfo}.",
            SS_84449: "A fishnet polygon mesh was created for aggregating points.",
            SS_84446: "${VarName} Properties:",
            SS_84444: "Incident Aggregation",
            SS_84437: "There were no locational outliers.",
            SS_84434: "There were ${NumOutliers} outlier locations; these were not used to compute ${AggregationType}.",
            SS_84428: "Initial Data Assessment.",
            SS_84271_0: "Min",
            SS_84272_0: "Max",
            SS_84261_0: "Mean",
            SS_84262_0: "Std. Dev.",
            SS_00002: "The following report outlines the workflow used to optimize your Find Hot Spots result:",
            AO_100001: "Aggregate Points failed.",
            AO_100002: "The geometry type of Point Layer must be points.",
            AO_100003: "The geometry type of  Polygon Layer must be polygons.",
            AO_100004: "The field  ${fieldName} provided for Summary Fields does not exist.",
            AO_100005: "The field  ${fieldName} provided for Summary Fields is not numeric.",
            AO_100006: "The summary type ${summary} provided for field ${fieldName} is invalid.",
            AO_100007: "Find Hot Spots failed.",
            AO_100008: "The geometry type for the boundingPolygonLayer must be polygon.",
            AO_100009: "The geometry type of Analysis Layer must be points or polygons.",
            AO_100010: "The geometry type of Aggregation Polygon Layer must be polygon.",
            AO_100011: "Must provide an Analysis Field for polygon Analysis Layer.",
            AO_100012: "Create Buffers failed.",
            AO_100013: "Overlay Layers failed.",
            AO_100014: "Summarize Within failed.",
            AO_100015: "The geometry type of Summarize Layer input must be point, line, or polygons.",
            AO_100016: "The geometry type of Summarize Layer input must be point or line.",
            AO_100017: "The geometry type of Summarize Layer input must be point.",
            AO_100018: "Sum Units ${sumUnits} is not applicable for ${shapeType} shape type.",
            AO_100019: "At least one of the parameters, Summarize Shape or  Summary Fields is required.",
            AO_468: "Input shape types are not equal.",
            AO_1156: "A field value was incompatible with the field type.",
            AO_800: "The value is not a member of SUM | MEAN | MIN | MAX | RANGE | STD | COUNT | FIRST | LAST.",
            AO_728: "The analysisField ${fieldName} you specified does not exist in the analysisLayer.",
            AO_12: "Field to add already exists.",
            AO_539: "Expression is invalid.",
            AO_1115: "Layer description property must be set for ${layerName}.",
            AO_366: "Invalid geometry type.",
            AO_641: "This tool requires at least ${numFeatures} feature(s) to compute results.",
            AO_906: "Zero variance: all of the values for your input field are likely the same.",
            AO_1533: "We were not able to compute hot and cold spots for the data provided.\u00a0 If appropriate, try specifying an Analysis Field.",
            AO_1534: "Hot and cold spots cannot be computed when the number of points in every polygon area is identical. Try different polygon areas or different analysis options.",
            AO_1535: "The analysis option you selected requires a minimum of ${minNumFeatures} aggregation areas.",
            AO_1536: "The analysis options you selected require a minimum of ${minNumIncidents} points to compute hot and cold spots.",
            AO_1570: "The analysis option you selected requires a minimum of ${minNumIncidents} points to be inside the bounding polygon area(s).",
            AO_1571: "The analysis options you selected require a minimum of ${minNumFeatures} features with valid data in the analysis field in order to compute hot and cold spots.\t",
            AO_1572: "There is not enough variation in point locations to compute hot and cold spots. Coincident points, for example, reduce spatial variation.\u00a0 You can try providing a bounding area, aggregation areas (a minimum of 30), or an Analysis Field.",
            AO_1573: "There is not enough variation among the points within the bounding polygon area(s). You can try providing larger boundaries.",
            AO_1574: "The analysis option you selected requires a minimum of ${minNumIncidents} points to be inside the aggregation polygons.",
            AO_1575: "All of the values for your analysis field are likely the same.\u00a0 Hot and cold spots cannot be computed when there is no variation in the field being analyzed.",
            AO_84426: "Must provide polygons for aggregating incidents into counts for this incident data aggregation method.",
            AO_26: "Buffer distance is zero.",
            AO_109: "The buffer distance cannot be negative for lines and points.",
            AO_385: "The LINE option is not valid with point features.",
            AO_438: "Overlay not polygon.",
            AO_100020: "Enrich Layer failed.",
            AO_100021: "The geometry type of Input Layer must be point, line or polygon.",
            AO_100022: "Units ${units} is not supported for Buffer type ${bufferType}.",
            AO_100023: "Unable to enrich layer for input spatial reference ${spref}.",
            AO_100024: "The number of features in ${inputLayer} is zero.",
            AO_100025: "Summarize Nearby failed.",
            AO_100026: "Extract Data failed.",
            AO_100027: "Dissolve Boundaries failed.",
            AO_100028: "Create Drive Time Areas failed.",
            AO_100029: "Merge Layers failed.",
            AO_100030: "Find Nearest failed.",
            AO_100031: "The number of nearest locations to find can not be greater than 100.",
            AO_100032: "The number of features in ${analysisLayer} is zero.",
            AO_100033: "The number of features in ${nearLayer} is zero.",
            AO_100034: "The number of features in ${analysisLayer} can not be greater than 1000.",
            AO_100035: "The number of features in ${nearLayer} can not be greater than 1000.",
            AO_100036: "The ${analysisLayer} layer must have a point geometry type when using ${measurementType} as the measurement type.",
            AO_100037: "The ${nearLayer} layer must have a point geometry type when using ${measurementType} as the measurement type.",
            AO_100038: "The search cutoff cannot be less than zero.",
            AO_100039: "The ${inputLayer} must have a point geometry type.",
            AO_100040: "The number of features in ${inputLayer} can not be greater than ${max}.",
            AO_100041: "Buffer type parameter is supported only for layers containing points or lines.",
            AO_100042: "The geometry type ${shapeType} of Nearby Layer is not supported for Near type ${nearType}",
            AO_100043: "Units ${units} is not supported for Near type ${nearType}.",
            AO_100044: "Distance value should be greater than 0",
            AO_100045: "Distance and units are required when Buffer type is specified",
            AO_100046: "Failed to access GeoEnrichment server.",
            AO_100047: "Enrichment may not be available for some features.",
            AO_100048: "The input layer ${inputLayer} contains multipoint geometry and has been converted to single point geometry.",
            AO_100049: "No features in the processing extent for any input layers.",
            AO_100050: "No fields exist in the input layer for data extraction.",
            AO_100051: "No features in the processing extent for any input layers and none of the input layers have fields for data extraction. ",
            AO_100052: "The field name ${fieldName} does not exist in the ${paramName}.",
            AO_100053: "Required keys ${missingKeys} are missing in attribute expression ${expression}.",
            AO_100054: "Required keys ${missingKeys} are missing in spatial relationship expression ${expression}.",
            AO_100055: "Invalid expression; malformed JSON.",
            AO_100056: "Invalid layer index in expression ${expression}.",
            AO_100057: "Layer index exceeds the number of input layers in expression ${expression}.",
            AO_100058: "${spatialRel} spatial relationship does not support ${lyrGeomType}/${selLyrGeomType} geometry types for layer/selectingLayer in expression ${expression}.",
            AO_100059: "Invalid spatial relationship {spatialRel} in expression ${expression}.",
            AO_100060: "Query expression failed in expression ${expression}.",
            AO_100061: "FindExistingLocations failed.",
            AO_100062: "Invalid distance and/or units in expression ${expression}",
            AO_100063: "PlanRoutes failed.",
            AO_100064: "The number of features in ${stopsLayer} is zero.",
            AO_100065: "The number of features in ${startLayer} is zero.",
            AO_100066: "The maximum number of vehicles to route cannot be less than zero and greater than ${max}.",
            AO_100067: "The maximum number of stops per vehicle cannot be less than zero and greater than ${max}.",
            AO_100068: "The number of features in ${stopsLayer} cannot be greater than ${max}.",
            AO_100069: "The number of features in ${startLayer} cannot be greater than ${max}.",
            AO_100070: "The number of features in ${endLayer} cannot be greater than ${max}.",
            AO_100071: "The ${stopsLayer} layer must have a point geometry type.",
            AO_100072: "The ${startLayer} layer must have a point geometry.",
            AO_100073: "The ${endLayer} layer must have a point geometry.",
            AO_100074: "The time spent at each stop cannot be less than zero.",
            AO_100075: "The total route time per vehicle should be greater than zero and less than one year (525600 minutes).",
            AO_100076: "The ${endLayer} should not be specified if return to start is true.",
            AO_100077: "Find Similar Locations failed.",
            AO_100078: "Invalid field name in expression ${expression}",
            AO_100079: "Derive New Locations failed.",
            AO_100080: "Connect Origins To Destinations failed.",
            AO_100081: "Field Calculator failed.",
            AO_735: "Please provide at least one valid analysis field to base similarity on.",
            AO_1589: "This tool requires a minimum of 2 locations to search.",
            AO_100082: "A field name and an expression are required.",
            AO_100083: "A field type is required for creating a new field.",
            AO_100084: "Field type is required to be String, Integer, Double or Date.",
            AO_1599: "Too few records for analysis. This tool requires at least 1 reference  location in the Input Layer to compute results.",
            AO_100088: "Field(s) ${attribute} must be in both the reference and candidate search layers.",
            AO_100089: "The following fields lack sufficient variation for use in this analysis: ${attribute}.",
            AO_100090: "This tool requires at least 2 candidate search locations that are not also reference locations.",
            AO_100094: "The maximum number of vehicles to route must be equal to the number of features in ${startLayer}.",
            AO_100104: "InterpolatePoints failed.",
            AO_40039: "Not enough data to compute method.",
            AO_40040: "Data is distributed along a straight line and cannot be processed.",
            AO_40069: "The variance of the data is too small to be calculated.",
            AO_100091: "The geometry type of ${paramName} must be Points",
            AO_100092: "The geometry type of boundingPolygonLayer must be Polygons",
            AO_100093: "The classification type Manual requires classbreaks value.",
            AO_100095: "The number of features in ${endLayer} must be equal to the number of features in ${startLayer}.",
            AO_100096: "The ${startLayerRouteIDField} in ${startLayer} does not have unique values.",
            AO_100097: "The ${endLayerRouteIDField} in ${endLayer} does not have unique values.",
            AO_100098: "The values in ${startLayerRouteIDField} in ${startLayer} do not have a one-to-one match with the values in ${endLayerRouteIDField} in ${endLayer}.",
            AO_100099: "All break values must be greater than zero.",
            AO_100100: "The features in ${inputLayer} are not within the data coverage area. See availability at ${url}.",
            AO_100101: "No features in ${inputLayer} are within a distance of ${max} kilometers from streets.",
            AO_100102: "All features in ${inputLayer} must be in the same time zone when using traffic and creating areas with dissolve or split options.",
            AO_100103: "The ${measureType} value cannot be greater than ${max} ${breakUnits}.",
            AO_100105: "CalculateDensity failed",
            AO_100106: "Field ${fieldName} is not numeric.",
            AO_100107: "Field ${fieldName} does not have any positive values.",
            AO_100108: "Field ${fieldName} has negative values, only positive values will be considered for calculating density.",
            AO_100109: "The geometry type for the input layer must be points or lines.",
            AO_100110: "Your user role doesn\u2019t include the geoEnrichment privilege",
            AO_100111: "Your user role doesn\u2019t include the network analysis privilege",
            AO_100112: "Your user role doesn't include the publish hosted features privilege",
            AO_100113: "None of the stops were assigned to any routes. Check the Status and Violated Constraints fields in the output unassigned stops layer for more information.",
            AO_100114: "The time spent at each stop, ${stopServiceTime} minutes, must be less than the total route time per vehicle, ${maxRouteTime} minutes.",
            AO_100115: "Some stops were not assigned to any routes. Check the Violated Constraints field in the output unassigned stops layer for more information.",
            AO_100116: "Only ${routesUsed} out of ${routeCount} routes are needed to reach all stops. If you want to use more routes, run Plan Routes again but reduce the limits on the maximum number of stops or the total route time per vehicle.",
            AO_100117: "Driving a truck is currently not supported outside of North America and Central America.",
            AO_100118: "Your user role doesn't include the create, update and delete content privilege.",
            GPEXT_001: "Invalid parameter ${name} value",
            GPEXT_002: "Parameter missing ${name}",
            GPEXT_003: "Invalid parameter ${name}:property ${propname} is missing",
            GPEXT_004: "Invalid layer parameter property ${propname} is missing",
            GPEXT_005: "Failed to access url ${url}",
            GPEXT_006: "Accessing url ${url} returned error ${error}",
            GPEXT_007: "Invalid item ${id}",
            GPEXT_008: "Failed to create service ${name}",
            GPEXT_009: "Failed to add layer ${lname} to service ${name}",
            GPEXT_010: "Failed to parse layer JSON",
            GPEXT_011: "Layer ${url} does not have Extract capability",
            GPEXT_012: "Invalid External Operation",
            GPEXT_013: "This tool uses the Geoenrichment Service.  Please refer to ArcGIS Online Service Credit Estimator for more details.",
            GPEXT_014: "This tool uses Network Analysis Services.  Please refer to ArcGIS Online Service Credit Estimator for more details.",
            GPEXT_015: "Select appropriate helper services url from Portal for requested operation.",
            GPEXT_016: "Invalid layer object.",
            GPEXT_017: "Service ${name} already exists.",
            SS_00003: "The following report outlines the summary of your Find Similar Locations result:",
            SS_84503: "Summary of Input Features to Match",
            SS_89997: '["Attribute", "Min", "Max", "SD", "Mean"]',
            SS_84504: "Summary of Attributes of Interest",
            SS_84512: '["Attribute", "Min", "Max", "SD", "Mean", "Input"]',
            SS_84505: "Top ${numResults} Most Similar Locations (Values)",
            SS_84506: " Top 10 of ${numResults} Most Similar Locations (Values)",
            SS_84510: '["OID", "SIMRANK", "SIMINDEX"]',
            SS_89998: ' ["", "Total", ${sumIndex}] ',
            AO_100119: "The geometry type of WithinLayer input must be polygons",
            AO_100120: "The features in the layer are beyond max request size limit and cannot be enriched",
            AO_100121: "CreateViewshed Failed",
            AO_100122: "TraceDownstream Failed",
            AO_100123: "CreateWatersheds Failed",
            AO_100124: "The geometry type of Input Layer must be point for buffer type ${bufferType}",
            AO_100125: "The groupby field ${fieldName} must be integers, text or date.",
            AO_100126: "The features in the input layer are beyond max request size and hence simplified",
            AO_100127: "All points fall outside the processing unit extent",
            AO_100128: "The point field provided must be string or integer",
            AO_100129: "The point falls outside the catchment extent",
            AO_100130: "The point falls outside the processing unit extent",
            AO_100131: "The maximum viewing distance parameter cannot be more than ${max}${units}",
            AO_100132: "The DEM source data is not available in the input points area.",
            AO_100133: "The input DEM resolution is not supported at the specified maximum distance value. Specify a smaller maximum distance value.",
            AO_100136: "The geometry type for Extent Layer must be polygon.",
            AO_100137: "A value for the  ${parameterName} is required.",
            AO_100138: "Some origins were not connected to their paired destinations. Check the Status field in output unassigned origins and unassigned destinations layers for more information.",
            AO_100139: "None of the origins could be connected to destinations.",
            AO_100140: "The features in the Extent Layer are beyond max request size and hence simplified.",
            AO_100141: "The features in the Extent Layer are beyond max request size limit and cannot be extracted."
        },
        geoenrichment: {
            task: {
                GeoenrichmentTask: {
                    noData: "There is no data for the selected area"
                }
            },
            dijit: {
                AgePyramid: {
                    maxLabel: "The largest group:",
                    minLabel: "The smallest group:",
                    compLabel: "Dots show comparison to",
                    menLabel: "Men",
                    womenLabel: "Women"
                },
                BufferOptions: {
                    studyArea: "Show data for:",
                    ring: "Ring",
                    driveTime: "Drive Times",
                    driveDistance: "Drive Distance",
                    radius: "Radius:",
                    time: "Time:",
                    distance: "Distance:",
                    buffer: "Buffer:",
                    units: {
                        esriDriveTimeUnitsMinutes: "minutes",
                        esriMiles: "miles",
                        esriKilometers: "kilometers",
                        esriFeet: "feet",
                        esriMeters: "meters"
                    }
                },
                bufferTitle: {
                    pointRing: {
                        esriFeet: "${radius}-feet ring",
                        esriKilometers: "${radius}-km ring",
                        esriMeters: "${radius}-meter ring",
                        esriMiles: "${radius}-mile ring"
                    },
                    pointDriveTime: {
                        esriFeet: "${radius}-feet drive distance",
                        esriKilometers: "${radius}-km drive distance",
                        esriMeters: "${radius}-meter drive distance",
                        esriMiles: "${radius}-mile drive distance",
                        esriDriveTimeUnitsMinutes: "${radius}-minute drive time"
                    },
                    lineBuffer: {
                        esriFeet: "${radius}-feet buffer",
                        esriKilometers: "${radius}-km buffer",
                        esriMeters: "${radius}-meter buffer",
                        esriMiles: "${radius}-mile buffer"
                    },
                    polygon: "This area",
                    stdGeo: "Intersecting ${level} feature"
                },
                DataCategoriesPage: {
                    loading: "Loading...",
                    global: "Global",
                    search: "search for a variable name",
                    noResults: "No results found for '${seachKey}'."
                },
                DataCollectionsPage: {
                    categoryName: "${categoryName} Variables",
                    mapPopVar: "Choose a Popular Variable",
                    keepBrowse: "Keep Browsing",
                    showAll: "Show all ${categoryName} Variables",
                    search: "search within the current category",
                    noResults: "No results found for '${seachKey}'.",
                    from: "from '${categoryName}'"
                },
                DataVariablesPage: {
                    vars: "variables"
                },
                ShoppingCart: {
                    selectedVars: "Selected Variables",
                    noVariables: "No variables have yet been selected"
                },
                VariableInfo: {
                    name: "Name",
                    variable: "Variable",
                    source: "Source",
                    vintage: "Vintage"
                },
                EnrichOptionsPage: {
                    bufferRing: "1 mile circle around locations",
                    bufferPolygon: "input polygons (buffer unavailable)",
                    selectedVariables: "Selected Variables:",
                    customize: "customize",
                    bufferOptions: "Show data for:",
                    edit: "edit",
                    totalVars: "Total Variables: ${varCount} (${credits})",
                    varsPerRow: "Variables per Row: ${varCount} (${credits})",
                    credits: "${credits} credits",
                    creditsCalc: "calculating...",
                    totalVarsTooltip: "This operation will enrich ${rowCount} rows with ${varCount} variables and will cost ${credits}.",
                    varsPerRowTooltip: "This operation will enrich each row with ${varCount} variables and will cost ${credits} per row.",
                    overwriteExisting: "Existing column values will be overwritten",
                    varName: "Variable Name",
                    column: "Column",
                    newColumn: "\x3cCreate New\x3e",
                    noColumn: "\x3cNone\x3e",
                    back: "Back",
                    finish: "Add data to system"
                },
                InfographicsMainPage: {
                    mainTitle: "Configure Infographics",
                    loading: "Loading...",
                    chooseCountry: "Show available data for: ",
                    chooseDataCollection: "Choose from popular data collections: ",
                    chooseTheme: "Select color theme:",
                    dark: "Dark",
                    light: "Light",
                    addVariables: "Add more variables...",
                    ok: "OK",
                    add: "Add",
                    cancel: "Cancel"
                },
                OneVar: {
                    subtitleSite2: "for this area ",
                    subtitleVar2: "${alias} is ",
                    lessThan: "which is less than the average for ${site}",
                    moreThan: "which is more than the average for ${site}",
                    same: "which is the same as the average for ${site}",
                    areaCol: "Area",
                    valueCol: "Value"
                },
                RelatedVariables: {
                    highLabel2: "The largest group: ${alias}",
                    lowLabel2: "The smallest group: ${alias}",
                    indicatorCol: "Indicator",
                    valueCol: "Value",
                    difCol: "Difference",
                    chartLabel: "Bars show deviation from"
                },
                Tapestry: {
                    hhTypeLabel: "Household Type:",
                    medianAgeLabel: "Median Age:",
                    incomeLabel: "Income:",
                    employmentLabel: "Employment:",
                    educationLabel: "Education:",
                    residentialLabel: "Residential:",
                    raceEthnicityLabel: "Race / Ethnicity:",
                    hhLabel: "households",
                    adultsLabel: "adults"
                },
                WizardButtons: {
                    back: "Back",
                    ok: "OK",
                    apply: "Apply",
                    cancel: "Cancel",
                    next: "Next"
                },
                EnrichConfig: {
                    title: "Enrich Layer"
                },
                DataBrowser: {
                    title: "Data Browser"
                }
            }
        },
        filterDlg: {
            expressionTemplate: "${field_dropdown} ${operator_dropdown} ${values_input}",
            filter: "Filter",
            applyFilter: "Apply Filter",
            applyFilterBtn: "Apply Filter",
            removeFilterBtn: "Remove Filter",
            view: "View",
            change: "Change",
            edit: "Edit",
            create: "Create",
            match1Msg: "Display features in the layer that match the following expression",
            matchMsg: "Display features in the layer that match ${any_or_all} of the following expressions",
            matchMsgSet: "${any_or_all} of the following expressions in this set are true",
            all: "All",
            any: "Any",
            andBetweenValues: "and",
            and: "and",
            or: "or",
            friendlyAnd: "All of these expressions must be true:",
            friendlyOr: "Any of these expressions must be true:",
            friendlyDatePattern: "MM/dd/yyyy",
            addAnotherExpression: "Add another expression",
            addSet: "Add a set",
            askForValues: "Ask for values",
            value: "Value",
            valueTooltip: "Enter value",
            field: "Field",
            fieldTooltip: "Pick from existing field",
            uniqueValues: "Unique",
            uniqueValueTooltip: "Pick from unique values in selected field",
            toThisLayer: "To this layer",
            toNewLayer: "To a new layer",
            newLayerName: "New layer name",
            showFilterExpression: "Show filter's expressions",
            deleteExpression: "Delete this expression",
            deleteSet: "Delete this set",
            addExpression: "Add an expression to this set",
            addSetTooltip: "Add a set to contain expressions",
            promptMsg: "Provide a prompt and some hint text to present this filter interactively to others",
            prompt: "Prompt",
            hint: "Hint",
            stringOperatorIs: "is",
            stringOperatorIsNot: "is not",
            stringOperatorStartsWith: "starts with",
            stringOperatorEndsWith: "ends with",
            stringOperatorContains: "contains",
            stringOperatorDoesNotContain: "does not contain",
            stringOperatorIsBlank: "is blank",
            stringOperatorIsNotBlank: "is not blank",
            dateOperatorIsOn: "is on",
            dateOperatorIsNotOn: "is not on",
            dateOperatorIsBefore: "is before",
            dateOperatorIsAfter: "is after",
            dateOperatorDays: "days",
            dateOperatorWeeks: "weeks",
            dateOperatorMonths: "months",
            dateOperatorInTheLast: "in the last",
            dateOperatorNotInTheLast: "not in the last",
            dateOperatorIsBetween: "is between",
            dateOperatorIsNotBetween: "is not between",
            dateOperatorIsBlank: "is blank",
            dateOperatorIsNotBlank: "is not blank",
            numberOperatorIs: "is",
            numberOperatorIsNot: "is not",
            numberOperatorIsAtLeast: "is at least",
            numberOperatorIsLessThan: "is less than",
            numberOperatorIsAtMost: "is at most",
            numberOperatorIsGreaterThan: "is greater than",
            numberOperatorIsBetween: "is between",
            numberOperatorIsNotBetween: "is not between",
            numberOperatorIsBlank: "is blank",
            numberOperatorIsNotBlank: "is not blank",
            emptyString: "empty string",
            error: {
                noUniqueValues: "The specified field has has no values.",
                generateRendererFailed: "Unique values could not be determined for the selected field.",
                missingValue: "there's a missing value in one of the expressions",
                cantParseExpression: "Filter cannot be shown because one or more of its expressions cannot be parsed. To edit the filter expressions, clear the filter and create a new filter interactively.",
                noFilterFields: "Layer ${name} has no fields that can be used for filtering."
            }
        },
        calculateFields: {
            addFieldTitle: "Add Field",
            nameLabel: "Name:",
            aliasLabel: "Alias:",
            typeLabel: "Type:",
            lengthLabel: "Length:",
            defaultValueLabel: "Default Value:",
            optional: "(Optional)",
            stringLabel: "String",
            integerLabel: "Integer",
            doubleLabel: "Double",
            dateLabel: "Date",
            expBuilderTitle: "Expression Builder",
            operators: "Operators",
            availableFields: "Available Fields",
            helpers: "Helpers",
            functions: "Functions",
            numeric: "Numeric",
            clear: "Clear",
            validate: "Validate",
            addNewField: "Add New Field",
            add: "Add",
            close: "Close",
            calculate: "Calculate",
            deleteLabel: "Delete",
            exprLabel: "${fieldName} \x3d",
            layerReqMsg: "A layer is required parameter for calculate field",
            fieldReqMsg: "A calculate field has not been provided",
            lyrSupportCalMsg: "This layer ${layername} does not support calculate fields",
            lyrUpdateCapMsg: "Either update capability is not enabled on the layer ${layername} or, you do not have access to update features on this layer",
            selectCalField: "Choose field to calculate:",
            firstOperatorMsg: "Operator '${operator}' cannot start an expression",
            completeHelperMsg: "Complete the helper method added previously",
            successMsg: "Successfully updated ${count} features ",
            deleteField: "Delete Field",
            deleteFieldConfirm: "Are you sure you want to delete '${field}' field from this layer?",
            fields: "Fields",
            exprFailedMsg: "Calculate for the expression '${expr}' failed.",
            inValidFielNameCharMsg: "The field name contains one or more invalid characters \x3cbr/\x3e(`~@#$%^\x26*()-+\x3d|\\\x3c\x3e?/{.!'[]:\n\r).",
            inValidFieldStartCharMsg: "The field name cannot start with one of these invalid characters \x3cbr/\x3e(`~@#$%^\x26*()-+\x3d|\\\x3c\x3e?/{}.!'[]:;\n\r_012356789).",
            invalidSqlkeywordsMsg: "The field name cannot be the same as an SQL keyword.",
            invalidExpression: "The calculate expression is not valid",
            sameFielNameMsg: "The field name cannot be same as an existing field name",
            errorCodes: {
                3001: "Sql expression is not supported.",
                3002: "Sql expression syntax error.",
                3004: "Sql expression semantic error.",
                3007: "Invalid table name ${tableName}.",
                3008: "Invalid field name ${fieldName}.",
                3009: "Unsafe sql expression is not allowed."
            },
            absFunc: "${functionName}: Returns the absolute (positive) value of ${num}.",
            castFunc: "${functionName}: Converts a ${num} to a different type. FLOAT converts ${num} to a double and INT converts to an integer.",
            ceilingFunc: "${functionName}: Returns the smallest integer greater than or equal to  ${num}.",
            cosFunc: "${functionName}: Returns the trigonometric cosine of ${num}. ${num} is assumed to be an angle in radians.",
            floorFunc: "${functionName}: Returns the largest integer that is less than or equal to ${num}.",
            logFunc: "${functionName}: The natural logarithm of ${num}.",
            log10Func: "${functionName}: The base-10 logarithm of ${num}.",
            modFunc: "${functionName}: Returns the remainder after the division of n is performed on ${num}. Both ${n} and ${num} must be integer.",
            powerFunc: "${functionName}: Returns the value of ${num} raised to the specified power ${y}.",
            roundFunc: "${functionName}: Rounds ${num} to the specified ${length}.",
            sinFunc: "${functionName}: Returns the trigonometric sine of ${num}. ${num} is assumed to be an angle in radians.",
            tanFunc: "${functionName}: Returns the tangent of ${num}. ${num} is assumed to be an angle in radians.",
            truncateFunc: "${functionName}: Truncates ${num} at the specified ${decimal_place}. A positive ${decimal_place} truncates while a negative ${decimal_place} rounds.",
            nullifFunc: "${functionName}: Returns null if ${num} equals ${value}. Commonly used to prevent divide-by-zero errors by setting ${value} to 0.",
            char_lengthFunc: "${functionName}: Returns the number of characters in ${str}. The result is an integer.",
            concatFunc: "${functionName}: Concatenates two strings.",
            positionFunc: "${functionName}: Returns the position of the first occurrence of substring in ${str}. If substring is not found, the result is 0.",
            lowerFunc: "${functionName}: Returns a string where all characters in ${str} are converted to lowercase.",
            substringFunc: "${functionName}: Returns a part of ${str}. ${start} is an integer index specifying where the returned characters start. ${length} is the number of characters to be returned.",
            trimFunc: "${functionName}: Returns a string where all leading or trailing spaces are removed from ${str}.",
            upperFunc: "${functionName}: Returns a string where all characters in ${str} are converted to uppercase.",
            current_dateFunc: "${functionName}: Returns the current date.",
            current_timeFunc: "${functionName}: Returns the current time (hours, minutes, seconds).",
            current_timestampFunc: "${functionName}: Returns the current time (hours, minutes, seconds, milliseconds)."
        },
        colorPicker: {
            transparency: "Transparency",
            recent: "Recent",
            brightsTooltip: "Brights",
            pastelsTooltip: "Pastels",
            paletteTooltip: "Select a color.",
            noColorTooltip: "No color",
            hexInputTooltip: "A custom color in hexadecimal notation (#FFFF00)."
        },
        visibleScaleRangeSlider: {
            noLimit: "No Limit",
            preview: "Preview",
            currentScaleTooltip: "Current map scale (${scaleLabel})",
            suggestedVisibleRangeTooltip: "Suggested visible range",
            customScaleInputTooltip: "Type in a scale.",
            scaleRangeLabels: {
                world: "World",
                continent: "Continent",
                countries: "Countries",
                country: "Country",
                states: "States",
                state: "State",
                counties: "Counties",
                county: "County",
                metropolitanArea: "Metropolitan Area",
                cities: "Cities",
                city: "City",
                town: "Town",
                neighborhood: "Neighborhood",
                streets: "Streets",
                street: "Street",
                buildings: "Buildings",
                building: "Building",
                smallBuilding: "Small Building",
                rooms: "Rooms",
                room: "Room"
            },
            featuredScaleLabels: {
                current: "Current Map View (${scaleLabel})",
                world: "World (${scaleLabel})",
                continent: "Continent (${scaleLabel})",
                countriesBig: "Countries - Big (${scaleLabel})",
                countriesSmall: "Countries - Small (${scaleLabel})",
                statesProvinces: "States / Provinces (${scaleLabel})",
                stateProvince: "State/Province (${scaleLabel})",
                counties: "Counties (${scaleLabel})",
                county: "County (${scaleLabel})",
                metropolitanArea: "Metropolitan Area (${scaleLabel})",
                cities: "Cities (${scaleLabel})",
                city: "City (${scaleLabel})",
                town: "Town (${scaleLabel})",
                neighborhood: "Neighborhood (${scaleLabel})",
                streets: "Streets (${scaleLabel})",
                street: "Street (${scaleLabel})",
                buildings: "Buildings (${scaleLabel})",
                building: "Building (${scaleLabel})"
            }
        },
        symbolEditor: {
            preview: "Preview",
            shape: "Shape",
            fill: "Fill",
            outline: "Outline",
            px: "px",
            symbolSize: "Symbol Size",
            symbolSizeTooltip: "Set symbol size from ${min} to ${max} pixels.",
            useImage: "Use an Image",
            useImageTooltip: "Use a custom image.",
            imageUrlInputTooltip: "For best results, the image should be no greater than 120 pixels wide by 120 pixels high. Other sizes will be adjusted to fit. Acceptable image formats are: PNG, GIF and JPEG.",
            selectCategoryTooltip: "Select a category.",
            imageLoadError: "Unable to load image.",
            symbolLoadError: "Unable to load symbols.",
            noFillTooltip: "No fill",
            symbolTransparencyTooltip: "Symbol transparency",
            lineWidth: "Line Width",
            lineWidthTooltip: "Set a line width from ${min} to ${max} pixels.",
            pattern: "Pattern",
            patternTooltip: "Line type",
            flipColors: "Flip Colors",
            flipColorsTooltip: "Invert color ramp.",
            noOutlineTooltip: "No outline",
            saturation: "Saturation",
            saturationTooltip: "Adjust color intensity.",
            selectRampTooltip: "Select a color ramp."
        },
        smartStyling: {
            others: "Others"
        }
    },
    ar: 1,
    cs: 1,
    da: 1,
    de: 1,
    es: 1,
    et: 1,
    fi: 1,
    fr: 1,
    he: 1,
    it: 1,
    ja: 1,
    ko: 1,
    lv: 1,
    lt: 1,
    nl: 1,
    nb: 1,
    pl: 1,
    "pt-br": 1,
    "pt-pt": 1,
    ro: 1,
    ru: 1,
    sv: 1,
    th: 1,
    tr: 1,
    vi: 1,
    "zh-cn": 1
});
},
'esri/deferredUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "./kernel"], function(g, h, k) {
    return {
        _dfdCanceller: function(a) {
            a.canceled = !0;
            var b = a._pendingDfd; - 1 === a.fired && (b && -1 === b.fired) && b.cancel();
            a._pendingDfd = null
        },
        _fixDfd: function(a) {
            var b = a.then;
            a.then = function(a, c, f) {
                if (a) {
                    var d = a;
                    a = function(a) {
                        return a && a._argsArray ? d.apply(null, a) : d(a)
                    }
                }
                return b.call(this, a, c, f)
            };
            return a
        },
        _resDfd: function(a, b, e) {
            var c = b.length;
            1 === c ? e ? a.errback(b[0]) : a.callback(b[0]) : 1 < c ? (b._argsArray = !0, a.callback(b)) : a.callback()
        }
    }
});
},
'esri/SpatialReference':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "./kernel", "./lang"], function(g, f, e, c, d, h) {
    c = [-2.0037508342788905E7, 2.0037508342788905E7];
    d = [-2.0037508342787E7, 2.0037508342787E7];
    return g(null, {
        declaredClass: "esri.SpatialReference",
        constructor: function(a) {
            a && (e.isObject(a) ? e.mixin(this, a) : e.isString(a) ? this.wkt = a : this.wkid = a)
        },
        wkid: null,
        wkt: null,
        _info: {
            102113: {
                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
                valid: c,
                origin: d,
                dx: 1E-5
            },
            102100: {
                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
                valid: c,
                origin: d,
                dx: 1E-5
            },
            3785: {
                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
                valid: c,
                origin: d,
                dx: 1E-5
            },
            3857: {
                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
                valid: c,
                origin: d,
                dx: 1E-5
            },
            4326: {
                wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",${Central_Meridian}],UNIT["Degree",0.0174532925199433]]',
                altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${Central_Meridian}],UNIT["Degrees",111319.491]]',
                valid: [-180, 180],
                origin: [-180, 180],
                dx: 1E-5
            }
        },
        _isWebMercator: function() {
            return -1 !== f.indexOf([102113, 102100, 3857, 3785], this.wkid)
        },
        _isWrappable: function() {
            return -1 !== f.indexOf([102113, 102100, 3857, 3785, 4326], this.wkid)
        },
        _getInfo: function() {
            return this.wkid ? this._info[this.wkid] : null
        },
        _canProject: function(a) {
            var b = !1;
            a && (b = this.isWebMercator() && 4326 === a.wkid || a.isWebMercator() && 4326 === this.wkid);
            return b
        },
        isWebMercator: function() {
            return this._isWebMercator()
        },
        equals: function(a) {
            var b = !1;
            a && (this === a &&
                (b = !0), this.wkid || a.wkid ? b = this.wkid === a.wkid || this.isWebMercator() && a.isWebMercator() || this.wkid === a.latestWkid || a.wkid === this.latestWkid : this.wkt && a.wkt && (b = this.wkt.toUpperCase() === a.wkt.toUpperCase()));
            return b
        },
        toJson: function() {
            var a = null,
                b = h.isDefined;
            b(this.wkid) ? a = {
                wkid: this.wkid
            } : b(this.wkt) && (a = {
                wkt: this.wkt
            });
            a && b(this.latestWkid) && (a.latestWkid = this.latestWkid);
            return a
        }
    })
});
},
'esri/map':function(){
//>>built
define(["require", "dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/event", "dojo/on", "dojo/aspect", "dojo/dom", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dijit/registry", "./kernel", "./config", "./sniff", "./lang", "./_coremap", "./MapNavigationManager"], function(v, K, L, A, p, r, B, C, M, D, g, E, N, O, P, w, F, h, s, Q, R) {
    var x = {
            up: "panUp",
            right: "panRight",
            down: "panDown",
            left: "panLeft"
        },
        G = {
            upperRight: "panUpperRight",
            lowerRight: "panLowerRight",
            lowerLeft: "panLowerLeft",
            upperLeft: "panUpperLeft"
        },
        e = A.connect,
        l = A.disconnect,
        m = E.create,
        q = O.set,
        y = p.hitch,
        t = N.getMarginBox,
        H = K.deprecated,
        z = p.mixin,
        I = 0;
    return L(Q, {
        declaredClass: "esri.Map",
        constructor: function(a, c) {
            z(this, {
                _slider: null,
                _navDiv: null,
                _mapParams: z({
                    attributionWidth: 0.45,
                    slider: !0,
                    nav: !1,
                    logo: !0,
                    sliderStyle: "small",
                    sliderPosition: "top-left",
                    sliderOrientation: "vertical",
                    autoResize: !0
                }, c || {})
            });
            z(this, {
                isDoubleClickZoom: !1,
                isShiftDoubleClickZoom: !1,
                isClickRecenter: !1,
                isScrollWheelZoom: !1,
                isPan: !1,
                isRubberBandZoom: !1,
                isKeyboardNavigation: !1,
                isPanArrows: !1,
                isZoomSlider: !1
            });
            p.isFunction(w._css) && (w._css = w._css(this._mapParams.force3DTransforms), this.force3DTransforms = this._mapParams.force3DTransforms);
            var b = h("esri-transforms") && h("esri-transitions");
            this.navigationMode = this._mapParams.navigationMode || b && "css-transforms" || "classic";
            "css-transforms" === this.navigationMode && !b && (this.navigationMode = "classic");
            this.fadeOnZoom = s.isDefined(this._mapParams.fadeOnZoom) ? this._mapParams.fadeOnZoom : "css-transforms" === this.navigationMode;
            "css-transforms" !== this.navigationMode && (this.fadeOnZoom = !1);
            this.setMapCursor("default");
            this.smartNavigation = c && c.smartNavigation;
            if (!s.isDefined(this.smartNavigation) && h("mac") && !h("esri-touch") && !h("esri-pointer") && !(3.5 >= h("ff"))) {
                var d = navigator.userAgent.match(/Mac\s+OS\s+X\s+([\d]+)(\.|\_)([\d]+)\D/i);
                d && (s.isDefined(d[1]) && s.isDefined(d[3])) && (b = parseInt(d[1], 10), d = parseInt(d[3], 10), this.smartNavigation = 10 < b || 10 === b && 6 <= d)
            }
            this.showAttribution = s.isDefined(this._mapParams.showAttribution) ?
                this._mapParams.showAttribution : !0;
            this._onLoadHandler_connect = e(this, "onLoad", this, "_onLoadInitNavsHandler");
            var k = m("div", {
                "class": "esriControlsBR" + (this._mapParams.nav ? " withPanArrows" : "")
            }, this.root);
            if (this.showAttribution)
                if (b = p.getObject("esri.dijit.Attribution", !1)) this._initAttribution(b, k);
                else {
                    var J = I++,
                        f = this;
                    this._rids && this._rids.push(J);
                    v(["./dijit/Attribution"], function(a) {
                        var b = f._rids ? r.indexOf(f._rids, J) : -1; - 1 !== b && (f._rids.splice(b, 1), f._initAttribution(a, k))
                    })
                }
            this._mapParams.logo &&
                (b = {}, 6 === h("ie") && (b.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled\x3d'true', sizingMethod\x3d'crop', src\x3d'" + v.toUrl("./images/map/logo-med.png") + "')"), this._ogol = m("div", {
                    style: b
                }, k), this._setLogoSize(), this._onMapResizeLogo_connect = e(this, "onResize", this, "_setLogoSize"), h("esri-touch") || (this._ogol_connect = e(this._ogol, "onclick", this, "_openLogoLink")));
            this.navigationManager = new R(this);
            c && c.basemap && (this._onLoadFix = !0, this.setBasemap(c.basemap), this._onLoadFix = !1);
            if (this.autoResize =
                this._mapParams.autoResize) b = this._getEnclosingResizableWidget(this.container) || window, d = y(this, this.resize), this._rszSignal = C.pausable(b, "resize", d), this._oriSignal = C.pausable(window, "orientationchange", d), M.after(b, "resize", d, !0)
        },
        _getEnclosingResizableWidget: function(a) {
            var c = P.getEnclosingWidget(a);
            return !c ? c : c.resize ? c : this._getEnclosingResizableWidget(a.parentNode)
        },
        _setLogoSize: function() {
            this._ogol && (25E4 > this.root.clientWidth * this.root.clientHeight ? (g.remove(this._ogol, "logo-med"), g.add(this._ogol,
                "logo-sm")) : (g.remove(this._ogol, "logo-sm"), g.add(this._ogol, "logo-med")))
        },
        _initAttribution: function(a, c) {
            var b = m("span", {
                "class": "esriAttribution"
            }, c, "first");
            q(b, "maxWidth", Math.floor(this.width * this._mapParams.attributionWidth) + "px");
            this._connects.push(e(b, "onclick", function() {
                g.contains(this, "esriAttributionOpen") ? g.remove(this, "esriAttributionOpen") : this.scrollWidth > this.clientWidth && g.add(this, "esriAttributionOpen")
            }));
            this.attribution = new a({
                map: this
            }, b)
        },
        _cleanUp: function() {
            this.disableMapNavigation();
            this.navigationManager.destroy();
            var a = this._slider;
            a && (a.destroy && !a._destroyed) && a.destroy();
            var a = this._navDiv,
                c = this.attribution;
            a && E.destroy(a);
            c && c.destroy();
            this._connects.push(this._slider_connect, this._ogol_connect, this._rszSignal, this._oriSignal);
            r.forEach(this._connects, l);
            this.attribution = this.navigationManager = this._rids = this._connects = this._slider_connect = this._ogol_connect = this._rszSignal = this._oriSignal = null;
            this.inherited("_cleanUp", arguments)
        },
        _isPanningOrZooming: function() {
            return this.__panning ||
                this.__zooming
        },
        _canZoom: function(a) {
            var c = this.getLevel();
            return !this.__tileInfo || !(c === this.getMinZoom() && 0 > a || c === this.getMaxZoom() && 0 < a)
        },
        _onLoadInitNavsHandler: function() {
            this.enableMapNavigation();
            this._createNav();
            if ("small" === this._mapParams.sliderStyle || !this._createSlider) this._createSimpleSlider();
            else if (this._mapParams.slider) {
                var a = -1 !== this._getSliderClass(!0).indexOf("Horizontal"),
                    a = [a ? "dijit.form.HorizontalSlider" : "dijit.form.VerticalSlider", a ? "dijit.form.HorizontalRule" : "dijit.form.VerticalRule",
                        a ? "dijit.form.HorizontalRuleLabels" : "dijit.form.VerticalRuleLabels"
                    ];
                if (r.some(a, function(a) {
                        return !p.getObject(a, !1)
                    })) {
                    var a = r.map(a, function(a) {
                            return a.replace(/\./g, "/")
                        }),
                        c = I++,
                        b = this;
                    this._rids && this._rids.push(c);
                    v(a, function() {
                        var a = b._rids ? r.indexOf(b._rids, c) : -1; - 1 !== a && (b._rids.splice(a, 1), b._createSlider.apply(b, arguments))
                    })
                } else a = r.map(a, function(a) {
                    return p.getObject(a, !1)
                }), this._createSlider.apply(this, a)
            }
            l(this._onLoadHandler_connect)
        },
        _createNav: function() {
            if (this._mapParams.nav) {
                var a,
                    c, b, d = g.add,
                    k = this.id;
                this._navDiv = m("div", {
                    id: k + "_navdiv"
                }, this.root);
                d(this._navDiv, "navDiv");
                var h = this.width / 2,
                    f = this.height / 2,
                    n;
                for (b in x) c = x[b], a = m("div", {
                    id: k + "_pan_" + b
                }, this._navDiv), d(a, "fixedPan " + c), "up" === b || "down" === b ? (n = parseInt(t(a).w, 10) / 2, q(a, {
                    left: h - n + "px",
                    zIndex: 30
                })) : (n = parseInt(t(a).h, 10) / 2, q(a, {
                    top: f - n + "px",
                    zIndex: 30
                })), this._connects.push(e(a, "onclick", y(this, this[c])));
                this._onMapResizeNavHandler_connect = e(this, "onResize", this, "_onMapResizeNavHandler");
                for (b in G) c = G[b], a =
                    m("div", {
                        id: k + "_pan_" + b,
                        style: {
                            zIndex: 30
                        }
                    }, this._navDiv), d(a, "fixedPan " + c), this._connects.push(e(a, "onclick", y(this, this[c])));
                this.isPanArrows = !0
            }
        },
        _onMapResizeNavHandler: function(a, c, b) {
            a = this.id;
            c /= 2;
            b /= 2;
            var d = D.byId,
                k, e, f;
            for (k in x) e = d(a + "_pan_" + k), "up" === k || "down" === k ? (f = parseInt(t(e).w, 10) / 2, q(e, "left", c - f + "px")) : (f = parseInt(t(e).h, 10) / 2, q(e, "top", b - f + "px"))
        },
        _createSimpleSlider: function() {
            if (this._mapParams.slider) {
                var a = this._slider = m("div", {
                        id: this.id + "_zoom_slider",
                        "class": this._getSliderClass(),
                        style: {
                            zIndex: 30
                        }
                    }),
                    c = h("esri-touch") && !h("ff") ? "touchstart" : h("esri-pointer") ? navigator.msPointerEnabled ? "MSPointerDown" : "pointerdown" : "onclick",
                    b = m("div", {
                        "class": "esriSimpleSliderIncrementButton"
                    }, a),
                    d = m("div", {
                        "class": "esriSimpleSliderDecrementButton"
                    }, a);
                this._incButton = b;
                this._decButton = d;
                this._simpleSliderZoomHandler(null, null, null, this.getLevel());
                b.innerHTML = "\x3cspan\x3e+\x3c/span\x3e";
                d.innerHTML = "\x3cspan\x3e\x26ndash;\x3c/span\x3e";
                8 > h("ie") && g.add(d, "dj_ie67Fix");
                this._connects.push(e(b,
                    c, this, this._simpleSliderChangeHandler));
                this._connects.push(e(d, c, this, this._simpleSliderChangeHandler));
                "touchstart" == c && (this._connects.push(e(b, "onclick", this, this._simpleSliderChangeHandler)), this._connects.push(e(d, "onclick", this, this._simpleSliderChangeHandler)));
                (-1 < this.getMaxZoom() || -1 < this.getMinZoom()) && this._connects.push(e(this, "onZoomEnd", this, this._simpleSliderZoomHandler));
                10 > h("ie") && D.setSelectable(a, !1);
                this.root.appendChild(a);
                this.isZoomSlider = !0
            }
        },
        _simpleSliderChangeHandler: function(a) {
            B.stop(a);
            a = -1 !== a.currentTarget.className.indexOf("IncrementButton") ? !0 : !1;
            this._extentUtil({
                numLevels: a ? 1 : -1
            })
        },
        _simpleSliderZoomHandler: function(a, c, b, d) {
            var e;
            a = this._incButton;
            c = this._decButton; - 1 < d && d === this.getMaxZoom() ? e = a : -1 < d && d === this.getMinZoom() && (e = c);
            e ? (g.add(e, "esriSimpleSliderDisabledButton"), g.remove(e === a ? c : a, "esriSimpleSliderDisabledButton")) : (g.remove(a, "esriSimpleSliderDisabledButton"), g.remove(c, "esriSimpleSliderDisabledButton"))
        },
        _getSliderClass: function(a) {
            a = a ? "Large" : "Simple";
            var c =
                this._mapParams.sliderOrientation,
                b = this._mapParams.sliderPosition || "",
                c = c && "horizontal" === c.toLowerCase() ? "esri" + a + "SliderHorizontal" : "esri" + a + "SliderVertical";
            if (b) switch (b.toLowerCase()) {
                case "top-left":
                    b = "esri" + a + "SliderTL";
                    break;
                case "top-right":
                    b = "esri" + a + "SliderTR";
                    break;
                case "bottom-left":
                    b = "esri" + a + "SliderBL";
                    break;
                case "bottom-right":
                    b = "esri" + a + "SliderBR"
            }
            return "esri" + a + "Slider " + c + " " + b
        },
        _createSlider: function(a, c, b) {
            if (this._mapParams.slider) {
                var d = m("div", {
                            id: this.id + "_zoom_slider"
                        },
                        this.root),
                    k = F.defaults.map,
                    g = this._getSliderClass(!0),
                    f = -1 !== g.indexOf("Horizontal"),
                    n = this.getNumLevels();
                if (0 < n) {
                    var l, p, u = this._mapParams.sliderLabels,
                        s = !!u;
                    if (k = !1 !== u) {
                        var t = f ? "bottomDecoration" : "rightDecoration";
                        if (!u) {
                            u = [];
                            for (f = 0; f < n; f++) u[f] = ""
                        }
                        r.forEach([{
                            "class": "esriLargeSliderTicks",
                            container: t,
                            count: n,
                            dijitClass: c
                        }, {
                            "class": s && "esriLargeSliderLabels",
                            container: t,
                            count: n,
                            labels: u,
                            dijitClass: b
                        }], function(a) {
                            var b = m("div"),
                                e = a.dijitClass;
                            delete a.dijitClass;
                            d.appendChild(b);
                            e === c ? l = new e(a,
                                b) : p = new e(a, b)
                        })
                    }
                    a = this._slider = new a({
                        id: d.id,
                        "class": g,
                        minimum: this.getMinZoom(),
                        maximum: this.getMaxZoom(),
                        discreteValues: n,
                        value: this.getLevel(),
                        clickSelect: !0,
                        intermediateChanges: !0,
                        style: "z-index:30;"
                    }, d);
                    a.startup();
                    k && (l.startup(), p.startup());
                    this._slider_connect = e(a, "onChange", this, "_onSliderChangeHandler");
                    this._connects.push(e(this, "onExtentChange", this, "_onExtentChangeSliderHandler"));
                    this._connects.push(e(a._movable, "onFirstMove", this, "_onSliderMoveStartHandler"))
                } else {
                    a = this._slider =
                        new a({
                            id: d.id,
                            "class": g,
                            minimum: 0,
                            maximum: 2,
                            discreteValues: 3,
                            value: 1,
                            clickSelect: !0,
                            intermediateChanges: k.sliderChangeImmediate,
                            style: "height:50px; z-index:30;"
                        }, d);
                    b = a.domNode.firstChild.childNodes;
                    for (f = 1; 3 >= f; f++) q(b[f], "visibility", "hidden");
                    a.startup();
                    this._slider_connect = e(a, "onChange", this, "_onDynSliderChangeHandler");
                    this._connects.push(e(this, "onExtentChange", this, "_onExtentChangeDynSliderHandler"))
                }
                b = a.decrementButton;
                a.incrementButton.style.outline = "none";
                b.style.outline = "none";
                a.sliderHandle.style.outline =
                    "none";
                a._onKeyPress = function() {};
                if (a = a._movable) {
                    var v = a.onMouseDown;
                    a.onMouseDown = function(a) {
                        9 > h("ie") && 1 !== a.button || v.apply(this, arguments)
                    }
                }
                this.isZoomSlider = !0
            }
        },
        _onSliderMoveStartHandler: function() {
            l(this._slider_connect);
            l(this._slidermovestop_connect);
            this._slider_connect = e(this._slider, "onChange", this, "_onSliderChangeDragHandler");
            this._slidermovestop_connect = e(this._slider._movable, "onMoveStop", this, "_onSliderMoveEndHandler")
        },
        _onSliderChangeDragHandler: function(a) {
            this._extentUtil({
                targetLevel: a
            })
        },
        _onSliderMoveEndHandler: function() {
            l(this._slider_connect);
            l(this._slidermovestop_connect)
        },
        _onSliderChangeHandler: function(a) {
            this.setLevel(a)
        },
        _updateSliderValue: function(a, c) {
            l(this._slider_connect);
            var b = this._slider,
                d = b._onChangeActive;
            b._onChangeActive = !1;
            b.set("value", a);
            b._onChangeActive = d;
            this._slider_connect = e(b, "onChange", this, c)
        },
        _onExtentChangeSliderHandler: function(a, c, b, d) {
            l(this._slidermovestop_connect);
            this._updateSliderValue(d.level, "_onSliderChangeHandler")
        },
        _onDynSliderChangeHandler: function(a) {
            this._extentUtil({
                numLevels: 0 <
                    a ? 1 : -1
            })
        },
        _onExtentChangeDynSliderHandler: function() {
            this._updateSliderValue(1, "_onDynSliderChangeHandler")
        },
        _openLogoLink: function(a) {
            window.open(F.defaults.map.logoLink, "_blank");
            B.stop(a)
        },
        enableMapNavigation: function() {
            this.navigationManager.enableNavigation()
        },
        disableMapNavigation: function() {
            this.navigationManager.disableNavigation()
        },
        enableDoubleClickZoom: function() {
            this.isDoubleClickZoom || (this.navigationManager.enableDoubleClickZoom(), this.isDoubleClickZoom = !0)
        },
        disableDoubleClickZoom: function() {
            this.isDoubleClickZoom &&
                (this.navigationManager.disableDoubleClickZoom(), this.isDoubleClickZoom = !1)
        },
        enableShiftDoubleClickZoom: function() {
            this.isShiftDoubleClickZoom || (H(this.declaredClass + ": Map.(enable/disable)ShiftDoubleClickZoom deprecated. Shift-Double-Click zoom behavior will not be supported.", null, "v2.0"), this.navigationManager.enableShiftDoubleClickZoom(), this.isShiftDoubleClickZoom = !0)
        },
        disableShiftDoubleClickZoom: function() {
            this.isShiftDoubleClickZoom && (H(this.declaredClass + ": Map.(enable/disable)ShiftDoubleClickZoom deprecated. Shift-Double-Click zoom behavior will not be supported.",
                null, "v2.0"), this.navigationManager.disableShiftDoubleClickZoom(), this.isShiftDoubleClickZoom = !1)
        },
        enableClickRecenter: function() {
            this.isClickRecenter || (this.navigationManager.enableClickRecenter(), this.isClickRecenter = !0)
        },
        disableClickRecenter: function() {
            this.isClickRecenter && (this.navigationManager.disableClickRecenter(), this.isClickRecenter = !1)
        },
        enablePan: function() {
            this.isPan || (this.navigationManager.enablePan(), this.isPan = !0)
        },
        disablePan: function() {
            this.isPan && (this.navigationManager.disablePan(),
                this.isPan = !1)
        },
        enableRubberBandZoom: function() {
            this.isRubberBandZoom || (this.navigationManager.enableRubberBandZoom(), this.isRubberBandZoom = !0)
        },
        disableRubberBandZoom: function() {
            this.isRubberBandZoom && (this.navigationManager.disableRubberBandZoom(), this.isRubberBandZoom = !1)
        },
        enableKeyboardNavigation: function() {
            this.isKeyboardNavigation || (this.navigationManager.enableKeyboardNavigation(), this.isKeyboardNavigation = !0)
        },
        disableKeyboardNavigation: function() {
            this.isKeyboardNavigation && (this.navigationManager.disableKeyboardNavigation(),
                this.isKeyboardNavigation = !1)
        },
        enableScrollWheelZoom: function() {
            this.isScrollWheelZoom || (this.navigationManager.enableScrollWheelZoom(), this.isScrollWheelZoom = !0)
        },
        disableScrollWheelZoom: function() {
            this.isScrollWheelZoom && (this.navigationManager.disableScrollWheelZoom(), this.isScrollWheelZoom = !1)
        },
        showPanArrows: function() {
            this._navDiv && (this._navDiv.style.display = "block", this.isPanArrows = !0)
        },
        hidePanArrows: function() {
            this._navDiv && (this._navDiv.style.display = "none", this.isPanArrows = !1)
        },
        showZoomSlider: function() {
            this._slider &&
                (q(this._slider.domNode || this._slider, "visibility", "visible"), this.isZoomSlider = !0)
        },
        hideZoomSlider: function() {
            this._slider && (q(this._slider.domNode || this._slider, "visibility", "hidden"), this.isZoomSlider = !1)
        }
    })
});
},
'esri/_coremap':function(){
//>>built
define(["require", "module", "dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/Deferred", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/event", "dojo/_base/unload", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/sniff", "dijit/registry", "dojox/gfx/matrix", "./kernel", "./config", "./basemaps", "./lang", "./Evented", "./fx", "./deferredUtils", "./tileUtils", "./PluginTarget", "./geometry/Point", "./geometry/ScreenPoint", "./geometry/Extent", "./geometry/Rect", "./geometry/mathUtils", "./geometry/scaleUtils", "./geometry/screenUtils", "./geometry/webMercatorUtils", "./layers/GraphicsLayer", "./layers/TileInfo", "./layers/LOD", "./layers/ArcGISTiledMapServiceLayer", "./layers/OpenStreetMapLayer", "./dijit/Popup", "./plugins/popupManager", "dojo/uacss"], function(P, ia, ja, ka, z, aa, H, m, Aa, la, ma, na, X, Q, U, V, R, oa, pa, Ba, qa, D, t, ra, ba, sa, ca, ta, M, C, A, N, ua, G, da, Y, E, va, wa, xa, ea, ya) {
    function fa(a, b) {
        var c = a.lods;
        c.sort(function(a, b) {
            return a.scale > b.scale ? -1 : a.scale < b.scale ? 1 : 0
        });
        var d = [],
            c = m.filter(c, function(a) {
                if (-1 === I(d, a.scale)) return d.push(a.scale), !0
            }),
            e = b.lods = [],
            f;
        m.forEach(c, function(a, b) {
            f = e[b] = new wa(a);
            f.level = b
        });
        b.tileInfo = new va(S(a, {
            lods: e
        }))
    }
    var Z, T = da.toMapPoint,
        $ = da.toScreenPoint,
        W = z.connect,
        O = z.disconnect,
        x = H.hitch,
        B = V.set,
        I = m.indexOf,
        S =
        H.mixin,
        ga = 0,
        J = qa.defaults.map,
        za = function() {};
    return ka([ra, ta], {
        declaredClass: "esri._CoreMap",
        resizeDelay: 300,
        invalidExtent: "Map does not have a valid extent.",
        invalidGeometry: "Geometry (wkid: ${geometry}) cannot be converted to spatial reference of the map (wkid: ${map})",
        unknownBasemap: 'Unable to find basemap definition for: "${basemapName}". Try one of these: ${list}',
        invalidBasemap: 'Unable to add basemap: "${basemapName}".',
        unknownLayerType: 'Unknown basemap layer type: "${type}" found in basemap definition for: "${basemapName}".',
        visible: !0,
        _eventMap: {
            "basemap-change": !0,
            "extent-change": ["extent", "delta", "levelChange", "lod"],
            "layer-add": ["layer"],
            "layer-add-result": ["layer", "error"],
            "layer-remove": ["layer"],
            "layer-reorder": ["layer", "index"],
            "layer-resume": ["layer"],
            "layer-suspend": ["layer"],
            "layers-add-result": ["layers"],
            "layers-removed": !0,
            "layers-reordered": ["layerIds"],
            load: ["map"],
            pan: ["extent", "delta"],
            "pan-end": ["extent", "delta"],
            "pan-start": ["extent", "screenPoint"],
            reposition: ["x", "y"],
            resize: ["extent", "width", "height"],
            scale: ["matrix", "immediate"],
            "time-extent-change": ["timeExtent"],
            "before-unload": ["map"],
            unload: ["map"],
            "update-end": ["error"],
            "update-start": !0,
            zoom: ["extent", "zoomFactor", "anchor"],
            "zoom-end": ["extent", "zoomFactor", "anchor", "level"],
            "zoom-start": ["extent", "zoomFactor", "anchor", "level"],
            click: !0,
            "dbl-click": !0,
            "key-down": !0,
            "key-up": !0,
            "mouse-down": !0,
            "mouse-drag": !0,
            "mouse-drag-end": !0,
            "mouse-drag-start": !0,
            "mouse-move": !0,
            "mouse-out": !0,
            "mouse-over": !0,
            "mouse-up": !0,
            "mouse-wheel": !0,
            "basic-tap": !0,
            "double-tap": !0,
            "pinch-end": !0,
            "pinch-move": !0,
            "pinch-start": !0,
            "processed-double-tap": !0,
            "processed-tap": !0,
            "swipe-end": !0,
            "swipe-move": !0,
            "swipe-start": !0,
            tap: !0,
            "two-finger-tap": !0
        },
        constructor: function(a, b) {
            var c = this;
            this.registerConnectEvents();
            S(this, {
                _internalLayerIds: [],
                _layers: [],
                _layerDivs: [],
                _layerSize: 0,
                _connects: [],
                _zoomAnimDiv: null,
                _zoomAnim: null,
                _layersDiv: null,
                _firstLayerId: null,
                _delta: null,
                _cursor: null,
                _ratioW: 1,
                _ratioH: 1,
                _params: null,
                cursor: null,
                layerIds: [],
                graphicsLayerIds: [],
                graphics: null,
                _labels: null,
                loaded: !1,
                __panning: !1,
                __zooming: !1,
                __container: null,
                root: null,
                __LOD: null,
                __tileInfo: null,
                __visibleRect: null,
                __visibleDelta: null,
                _rids: []
            });
            var d = this.container = ma.byId(a),
                e = this.id = na.get(d, "id") || oa.getUniqueId(this.declaredClass);
            X.add(d, "map");
            var f = U.getContentBox(d),
                g = X.add,
                h = Q.create;
            this.position = new C(0, 0);
            this._reposition();
            var k = this.width = f.w || J.width,
                l = this.height = f.h || J.height;
            0 === f.w && B(d, "width", k + "px");
            0 === f.h && B(d, "height", l + "px");
            var u = this.root = h("div", {
                id: e + "_root",
                style: {
                    width: k + "px",
                    height: l + "px",
                    direction: "ltr"
                }
            });
            g(u, "container");
            f = this.__container = h("div", {
                id: e + "_container"
            }, u);
            B(f, "position", "absolute");
            g(f, "container");
            d.appendChild(u);
            d = this._params = S({
                slider: !0,
                nav: !1,
                zoom: -1,
                minZoom: -1,
                maxZoom: -1,
                scale: -1,
                minScale: 0,
                maxScale: 0,
                showInfoWindowOnClick: !0,
                displayGraphicsOnPan: !0,
                wrapAround180: !0,
                fitExtent: !1,
                optimizePanAnimation: !0
            }, b || {});
            this.wrapAround180 = d.wrapAround180;
            this.optimizePanAnimation = d.optimizePanAnimation;
            t.isDefined(d.resizeDelay) &&
                (this.resizeDelay = d.resizeDelay);
            d.lods && (fa({
                rows: 512,
                cols: 512,
                dpi: 96,
                format: "JPEG",
                compressionQuality: 75,
                origin: {
                    x: -180,
                    y: 90
                },
                spatialReference: {
                    wkid: 4326
                },
                lods: d.lods
            }, d), this.__tileInfo = d.tileInfo);
            this.extent = d.extent;
            this._extentUtil({
                mapCenter: d.center,
                targetLevel: d.zoom,
                targetScale: d.scale
            });
            this.__visibleRect = new N(0, 0, k, l);
            this.__visibleDelta = new N(0, 0, k, l);
            e = this._layersDiv = h("div", {
                id: e + "_layers"
            });
            g(e, "layersDiv");
            f.appendChild(e);
            this._zoomAnimDiv = h("div", {
                style: {
                    position: "absolute"
                }
            });
            d.infoWindow ? this.infoWindow = d.infoWindow : (g = this.infoWindow = new ya(d.popupOptions, h("div")), g.startup(), g._ootb = !0, B(g.domNode, "zIndex", 40));
            d.showLabels && (P(["./layers/LabelLayer"], function(a) {
                Z = a;
                c._createLabelLayer()
            }), this.on("load", function() {
                c._createLabelLayer()
            }));
            this.addPlugin(this._getAbsMid("./plugins/popupManager"), {
                enabled: d.showInfoWindowOnClick
            });
            this._zoomStartHandler = x(this, this._zoomStartHandler);
            this._zoomingHandler = x(this, this._zoomingHandler);
            this._zoomEndHandler = x(this, this._zoomEndHandler);
            this._panningHandler = x(this, this._panningHandler);
            this._panEndHandler = x(this, this._panEndHandler);
            this._endTranslate = x(this, this._endTranslate);
            la.addOnWindowUnload(this, this.destroy)
        },
        _getAbsMid: function(a) {
            return P.toAbsMid ? P.toAbsMid(a) : ia.id.replace(/\/[^\/]*$/ig, "/") + a
        },
        _cleanUp: function() {
            var a = this.infoWindow;
            a && (a._ootb && a.destroy ? a.destroy() : a.unsetMap(this), delete this.infoWindow);
            O(this._tsTimeExtentChange_connect);
            this.removePlugin("./plugins/popupManager");
            Q.destroy(this.root);
            this.root =
                null
        },
        _addLayer: function(a, b, c) {
            var d = a.id = a.id || (a instanceof E ? J.graphicsLayerNamePrefix : J.layerNamePrefix) + ga++;
            this._layers[d] = a;
            var e, f;
            if (b === this.layerIds || b === this.graphicsLayerIds) e = this._layerSize, this._layerSize++;
            a._isRefLayer = "top" === c;
            c = !t.isDefined(c) || 0 > c || c > b.length || "top" === c ? b.length : c;
            0 === e && (this._firstLayerId = d);
            if (!a._isRefLayer)
                for (;
                    (f = this.getLayer(b[c - 1])) && f._isRefLayer;) c--;
            b.splice(c, 0, d);
            var g = x(this, this._addLayerHandler),
                h = this;
            c = this._connects;
            f = function() {
                a.loaded ?
                    h._onLoadFix ? (h._onLoadFix = !1, setTimeout(function() {
                        g(a)
                    }, 0)) : g(a) : (h[d + "_addtoken_load"] = W(a, "onLoad", h, "_addLayerHandler"), h[d + "_addtoken_err"] = W(a, "onError", h, function(c) {
                        g(a, c, b)
                    }))
            };
            this.loaded || 0 === e || a.loaded && -1 === I(this.graphicsLayerIds, d) ? f() : c.push(W(this, "onLoad", f));
            return a
        },
        _addLayerHandler: function(a, b, c) {
            var d = this.id,
                e = a.id,
                f = I(a instanceof E ? this.graphicsLayerIds : this.layerIds, e),
                g = f,
                h = !1,
                k = this._params;
            O(this[e + "_addtoken_load"]);
            O(this[e + "_addtoken_err"]);
            if (b) delete this._layers[e], -1 !== f && (c.splice(f, 1), this.onLayerAddResult(a, b));
            else {
                -1 === f && (f = I(this._internalLayerIds, e), g = 20 + f, h = !0);
                if (e === this._firstLayerId) {
                    b = a.spatialReference;
                    if ((c = this.extent && this.extent.spatialReference) && !c.equals(b) && (a.tileInfo || !a.url)) c = null;
                    c = this.spatialReference = c || b;
                    this.wrapAround180 = this.wrapAround180 && c && c._isWrappable() ? !0 : !1;
                    a.tileInfo && (this.__tileInfo ? (b = this.__tileInfo.lods, this.__tileInfo = S({}, a.tileInfo), this.__tileInfo.lods = b) : (fa(S({}, a.tileInfo), k), this.__tileInfo = k.tileInfo));
                    if (this.wrapAround180) {
                        b = this.__tileInfo;
                        c = c._getInfo();
                        if (!b || Math.abs(c.origin[0] - b.origin.x) > c.dx) this.wrapAround180 = !1;
                        this.wrapAround180 && b && ca._addFrameInfo(b, c)
                    }
                    k.units = a.units;
                    if ((b = this.__tileInfo && this.__tileInfo.lods) && b.length) {
                        c = k.minScale;
                        var f = k.maxScale,
                            l = -1,
                            u = -1,
                            n = !1,
                            ha = !1,
                            q;
                        for (q = 0; q < b.length; q++) 0 < c && (!n && c >= b[q].scale) && (l = b[q].level, n = !0), 0 < f && (!ha && f >= b[q].scale) && (u = 0 < q ? b[q - 1].level : -1, ha = !0); - 1 === k.minZoom && (k.minZoom = 0 === c ? b[0].level : l); - 1 === k.maxZoom && (k.maxZoom = 0 === f ? b[b.length -
                            1].level : u);
                        for (q = 0; q < b.length; q++) k.minZoom === b[q].level && (k.minScale = b[q].scale), k.maxZoom === b[q].level && (k.maxScale = b[q].scale)
                    } else k.minZoom = k.maxZoom = k.zoom = -1
                }
                a instanceof E ? (this._gc || (this._gc = new E._GraphicsContainer, this._gc._setMap(this, this._layersDiv).id = d + "_gc"), g = a._setMap(this, this._gc._surface), g.id = d + "_" + e, this._layerDivs[e] = g, this._reorderLayers(this.graphicsLayerIds)) : (g = a._setMap(this, this._layersDiv, g, this.__LOD), g.id = d + "_" + e, this._layerDivs[e] = g, this._reorderLayers(this.layerIds), !h && -1 !== a.declaredClass.indexOf("VETiledLayer") && this._onBingLayerAdd(a));
                e === this._firstLayerId && (this.graphics = new E({
                    id: d + "_graphics",
                    displayOnPan: k.displayGraphicsOnPan
                }), this._addLayer(this.graphics, this._internalLayerIds, 20));
                if (a === this.graphics) {
                    c = this._layers[this._firstLayerId];
                    d = k.zoom;
                    g = k.scale;
                    b = k.center;
                    c = c.initialExtent || c.fullExtent;
                    this._firstLayerId = null;
                    this.extent && (this.extent = this._convertGeometry(this, this.extent));
                    !this.extent && c && (b && (b = this._convertGeometry(c, b)), b && (c =
                        c.centerAt(b)));
                    if (b = this.extent || c && new A(c.toJson())) - 1 < d ? b = this.__getExtentForLevel(d, null, b).extent : 0 < g && (b = G.getExtentForScale(this, g, b));
                    if (!b) {
                        console.log("Map: " + this.invalidExtent);
                        return
                    }
                    d = this._fixExtent(b, k.fitExtent);
                    this.extent = d.extent;
                    this.__LOD = d.lod;
                    this.__setExtent(this.extent, null, null, k.fitExtent);
                    this.loaded = !0;
                    this.attr("data-loaded", "");
                    this.infoWindow.setMap(this);
                    this.onLoad(this)
                }
                h || (this.onLayerAdd(a), this.onLayerAddResult(a));
                O(this[e + "_addLayerHandler_connect"])
            }
        },
        _convertGeometry: function(a,
            b) {
            var c = a && a.spatialReference,
                d = b && b.spatialReference;
            c && (d && !c.equals(d)) && (c._canProject(d) ? c.isWebMercator() ? b = Y.geographicToWebMercator(b) : 4326 === c.wkid && (b = Y.webMercatorToGeographic(b, !0)) : (console.log("Map: " + t.substitute({
                geometry: d.wkid || d.wkt,
                map: c.wkid || c.wkt
            }, this.invalidGeometry)), b = null));
            return b
        },
        _reorderLayers: function(a) {
            var b = this.onLayerReorder,
                c = Q.place,
                d = this._layerDivs,
                e = this._layers,
                f = this._gc ? this._gc._surface.getEventSource() : null;
            if (a === this.graphicsLayerIds) m.forEach(a,
                function(a, g) {
                    var h = d[a];
                    h && (c(h.getEventSource(), f, g), b(e[a], g))
                });
            else {
                var g = this.graphics,
                    h = g ? g.id : null,
                    k = this._layersDiv,
                    l;
                m.forEach(a, function(a, f) {
                    l = d[a];
                    a !== h && l && (c(l, k, f), b(e[a], f))
                });
                f && (f = 9 > R("ie") ? f.parentNode : f, c(f, f.parentNode, a.length))
            }
            this.onLayersReordered([].concat(a))
        },
        _zoomStartHandler: function() {
            this.__zoomStart(this._zoomAnimDiv.startingExtent, this._zoomAnimDiv.anchor)
        },
        _zoomingHandler: function(a) {
            var b = parseFloat(a.left),
                c = parseFloat(a.top);
            a = new A(b, c - parseFloat(a.height),
                b + parseFloat(a.width), c, this.spatialReference);
            b = this.extent.getWidth() / a.getWidth();
            this.__zoom(a, b, this._zoomAnimDiv.anchor)
        },
        _zoomEndHandler: function() {
            var a = this._zoomAnimDiv,
                b = a.extent,
                c = this.extent.getWidth() / b.getWidth(),
                d = a.anchor,
                e = a.newLod,
                f = a.levelChange;
            a.extent = a.anchor = a.levelChange = a.startingExtent = a.newLod = this._delta = this._zoomAnim = null;
            this.__zoomEnd(b, c, d, e, f)
        },
        _panningHandler: function(a) {
            if (isNaN(parseFloat(a.left)) || isNaN(parseFloat(a.top))) {
                var b = Math.round,
                    c = this._panAnim.node;
                a.left = -1 * (this._delta.x - b(this.width / 2)) + "px";
                a.top = -1 * (this._delta.y - b(this.height / 2)) + "px";
                V.set(c, "left", a.left);
                V.set(c, "top", a.top)
            }
            a = new C(parseFloat(a.left), parseFloat(a.top));
            b = this.toMap(a);
            this.onPan(this.extent.offset(this.extent.xmin - b.x, this.extent.ymax - b.y), a)
        },
        _panEndHandler: function(a) {
            this.__panning = !1;
            var b = Math.round;
            a = new C(-b(parseFloat(a.style.left)), -b(parseFloat(a.style.top)));
            var b = a.x,
                c = a.y,
                d = this.__visibleRect,
                e = this.__visibleDelta;
            d.x += -b;
            d.y += -c;
            e.x += -b;
            e.y += -c;
            B(this._zoomAnimDiv, {
                left: "0px",
                top: "0px"
            });
            var d = this.extent,
                e = this._ratioW,
                f = this._ratioH,
                d = new A(d.xmin + b / e, d.ymin - c / f, d.xmax + b / e, d.ymax - c / f, this.spatialReference);
            a.setX(-a.x);
            a.setY(-a.y);
            this._delta = this._panAnim = null;
            this._updateExtent(d);
            this.onPanEnd(d, a);
            this._fireExtChg([d, a, !1, this.__LOD])
        },
        _fixExtent: function(a, b) {
            for (var c = this._reshapeExtent(a), d = 1.25; !0 === b && (c.extent.getWidth() < a.getWidth() || c.extent.getHeight() < a.getHeight()) && 0 < c.lod.level && 3 >= d;) c = this._reshapeExtent(a.expand(d)), d += 0.25;
            return c
        },
        _getFrameWidth: function() {
            var a = -1,
                b = this.spatialReference._getInfo();
            this.__LOD ? (b = this.__LOD._frameInfo) && (a = b[3]) : b && (a = Math.round(2 * b.valid[1] / (this.extent.getWidth() / this.width)));
            return a
        },
        _fixAspectRatio: function(a) {
            var b = a.getWidth(),
                c = a.getHeight(),
                d = b / c,
                e = this.width / this.height,
                f = 0,
                g = 0;
            this.width > this.height ? b > c ? e > d ? f = c * e - b : g = b / e - c : f = c * e - b : this.width < this.height ? b < c ? e > d ? f = c * e - b : g = b / e - c : g = b / e - c : b < c ? f = c - b : b > c && (g = b / e - c);
            f && (a.xmin -= f / 2, a.xmax += f / 2);
            g && (a.ymin -= g / 2, a.ymax += g / 2);
            return a
        },
        _reshapeExtent: function(a) {
            a =
                this._fixAspectRatio(a);
            return this._getAdjustedExtent(a)
        },
        _getAdjustedExtent: function(a) {
            if (this.__tileInfo) return ca.getCandidateTileInfo(this, this.__tileInfo, a);
            var b = G.getScale(this, a),
                c = this.getMinScale(),
                d = this.getMaxScale(),
                e = !d || b >= d;
            c && !(b <= c) ? a = G.getExtentForScale(this, c, a) : e || (a = G.getExtentForScale(this, d, a));
            return {
                extent: a
            }
        },
        _onBingLayerAdd: function(a) {
            this["__" + a.id + "_vis_connect"] = z.connect(a, "onVisibilityChange", this, "_toggleBingLogo");
            this._toggleBingLogo(a.visible)
        },
        _onBingLayerRemove: function(a) {
            z.disconnect(this["__" +
                a.id + "_vis_connect"]);
            delete this["__" + a.id + "_vis_connect"];
            var b = m.some(this.layerIds, function(b) {
                return (a = this._layers[b]) && a.visible && -1 !== a.declaredClass.indexOf("VETiledLayer")
            }, this);
            this._toggleBingLogo(b)
        },
        _toggleBingLogo: function(a) {
            a && !this._bingLogo ? (a = {
                    left: this._mapParams && this._mapParams.nav ? "25px" : ""
                }, 6 === R("ie") && (a.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled\x3d'true', sizingMethod\x3d'crop', src\x3d'" + P.toUrl("./images/map/bing-logo-lg.png") + "')"), a = this._bingLogo =
                Q.create("div", {
                    style: a
                }, this.root), X.add(a, "bingLogo-lg")) : !a && this._bingLogo && (Q.destroy(this._bingLogo), delete this._bingLogo)
        },
        __panStart: function(a, b) {
            var c = this._zoomAnim,
                d = this._panAnim;
            if (c && c._active) c.stop(), c._fire("onEnd", [c.node]);
            else if (d && d._active) {
                d.stop();
                this._panAnim = null;
                var d = d.curve.getValue(d._getStep()),
                    c = Math.round(parseFloat(d.left)),
                    d = Math.round(parseFloat(d.top)),
                    e = this.navigationManager._dragOrigin;
                this.__pan(c, d);
                e && (e.x -= c, e.y -= d);
                return
            }
            this.__panning = !0;
            this.onPanStart(this.extent,
                new C(a, b))
        },
        __pan: function(a, b) {
            var c = this.extent,
                d = this._ratioW,
                e = this._ratioH;
            this.onPan(new A(c.xmin - a / d, c.ymin + b / e, c.xmax - a / d, c.ymax + b / e, this.spatialReference), new C(a, b))
        },
        __panEnd: function(a, b) {
            var c = this.__visibleRect,
                d = this.__visibleDelta;
            c.x += a;
            c.y += b;
            d.x += a;
            d.y += b;
            var c = new C(a, b),
                d = this.extent,
                e = this._ratioW,
                f = this._ratioH,
                d = new A(d.xmin - a / e, d.ymin + b / f, d.xmax - a / e, d.ymax + b / f, this.spatialReference);
            this.__panning = !1;
            this._updateExtent(d);
            this.onPanEnd(d, c);
            this._fireExtChg([d, c, !1, this.__LOD])
        },
        __zoomStart: function(a, b) {
            this.__zooming = !0;
            this.onZoomStart(a, 1, b, this.__LOD ? this.__LOD.level : null)
        },
        __zoom: function(a, b, c) {
            this.onZoom(a, b, c)
        },
        __zoomEnd: function(a, b, c, d, e) {
            B(this._layersDiv, {
                left: "0px",
                top: "0px"
            });
            this._delta = new C(0, 0);
            this.__visibleRect.x = this.__visibleRect.y = 0;
            a = new A(a);
            this.__LOD = d;
            this._ratioW = this.width / a.getWidth();
            this._ratioH = this.height / a.getHeight();
            var f = this._delta;
            this._delta = null;
            this.__zooming = !1;
            this._updateExtent(a, e);
            this.onZoomEnd(a, b, c, d ? d.level : null);
            this._fireExtChg([a,
                f, e, d
            ])
        },
        _extentUtil: function(a, b, c, d, e) {
            var f = new aa,
                g, h, k, l, u, n, m, q, v, y, r = this.width,
                p = this.height,
                L, s, w;
            a && (g = a.numLevels, h = a.targetLevel, L = t.isDefined(h), k = a.factor, l = a.mapAnchor, u = a.screenAnchor, n = a.mapCenter, s = a.levelOrFactor, m = a.targetScale, q = t.isDefined(m) && 0 < m);
            b && (v = b.dx, y = b.dy, n = b.mapCenter);
            H.isArray(n) && (n = new M(n));
            var z = this._panAnim;
            b = (a = this._stopAnim()) ? a.divExtent : this.extent;
            var B = this.__tileInfo,
                F = this._params;
            if (!this.loaded) {
                if (c) b && (c = this._convertGeometry(b, c)), c && (this.extent =
                    c, F.zoom = F.scale = -1, F.center = null);
                else if (n || L || q) {
                    if (n)
                        if (b) {
                            if (n = this._convertGeometry(b, n)) this.extent = b.centerAt(n), F.center = null
                        } else F.center = n;
                    L && -1 < h ? (F.zoom = h, F.scale = -1) : q && (F.scale = m, F.zoom = -1)
                }
                f.resolve();
                return f
            }
            if (n && (n = this._convertGeometry(this, n), !n) || l && (l = this._convertGeometry(this, l), !l) || c && (c = this._convertGeometry(this, c), !c)) return f.reject(), f;
            z && (l && u) && (l = T(this.extent, r, p, u));
            a && (l && u) && (l = T(a.divExtent, r, p, u));
            L && (B ? (g = this.getMinZoom(), L = this.getMaxZoom(), h < g ? h = g : h >
                L && (h = L), g = h - (a ? a.level : this.getLevel())) : (g = 0 < h ? -1 : 1, w = s ? h : null));
            if (!c)
                if (t.isDefined(g)) B ? (r = a ? a.level : this.getLevel(), p = this.__getExtentForLevel(r + g, n, b).extent) : (p = (a ? a.end : this.extent).expand(w || (0 < g ? 0.5 * g : 2 * -g)), w && n && (p = p.centerAt(n))), p && (n ? c = p : (r = l || b.getCenter(), v = b.ymax - (p.getHeight() - b.getHeight()) * (r.y - b.ymax) / b.getHeight(), r = b.xmin - (p.getWidth() - b.getWidth()) * (r.x - b.xmin) / b.getWidth(), c = new A(r, v - p.getHeight(), r + p.getWidth(), v, this.spatialReference)));
                else if (q) c = G.getExtentForScale(this,
                m, b);
            else if (t.isDefined(k)) c = b.expand(k);
            else if (v || y) a ? (c = a.end, l = c.getCenter(), w = $(c, r, p, l), w.x += v, w.y += y, w = T(c, r, p, w), c = c.offset(w.x - l.x, w.y - l.y)) : (v = new C(r / 2 + v, p / 2 + y), y = T(b, r, p, v), p = b.getWidth(), v = b.getHeight(), r = y.x - p / 2, y = y.y - v / 2, c = new A(r, y, r + p, y + v, this.spatialReference));
            c || (n ? (b = a ? a.end : b, p = b.getWidth(), v = b.getHeight(), r = n.x - p / 2, y = n.y - v / 2, c = new A(r, y, r + p, y + v, this.spatialReference)) : a && (c = a.end));
            c ? (this._extentDfd && -1 === this._extentDfd.fired && (this._extentDfd.then(null, za), this._extentDfd.reject()),
                this._extentDfd = f, this.__setExtent(c, null, u, d, a, e)) : f.reject();
            return f
        },
        __setExtent: function(a, b, c, d, e, f) {
            try {
                if (this._firstLayerId) this.extent = a;
                else {
                    var g = !0,
                        h = this.spatialReference,
                        k = e ? e.divExtent : this.extent,
                        l = this._fixExtent(a, d || !1);
                    a = l.extent;
                    var u = a.getWidth(),
                        n = a.getHeight(),
                        m = Math.round;
                    if (k) var q = m(1E6 * k.getWidth()),
                        v = m(1E6 * u),
                        y = m(1E6 * k.getHeight()),
                        r = m(1E6 * n),
                        g = q !== v || y !== r;
                    var p, t, s = e && e.rect,
                        w = e && e.divExtent;
                    if (J.zoomDuration && g && k) {
                        w = w || new A(k);
                        s = s || {
                            left: k.xmin,
                            top: k.ymax,
                            width: k.getWidth(),
                            height: k.getHeight()
                        };
                        t = {
                            left: a.xmin,
                            top: a.ymax,
                            width: u,
                            height: n
                        };
                        var z = new M(a.xmin, a.ymax, h),
                            D = new M(a.xmin, a.ymin, h),
                            F = new M(this.extent.xmin, this.extent.ymax, h),
                            E = new M(this.extent.xmin, this.extent.ymin, h);
                        p = ua.getLineIntersection(F, z, E, D, h);
                        !p && !e && (g = !1)
                    }
                    this._ratioW = this.width / u;
                    this._ratioH = this.height / n;
                    var K = this._zoomAnimDiv;
                    if (g) B(this._layersDiv, {
                        left: "0px",
                        top: "0px"
                    }), b = new C(0, 0), this.__visibleRect.x = this.__visibleRect.y = 0, s && t ? (this._delta = b, K.id = "_zAD", K.startingExtent = w, K.extent =
                        a, K.levelChange = g, K.newLod = l.lod, K.anchor = c ? c : !p && e ? e.anchor : $(this.extent, this.width, this.height, p), this._zoomAnim = ba.resize({
                            node: K,
                            start: s,
                            end: t,
                            duration: J.zoomDuration,
                            rate: J.zoomRate,
                            beforeBegin: !e ? this._zoomStartHandler : null,
                            onAnimate: this._zoomingHandler,
                            onEnd: this._zoomEndHandler
                        }).play(), this._fireOnScale(this.extent.getWidth() / a.getWidth(), K.anchor)) : (this._updateExtent(a, g), this._fireExtChg([this.extent, b, g, this.__LOD = l.lod]));
                    else if (!this.__panning)
                        if (!1 === this.loaded || f) this._updateExtent(a,
                            g), this._fireExtChg([this.extent, b, g, this.__LOD = l.lod]);
                        else {
                            this.__panning = !0;
                            s = (new N(0, 0, this.width, this.height, this.spatialReference)).getCenter();
                            s.x = m(s.x);
                            s.y = m(s.y);
                            var x = this._delta = this.toScreen(a.getCenter()),
                                G = Math.abs(s.x - x.x),
                                H = Math.abs(s.y - x.y);
                            5E4 < G || 5E4 < H ? (this.__visibleRect.x = this.__visibleRect.y = this.__visibleDelta.x = this.__visibleDelta.y = 0, this.__panning = !1, this._delta = null, this._updateExtent(a, !1), this._fireExtChg([this.extent, new C(0, 0), !0, this.__LOD])) : this.optimizePanAnimation &&
                                (G > 2 * this.width || H > 2 * this.height) ? (b = new C(s.x - x.x, s.y - x.y), this.__panStart(s.x, s.y), this.__pan(b.x, b.y), this.__panEnd(b.x, b.y)) : (this.onPanStart(this.extent, new C(0, 0)), this._panAnim = ba.slideTo({
                                    node: K,
                                    left: s.x - x.x,
                                    top: s.y - x.y,
                                    duration: J.panDuration,
                                    rate: J.panRate,
                                    onAnimate: this._panningHandler,
                                    onEnd: this._panEndHandler
                                }), this._panAnim.play())
                        }
                }
            } catch (I) {
                console.log(I.stack), console.error(I)
            }
        },
        _fireOnScale: function(a, b, c) {
            if ("css-transforms" === this.navigationMode) {
                var d = this.__visibleDelta;
                this.onScale(pa.scaleAt(a, {
                    x: -1 * (this.width / 2 - (b.x - d.x)),
                    y: -1 * (this.height / 2 - (b.y - d.y))
                }), c)
            }
        },
        _stopAnim: function() {
            var a = this._zoomAnim,
                b = this._panAnim;
            if (a && a._active) {
                a.stop();
                var b = a.curve.getValue(a._getStep()),
                    c = parseFloat(b.left),
                    d = parseFloat(b.top),
                    a = a.node;
                return {
                    anchor: a.anchor,
                    start: a.startingExtent,
                    end: a.extent,
                    level: a.newLod && a.newLod.level,
                    rect: b,
                    divExtent: new A(c, d - parseFloat(b.height), c + parseFloat(b.width), d, this.spatialReference)
                }
            }
            b && b._active && (b.stop(), b._fire("onEnd", [b.node]))
        },
        __getExtentForLevel: function(a,
            b, c) {
            var d = this.__tileInfo,
                d = d && d.lods;
            a = t.isDefined(a) ? a : 0;
            c = c || this.extent;
            b = b || c && c.getCenter();
            if (d) {
                if (b) {
                    c = this.getMinZoom();
                    var e = this.getMaxZoom();
                    a > e && (a = e);
                    a < c && (a = c);
                    a = d[a];
                    d = this.width * a.resolution / 2;
                    c = this.height * a.resolution / 2;
                    return {
                        extent: new A(b.x - d, b.y - c, b.x + d, b.y + c, b.spatialReference),
                        lod: a
                    }
                }
            } else if (c) return {
                extent: c.expand(!a || 1 > a ? 1 : a).centerAt(b)
            };
            console.log("Map: " + this.invalidExtent)
        },
        _jobs: 0,
        _incr: function() {
            1 === ++this._jobs && (this.updating = !0, this.attr("data-updating", ""),
                this.onUpdateStart())
        },
        _decr: function() {
            var a = --this._jobs;
            a ? 0 > a && (this._jobs = 0) : (this.updating = !1, this.attr("data-updating"), this.onUpdateEnd())
        },
        _fireEvent: function(a, b) {
            this[a] && this[a].apply(this, b)
        },
        _updateExtent: function(a, b) {
            this.extent = a;
            b && this._setClipRect();
            var c = this.spatialReference;
            c && (c.isWebMercator() ? this.geographicExtent = Y.webMercatorToGeographic(this._getAvailExtent(), !0) : 4326 === c.wkid && (this.geographicExtent = new A(this._getAvailExtent().toJson())))
        },
        _fireExtChg: function(a) {
            this.attr("data-zoom",
                this.getZoom());
            this.attr("data-scale", this.getScale());
            this._fireEvent("onExtentChange", a);
            if (a = this._extentDfd) delete this._extentDfd, a.resolve()
        },
        attr: function(a, b) {
            var c = this.container;
            c && (null == b ? c.removeAttribute(a) : c.setAttribute(a, b));
            return this
        },
        onUpdateStart: function() {},
        onUpdateEnd: function() {},
        onLoad: function() {
            this._setClipRect()
        },
        onBeforeUnload: function() {},
        onUnload: function() {},
        onExtentChange: function(a, b, c) {},
        onTimeExtentChange: function() {},
        onLayerAdd: function() {},
        onLayerAddResult: function() {},
        onLayersAddResult: function() {},
        onLayerRemove: function() {},
        onLayersRemoved: function() {},
        onLayerReorder: function() {},
        onLayersReordered: function() {},
        onLayerSuspend: function() {},
        onLayerResume: function() {},
        onPanStart: function() {},
        onPan: function() {},
        onPanEnd: function() {},
        onScale: function() {},
        onZoomStart: function() {},
        onZoom: function() {},
        onZoomEnd: function() {},
        onResize: function() {
            this._setClipRect()
        },
        onReposition: function() {},
        destroy: function() {
            this._destroyed || (this.onBeforeUnload(this), this.removeAllLayers(),
                this._cleanUp(), this._gc && this._gc._cleanUp(), this._destroyed = !0, this.onUnload(this))
        },
        setCursor: function(a) {
            B(this.__container, "cursor", this.cursor = a)
        },
        setMapCursor: function(a) {
            this.setCursor(this._cursor = a)
        },
        resetMapCursor: function() {
            this.setCursor(this._cursor)
        },
        setInfoWindow: function(a) {
            var b = this.infoWindow;
            b && b.unsetMap(this);
            this.infoWindow = a;
            this.loaded && a && a.setMap(this)
        },
        setInfoWindowOnClick: function(a) {
            this._params.showInfoWindowOnClick = a;
            this.popupManager && this.popupManager.set("enabled",
                a)
        },
        getInfoWindowAnchor: function(a) {
            return this.infoWindow && this.infoWindow._getAnchor && this.infoWindow._getAnchor(a) || "upperright"
        },
        toScreen: function(a, b) {
            return $(this.extent, this.width, this.height, a, b)
        },
        toMap: function(a) {
            return T(this.extent, this.width, this.height, a)
        },
        addLayer: function(a, b) {
            a && !this.getLayer(a.id) && this._addLayer(a, a instanceof E ? this.graphicsLayerIds : this.layerIds, b);
            return a
        },
        addLayers: function(a) {
            var b = [],
                c = a.length,
                d, e, f = a.length;
            d = z.connect(this, "onLayerAddResult", function(e,
                f) {
                -1 !== m.indexOf(a, e) && (c--, b.push({
                    layer: e,
                    success: !f,
                    error: f
                }), c || (z.disconnect(d), this.onLayersAddResult(b)))
            });
            for (e = 0; e < f; e++) this.addLayer(a[e]);
            return this
        },
        removeLayer: function(a, b) {
            var c = a.id,
                d = a instanceof E ? this.graphicsLayerIds : this.layerIds,
                e = I(d, c);
            0 <= e && (d.splice(e, 1), a instanceof E ? (O(this["_gl_" + a.id + "_click_connect"]), a.loaded && a._unsetMap(this, this._gc._surface)) : a.loaded && (a._unsetMap(this, this._layersDiv), -1 !== a.declaredClass.indexOf("VETiledLayer") && this._onBingLayerRemove(a)),
                delete this._layers[c], delete this._layerDivs[c], b || this._reorderLayers(d), this.onLayerRemove(a))
        },
        removeAllLayers: function() {
            var a = this.layerIds,
                b;
            for (b = a.length - 1; 0 <= b; b--) this.removeLayer(this._layers[a[b]], 1);
            a = this.graphicsLayerIds;
            for (b = a.length - 1; 0 <= b; b--) this.removeLayer(this._layers[a[b]], 1);
            this.onLayersRemoved()
        },
        reorderLayer: function(a, b) {
            H.isString(a) && (ja.deprecated(this.declaredClass + ": Map.reorderLayer(/*String*/ id, /*Number*/ index) deprecated. Use Map.reorderLayer(/*Layer*/ layer, /*Number*/ index).",
                null, "v2.0"), a = this.getLayer(a));
            var c = a.id,
                d, e = a instanceof E ? this.graphicsLayerIds : this.layerIds;
            0 > b ? b = 0 : b >= e.length && (b = e.length - 1);
            d = I(e, c); - 1 === d || d === b || (e.splice(d, 1), e.splice(b, 0, c), this._reorderLayers(e))
        },
        getLayer: function(a) {
            return this._layers[a]
        },
        setExtent: function(a, b) {
            a = new A(a.toJson());
            var c = a.getWidth(),
                d = a.getHeight();
            return 0 === c && 0 === d ? this.centerAt(new M({
                x: a.xmin,
                y: a.ymin,
                spatialReference: a.spatialReference && a.spatialReference.toJson()
            })) : this._extentUtil(null, null, a, b)
        },
        centerAt: function(a) {
            return this._extentUtil(null, {
                mapCenter: a
            })
        },
        centerAndZoom: function(a, b) {
            return this._extentUtil({
                targetLevel: b,
                mapCenter: a,
                levelOrFactor: !0
            })
        },
        getScale: function() {
            return this.__LOD ? this.__LOD.scale : G.getScale(this)
        },
        getResolution: function() {
            return this.__LOD ? this.__LOD.resolution : this.extent ? this.extent.getWidth() / this.width : 0
        },
        getResolutionInMeters: function() {
            return this.getResolution() * (G.getUnitValue(this.spatialReference) || 20015077 / 180)
        },
        getMinScale: function() {
            return this._params.minScale
        },
        getMaxScale: function() {
            return this._params.maxScale
        },
        setScale: function(a) {
            return this._extentUtil({
                targetScale: a
            })
        },
        getLayersVisibleAtScale: function(a) {
            var b = [];
            (a = a || this.getScale()) && m.forEach(this.layerIds.concat(this.graphicsLayerIds), function(c) {
                c = this.getLayer(c);
                c.isVisibleAtScale(a) && b.push(c)
            }, this);
            return b
        },
        getNumLevels: function() {
            var a = this.getMinZoom(),
                b = this.getMaxZoom();
            return a === b && 0 > a ? 0 : b - a + 1
        },
        getLevel: function() {
            return this.__LOD ? this.__LOD.level : -1
        },
        setLevel: function(a) {
            if (-1 < a) return this._extentUtil({
                targetLevel: a
            })
        },
        getZoom: function() {
            return this.getLevel()
        },
        setZoom: function(a) {
            return this.setLevel(a)
        },
        getMinZoom: function() {
            return this._params.minZoom
        },
        getMaxZoom: function() {
            return this._params.maxZoom
        },
        setBasemap: function(a) {
            var b;
            H.isObject(a) ? (b = a, a = b.title) : b = D && D[a];
            if (b) {
                this._basemapDfd && -1 === this._basemapDfd.fired && this._basemapDfd.cancel();
                var c = [],
                    d = [],
                    e = 0;
                m.forEach(b.baseMapLayers || b.layers, function(b) {
                    var f, g = {
                        id: b.id,
                        displayLevels: b.displayLevels,
                        opacity: t.isDefined(b.opacity) ? b.opacity : null,
                        visible: t.isDefined(b.visibility) ? b.visibility : null
                    };
                    if (b.type) switch (b.type) {
                        case "OpenStreetMap":
                            f = new ea(g);
                            break;
                        default:
                            console.log("Map.setBasemap: " + t.substitute({
                                basemapName: a,
                                type: b.type
                            }, this.unknownLayerType))
                    } else {
                        f = b.url;
                        if ("https:" === window.location.protocol && (-1 !== f.search(/^http\:\/\/server\.arcgisonline\.com/i) || -1 !== f.search(/^http\:\/\/services\.arcgisonline\.com/i) || -1 !== f.search(/^http\:\/\/.+\.arcgis\.com/i))) f = f.replace(/http:/i, "https:");
                        f = new xa(f, g)
                    }
                    f && (c.push(f), d.push(b), b.isReference || e++)
                }, this);
                if (!c.length || !e) console.log("Map.setBasemap: " +
                    t.substitute({
                        basemapName: a
                    }, this.invalidBasemap));
                else {
                    var f = {
                        basemapName: a,
                        infos: d,
                        layers: c
                    };
                    if (this.loaded) {
                        var g = this,
                            h = new aa(sa._dfdCanceller),
                            k = function(a) {
                                h._pendingLayers--;
                                a = m.indexOf(f.layers, this);
                                if (-1 < a && (a = h._layerEvents[a])) z.disconnect(a[0]), z.disconnect(a[1]);
                                0 >= h._pendingLayers && (delete h._layerEvents, delete g._basemapDfd, 0 > h.fired && h.callback(f))
                            };
                        this._basemapDfd = h;
                        h._pendingLayers = 0;
                        h._layerEvents = {};
                        m.forEach(c, function(a, b) {
                            a && (h._pendingLayers++, a.loaded ? k(a) : h._layerEvents[b] = [z.connect(a, "onLoad", a, k), z.connect(a, "onError", a, k)])
                        });
                        h.addCallback(x(this, this._basemapLoaded))
                    } else this._basemapLoaded(f)
                }
            } else {
                b = [];
                for (var l in D) b.push(l);
                console.log("Map.setBasemap: " + t.substitute({
                    basemapName: a,
                    list: b.join(",")
                }, this.unknownBasemap))
            }
        },
        _basemapLoaded: function(a) {
            var b = a.layers,
                c = a.infos,
                d = 0,
                e = !0,
                f;
            this.loaded && (m.forEach(b, function(a, b) {
                a.loaded && (c[b].isReference || d++)
            }), e = d);
            e && (this.basemapLayerIds && (f = {
                    basemapName: this._basemap,
                    infos: D && D[this._basemap] && D[this._basemap].baseMapLayers
                },
                f.basemapName || (m.forEach(this.basemapLayerIds, function(a) {
                    if (this.getLayer(a) instanceof ea) return f.basemapName = "osm", f.infos = D && D.osm && D.osm.baseMapLayers, !1
                }, this), f.basemapName || (f = null))), this._removeBasemap(), this._basemap = a.basemapName, this.basemapLayerIds = this._addBasemap(b, c), this.attr("data-basemap", this.getBasemap()), this.emit("basemap-change", {
                current: a,
                previous: f
            }))
        },
        _addBasemap: function(a, b) {
            var c = [],
                d = [],
                e = 0;
            m.forEach(a, function(a, g) {
                b[g].isReference ? c.push(a) : (this.addLayer(a, e++),
                    d.push(a.id))
            }, this);
            c.length && m.forEach(c, function(a) {
                this.addLayer(a, "top");
                d.push(a.id)
            }, this);
            return d
        },
        _removeBasemap: function() {
            var a = this.basemapLayerIds,
                b;
            a && a.length && m.forEach(a, function(a) {
                (b = this.getLayer(a)) && this.removeLayer(b)
            }, this)
        },
        getBasemap: function() {
            return this._basemap || ""
        },
        translate: function(a, b) {
            a = a || 0;
            b = b || 0;
            if (!this._txTimer) {
                this._tx = this._ty = 0;
                var c = this.toScreen(this.extent.getCenter());
                this.__panStart(c.x, c.y)
            }
            this._tx += a;
            this._ty += b;
            this.__pan(this._tx, this._ty);
            clearTimeout(this._txTimer);
            this._txTimer = setTimeout(this._endTranslate, 150)
        },
        _endTranslate: function() {
            clearTimeout(this._txTimer);
            this._txTimer = null;
            var a = this._tx,
                b = this._ty;
            this._tx = this._ty = 0;
            this.__panEnd(a, b)
        },
        setTimeExtent: function(a) {
            a = (this.timeExtent = a) ? new a.constructor(a.toJson()) : null;
            this.onTimeExtentChange(a)
        },
        setTimeSlider: function(a) {
            this.timeSlider && (O(this._tsTimeExtentChange_connect), this.timeSlider = this._tsTimeExtentChange_connect = null);
            a && (this.timeSlider = a, this.setTimeExtent(a.getCurrentTimeExtent()),
                this._tsTimeExtentChange_connect = W(a, "onTimeExtentChange", this, "setTimeExtent"))
        },
        setVisibility: function(a) {
            if (this.visible !== a) {
                this.visible = a;
                a || (this._display = this.container.style.display);
                this.container.style.display = a ? this._display : "none";
                if (this.autoResize) {
                    var b = a ? "resume" : "pause";
                    this._rszSignal[b]();
                    this._oriSignal[b]()
                }
                a && this.resize()
            }
            return this
        },
        resize: function(a) {
            var b = this,
                c = function() {
                    clearTimeout(b._resizeT);
                    b.reposition();
                    b._resize()
                };
            clearTimeout(b._resizeT);
            !0 === a ? c() : b._resizeT =
                setTimeout(c, b.resizeDelay)
        },
        _resize: function() {
            var a = this.width,
                b = this.height,
                c = U.getContentBox(this.container);
            if (!(a === c.w && b === c.h)) {
                var d = this._zoomAnim || this._panAnim;
                d && (d.stop(), d._fire("onEnd", [d.node]));
                B(this.root, {
                    width: (this.width = c.w) + "px",
                    height: (this.height = c.h) + "px"
                });
                c = this.width;
                d = this.height;
                this.attribution && this.attribution.domNode && V.set(this.attribution.domNode, "maxWidth", Math.floor(c * this._mapParams.attributionWidth) + "px");
                this.__visibleRect.update(this.__visibleRect.x, this.__visibleRect.y,
                    c, d);
                this.__visibleDelta.update(this.__visibleDelta.x, this.__visibleDelta.y, c, d);
                var e = new N(this.extent),
                    a = (new N(e.x, e.y, e.width * (c / a), e.height * (d / b), this.spatialReference)).getExtent();
                this.onResize(a, c, d);
                this._extentUtil(null, null, a, null, !0)
            }
        },
        reposition: function() {
            this._reposition();
            this.onReposition(this.position.x, this.position.y)
        },
        _reposition: function() {
            var a = U.position(this.container, !0),
                b = U.getPadBorderExtents(this.container);
            this.position.update(a.x + b.l, a.y + b.t)
        },
        _setClipRect: function() {
            delete this._clip;
            var a = 7 >= R("ie") || void 0 === R("ie") && 7 <= R("trident") ? "rect(auto,auto,auto,auto)" : "auto";
            if (this.wrapAround180) {
                var b = this.width,
                    c = this.height,
                    d = this._getFrameWidth(),
                    e = b - d;
                0 < e && (a = e / 2, a = "rect(0px," + (a + d) + "px," + c + "px," + a + "px)", c = this.extent.getWidth(), b = c * (d / b), this._clip = [(c - b) / 2, b])
            }
            B(this.__container, "clip", a)
        },
        _getAvailExtent: function() {
            var a = this.extent,
                b = this._clip;
            if (b) {
                if (!a._clip) {
                    var c = new N(a);
                    c.width = b[1];
                    c.x += b[0];
                    a._clip = c.getExtent()
                }
                return a._clip
            }
            return a
        },
        _fixedPan: function(a, b) {
            return this._extentUtil(null, {
                dx: a,
                dy: b
            })
        },
        panUp: function() {
            return this._fixedPan(0, -0.75 * this.height)
        },
        panUpperRight: function() {
            return this._fixedPan(0.75 * this.width, -0.75 * this.height)
        },
        panRight: function() {
            return this._fixedPan(0.75 * this.width, 0)
        },
        panLowerRight: function() {
            return this._fixedPan(0.75 * this.width, 0.75 * this.height)
        },
        panDown: function() {
            return this._fixedPan(0, 0.75 * this.height)
        },
        panLowerLeft: function() {
            return this._fixedPan(-0.75 * this.width, 0.75 * this.height)
        },
        panLeft: function() {
            return this._fixedPan(-0.75 * this.width,
                0)
        },
        panUpperLeft: function() {
            return this._fixedPan(-0.75 * this.width, -0.75 * this.height)
        },
        enableSnapping: function(a) {
            a = a || {};
            if ("esri.SnappingManager" === a.declaredClass) this.snappingManager = a;
            else {
                var b = ga++,
                    c = this;
                this._rids && this._rids.push(b);
                P(["./SnappingManager"], function(d) {
                    var e = c._rids ? m.indexOf(c._rids, b) : -1; - 1 !== e && (c._rids.splice(e, 1), c.snappingManager = new d(H.mixin({
                        map: c
                    }, a)))
                })
            }
            return this.snappingManager
        },
        disableSnapping: function() {
            this.snappingManager && this.snappingManager.destroy();
            this.snappingManager = null
        },
        _createLabelLayer: function() {
            function a() {
                b._labels.removeAllFeatureLayers();
                m.forEach(b.graphicsLayerIds, function(a) {
                    a = b.getLayer(a);
                    "function" === typeof a.applyEdits && b._labels.addFeatureLayer(a)
                })
            }
            var b = this;
            !this._labels && (Z && this.loaded) && (this._labels = new Z({
                id: "_internal_LabelLayer"
            }), this._labels._setMap(this, this._gc._surface), a(), this.on("layers-reordered", a))
        }
    })
});
},
'dojox/gfx/matrix':function(){
define(["./_base","dojo/_base/lang"], 
  function(g, lang){
	var m = g.matrix = {};

	// candidates for dojox.math:
	var _degToRadCache = {};
	m._degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	m._radToDeg = function(radian){ return radian / Math.PI * 180; };

	m.Matrix2D = function(arg){
		// summary:
		//		a 2D matrix object
		// description:
		//		Normalizes a 2D matrix-like object. If arrays is passed,
		//		all objects of the array are normalized and multiplied sequentially.
		// arg: Object
		//		a 2D matrix-like object, a number, or an array of such objects
		if(arg){
			if(typeof arg == "number"){
				this.xx = this.yy = arg;
			}else if(arg instanceof Array){
				if(arg.length > 0){
					var matrix = m.normalize(arg[0]);
					// combine matrices
					for(var i = 1; i < arg.length; ++i){
						var l = matrix, r = m.normalize(arg[i]);
						matrix = new m.Matrix2D();
						matrix.xx = l.xx * r.xx + l.xy * r.yx;
						matrix.xy = l.xx * r.xy + l.xy * r.yy;
						matrix.yx = l.yx * r.xx + l.yy * r.yx;
						matrix.yy = l.yx * r.xy + l.yy * r.yy;
						matrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
						matrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
					}
					lang.mixin(this, matrix);
				}
			}else{
				lang.mixin(this, arg);
			}
		}
	};

	// the default (identity) matrix, which is used to fill in missing values
	lang.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});

	lang.mixin(m, {
		// summary:
		//		class constants, and methods of dojox/gfx/matrix

		// matrix constants

		// identity: dojox/gfx/matrix.Matrix2D
		//		an identity matrix constant: identity * (x, y) == (x, y)
		identity: new m.Matrix2D(),

		// flipX: dojox/gfx/matrix.Matrix2D
		//		a matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)
		flipX:    new m.Matrix2D({xx: -1}),

		// flipY: dojox/gfx/matrix.Matrix2D
		//		a matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)
		flipY:    new m.Matrix2D({yy: -1}),

		// flipXY: dojox/gfx/matrix.Matrix2D
		//		a matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)
		flipXY:   new m.Matrix2D({xx: -1, yy: -1}),

		// matrix creators

		translate: function(a, b){
			// summary:
			//		forms a translation matrix
			// description:
			//		The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number|dojox/gfx.Point
			//		an x coordinate value, or a point-like object, which specifies offsets for both dimensions
			// b: Number?
			//		a y coordinate value
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 1){
				return new m.Matrix2D({dx: a, dy: b}); // dojox/gfx/matrix.Matrix2D
			}
			// branch
			return new m.Matrix2D({dx: a.x, dy: a.y}); // dojox/gfx/matrix.Matrix2D
		},
		scale: function(a, b){
			// summary:
			//		forms a scaling matrix
			// description:
			//		The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number|dojox/gfx.Point
			//		a scaling factor used for the x coordinate, or
			//		a uniform scaling factor used for the both coordinates, or
			//		a point-like object, which specifies scale factors for both dimensions
			// b: Number?
			//		a scaling factor used for the y coordinate
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 1){
				return new m.Matrix2D({xx: a, yy: b}); // dojox/gfx/matrix.Matrix2D
			}
			if(typeof a == "number"){
				return new m.Matrix2D({xx: a, yy: a}); // dojox/gfx/matrix.Matrix2D
			}
			return new m.Matrix2D({xx: a.x, yy: a.y}); // dojox/gfx/matrix.Matrix2D
		},
		rotate: function(angle){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// returns: dojox/gfx/matrix.Matrix2D
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			return new m.Matrix2D({xx: c, xy: -s, yx: s, yy: c}); // dojox/gfx/matrix.Matrix2D
		},
		rotateg: function(degree){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.rotate() for comparison.
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// returns: dojox/gfx/matrix.Matrix2D
			return m.rotate(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D
		},
		skewX: function(angle) {
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: dojox/gfx/matrix.Matrix2D
			return new m.Matrix2D({xy: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D
		},
		skewXg: function(degree){
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.skewX() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: dojox/gfx/matrix.Matrix2D
			return m.skewX(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D
		},
		skewY: function(angle){
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: dojox/gfx/matrix.Matrix2D
			return new m.Matrix2D({yx: Math.tan(angle)}); // dojox/gfx/matrix.Matrix2D
		},
		skewYg: function(degree){
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.skewY() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: dojox/gfx/matrix.Matrix2D
			return m.skewY(m._degToRad(degree)); // dojox/gfx/matrix.Matrix2D
		},
		reflect: function(a, b){
			// summary:
			//		forms a reflection matrix
			// description:
			//		The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox/gfx.Point|Number
			//		a point-like object, which specifies a vector of reflection, or an X value
			// b: Number?
			//		a Y value
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = 2 * a * b / n2;
			return new m.Matrix2D({xx: 2 * a2 / n2 - 1, xy: xy, yx: xy, yy: 2 * b2 / n2 - 1}); // dojox/gfx/matrix.Matrix2D
		},
		project: function(a, b){
			// summary:
			//		forms an orthogonal projection matrix
			// description:
			//		The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a: dojox/gfx.Point|Number
			//		a point-like object, which specifies a vector of projection, or
			//		an x coordinate value
			// b: Number?
			//		a y coordinate value
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = a * b / n2;
			return new m.Matrix2D({xx: a2 / n2, xy: xy, yx: xy, yy: b2 / n2}); // dojox/gfx/matrix.Matrix2D
		},

		// ensure matrix 2D conformance
		normalize: function(matrix){
			// summary:
			//		converts an object to a matrix, if necessary
			// description:
			//		Converts any 2D matrix-like object or an array of
			//		such objects to a valid dojox/gfx/matrix.Matrix2D object.
			// matrix: Object
			//		an object, which is converted to a matrix, if necessary
			// returns: dojox/gfx/matrix.Matrix2D
			return (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox/gfx/matrix.Matrix2D
		},

		// common operations

		isIdentity: function(matrix){
			// summary:
			//		returns whether the specified matrix is the identity.
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix object to be tested
			// returns: Boolean
			return matrix.xx == 1 && matrix.xy == 0 && matrix.yx == 0 && matrix.yy == 1 && matrix.dx == 0 && matrix.dy == 0; // Boolean
		},
		clone: function(matrix){
			// summary:
			//		creates a copy of a 2D matrix
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix-like object to be cloned
			// returns: dojox/gfx/matrix.Matrix2D
			var obj = new m.Matrix2D();
			for(var i in matrix){
				if(typeof(matrix[i]) == "number" && typeof(obj[i]) == "number" && obj[i] != matrix[i]) obj[i] = matrix[i];
			}
			return obj; // dojox/gfx/matrix.Matrix2D
		},
		invert: function(matrix){
			// summary:
			//		inverts a 2D matrix
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix-like object to be inverted
			// returns: dojox/gfx/matrix.Matrix2D
			var M = m.normalize(matrix),
				D = M.xx * M.yy - M.xy * M.yx;
				M = new m.Matrix2D({
					xx: M.yy/D, xy: -M.xy/D,
					yx: -M.yx/D, yy: M.xx/D,
					dx: (M.xy * M.dy - M.yy * M.dx) / D,
					dy: (M.yx * M.dx - M.xx * M.dy) / D
				});
			return M; // dojox/gfx/matrix.Matrix2D
		},
		_multiplyPoint: function(matrix, x, y){
			// summary:
			//		applies a matrix to a point
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix object to be applied
			// x: Number
			//		an x coordinate of a point
			// y: Number
			//		a y coordinate of a point
			// returns: dojox/gfx.Point
			return {x: matrix.xx * x + matrix.xy * y + matrix.dx, y: matrix.yx * x + matrix.yy * y + matrix.dy}; // dojox/gfx.Point
		},
		multiplyPoint: function(matrix, /* Number||Point */ a, /* Number? */ b){
			// summary:
			//		applies a matrix to a point
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix object to be applied
			// a: Number|dojox/gfx.Point
			//		an x coordinate of a point, or a point
			// b: Number?
			//		a y coordinate of a point
			// returns: dojox/gfx.Point
			var M = m.normalize(matrix);
			if(typeof a == "number" && typeof b == "number"){
				return m._multiplyPoint(M, a, b); // dojox/gfx.Point
			}
			return m._multiplyPoint(M, a.x, a.y); // dojox/gfx.Point
		},
		multiplyRectangle: function(matrix, /*Rectangle*/ rect){
			// summary:
			//		Applies a matrix to a rectangle.
			// description:
			//		The method applies the transformation on all corners of the
			//		rectangle and returns the smallest rectangle enclosing the 4 transformed
			//		points.
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix object to be applied.
			// rect: Rectangle
			//		the rectangle to transform.
			// returns: dojox/gfx.Rectangle
			var M = m.normalize(matrix);
			rect = rect || {x:0, y:0, width:0, height:0}; 
			if(m.isIdentity(M))
				return {x: rect.x, y: rect.y, width: rect.width, height: rect.height}; // dojo/gfx.Rectangle
			var p0 = m.multiplyPoint(M, rect.x, rect.y),
				p1 = m.multiplyPoint(M, rect.x, rect.y + rect.height),
				p2 = m.multiplyPoint(M, rect.x + rect.width, rect.y),
				p3 = m.multiplyPoint(M, rect.x + rect.width, rect.y + rect.height),
				minx = Math.min(p0.x, p1.x, p2.x, p3.x),
				miny = Math.min(p0.y, p1.y, p2.y, p3.y),
				maxx = Math.max(p0.x, p1.x, p2.x, p3.x),
				maxy = Math.max(p0.y, p1.y, p2.y, p3.y);
			return{ // dojo/gfx.Rectangle
				x: minx,
				y: miny,
				width: maxx - minx,
				height: maxy - miny
			};
		},
		multiply: function(matrix){
			// summary:
			//		combines matrices by multiplying them sequentially in the given order
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too
			var M = m.normalize(matrix);
			// combine matrices
			for(var i = 1; i < arguments.length; ++i){
				var l = M, r = m.normalize(arguments[i]);
				M = new m.Matrix2D();
				M.xx = l.xx * r.xx + l.xy * r.yx;
				M.xy = l.xx * r.xy + l.xy * r.yy;
				M.yx = l.yx * r.xx + l.yy * r.yx;
				M.yy = l.yx * r.xy + l.yy * r.yy;
				M.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
				M.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
			}
			return M; // dojox/gfx/matrix.Matrix2D
		},

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary:
			//		applies a matrix at a central point
			// matrix: dojox/gfx/matrix.Matrix2D
			//		a 2D matrix-like object, which is applied at a central point
			// x: Number
			//		an x component of the central point
			// y: Number
			//		a y component of the central point
			return m.multiply(m.translate(x, y), matrix, m.translate(-x, -y)); // dojox/gfx/matrix.Matrix2D
		},
		scaleAt: function(a, b, c, d){
			// summary:
			//		scales a picture using a specified point as a center of scaling
			// description:
			//		Compare with dojox/gfx/matrix.scale().
			// a: Number
			//		a scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates
			// b: Number?
			//		a scaling factor used for the y coordinate
			// c: Number|Point
			//		an x component of a central point, or a central point
			// d: Number
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return m._sandwich(m.scale(a, b), c, d); // dojox/gfx/matrix.Matrix2D
				case 3:
					if(typeof c == "number"){
						return m._sandwich(m.scale(a), b, c); // dojox/gfx/matrix.Matrix2D
					}
					return m._sandwich(m.scale(a, b), c.x, c.y); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.scale(a), b.x, b.y); // dojox/gfx/matrix.Matrix2D
		},
		rotateAt: function(angle, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with dojox/gfx/matrix.rotate().
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.rotate(angle), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.rotate(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		},
		rotategAt: function(degree, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with dojox/gfx/matrix.rotateg().
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.rotateg(degree), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.rotateg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		},
		skewXAt: function(angle, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with dojox/gfx/matrix.skewX().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.skewX(angle), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.skewX(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		},
		skewXgAt: function(degree, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with dojox/gfx/matrix.skewXg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.skewXg(degree), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.skewXg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		},
		skewYAt: function(angle, a, b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with dojox/gfx/matrix.skewY().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.skewY(angle), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.skewY(angle), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with dojox/gfx/matrix.skewYg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: dojox/gfx/matrix.Matrix2D
			if(arguments.length > 2){
				return m._sandwich(m.skewYg(degree), a, b); // dojox/gfx/matrix.Matrix2D
			}
			return m._sandwich(m.skewYg(degree), a.x, a.y); // dojox/gfx/matrix.Matrix2D
		}

		//TODO: rect-to-rect mapping, scale-to-fit (isotropic and anisotropic versions)

	});
	// propagate Matrix2D up
	g.Matrix2D = m.Matrix2D;

	return m;
});



},
'dojox/gfx/_base':function(){
define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/Color", "dojo/_base/sniff", "dojo/_base/window",
	    "dojo/_base/array","dojo/dom", "dojo/dom-construct","dojo/dom-geometry"],
function(kernel, lang, Color, has, win, arr, dom, domConstruct, domGeom){
	// module:
	//		dojox/gfx
	// summary:
	//		This module contains common core Graphics API used by different graphics renderers.

	var g = lang.getObject("dojox.gfx", true),
		b = g._base = {};
	
	// candidates for dojox.style (work on VML and SVG nodes)
	g._hasClass = function(/*DomNode*/node, /*String*/classStr){
		// summary:
		//		Returns whether or not the specified classes are a portion of the
		//		class list currently applied to the node.
		
		// return (new RegExp('(^|\\s+)'+classStr+'(\\s+|$)')).test(node.className)	// Boolean
		var cls = node.getAttribute("className");
		return cls && (" " + cls + " ").indexOf(" " + classStr + " ") >= 0;  // Boolean
	};
	g._addClass = function(/*DomNode*/node, /*String*/classStr){
		// summary:
		//		Adds the specified classes to the end of the class list on the
		//		passed node.
		var cls = node.getAttribute("className") || "";
		if(!cls || (" " + cls + " ").indexOf(" " + classStr + " ") < 0){
			node.setAttribute("className", cls + (cls ? " " : "") + classStr);
		}
	};
	g._removeClass = function(/*DomNode*/node, /*String*/classStr){
		// summary:
		//		Removes classes from node.
		var cls = node.getAttribute("className");
		if(cls){
			node.setAttribute(
				"className",
				cls.replace(new RegExp('(^|\\s+)' + classStr + '(\\s+|$)'), "$1$2")
			);
		}
	};

	// candidate for dojox.html.metrics (dynamic font resize handler is not implemented here)

	//		derived from Morris John's emResized measurer
	b._getFontMeasurements = function(){
		// summary:
		//		Returns an object that has pixel equivilents of standard font
		//		size values.
		var heights = {
			'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,
			'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,
			'xx-large': 0
		};
		var p, oldStyle;	
		if(has("ie")){
			//	We do a font-size fix if and only if one isn't applied already.
			// NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			oldStyle = win.doc.documentElement.style.fontSize || "";
			if(!oldStyle){
				win.doc.documentElement.style.fontSize="100%";
			}
		}

		//		set up the measuring node.
		var div = domConstruct.create("div", {style: {
				position: "absolute",
				left: "0",
				top: "-100px",
				width: "30px",
				height: "1000em",
				borderWidth: "0",
				margin: "0",
				padding: "0",
				outline: "none",
				lineHeight: "1",
				overflow: "hidden"
			}}, win.body());

		//		do the measurements.
		for(p in heights){
			div.style.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}

		if(has("ie")){
			// Restore the font to its old style.
			win.doc.documentElement.style.fontSize = oldStyle;
		}
		win.body().removeChild(div);
		return heights; //object
	};

	var fontMeasurements = null;

	b._getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = b._getFontMeasurements();
		}
		return fontMeasurements;
	};

	// candidate for dojox.html.metrics

	var measuringNode = null, empty = {};
	b._getTextBox = function(	/*String*/ text,
								/*Object*/ style,
								/*String?*/ className){
		var m, s, al = arguments.length;
		var i, box;
		if(!measuringNode){
			measuringNode = domConstruct.create("div", {style: {
				position: "absolute",
				top: "-10000px",
				left: "0",
				visibility: "hidden"
			}}, win.body());
		}
		m = measuringNode;
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(al > 1 && style){
			for(i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(al > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;

		if(m.getBoundingClientRect){
			var bcr = m.getBoundingClientRect();
			box = {l: bcr.left, t: bcr.top, w: bcr.width || (bcr.right - bcr.left), h: bcr.height || (bcr.bottom - bcr.top)};
		}else{
			box = domGeom.getMarginBox(m);
		}
		m.innerHTML = "";
		return box;
	};

	b._computeTextLocation = function(/*g.defaultTextShape*/textShape, /*Number*/width, /*Number*/height, /*Boolean*/fixHeight) {
		var loc = {}, align = textShape.align;
		switch (align) {
			case 'end':
				loc.x = textShape.x - width;
				break;
			case 'middle':
				loc.x = textShape.x - width / 2;
				break;
			default:
				loc.x = textShape.x;
				break;
		}
		var c = fixHeight ? 0.75 : 1;
		loc.y = textShape.y - height*c; // **rough** approximation of the ascent...
		return loc;
	};
	b._computeTextBoundingBox = function(/*shape.Text*/s){
		// summary:
		//		Compute the bbox of the given shape.Text instance. Note that this method returns an
		//		approximation of the bbox, and should be used when the underlying renderer cannot provide precise metrics.
		if(!g._base._isRendered(s)){
			return {x:0, y:0, width:0, height:0};
		}
		var loc, textShape = s.getShape(),
			font = s.getFont() || g.defaultFont,
			w = s.getTextWidth(),
			h = g.normalizedLength(font.size);
		loc = b._computeTextLocation(textShape, w, h, true);
		return {
			x: loc.x,
			y: loc.y,
			width: w,
			height: h
		};
	};
	b._isRendered = function(/*Shape*/s){
		var p = s.parent;
		while(p && p.getParent){
			p = p.parent;
		}
		return p !== null;
	};

	// candidate for dojo.dom

	var uniqueId = 0;
	b._getUniqueId = function(){
		// summary:
		//		returns a unique string for use with any DOM element
		var id;
		do{
			id = kernel._scopeName + "xUnique" + (++uniqueId);
		}while(dom.byId(id));
		return id;
	};

	// IE10

	b._fixMsTouchAction = function(/*dojox/gfx/shape.Surface*/surface){
		var r = surface.rawNode;
		if (typeof r.style.msTouchAction != 'undefined')
			r.style.msTouchAction = "none";
	};

	/*=====
	g.Stroke = {
		// summary:
		//		A stroke defines stylistic properties that are used when drawing a path.

		// color: String
		//		The color of the stroke, default value 'black'.
		color: "black",

		// style: String
		//		The style of the stroke, one of 'solid', ... . Default value 'solid'.
		style: "solid",

		// width: Number
		//		The width of a stroke, default value 1.
		width: 1,

		// cap: String
		//		The endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.
		cap: "butt",

		// join: Number
		//		The join style to use when combining path segments. Default value 4.
		join: 4
	};
	
	g.Fill = {
		// summary:
		//		Defines how to fill a shape. Four types of fills can be used: solid, linear gradient, radial gradient and pattern.
		//		See dojox/gfx.LinearGradient, dojox/gfx.RadialGradient and dojox/gfx.Pattern respectively for more information about the properties supported by each type.
		
		// type: String?
		//		The type of fill. One of 'linear', 'radial', 'pattern' or undefined. If not specified, a solid fill is assumed.
		type:"",
		
		// color: String|dojo/Color?
		//		The color of a solid fill type.
		color:null,
		
	};
	
	g.LinearGradient = {
		// summary:
		//		An object defining the default stylistic properties used for Linear Gradient fills.
		//		Linear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.

		// type: String
		//		Specifies this object is a Linear Gradient, value 'linear'
		type: "linear",

		// x1: Number
		//		The X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
		x1: 0,

		// y1: Number
		//		The Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
		y1: 0,

		// x2: Number
		//		The X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
		x2: 100,

		// y2: Number
		//		The Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
		y2: 100,

		// colors: Array
		//		An array of colors at given offsets (from the start of the line).  The start of the line is
		//		defined at offest 0 with the end of the line at offset 1.
		//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.
		colors: []
	};
	
	g.RadialGradient = {
		// summary:
		//		Specifies the properties for RadialGradients using in fills patterns.

		// type: String
		//		Specifies this is a RadialGradient, value 'radial'
		type: "radial",

		// cx: Number
		//		The X coordinate of the center of the radial gradient, default value 0.
		cx: 0,

		// cy: Number
		//		The Y coordinate of the center of the radial gradient, default value 0.
		cy: 0,

		// r: Number
		//		The radius to the end of the radial gradient, default value 100.
		r: 100,

		// colors: Array
		//		An array of colors at given offsets (from the center of the radial gradient).
		//		The center is defined at offest 0 with the outer edge of the gradient at offset 1.
		//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.
		colors: []
	};
	
	g.Pattern = {
		// summary:
		//		An object specifying the default properties for a Pattern using in fill operations.

		// type: String
		//		Specifies this object is a Pattern, value 'pattern'.
		type: "pattern",

		// x: Number
		//		The X coordinate of the position of the pattern, default value is 0.
		x: 0,

		// y: Number
		//		The Y coordinate of the position of the pattern, default value is 0.
		y: 0,

		// width: Number
		//		The width of the pattern image, default value is 0.
		width: 0,

		// height: Number
		//		The height of the pattern image, default value is 0.
		height: 0,

		// src: String
		//		A url specifying the image to use for the pattern.
		src: ""
	};

	g.Text = {
		//	summary:
		//		A keyword argument object defining both the text to be rendered in a VectorText shape,
		//		and specifying position, alignment, and fitting.
		//	text: String
		//		The text to be rendered.
		//	x: Number?
		//		The left coordinate for the text's bounding box.
		//	y: Number?
		//		The top coordinate for the text's bounding box.
		//	width: Number?
		//		The width of the text's bounding box.
		//	height: Number?
		//		The height of the text's bounding box.
		//	align: String?
		//		The alignment of the text, as defined in SVG. Can be "start", "end" or "middle".
		//	fitting: Number?
		//		How the text is to be fitted to the bounding box. Can be 0 (no fitting), 1 (fitting based on
		//		passed width of the bounding box and the size of the font), or 2 (fit text to the bounding box,
		//		and ignore any size parameters).
		//	leading: Number?
		//		The leading to be used between lines in the text.
		//	decoration: String?
		//		Any text decoration to be used.
	};

	g.Font = {
		// summary:
		//		An object specifying the properties for a Font used in text operations.
	
		// type: String
		//		Specifies this object is a Font, value 'font'.
		type: "font",
	
		// style: String
		//		The font style, one of 'normal', 'bold', default value 'normal'.
		style: "normal",
	
		// variant: String
		//		The font variant, one of 'normal', ... , default value 'normal'.
		variant: "normal",
	
		// weight: String
		//		The font weight, one of 'normal', ..., default value 'normal'.
		weight: "normal",
	
		// size: String
		//		The font size (including units), default value '10pt'.
		size: "10pt",
	
		// family: String
		//		The font family, one of 'serif', 'sanserif', ..., default value 'serif'.
		family: "serif"
	};

	=====*/

	lang.mixin(g, {
		// summary:
		//		defines constants, prototypes, and utility functions for the core Graphics API

		// default shapes, which are used to fill in missing parameters
		defaultPath: {
			// summary:
			//		Defines the default Path prototype object.

			// type: String
			//		Specifies this object is a Path, default value 'path'.
			type: "path", 

			// path: String
			//		The path commands. See W32C SVG 1.0 specification.
			//		Defaults to empty string value.
			path: ""
		},
		defaultPolyline: {
			// summary:
			//		Defines the default PolyLine prototype.

			// type: String
			//		Specifies this object is a PolyLine, default value 'polyline'.
			type: "polyline",

			// points: Array
			//		An array of point objects [{x:0,y:0},...] defining the default polyline's line segments. Value is an empty array [].
			points: []
		},
		defaultRect: {
			// summary:
			//		Defines the default Rect prototype.

			// type: String
			//		Specifies this default object is a type of Rect. Value is 'rect'
			type: "rect",

			// x: Number
			//		The X coordinate of the default rectangles position, value 0.
			x: 0,

			// y: Number
			//		The Y coordinate of the default rectangle's position, value 0.
			y: 0,

			// width: Number
			//		The width of the default rectangle, value 100.
			width: 100,

			// height: Number
			//		The height of the default rectangle, value 100.
			height: 100,

			// r: Number
			//		The corner radius for the default rectangle, value 0.
			r: 0
		},
		defaultEllipse: {
			// summary:
			//		Defines the default Ellipse prototype.

			// type: String
			//		Specifies that this object is a type of Ellipse, value is 'ellipse'
			type: "ellipse",

			// cx: Number
			//		The X coordinate of the center of the ellipse, default value 0.
			cx: 0,

			// cy: Number
			//		The Y coordinate of the center of the ellipse, default value 0.
			cy: 0,

			// rx: Number
			//		The radius of the ellipse in the X direction, default value 200.
			rx: 200,

			// ry: Number
			//		The radius of the ellipse in the Y direction, default value 200.
			ry: 100
		},
		defaultCircle: {
			// summary:
			//		An object defining the default Circle prototype.

			// type: String
			//		Specifies this object is a circle, value 'circle'
			type: "circle",

			// cx: Number
			//		The X coordinate of the center of the circle, default value 0.
			cx: 0,
			// cy: Number
			//		The Y coordinate of the center of the circle, default value 0.
			cy: 0,

			// r: Number
			//		The radius, default value 100.
			r: 100
		},
		defaultLine: {
			// summary:
			//		An object defining the default Line prototype.

			// type: String
			//		Specifies this is a Line, value 'line'
			type: "line",

			// x1: Number
			//		The X coordinate of the start of the line, default value 0.
			x1: 0,

			// y1: Number
			//		The Y coordinate of the start of the line, default value 0.
			y1: 0,

			// x2: Number
			//		The X coordinate of the end of the line, default value 100.
			x2: 100,

			// y2: Number
			//		The Y coordinate of the end of the line, default value 100.
			y2: 100
		},
		defaultImage: {
			// summary:
			//		Defines the default Image prototype.

			// type: String
			//		Specifies this object is an image, value 'image'.
			type: "image",

			// x: Number
			//		The X coordinate of the image's position, default value 0.
			x: 0,

			// y: Number
			//		The Y coordinate of the image's position, default value 0.
			y: 0,

			// width: Number
			//		The width of the image, default value 0.
			width: 0,

			// height: Number
			//		The height of the image, default value 0.
			height: 0,

			// src: String
			//		The src url of the image, defaults to empty string.
			src: ""
		},
		defaultText: {
			// summary:
			//		Defines the default Text prototype.

			// type: String
			//		Specifies this is a Text shape, value 'text'.
			type: "text",

			// x: Number
			//		The X coordinate of the text position, default value 0.
			x: 0,

			// y: Number
			//		The Y coordinate of the text position, default value 0.
			y: 0,

			// text: String
			//		The text to be displayed, default value empty string.
			text: "",

			// align:	String
			//		The horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.
			align: "start",

			// decoration: String
			//		The text decoration , one of 'none', ... . Default value 'none'.
			decoration: "none",

			// rotated: Boolean
			//		Whether the text is rotated, boolean default value false.
			rotated: false,

			// kerning: Boolean
			//		Whether kerning is used on the text, boolean default value true.
			kerning: true
		},
		defaultTextPath: {
			// summary:
			//		Defines the default TextPath prototype.

			// type: String
			//		Specifies this is a TextPath, value 'textpath'.
			type: "textpath",

			// text: String
			//		The text to be displayed, default value empty string.
			text: "",

			// align: String
			//		The horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.
			align: "start",

			// decoration: String
			//		The text decoration , one of 'none', ... . Default value 'none'.
			decoration: "none",

			// rotated: Boolean
			//		Whether the text is rotated, boolean default value false.
			rotated: false,

			// kerning: Boolean
			//		Whether kerning is used on the text, boolean default value true.
			kerning: true
		},

		// default stylistic attributes
		defaultStroke: {
			// summary:
			//		A stroke defines stylistic properties that are used when drawing a path.
			//		This object defines the default Stroke prototype.
			// type: String
			//		Specifies this object is a type of Stroke, value 'stroke'.
			type: "stroke",

			// color: String
			//		The color of the stroke, default value 'black'.
			color: "black",

			// style: String
			//		The style of the stroke, one of 'solid', ... . Default value 'solid'.
			style: "solid",

			// width: Number
			//		The width of a stroke, default value 1.
			width: 1,

			// cap: String
			//		The endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.
			cap: "butt",

			// join: Number
			//		The join style to use when combining path segments. Default value 4.
			join: 4
		},
		defaultLinearGradient: {
			// summary:
			//		An object defining the default stylistic properties used for Linear Gradient fills.
			//		Linear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.

			// type: String
			//		Specifies this object is a Linear Gradient, value 'linear'
			type: "linear",

			// x1: Number
			//		The X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
			x1: 0,

			// y1: Number
			//		The Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
			y1: 0,

			// x2: Number
			//		The X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
			x2: 100,

			// y2: Number
			//		The Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
			y2: 100,

			// colors: Array
			//		An array of colors at given offsets (from the start of the line).  The start of the line is
			//		defined at offest 0 with the end of the line at offset 1.
			//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.
			colors: [
				{ offset: 0, color: "black" }, { offset: 1, color: "white" }
			]
		},
		defaultRadialGradient: {
			// summary:
			//		An object specifying the default properties for RadialGradients using in fills patterns.

			// type: String
			//		Specifies this is a RadialGradient, value 'radial'
			type: "radial",

			// cx: Number
			//		The X coordinate of the center of the radial gradient, default value 0.
			cx: 0,

			// cy: Number
			//		The Y coordinate of the center of the radial gradient, default value 0.
			cy: 0,

			// r: Number
			//		The radius to the end of the radial gradient, default value 100.
			r: 100,

			// colors: Array
			//		An array of colors at given offsets (from the center of the radial gradient).
			//		The center is defined at offest 0 with the outer edge of the gradient at offset 1.
			//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white.
			colors: [
				{ offset: 0, color: "black" }, { offset: 1, color: "white" }
			]
		},
		defaultPattern: {
			// summary:
			//		An object specifying the default properties for a Pattern using in fill operations.

			// type: String
			//		Specifies this object is a Pattern, value 'pattern'.
			type: "pattern",

			// x: Number
			//		The X coordinate of the position of the pattern, default value is 0.
			x: 0,

			// y: Number
			//		The Y coordinate of the position of the pattern, default value is 0.
			y: 0,

			// width: Number
			//		The width of the pattern image, default value is 0.
			width: 0,

			// height: Number
			//		The height of the pattern image, default value is 0.
			height: 0,

			// src: String
			//		A url specifying the image to use for the pattern.
			src: ""
		},
		defaultFont: {
			// summary:
			//		An object specifying the default properties for a Font used in text operations.

			// type: String
			//		Specifies this object is a Font, value 'font'.
			type: "font",

			// style: String
			//		The font style, one of 'normal', 'bold', default value 'normal'.
			style: "normal",

			// variant: String
			//		The font variant, one of 'normal', ... , default value 'normal'.
			variant: "normal",

			// weight: String
			//		The font weight, one of 'normal', ..., default value 'normal'.
			weight: "normal",

			// size: String
			//		The font size (including units), default value '10pt'.
			size: "10pt",

			// family: String
			//		The font family, one of 'serif', 'sanserif', ..., default value 'serif'.
			family: "serif"
		},

		getDefault: (function(){
			// summary:
			//		Returns a function used to access default memoized prototype objects (see them defined above).
			var typeCtorCache = {};
			// a memoized delegate()
			return function(/*String*/ type){
				var t = typeCtorCache[type];
				if(t){
					return new t();
				}
				t = typeCtorCache[type] = new Function();
				t.prototype = g[ "default" + type ];
				return new t();
			}
		})(),

		normalizeColor: function(/*dojo/Color|Array|string|Object*/ color){
			// summary:
			//		converts any legal color representation to normalized
			//		dojo/Color object
			// color:
			//		A color representation.
			return (color instanceof Color) ? color : new Color(color); // dojo/Color
		},
		normalizeParameters: function(existed, update){
			// summary:
			//		updates an existing object with properties from an 'update'
			//		object
			// existed: Object
			//		the target object to be updated
			// update: Object
			//		the 'update' object, whose properties will be used to update
			//		the existed object
			var x;
			if(update){
				var empty = {};
				for(x in existed){
					if(x in update && !(x in empty)){
						existed[x] = update[x];
					}
				}
			}
			return existed;	// Object
		},
		makeParameters: function(defaults, update){
			// summary:
			//		copies the original object, and all copied properties from the
			//		'update' object
			// defaults: Object
			//		the object to be cloned before updating
			// update: Object
			//		the object, which properties are to be cloned during updating
			// returns: Object
			//      new object with new and default properties
			var i = null;
			if(!update){
				// return dojo.clone(defaults);
				return lang.delegate(defaults);
			}
			var result = {};
			for(i in defaults){
				if(!(i in result)){
					result[i] = lang.clone((i in update) ? update[i] : defaults[i]);
				}
			}
			return result; // Object
		},
		formatNumber: function(x, addSpace){
			// summary:
			//		converts a number to a string using a fixed notation
			// x: Number
			//		number to be converted
			// addSpace: Boolean
			//		whether to add a space before a positive number
			// returns: String
			//      the formatted value
			var val = x.toString();
			if(val.indexOf("e") >= 0){
				val = x.toFixed(4);
			}else{
				var point = val.indexOf(".");
				if(point >= 0 && val.length - point > 5){
					val = x.toFixed(4);
				}
			}
			if(x < 0){
				return val; // String
			}
			return addSpace ? " " + val : val; // String
		},
		// font operations
		makeFontString: function(font){
			// summary:
			//		converts a font object to a CSS font string
			// font: Object
			//		font object (see dojox/gfx.defaultFont)
			return font.style + " " + font.variant + " " + font.weight + " " + font.size + " " + font.family; // Object
		},
		splitFontString: function(str){
			// summary:
			//		converts a CSS font string to a font object
			// description:
			//		Converts a CSS font string to a gfx font object. The CSS font
			//		string components should follow the W3C specified order
			//		(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
			//		style, variant, weight, size, optional line height (will be
			//		ignored), and family. Note that the Font.size attribute is limited to numeric CSS length.
			// str: String
			//		a CSS font string.
			// returns: Object
			//      object in dojox/gfx.defaultFont format
			var font = g.getDefault("Font");
			var t = str.split(/\s+/);
			do{
				if(t.length < 5){ break; }
				font.style   = t[0];
				font.variant = t[1];
				font.weight  = t[2];
				var i = t[3].indexOf("/");
				font.size = i < 0 ? t[3] : t[3].substring(0, i);
				var j = 4;
				if(i < 0){
					if(t[4] == "/"){
						j = 6;
					}else if(t[4].charAt(0) == "/"){
						j = 5;
					}
				}
				if(j < t.length){
					font.family = t.slice(j).join(" ");
				}
			}while(false);
			return font;	// Object
		},
		// length operations

		// cm_in_pt: Number
		//		points per centimeter (constant)
		cm_in_pt: 72 / 2.54,

		// mm_in_pt: Number
		//		points per millimeter (constant)
		mm_in_pt: 7.2 / 2.54,

		px_in_pt: function(){
			// summary:
			//		returns the current number of pixels per point.
			return g._base._getCachedFontMeasurements()["12pt"] / 12;	// Number
		},

		pt2px: function(len){
			// summary:
			//		converts points to pixels
			// len: Number
			//		a value in points
			return len * g.px_in_pt();	// Number
		},

		px2pt: function(len){
			// summary:
			//		converts pixels to points
			// len: Number
			//		a value in pixels
			return len / g.px_in_pt();	// Number
		},

		normalizedLength: function(len) {
			// summary:
			//		converts any length value to pixels
			// len: String
			//		a length, e.g., '12pc'
			// returns: Number
			//      pixels
			if(len.length === 0){ return 0; }
			if(len.length > 2){
				var px_in_pt = g.px_in_pt();
				var val = parseFloat(len);
				switch(len.slice(-2)){
					case "px": return val;
					case "pt": return val * px_in_pt;
					case "in": return val * 72 * px_in_pt;
					case "pc": return val * 12 * px_in_pt;
					case "mm": return val * g.mm_in_pt * px_in_pt;
					case "cm": return val * g.cm_in_pt * px_in_pt;
				}
			}
			return parseFloat(len);	// Number
		},

		// pathVmlRegExp: RegExp
		//		a constant regular expression used to split a SVG/VML path into primitive components
		// tags:
		//		private
		pathVmlRegExp: /([A-Za-z]+)|(\d+(\.\d+)?)|(\.\d+)|(-\d+(\.\d+)?)|(-\.\d+)/g,

		// pathVmlRegExp: RegExp
		//		a constant regular expression used to split a SVG/VML path into primitive components
		// tags:
		//		private
		pathSvgRegExp: /([A-DF-Za-df-z])|([-+]?\d*[.]?\d+(?:[eE][-+]?\d+)?)/g,

		equalSources: function(a, b){
			// summary:
			//		compares event sources, returns true if they are equal
			// a: Object
			//		first event source
			// b: Object
			//		event source to compare against a
			// returns: Boolean
			//      true, if objects are truthy and the same
			return a && b && a === b;
		},

		switchTo: function(/*String|Object*/ renderer){
			// summary:
			//		switch the graphics implementation to the specified renderer.
			// renderer:
			//		Either the string name of a renderer (eg. 'canvas', 'svg, ...) or the renderer
			//		object to switch to.
			var ns = typeof renderer == "string" ? g[renderer] : renderer;
			if(ns){
				// If more options are added, update the docblock at the end of shape.js!
				arr.forEach(["Group", "Rect", "Ellipse", "Circle", "Line",
						"Polyline", "Image", "Text", "Path", "TextPath",
						"Surface", "createSurface", "fixTarget"], function(name){
					g[name] = ns[name];
				});
				if(typeof renderer == "string"){
					g.renderer = renderer;
				}else{
					arr.some(["svg","vml","canvas","canvasWithEvents","silverlight"], function(r){
						return (g.renderer = g[r] && g[r].Surface === g.Surface ? r : null);
					});
				}
			}
		}
	});
	
	/*=====
		g.createSurface = function(parentNode, width, height){
			// summary:
			//		creates a surface
			// parentNode: Node
			//		a parent node
			// width: String|Number
			//		width of surface, e.g., "100px" or 100
			// height: String|Number
			//		height of surface, e.g., "100px" or 100
			// returns: dojox/gfx.Surface
			//     newly created surface
		};
		g.fixTarget = function(){
			// tags:
			//		private
		};
	=====*/
	
	return g; // defaults object api
});

},
'esri/basemaps':function(){
//>>built
define(["dojo/has", "./kernel", "dojo/i18n!./nls/jsapi"], function(b, c, a) {
    return {
        streets: {
            title: a.basemaps.streets,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/d8855ee4d3d74413babfb0f41203b168/info/thumbnail/world_street_map.jpg",
            itemId: "d8855ee4d3d74413babfb0f41203b168",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer"
            }]
        },
        satellite: {
            title: a.basemaps.satellite,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/86de95d4e0244cba80f0fa2c9403a7b2/info/thumbnail/tempimagery.jpg",
            itemId: "86de95d4e0244cba80f0fa2c9403a7b2",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
            }]
        },
        hybrid: {
            title: a.basemaps.hybrid,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/413fd05bbd7342f5991d5ec96f4f8b18/info/thumbnail/tempimagery_with_labels_ne_usa.png",
            itemId: "413fd05bbd7342f5991d5ec96f4f8b18",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
            }, {
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer",
                isReference: !0
            }]
        },
        terrain: {
            title: a.basemaps.terrain,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/aab054ab883c4a4094c72e949566ad40/info/thumbnail/tempTerrain_with_labels_ne_usa.png",
            itemId: "aab054ab883c4a4094c72e949566ad40",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer"
            }, {
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer",
                isReference: !0
            }]
        },
        topo: {
            title: a.basemaps.topo,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/6e03e8c26aad4b9c92a87c1063ddb0e3/info/thumbnail/topo_map_2.jpg",
            itemId: "6e03e8c26aad4b9c92a87c1063ddb0e3",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer"
            }]
        },
        gray: {
            title: a.basemaps.gray,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/8b3b470883a744aeb60e5fff0a319ce7/info/thumbnail/templight_gray_canvas_with_labels__ne_usa.png",
            itemId: "8b3b470883a744aeb60e5fff0a319ce7",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer"
            }, {
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer",
                isReference: !0
            }]
        },
        "dark-gray": {
            title: a.basemaps["dark-gray"],
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/da65bacab5bd4defb576f839b6b28098/info/thumbnail/DGCanvasWebMap.jpg",
            itemId: "da65bacab5bd4defb576f839b6b28098",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer"
            }, {
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer",
                isReference: !0
            }]
        },
        oceans: {
            title: a.basemaps.oceans,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/48b8cec7ebf04b5fbdcaf70d09daff21/info/thumbnail/tempoceans.jpg",
            itemId: "48b8cec7ebf04b5fbdcaf70d09daff21",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer"
            }, {
                url: "http://services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer",
                isReference: !0
            }]
        },
        "national-geographic": {
            title: a.basemaps["national-geographic"],
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/509e2d6b034246d692a461724ae2d62c/info/thumbnail/natgeo.jpg",
            itemId: "509e2d6b034246d692a461724ae2d62c",
            baseMapLayers: [{
                url: "http://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer"
            }]
        },
        osm: {
            title: a.basemaps.osm,
            thumbnailUrl: "//www.arcgis.com/sharing/rest/content/items/5d2bfa736f8448b3a1708e1f6be23eed/info/thumbnail/temposm.jpg",
            itemId: "5d2bfa736f8448b3a1708e1f6be23eed",
            baseMapLayers: [{
                type: "OpenStreetMap"
            }]
        }
    }
});
},
'esri/Evented':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/aspect", "dojo/Evented", "dojo/has", "./kernel"], function(m, h, l, n, p, q) {
    return m([n], {
        declaredClass: "esri.Evented",
        registerConnectEvents: function() {
            var d = this.constructor,
                c = this.constructor._meta.parents,
                a = [{}],
                e = {},
                b, f, g = function(a, b) {
                    h.isArray(a) || (a = [a]);
                    for (var c = 0; c < a.length; c++) {
                        var d = a[c];
                        d._meta && d._meta.parents && g(d._meta.parents, b);
                        d.prototype._eventMap && b.push(h.mixin({}, d.prototype._eventMap))
                    }
                    return b
                };
            if (!d._onMap) {
                g(c, a);
                a.push(this._eventMap);
                c = h.mixin.apply(this, a);
                for (b in this) /^on\w/.test(b) && h.isFunction(this[b]) && (a = this._hyphenLower(b).toLowerCase(), c[a] || (e[a] = {
                    method: b
                }));
                for (f in c) b = this._onCamelCase(f), e[f] = {
                    method: b,
                    argKeys: c[f]
                };
                d._onMap = e;
                return d._onMap
            }
        },
        on: function(d, c) {
            if (-1 < d.indexOf(",")) {
                for (var a = d.split(/\s*,\s*/), e = a.length, b = []; e--;) b.push(this.on(a[e], c));
                b.remove = function() {
                    for (var a = 0; a < b.length; a++) b[a].remove()
                };
                return b
            }
            var a = this.constructor._onMap || this.registerConnectEvents(),
                e = "string" == typeof d && d.toLowerCase(),
                f = this._onCamelCase(e),
                g = a && a[e];
            return (f = g && g.method || this[f] && h.isFunction(this[f]) && f) ? g && h.isArray(g.argKeys) ? (a = this._onArr2Obj(c, a[e].argKeys), l.after(this, f, a, !0)) : l.after(this, f, function(a) {
                a = a || {};
                a.target || (a.target = this);
                c.call(this, a)
            }, !0) : this.inherited(arguments)
        },
        emit: function(d, c) {
            var a, e, b, f, g = d.toLowerCase();
            f = this._onCamelCase(d);
            var k = this.constructor._onMap || this.registerConnectEvents();
            f = (b = k && k[g] && k[g].method || h.isFunction(this[f]) && f) && this[b];
            b && (k && k[g]) && this._onObj2Arr(function() {
                e =
                    Array.prototype.slice.call(arguments)
            }, k[g].argKeys)(c);
            c = c || {};
            c.target || (c.target = this);
            f && (a = e && e.length ? e : [c], a = f.apply(this, a));
            this.inherited(arguments, [d, c]);
            return a
        },
        _onObj2Arr: function(d, c) {
            if (c) {
                var a = this;
                return function(e) {
                    var b, f = [],
                        g = c.length;
                    for (b = 0; b < g; b++) f[b] = e[c[b]];
                    d.apply(a, f)
                }
            }
            return d
        },
        _onArr2Obj: function(d, c) {
            if (c) {
                var a = this;
                return function() {
                    var e, b = {},
                        f = arguments.length;
                    for (e = 0; e < f; e++) b[c[e]] = arguments[e];
                    b.target || (b.target = a);
                    d.call(a, b)
                }
            }
            return d
        },
        _hyphenLower: function(d) {
            return d.replace(/^on/,
                "").replace(/[A-Z](?=[a-z])/g, function(c, a) {
                return (a ? "-" : "") + c.toLowerCase()
            })
        },
        _onCamelCase: function(d) {
            return "on" + d.substr(0, 1).toUpperCase() + d.substr(1).replace(/\-([a-z])/g, function(c, a) {
                return a.toUpperCase()
            })
        }
    })
});
},
'esri/fx':function(){
//>>built
define(["dojo/_base/connect", "dojo/_base/fx", "dojo/_base/lang", "dojo/dom", "dojo/dom-geometry", "dojo/dom-style", "dojo/fx", "dojo/has", "./kernel"], function(n, f, g, k, l, m, p, q, r) {
    return {
        animateRange: function(a) {
            var b = a.range;
            return new f.Animation(g.mixin({
                curve: new f._Line(b.start, b.end)
            }, a))
        },
        resize: function(a) {
            var b = a.node = k.byId(a.node),
                c = a.start,
                d = a.end;
            c || (c = l.getMarginBox(b), b = l.getPadBorderExtents(b), c = a.start = {
                left: c.l + b.l,
                top: c.t + b.t,
                width: c.w - b.w,
                height: c.h - b.h
            });
            d || (d = a.anchor ? a.anchor : {
                    x: c.left,
                    y: c.top
                },
                b = a.size, d = a.end = {
                    left: c.left - (b.width - c.width) * (d.x - c.left) / c.width,
                    top: c.top - (b.height - c.height) * (d.y - c.top) / c.height,
                    width: b.width,
                    height: b.height
                });
            return f.animateProperty(g.mixin({
                properties: {
                    left: {
                        start: c.left,
                        end: d.left
                    },
                    top: {
                        start: c.top,
                        end: d.top
                    },
                    width: {
                        start: c.width,
                        end: d.width
                    },
                    height: {
                        start: c.height,
                        end: d.height
                    }
                }
            }, a))
        },
        slideTo: function(a) {
            var b = a.node = k.byId(a.node),
                c = m.getComputedStyle,
                d = null,
                e = null,
                h = function() {
                    return function() {
                        var a = "absolute" == b.style.position ? "absolute" : "relative";
                        d = "absolute" == a ? b.offsetTop : parseInt(c(b).top) || 0;
                        e = "absolute" == a ? b.offsetLeft : parseInt(c(b).left) || 0;
                        "absolute" != a && "relative" != a && (a = l.position(b, !0), d = a.y, e = a.x, b.style.position = "absolute", b.style.top = d + "px", b.style.left = e + "px")
                    }
                }();
            h();
            a = f.animateProperty(g.mixin({
                properties: {
                    top: {
                        start: d,
                        end: a.top || 0
                    },
                    left: {
                        start: e,
                        end: a.left || 0
                    }
                }
            }, a));
            n.connect(a, "beforeBegin", a, h);
            return a
        },
        flash: function(a) {
            a = g.mixin({
                end: "#f00",
                duration: 500,
                count: 1
            }, a);
            a.duration /= 2 * a.count;
            var b = k.byId(a.node),
                c = a.start;
            c || (c = m.getComputedStyle(b).backgroundColor);
            var d = a.end,
                e = [],
                h = a.count,
                b = {
                    node: b,
                    duration: a.duration
                };
            for (a = 0; a < h; a++) e.push(f.animateProperty(g.mixin({
                properties: {
                    backgroundColor: {
                        start: c,
                        end: d
                    }
                }
            }, b))), e.push(f.animateProperty(g.mixin({
                properties: {
                    backgroundColor: {
                        start: d,
                        end: c
                    }
                }
            }, b)));
            return p.chain(e)
        }
    }
});
},
'dojo/fx':function(){
define([
	"./_base/lang",
	"./Evented",
	"./_base/kernel",
	"./_base/array",
	"./aspect",
	"./_base/fx",
	"./dom",
	"./dom-style",
	"./dom-geometry",
	"./ready",
	"require" // for context sensitive loading of Toggler
], function(lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require){

	// module:
	//		dojo/fx
	
	// For back-compat, remove in 2.0.
	if(!dojo.isAsync){
		ready(0, function(){
			var requires = ["./fx/Toggler"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var coreFx = dojo.fx = {
		// summary:
		//		Effects library on top of Base animations
	};

	var _baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		arrayUtil.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	_chain.prototype = new Evented();
	lang.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			this._onAnimateCtx.remove();
			this._onEndCtx.remove();
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
				this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = aspect.after(this._current, "beforeBegin", lang.hitch(this, function(){
					this._fire("beforeBegin");
				}), true),
				onBegin = aspect.after(this._current, "onBegin", lang.hitch(this, function(arg){
					this._fire("onBegin", arguments);
				}), true),
				onPlay = aspect.after(this._current, "onPlay", lang.hitch(this, function(arg){
					this._fire("onPlay", arguments);
					beforeBegin.remove();
					onBegin.remove();
					onPlay.remove();
				}));
			if(this._onAnimateCtx){
				this._onAnimateCtx.remove();
			}
			this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
			if(this._onEndCtx){
				this._onEndCtx.remove();
			}
			this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = aspect.after(this._current, "onPause", lang.hitch(this, function(arg){
						this._fire("onPause", arguments);
						e.remove();
					}), true);
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;

			arrayUtil.some(this._animations, function(a, index){
				if(offset <= a.duration){
					this._current = a;
					this._index = index;
					return true;
				}
				offset -= a.duration;
				return false;
			}, this);
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration);
			}
			if (andPlay) { this.play(); }
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = aspect.after(this._current, "onStop", lang.hitch(this, function(arg){
						this._fire("onStop", arguments);
						e.remove();
					}), true);
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			this.stop();
			if(this._onAnimateCtx){ this._onAnimateCtx.remove(); }
			if(this._onEndCtx){ this._onEndCtx.remove(); }
		}
	});
	lang.extend(_chain, _baseObj);

	coreFx.chain = function(/*dojo/_base/fx.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo/_base/fx.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo/_base/fx.Animation` which will play all passed
		//		`dojo/_base/fx.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.chain([
		//	|			fx.fadeIn({ node:node }),
		//	|			fx.fadeOut({ node:otherNode })
		//	|		]).play();
		//	|	});
		//
		return new _chain(animations); // dojo/_base/fx.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		arrayUtil.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(aspect.after(a, "onEnd", lang.hitch(this, "_onEnd"), true));
		}, this);

		this._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		arrayUtil.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(aspect.after(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); },
				true));
			}
		);
	};
	lang.extend(_combine, {
		_doAction: function(action, args){
			arrayUtil.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			arrayUtil.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			this.stop();
			arrayUtil.forEach(this._connects, function(handle){
				handle.remove();
			});
		}
	});
	lang.extend(_combine, _baseObj);

	coreFx.combine = function(/*dojo/_base/fx.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo/_base/fx.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo/_base/fx.Animation`s to run in parallel,
		//		providing a new `dojo/_base/fx.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.combine([
		//	|			fx.fadeIn({ node:node }),
		//	|			fx.fadeOut({ node:otherNode })
		//	|		]).play();
		//	|	});
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	require(["dojo/fx"], function(fx){
		//	|		var anim = fx.combine([
		//	|			fx.fadeIn({ node: n, duration:700 }),
		//	|			fx.fadeOut({ node: otherNode, duration: 300 })
		//	|		]);
		//	|		aspect.after(anim, "onEnd", function(){
		//	|			// overall animation is done.
		//	|		}, true);
		//	|		anim.play(); // play the animation
		//	|	});
		//
		return new _combine(animations); // dojo/_base/fx.Animation
	};

	coreFx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.wipeIn({
		//	|			node:"someId"
		//	|		}).play()
		//	|	});

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = domStyle.get(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		var fini = function(){
			s.height = "auto";
			s.overflow = o;
		};
		aspect.after(anim, "onStop", fini, true);
		aspect.after(anim, "onEnd", fini, true);

		return anim; // dojo/_base/fx.Animation
	};

	coreFx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.wipeOut({ node:"someId" }).play()
		//	|	});

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		aspect.after(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		}, true);
		var fini = function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		};
		aspect.after(anim, "onStop", fini, true);
		aspect.after(anim, "onEnd", fini, true);

		return anim; // dojo/_base/fx.Animation
	};

	coreFx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = dom.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = domStyle.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = geom.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		aspect.after(anim, "beforeBegin", init, true);

		return anim; // dojo/_base/fx.Animation
	};

	return coreFx;
});

},
'esri/tileUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/has", "./kernel", "./geometry/Point", "./geometry/Extent"], function(t, v, w, u, s) {
    return {
        _addFrameInfo: function(a, c) {
            var b, d, f = 2 * c.origin[1],
                g = c.origin[0],
                h = a.origin.x,
                e = a.width,
                l;
            t.forEach(a.lods, function(a) {
                b = Math.round(f / a.resolution);
                d = Math.ceil(b / e);
                l = Math.floor((g - h) / (e * a.resolution));
                a._frameInfo || (a._frameInfo = [d, l, l + d - 1, b])
            })
        },
        getContainingTileCoords: function(a, c, b) {
            var d = a.origin;
            b = b.resolution;
            return {
                row: Math.floor((d.y - c.y) / (a.height * b)),
                col: Math.floor((c.x -
                    d.x) / (a.width * b))
            }
        },
        getCandidateTileInfo: function(a, c, b) {
            var d;
            d = a.width;
            for (var f = a.height, g = b.xmax - b.xmin, h = b.ymax - b.ymin, e = a.__tileInfo === c, l = e ? a.getMinZoom() : -1, e = e ? a.getMaxZoom() : -1, m = -1, n = c.lods, p = Math.abs, k, q, r, e = -1 < e ? e : n.length - 1, l = -1 < l ? l : 0; l <= e; l++)
                if (q = n[l])
                    if (r = g > h ? p(h - f * q.resolution) : p(g - d * q.resolution), 0 > m || r <= m) k = q, m = r;
                    else break;
            d = k;
            k = d.resolution;
            f = (b.xmin + b.xmax) / 2;
            g = (b.ymin + b.ymax) / 2;
            h = a.width / 2 * k;
            k *= a.height / 2;
            f = new s(f - h, g - k, f + h, g + k, b.spatialReference);
            b = new u(f.xmin, f.ymax, b.spatialReference);
            e = d.resolution;
            h = c.width;
            g = c.height;
            c = c.origin;
            a = a.__visibleDelta;
            k = Math.floor;
            n = h * e;
            p = g * e;
            e = k((c.y - b.y) / p);
            m = k((b.x - c.x) / n);
            l = c.y - e * p;
            c = k(Math.abs((b.x - (c.x + m * n)) * h / n)) + a.x;
            a = k(Math.abs((b.y - l) * g / p)) + a.y;
            return {
                tile: {
                    point: b,
                    coords: {
                        row: e,
                        col: m
                    },
                    offsets: {
                        x: c,
                        y: a
                    }
                },
                lod: d,
                extent: f
            }
        },
        getTileExtent: function(a, c, b, d) {
            var f = a.origin;
            c = a.lods[c].resolution;
            var g = a.width,
                h = a.height;
            return new s(d * c * g + f.x, f.y - (b + 1) * c * h, (d + 1) * c * g + f.x, f.y - b * c * h, a.spatialReference)
        }
    }
});
},
'esri/geometry/Point':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../SpatialReference", "./Geometry"], function(d, f, s, t, l, q, r) {
    function g(a, b) {
        89.99999 < b ? b = 89.99999 : -89.99999 > b && (b = -89.99999);
        var c = b * m;
        return [a * m * e, e / 2 * Math.log((1 + Math.sin(c)) / (1 - Math.sin(c)))]
    }

    function h(a, b, c) {
        a = a / e * k;
        if (c) return b = n / 2 - 2 * Math.atan(Math.exp(-1 * b / e)), [a, b * k];
        c = a - 360 * Math.floor((a + 180) / 360);
        b = n / 2 - 2 * Math.atan(Math.exp(-1 * b / e));
        return [c, b * k]
    }
    var e = 6378137,
        n = 3.141592653589793,
        k = 57.29577951308232,
        m = 0.017453292519943,
        p = {
            type: "point",
            x: 0,
            y: 0
        };
    d = d(r, {
        declaredClass: "esri.geometry.Point",
        constructor: function(a, b, c) {
            f.mixin(this, p);
            f.isArray(a) ? (this.x = a[0], this.y = a[1], this.spatialReference = b) : f.isObject(a) ? (f.mixin(this, a), l.isDefined(this.latitude) && (this.y = this.latitude), l.isDefined(this.longitude) && (this.x = this.longitude), this.spatialReference && (this.spatialReference = new q(this.spatialReference))) : (this.x = a, this.y = b, this.spatialReference = c);
            this.verifySR()
        },
        offset: function(a, b) {
            return new this.constructor(this.x +
                a, this.y + b, this.spatialReference)
        },
        setX: function(a) {
            this.x = a;
            return this
        },
        setY: function(a) {
            this.y = a;
            return this
        },
        setLongitude: function(a) {
            var b = this.spatialReference;
            b && (b._isWebMercator() ? this.x = g(a, this.y)[0] : 4326 === b.wkid && (this.x = a));
            return this
        },
        setLatitude: function(a) {
            var b = this.spatialReference;
            b && (b._isWebMercator() ? this.y = g(this.x, a)[1] : 4326 === b.wkid && (this.y = a));
            return this
        },
        getLongitude: function() {
            var a = this.spatialReference,
                b;
            a && (a._isWebMercator() ? b = h(this.x, this.y)[0] : 4326 === a.wkid &&
                (b = this.x));
            return b
        },
        getLatitude: function() {
            var a = this.spatialReference,
                b;
            a && (a._isWebMercator() ? b = h(this.x, this.y)[1] : 4326 === a.wkid && (b = this.y));
            return b
        },
        update: function(a, b) {
            this.x = a;
            this.y = b;
            return this
        },
        normalize: function() {
            var a = this.x,
                b = this.spatialReference;
            if (b) {
                var c = b._getInfo();
                if (c) {
                    var d = c.valid[0],
                        e = c.valid[1],
                        c = 2 * e;
                    a > e ? (d = Math.ceil(Math.abs(a - e) / c), a -= d * c) : a < d && (d = Math.ceil(Math.abs(a - d) / c), a += d * c)
                }
            }
            return new this.constructor(a, this.y, b)
        },
        toJson: function() {
            var a = {
                    x: this.x,
                    y: this.y
                },
                b = this.spatialReference;
            b && (a.spatialReference = b.toJson());
            return a
        }
    });
    d.lngLatToXY = g;
    d.xyToLngLat = h;
    d.defaultProps = p;
    return d
});
},
'esri/geometry/Geometry':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../SpatialReference"], function(a, c, d, e, b) {
    return a(null, {
        declaredClass: "esri.geometry.Geometry",
        spatialReference: null,
        type: null,
        setSpatialReference: function(a) {
            this.spatialReference = a;
            return this
        },
        verifySR: function() {
            this.spatialReference || this.setSpatialReference(new b(4326))
        },
        getExtent: function() {
            return null
        }
    })
});
},
'esri/geometry/Extent':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../SpatialReference", "./Geometry", "./Point", "./webMercatorUtils", "./mathUtils"], function(w, u, p, A, B, x, s, y, m, t, z) {
    var v = {
            type: "extent",
            xmin: 0,
            ymin: 0,
            xmax: 0,
            ymax: 0
        },
        g = w(y, {
            declaredClass: "esri.geometry.Extent",
            constructor: function(a, c, b, d, e) {
                p.mixin(this, v);
                p.isObject(a) ? (p.mixin(this, a), this.spatialReference && (this.spatialReference = new s(this.spatialReference))) : this.update(a, c, b, d, e);
                this.verifySR()
            },
            getWidth: function() {
                return Math.abs(this.xmax -
                    this.xmin)
            },
            getHeight: function() {
                return Math.abs(this.ymax - this.ymin)
            },
            getCenter: function() {
                return new m((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2, this.spatialReference)
            },
            centerAt: function(a) {
                var c = this.getCenter(),
                    b = a.x - c.x;
                a = a.y - c.y;
                return new g(this.xmin + b, this.ymin + a, this.xmax + b, this.ymax + a, this.spatialReference)
            },
            update: function(a, c, b, d, e) {
                this.xmin = a;
                this.ymin = c;
                this.xmax = b;
                this.ymax = d;
                this.spatialReference = e;
                this._parts = this._shifted = null;
                return this
            },
            offset: function(a, c) {
                return new g(this.xmin +
                    a, this.ymin + c, this.xmax + a, this.ymax + c, this.spatialReference)
            },
            expand: function(a) {
                var c = (1 - a) / 2;
                a = this.getWidth() * c;
                c *= this.getHeight();
                return new g(this.xmin + a, this.ymin + c, this.xmax - a, this.ymax - c, this.spatialReference)
            },
            intersects: function(a) {
                if (!a) return !1;
                var c = a.type,
                    b = this.spatialReference,
                    d = a.spatialReference;
                b && (d && !b.equals(d) && b._canProject(d)) && (a = b.isWebMercator() ? t.geographicToWebMercator(a) : t.webMercatorToGeographic(a, !0));
                switch (c) {
                    case "point":
                        return this.contains(a);
                    case "multipoint":
                        return this._intersectsMultipoint(a);
                    case "extent":
                        return this._intersectsExtent(a);
                    case "polygon":
                        return this._intersectsPolygon(a);
                    case "polyline":
                        return this._intersectsPolyline(a)
                }
            },
            normalize: function() {
                var a = this._normalize(!1, !0);
                p.isArray(a) || (a = [a]);
                return a
            },
            shiftCentralMeridian: function() {
                return this._normalize(!0)
            },
            _intersectsMultipoint: function(a) {
                var c = a.points.length,
                    b;
                for (b = 0; b < c; b++)
                    if (this.contains(a.getPoint(b))) return !0;
                return !1
            },
            _intersectsExtent: function(a) {
                var c, b, d, e, f = !1;
                this.xmin <= a.xmin ? (c = a.xmin, this.xmax <
                    c ? f = !0 : d = Math.min(this.xmax, a.xmax) - c) : (c = this.xmin, a.xmax < c ? f = !0 : d = Math.min(this.xmax, a.xmax) - c);
                this.ymin <= a.ymin ? (b = a.ymin, this.ymax < b ? f = !0 : e = Math.min(this.ymax, a.ymax) - b) : (b = this.ymin, a.ymax < b ? f = !0 : e = Math.min(this.ymax, a.ymax) - b);
                return f ? null : new g(c, b, c + d, b + e, this.spatialReference)
            },
            _intersectsPolygon: function(a) {
                var c = [this.xmin, this.ymax],
                    b = [this.xmax, this.ymax],
                    d = [this.xmin, this.ymin],
                    e = [this.xmax, this.ymin],
                    f = [c, b, d, e],
                    c = [
                        [d, c],
                        [c, b],
                        [b, e],
                        [e, d]
                    ],
                    d = a.rings,
                    e = d.length,
                    k, g = new m(0, 0, this.spatialReference);
                k = f.length;
                for (b = 0; b < k; b++)
                    if (g.update(f[b][0], f[b][1]), a.contains(g)) return !0;
                g.setSpatialReference(a.spatialReference);
                for (var l, h, b = 0; b < e; b++)
                    if (f = d[b], k = f.length) {
                        l = f[0];
                        g.update(l[0], l[1]);
                        if (this.contains(g)) return !0;
                        for (a = 1; a < k; a++) {
                            h = f[a];
                            g.update(h[0], h[1]);
                            if (this.contains(g) || this._intersectsLine([l, h], c)) return !0;
                            l = h
                        }
                    }
                return !1
            },
            _intersectsPolyline: function(a) {
                var c = [
                        [
                            [this.xmin, this.ymin],
                            [this.xmin, this.ymax]
                        ],
                        [
                            [this.xmin, this.ymax],
                            [this.xmax, this.ymax]
                        ],
                        [
                            [this.xmax, this.ymax],
                            [this.xmax,
                                this.ymin
                            ]
                        ],
                        [
                            [this.xmax, this.ymin],
                            [this.xmin, this.ymin]
                        ]
                    ],
                    b, d = a.paths,
                    e = d.length,
                    f, k, g, l, h = new m(0, 0, a.spatialReference);
                for (a = 0; a < e; a++)
                    if (f = d[a], k = f.length) {
                        g = f[0];
                        h.update(g[0], g[1]);
                        if (this.contains(h)) return !0;
                        for (b = 1; b < k; b++) {
                            l = f[b];
                            h.update(l[0], l[1]);
                            if (this.contains(h) || this._intersectsLine([g, l], c)) return !0;
                            g = l
                        }
                    }
                return !1
            },
            _intersectsLine: function(a, c) {
                var b = z._getLineIntersection2,
                    d, e = c.length;
                for (d = 0; d < e; d++)
                    if (b(a, c[d])) return !0;
                return !1
            },
            contains: function(a) {
                if (!a) return !1;
                var c = a.type;
                if ("point" === c) {
                    var b = this.spatialReference,
                        d = a.spatialReference,
                        c = a.x;
                    a = a.y;
                    b && (d && !b.equals(d) && b._canProject(d)) && (a = b.isWebMercator() ? m.lngLatToXY(c, a) : m.xyToLngLat(c, a, !0), c = a[0], a = a[1]);
                    return c >= this.xmin && c <= this.xmax && a >= this.ymin && a <= this.ymax
                }
                return "extent" === c ? this._containsExtent(a) : !1
            },
            _containsExtent: function(a) {
                var c = a.xmin,
                    b = a.ymin,
                    d = a.xmax,
                    e = a.ymax,
                    f = a.spatialReference;
                a = new m(c, b, f);
                c = new m(c, e, f);
                e = new m(d, e, f);
                b = new m(d, b, f);
                return this.contains(a) && this.contains(c) && this.contains(e) &&
                    this.contains(b) ? !0 : !1
            },
            union: function(a) {
                return new g(Math.min(this.xmin, a.xmin), Math.min(this.ymin, a.ymin), Math.max(this.xmax, a.xmax), Math.max(this.ymax, a.ymax), this.spatialReference)
            },
            getExtent: function() {
                var a = this.spatialReference;
                return new g(this.xmin, this.ymin, this.xmax, this.ymax, a && new s(a.toJson()))
            },
            _shiftCM: function(a) {
                if (!this._shifted) {
                    var c = new g(this.toJson()),
                        b = c.spatialReference;
                    if (a = a || b._getInfo()) {
                        var d = this._getCM(a);
                        if (d) {
                            var e = b._isWebMercator() ? t.webMercatorToGeographic(d) :
                                d;
                            c.xmin -= d.x;
                            c.xmax -= d.x;
                            b._isWebMercator() || (e.x = this._normalizeX(e.x, a).x);
                            c.setSpatialReference(new s(x.substitute({
                                Central_Meridian: e.x
                            }, 4326 === b.wkid ? a.altTemplate : a.wkTemplate)))
                        }
                    }
                    this._shifted = c
                }
                return this._shifted
            },
            _getCM: function(a) {
                var c, b = a.valid[0];
                a = a.valid[1];
                var d = this.xmin,
                    e = this.xmax;
                if (!(d >= b && d <= a) || !(e >= b && e <= a)) c = this.getCenter();
                return c
            },
            _normalize: function(a, c, b) {
                var d = new g(this.toJson()),
                    e = d.spatialReference;
                if (e && (b = b || e._getInfo())) {
                    var f = u.map(this._getParts(b), function(a) {
                        return a.extent
                    });
                    return 2 < f.length ? a ? this._shiftCM(b) : d.update(b.valid[0], d.ymin, b.valid[1], d.ymax, e) : 2 === f.length ? a ? this._shiftCM(b) : c ? f : {
                        rings: u.map(f, function(a) {
                            return [
                                [a.xmin, a.ymin],
                                [a.xmin, a.ymax],
                                [a.xmax, a.ymax],
                                [a.xmax, a.ymin],
                                [a.xmin, a.ymin]
                            ]
                        }),
                        spatialReference: e
                    } : f[0] || d
                }
                return d
            },
            _getParts: function(a) {
                if (!this._parts) {
                    var c = this.xmin,
                        b = this.xmax,
                        d = this.ymin,
                        e = this.ymax,
                        f = this.spatialReference,
                        k = this.getWidth(),
                        m = c,
                        l = b,
                        h = 0,
                        n = 0,
                        p = [],
                        q, r;
                    a = a || f._getInfo();
                    q = a.valid[0];
                    r = a.valid[1];
                    n = this._normalizeX(c, a);
                    c = n.x;
                    h = n.frameId;
                    n = this._normalizeX(b, a);
                    b = n.x;
                    n = n.frameId;
                    a = c === b && 0 < k;
                    if (k > 2 * r) {
                        k = new g(m < l ? c : b, d, r, e, f);
                        c = new g(q, d, m < l ? b : c, e, f);
                        r = new g(0, d, r, e, f);
                        d = new g(q, d, 0, e, f);
                        f = [];
                        q = [];
                        k.contains(r) && f.push(h);
                        k.contains(d) && q.push(h);
                        c.contains(r) && f.push(n);
                        c.contains(d) && q.push(n);
                        for (e = h + 1; e < n; e++) f.push(e), q.push(e);
                        p.push({
                            extent: k,
                            frameIds: [h]
                        }, {
                            extent: c,
                            frameIds: [n]
                        }, {
                            extent: r,
                            frameIds: f
                        }, {
                            extent: d,
                            frameIds: q
                        })
                    } else c > b || a ? p.push({
                        extent: new g(c, d, r, e, f),
                        frameIds: [h]
                    }, {
                        extent: new g(q, d, b, e, f),
                        frameIds: [n]
                    }) : p.push({
                        extent: new g(c, d, b, e, f),
                        frameIds: [h]
                    });
                    this._parts = p
                }
                return this._parts
            },
            _normalizeX: function(a, c) {
                var b = 0,
                    d = c.valid[0],
                    e = c.valid[1],
                    f = 2 * e;
                a > e ? (b = Math.ceil(Math.abs(a - e) / f), a -= b * f) : a < d && (b = Math.ceil(Math.abs(a - d) / f), a += b * f, b = -b);
                return {
                    x: a,
                    frameId: b
                }
            },
            toJson: function() {
                var a = {
                        xmin: this.xmin,
                        ymin: this.ymin,
                        xmax: this.xmax,
                        ymax: this.ymax
                    },
                    c = this.spatialReference;
                c && (a.spatialReference = c.toJson());
                return a
            }
        });
    g.defaultProps = v;
    return g
});
},
'esri/geometry/webMercatorUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../SpatialReference", "./Point"], function(k, n, p, q, l, e) {
    function f(a, b, d, c) {
        if ("point" === a.type) {
            var g = b(a.x, a.y, c);
            return new a.constructor(g[0], g[1], new l(d))
        }
        if ("extent" === a.type) {
            var g = b(a.xmin, a.ymin, c),
                e = b(a.xmax, a.ymax, c);
            return new a.constructor(g[0], g[1], e[0], e[1], new l(d))
        }
        if ("polyline" === a.type || "polygon" === a.type) {
            var g = "polyline" === a.type,
                f = [],
                h;
            k.forEach(g ? a.paths : a.rings, function(a) {
                f.push(h = []);
                k.forEach(a, function(a) {
                    h.push(b(a[0],
                        a[1], c))
                })
            });
            return g ? new a.constructor({
                paths: f,
                spatialReference: d
            }) : new a.constructor({
                rings: f,
                spatialReference: d
            })
        }
        if ("multipoint" === a.type) {
            var m = [];
            k.forEach(a.points, function(a) {
                m.push(b(a[0], a[1], c))
            });
            return new a.constructor({
                points: m,
                spatialReference: d
            })
        }
    }

    function h(a, b) {
        var d = a && (null != a.wkid ? a : a.spatialReference),
            c = b && (null != b.wkid ? b : b.spatialReference);
        return !d || !c ? !1 : c.equals(d) ? !0 : c._canProject(d)
    }
    return {
        canProject: h,
        project: function(a, b) {
            var d = a && a.spatialReference,
                c = b && (null != b.wkid ?
                    b : b.spatialReference);
            d && c ? d.equals(c) ? a = new a.constructor(a.toJson()) : h(d, c) ? c.isWebMercator() ? a = f(a, e.lngLatToXY, {
                wkid: 102100
            }) : 4326 === c.wkid && (a = f(a, e.xyToLngLat, {
                wkid: 4326
            })) : a = null : a = null;
            return a
        },
        lngLatToXY: e.lngLatToXY,
        xyToLngLat: e.xyToLngLat,
        geographicToWebMercator: function(a) {
            return f(a, e.lngLatToXY, {
                wkid: 102100
            })
        },
        webMercatorToGeographic: function(a, b) {
            return f(a, e.xyToLngLat, {
                wkid: 4326
            }, b)
        }
    }
});
},
'esri/geometry/mathUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "../kernel", "./Point"], function(t, u, v, p) {
    function r(a, c, b) {
        return a instanceof p ? new p(a.x + b * (c.x - a.x), a.y + b * (c.y - a.y)) : [a[0] + b * (c[0] - a[0]), a[1] + b * (c[1] - a[1])]
    }

    function g(a, c) {
        return 1E-8 > Math.abs(a - c)
    }

    function s(a, c, b, d) {
        var e, f = g(a[0], c[0]) ? 1E10 : (a[1] - c[1]) / (a[0] - c[0]),
            k = g(b[0], d[0]) ? 1E10 : (b[1] - d[1]) / (b[0] - d[0]),
            l = a[1] - f * a[0],
            h = b[1] - k * b[0];
        if (g(f, k)) {
            if (g(l, h)) {
                if (g(a[0], c[0]))
                    if (Math.min(a[1], c[1]) < Math.max(b[1], d[1]) || Math.max(a[1], c[1]) > Math.min(b[1], d[1])) a =
                        (a[1] + c[1] + b[1] + d[1] - Math.min(a[1], c[1], b[1], d[1]) - Math.max(a[1], c[1], b[1], d[1])) / 2, e = (a - l) / f;
                    else return null;
                else if (Math.min(a[0], c[0]) < Math.max(b[0], d[0]) || Math.max(a[0], c[0]) > Math.min(b[0], d[0])) e = (a[0] + c[0] + b[0] + d[0] - Math.min(a[0], c[0], b[0], d[0]) - Math.max(a[0], c[0], b[0], d[0])) / 2, a = f * e + l;
                else return null;
                return [e, a]
            }
            return null
        }
        g(f, 1E10) ? (e = a[0], a = k * e + h) : g(k, 1E10) ? (e = b[0], a = f * e + l) : (e = -(l - h) / (f - k), a = a[1] === c[1] ? a[1] : b[1] === d[1] ? b[1] : f * e + l);
        return [e, a]
    }
    return {
        getLength: function(a, c) {
            var b = c.x -
                a.x,
                d = c.y - a.y;
            return Math.sqrt(b * b + d * d)
        },
        _getLength: function(a, c) {
            var b = c[0] - a[0],
                d = c[1] - a[1];
            return Math.sqrt(b * b + d * d)
        },
        getPointOnLine: r,
        getMidpoint: function(a, c) {
            return r(a, c, 0.5)
        },
        _equals: g,
        _getLineIntersection: s,
        getLineIntersection: function(a, c, b, d, e) {
            (a = s([a.x, a.y], [c.x, c.y], [b.x, b.y], [d.x, d.y])) && (a = new p(a[0], a[1], e));
            return a
        },
        _getLineIntersection2: function(a, c) {
            var b = a[0],
                d = a[1],
                e = c[0],
                f = c[1],
                k = b[0],
                b = b[1],
                l = d[0],
                d = d[1],
                h = e[0],
                q = e[1],
                e = f[0] - h,
                h = k - h,
                g = l - k,
                f = f[1] - q,
                q = b - q,
                m = d - b,
                n = f * g - e * m;
            if (0 ===
                n) return !1;
            e = (e * q - f * h) / n;
            h = (g * q - m * h) / n;
            return 0 <= e && 1 >= e && 0 <= h && 1 >= h ? [k + e * (l - k), b + e * (d - b)] : !1
        },
        _pointLineDistance: function(a, c) {
            var b = c[0],
                d = c[1],
                e = b[0],
                f = b[1],
                b = a[0],
                k = a[1],
                l = d[0] - e,
                h = d[1] - f,
                g = b - e,
                p = k - f,
                d = Math.sqrt,
                m = Math.pow,
                n = d(m(l, 2) + m(h, 2)),
                g = (g * l + p * h) / (n * n),
                f = f + g * h;
            return d(m(b - (e + g * l), 2) + m(k - f, 2))
        }
    }
});
},
'esri/PluginTarget':function(){
//>>built
define(["require", "dojo/aspect", "dojo/_base/array", "dojo/_base/lang", "dojo/Deferred", "dojo/when"], function(g, h, k, n, l, m) {
    function b() {
        h.after(this.constructor._meta, "ctor", this._pluginsHandler, !0);
        this._plugins = {}
    }
    b.prototype = {
        addPlugin: function(c, a) {
            var f = this,
                e = this._plugins,
                d = new l;
            try {
                g([c], function(b) {
                    c in e ? d.resolve({
                        id: e[c].declaredId || c.replace(/\//g, ".")
                    }) : (e[c] = b, m(b.add(f, a), function() {
                        var a = {
                            id: b.declaredId || c.replace(/\//g, ".")
                        };
                        f.emit("plugin-add", a);
                        d.resolve(a)
                    }, function(a) {
                        d.reject(a)
                    }))
                })
            } catch (b) {
                d.reject(b)
            }
            return d.promise
        },
        removePlugin: function(c) {
            if (c in this._plugins) {
                var a = this._plugins[c];
                a.remove(this);
                delete this._plugins[c];
                this.emit("plugin-remove", {
                    id: a.declaredId || c.replace(/\//g, ".")
                })
            }
        },
        _pluginsHandler: function() {
            var c = this;
            k.some(arguments, function(a) {
                if (a && a.plugins && a.plugins instanceof Array) {
                    a = a.plugins;
                    var b, e, d;
                    for (d = 0; d < a.length; d++) b = a[d], e = b instanceof Object ? b.id : b, c.addPlugin(e, b.options);
                    return !0
                }
            })
        }
    };
    return b
});
},
'esri/geometry/ScreenPoint':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./Point"], function(a, c, d, e, b) {
    return a(b, {
        declaredClass: "esri.geometry.ScreenPoint",
        verifySR: function() {}
    })
});
},
'esri/geometry/Rect':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "../SpatialReference", "./Geometry", "./Point", "./Extent"], function(h, b, q, k, r, l, m, n, p) {
    var g = h(m, {
        declaredClass: "esri.geometry.Rect",
        constructor: function(a, c, f, d, e) {
            b.mixin(this, k.defaultRect);
            b.isObject(a) && "extent" === a.type && (c = a.ymax, f = a.getWidth(), d = a.getHeight(), e = a.spatialReference, a = a.xmin);
            b.isObject(a) ? (b.mixin(this, a), this.spatialReference && (this.spatialReference = new l(this.spatialReference))) : (this.x = a, this.y =
                c, this.width = f, this.height = d, this.spatialReference = e);
            this.verifySR()
        },
        getCenter: function() {
            return new n(this.x + this.width / 2, this.y + this.height / 2, this.spatialReference)
        },
        offset: function(a, c) {
            return new g(this.x + a, this.y + c, this.width, this.height, this.spatialReference)
        },
        intersects: function(a) {
            return a.x + a.width <= this.x || a.y + a.height <= this.y || a.y >= this.y + this.height || a.x >= this.x + this.width ? !1 : !0
        },
        getExtent: function() {
            return new p(parseFloat(this.x), parseFloat(this.y) - parseFloat(this.height), parseFloat(this.x) +
                parseFloat(this.width), parseFloat(this.y), this.spatialReference)
        },
        update: function(a, c, b, d, e) {
            this.x = a;
            this.y = c;
            this.width = b;
            this.height = d;
            this.spatialReference = e;
            return this
        }
    });
    return g
});
},
'esri/geometry/scaleUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "../kernel", "../config", "../lang", "../WKIDUnitConversion"], function(p, q, r, m, n, h) {
    var k = 20015077 / 180,
        l = m.defaults,
        f = {
            getUnitValue: function(a) {
                var b, c, d;
                a && ("object" === typeof a ? (b = a.wkid, c = a.wkt) : "number" === typeof a ? b = a : "string" === typeof a && (c = a));
                b ? d = h.values[h[b]] : c && -1 !== c.search(/^PROJCS/i) && (a = /UNIT\[([^\]]+)\]\]$/i.exec(c)) && a[1] && (d = parseFloat(a[1].split(",")[1]));
                return d
            },
            getScale: function(a, b, c) {
                var d, e, g;
                1 < arguments.length && n.isDefined(b) && !b.declaredClass ?
                    (d = a, e = b, b = null, g = f.getUnitValue(c)) : (d = b || a.extent, e = a.width, g = f.getUnitValue(d && d.spatialReference));
                return d && e ? 39.37 * (d.getWidth() / e * (g || k)) * l.screenDPI : 0
            },
            getExtentForScale: function(a, b, c) {
                c = c || a.extent;
                var d = f.getUnitValue(a.spatialReference);
                return c.expand(b * a.width / (39.37 * (d || k) * l.screenDPI) / c.getWidth())
            }
        };
    return f
});
},
'esri/WKIDUnitConversion':function(){
//>>built
define(["dojo/has", "./kernel"], function(a, b) {
    return {
        values: [1, 0.3048, 0.3048006096012192, 0.3047972654, 0.9143917962, 0.201166195164, 0.9143984146160287, 0.3047994715386762, 20.11676512155263, 20.11678249437587, 0.9143985307444408, 0.91439523, 0.3047997101815088, 20.116756, 5E4, 15E4],
        2E3: 0,
        2001: 0,
        2002: 0,
        2003: 0,
        2004: 0,
        2005: 0,
        2006: 0,
        2007: 0,
        2008: 0,
        2009: 0,
        2010: 0,
        2011: 0,
        2012: 0,
        2013: 0,
        2014: 0,
        2015: 0,
        2016: 0,
        2017: 0,
        2018: 0,
        2019: 0,
        2020: 0,
        2021: 0,
        2022: 0,
        2023: 0,
        2024: 0,
        2025: 0,
        2026: 0,
        2027: 0,
        2028: 0,
        2029: 0,
        2030: 0,
        2031: 0,
        2032: 0,
        2033: 0,
        2034: 0,
        2035: 0,
        2036: 0,
        2037: 0,
        2038: 0,
        2039: 0,
        2040: 0,
        2041: 0,
        2042: 0,
        2043: 0,
        2044: 0,
        2045: 0,
        2056: 0,
        2057: 0,
        2058: 0,
        2059: 0,
        2060: 0,
        2061: 0,
        2062: 0,
        2063: 0,
        2064: 0,
        2065: 0,
        2066: 5,
        2067: 0,
        2068: 0,
        2069: 0,
        2070: 0,
        2071: 0,
        2072: 0,
        2073: 0,
        2074: 0,
        2075: 0,
        2076: 0,
        2077: 0,
        2078: 0,
        2079: 0,
        2080: 0,
        2081: 0,
        2082: 0,
        2083: 0,
        2084: 0,
        2085: 0,
        2086: 0,
        2087: 0,
        2088: 0,
        2089: 0,
        2090: 0,
        2091: 0,
        2092: 0,
        2093: 0,
        2094: 0,
        2095: 0,
        2096: 0,
        2097: 0,
        2098: 0,
        2099: 0,
        2100: 0,
        2101: 0,
        2102: 0,
        2103: 0,
        2104: 0,
        2105: 0,
        2106: 0,
        2107: 0,
        2108: 0,
        2109: 0,
        2110: 0,
        2111: 0,
        2112: 0,
        2113: 0,
        2114: 0,
        2115: 0,
        2116: 0,
        2117: 0,
        2118: 0,
        2119: 0,
        2120: 0,
        2121: 0,
        2122: 0,
        2123: 0,
        2124: 0,
        2125: 0,
        2126: 0,
        2127: 0,
        2128: 0,
        2129: 0,
        2130: 0,
        2131: 0,
        2132: 0,
        2133: 0,
        2134: 0,
        2135: 0,
        2136: 12,
        2137: 0,
        2138: 0,
        2139: 0,
        2140: 0,
        2141: 0,
        2142: 0,
        2143: 0,
        2144: 0,
        2145: 0,
        2146: 0,
        2147: 0,
        2148: 0,
        2149: 0,
        2150: 0,
        2151: 0,
        2152: 0,
        2153: 0,
        2154: 0,
        2155: 2,
        2157: 0,
        2158: 0,
        2159: 12,
        2160: 12,
        2161: 0,
        2162: 0,
        2163: 0,
        2164: 0,
        2165: 0,
        2166: 0,
        2167: 0,
        2168: 0,
        2169: 0,
        2170: 0,
        2172: 0,
        2173: 0,
        2174: 0,
        2175: 0,
        2176: 0,
        2177: 0,
        2178: 0,
        2179: 0,
        2180: 0,
        2181: 0,
        2182: 0,
        2183: 0,
        2184: 0,
        2185: 0,
        2186: 0,
        2187: 0,
        2188: 0,
        2189: 0,
        2190: 0,
        2191: 0,
        2192: 0,
        2193: 0,
        2195: 0,
        2196: 0,
        2197: 0,
        2198: 0,
        2200: 0,
        2201: 0,
        2202: 0,
        2203: 0,
        2204: 2,
        2205: 0,
        2206: 0,
        2207: 0,
        2208: 0,
        2209: 0,
        2210: 0,
        2211: 0,
        2212: 0,
        2213: 0,
        2214: 0,
        2215: 0,
        2216: 0,
        2217: 0,
        2219: 0,
        2220: 0,
        2222: 1,
        2223: 1,
        2224: 1,
        2225: 2,
        2226: 2,
        2227: 2,
        2228: 2,
        2229: 2,
        2230: 2,
        2231: 2,
        2232: 2,
        2233: 2,
        2234: 2,
        2235: 2,
        2236: 2,
        2237: 2,
        2238: 2,
        2239: 2,
        2240: 2,
        2241: 2,
        2242: 2,
        2243: 2,
        2244: 2,
        2245: 2,
        2246: 2,
        2247: 2,
        2248: 2,
        2249: 2,
        2250: 2,
        2251: 1,
        2252: 1,
        2253: 1,
        2254: 2,
        2255: 2,
        2256: 1,
        2257: 2,
        2258: 2,
        2259: 2,
        2260: 2,
        2261: 2,
        2262: 2,
        2263: 2,
        2264: 2,
        2265: 1,
        2266: 1,
        2267: 2,
        2268: 2,
        2269: 1,
        2270: 1,
        2271: 2,
        2272: 2,
        2273: 1,
        2274: 2,
        2275: 2,
        2276: 2,
        2277: 2,
        2278: 2,
        2279: 2,
        2280: 1,
        2281: 1,
        2282: 1,
        2283: 2,
        2284: 2,
        2285: 2,
        2286: 2,
        2287: 2,
        2288: 2,
        2289: 2,
        2290: 0,
        2291: 0,
        2292: 0,
        2294: 0,
        2295: 0,
        2308: 0,
        2309: 0,
        2310: 0,
        2311: 0,
        2312: 0,
        2313: 0,
        2314: 3,
        2315: 0,
        2316: 0,
        2317: 0,
        2318: 0,
        2319: 0,
        2320: 0,
        2321: 0,
        2322: 0,
        2323: 0,
        2324: 0,
        2325: 0,
        2326: 0,
        2327: 0,
        2328: 0,
        2329: 0,
        2330: 0,
        2331: 0,
        2332: 0,
        2333: 0,
        2334: 0,
        2335: 0,
        2336: 0,
        2337: 0,
        2338: 0,
        2339: 0,
        2340: 0,
        2341: 0,
        2342: 0,
        2343: 0,
        2344: 0,
        2345: 0,
        2346: 0,
        2347: 0,
        2348: 0,
        2349: 0,
        2350: 0,
        2351: 0,
        2352: 0,
        2353: 0,
        2354: 0,
        2355: 0,
        2356: 0,
        2357: 0,
        2358: 0,
        2359: 0,
        2360: 0,
        2361: 0,
        2362: 0,
        2363: 0,
        2364: 0,
        2365: 0,
        2366: 0,
        2367: 0,
        2368: 0,
        2369: 0,
        2370: 0,
        2371: 0,
        2372: 0,
        2373: 0,
        2374: 0,
        2375: 0,
        2376: 0,
        2377: 0,
        2378: 0,
        2379: 0,
        2380: 0,
        2381: 0,
        2382: 0,
        2383: 0,
        2384: 0,
        2385: 0,
        2386: 0,
        2387: 0,
        2388: 0,
        2389: 0,
        2390: 0,
        2391: 0,
        2392: 0,
        2393: 0,
        2394: 0,
        2395: 0,
        2396: 0,
        2397: 0,
        2398: 0,
        2399: 0,
        2400: 0,
        2401: 0,
        2402: 0,
        2403: 0,
        2404: 0,
        2405: 0,
        2406: 0,
        2407: 0,
        2408: 0,
        2409: 0,
        2410: 0,
        2411: 0,
        2412: 0,
        2413: 0,
        2414: 0,
        2415: 0,
        2416: 0,
        2417: 0,
        2418: 0,
        2419: 0,
        2420: 0,
        2421: 0,
        2422: 0,
        2423: 0,
        2424: 0,
        2425: 0,
        2426: 0,
        2427: 0,
        2428: 0,
        2429: 0,
        2430: 0,
        2431: 0,
        2432: 0,
        2433: 0,
        2434: 0,
        2435: 0,
        2436: 0,
        2437: 0,
        2438: 0,
        2439: 0,
        2440: 0,
        2441: 0,
        2442: 0,
        2443: 0,
        2444: 0,
        2445: 0,
        2446: 0,
        2447: 0,
        2448: 0,
        2449: 0,
        2450: 0,
        2451: 0,
        2452: 0,
        2453: 0,
        2454: 0,
        2455: 0,
        2456: 0,
        2457: 0,
        2458: 0,
        2459: 0,
        2460: 0,
        2461: 0,
        2462: 0,
        2523: 0,
        2524: 0,
        2525: 0,
        2526: 0,
        2527: 0,
        2528: 0,
        2529: 0,
        2530: 0,
        2531: 0,
        2532: 0,
        2533: 0,
        2534: 0,
        2535: 0,
        2536: 0,
        2537: 0,
        2538: 0,
        2539: 0,
        2540: 0,
        2541: 0,
        2542: 0,
        2543: 0,
        2544: 0,
        2545: 0,
        2546: 0,
        2547: 0,
        2548: 0,
        2549: 0,
        2550: 0,
        2551: 0,
        2552: 0,
        2553: 0,
        2554: 0,
        2555: 0,
        2556: 0,
        2557: 0,
        2558: 0,
        2559: 0,
        2560: 0,
        2561: 0,
        2562: 0,
        2563: 0,
        2564: 0,
        2565: 0,
        2566: 0,
        2567: 0,
        2568: 0,
        2569: 0,
        2570: 0,
        2571: 0,
        2572: 0,
        2573: 0,
        2574: 0,
        2575: 0,
        2576: 0,
        2577: 0,
        2578: 0,
        2579: 0,
        2580: 0,
        2581: 0,
        2582: 0,
        2583: 0,
        2584: 0,
        2585: 0,
        2586: 0,
        2587: 0,
        2588: 0,
        2589: 0,
        2590: 0,
        2591: 0,
        2592: 0,
        2593: 0,
        2594: 0,
        2595: 0,
        2596: 0,
        2597: 0,
        2598: 0,
        2599: 0,
        2600: 0,
        2601: 0,
        2602: 0,
        2603: 0,
        2604: 0,
        2605: 0,
        2606: 0,
        2607: 0,
        2608: 0,
        2609: 0,
        2610: 0,
        2611: 0,
        2612: 0,
        2613: 0,
        2614: 0,
        2615: 0,
        2616: 0,
        2617: 0,
        2618: 0,
        2619: 0,
        2620: 0,
        2621: 0,
        2622: 0,
        2623: 0,
        2624: 0,
        2625: 0,
        2626: 0,
        2627: 0,
        2628: 0,
        2629: 0,
        2630: 0,
        2631: 0,
        2632: 0,
        2633: 0,
        2634: 0,
        2635: 0,
        2636: 0,
        2637: 0,
        2638: 0,
        2639: 0,
        2640: 0,
        2641: 0,
        2642: 0,
        2643: 0,
        2644: 0,
        2645: 0,
        2646: 0,
        2647: 0,
        2648: 0,
        2649: 0,
        2650: 0,
        2651: 0,
        2652: 0,
        2653: 0,
        2654: 0,
        2655: 0,
        2656: 0,
        2657: 0,
        2658: 0,
        2659: 0,
        2660: 0,
        2661: 0,
        2662: 0,
        2663: 0,
        2664: 0,
        2665: 0,
        2666: 0,
        2667: 0,
        2668: 0,
        2669: 0,
        2670: 0,
        2671: 0,
        2672: 0,
        2673: 0,
        2674: 0,
        2675: 0,
        2676: 0,
        2677: 0,
        2678: 0,
        2679: 0,
        2680: 0,
        2681: 0,
        2682: 0,
        2683: 0,
        2684: 0,
        2685: 0,
        2686: 0,
        2687: 0,
        2688: 0,
        2689: 0,
        2690: 0,
        2691: 0,
        2692: 0,
        2693: 0,
        2694: 0,
        2695: 0,
        2696: 0,
        2697: 0,
        2698: 0,
        2699: 0,
        2700: 0,
        2701: 0,
        2702: 0,
        2703: 0,
        2704: 0,
        2705: 0,
        2706: 0,
        2707: 0,
        2708: 0,
        2709: 0,
        2710: 0,
        2711: 0,
        2712: 0,
        2713: 0,
        2714: 0,
        2715: 0,
        2716: 0,
        2717: 0,
        2718: 0,
        2719: 0,
        2720: 0,
        2721: 0,
        2722: 0,
        2723: 0,
        2724: 0,
        2725: 0,
        2726: 0,
        2727: 0,
        2728: 0,
        2729: 0,
        2730: 0,
        2731: 0,
        2732: 0,
        2733: 0,
        2734: 0,
        2735: 0,
        2736: 0,
        2737: 0,
        2738: 0,
        2739: 0,
        2740: 0,
        2741: 0,
        2742: 0,
        2743: 0,
        2744: 0,
        2745: 0,
        2746: 0,
        2747: 0,
        2748: 0,
        2749: 0,
        2750: 0,
        2751: 0,
        2752: 0,
        2753: 0,
        2754: 0,
        2755: 0,
        2756: 0,
        2757: 0,
        2758: 0,
        2759: 0,
        2760: 0,
        2761: 0,
        2762: 0,
        2763: 0,
        2764: 0,
        2765: 0,
        2766: 0,
        2767: 0,
        2768: 0,
        2769: 0,
        2770: 0,
        2771: 0,
        2772: 0,
        2773: 0,
        2774: 0,
        2775: 0,
        2776: 0,
        2777: 0,
        2778: 0,
        2779: 0,
        2780: 0,
        2781: 0,
        2782: 0,
        2783: 0,
        2784: 0,
        2785: 0,
        2786: 0,
        2787: 0,
        2788: 0,
        2789: 0,
        2790: 0,
        2791: 0,
        2792: 0,
        2793: 0,
        2794: 0,
        2795: 0,
        2796: 0,
        2797: 0,
        2798: 0,
        2799: 0,
        2800: 0,
        2801: 0,
        2802: 0,
        2803: 0,
        2804: 0,
        2805: 0,
        2806: 0,
        2807: 0,
        2808: 0,
        2809: 0,
        2810: 0,
        2811: 0,
        2812: 0,
        2813: 0,
        2814: 0,
        2815: 0,
        2816: 0,
        2817: 0,
        2818: 0,
        2819: 0,
        2820: 0,
        2821: 0,
        2822: 0,
        2823: 0,
        2824: 0,
        2825: 0,
        2826: 0,
        2827: 0,
        2828: 0,
        2829: 0,
        2830: 0,
        2831: 0,
        2832: 0,
        2833: 0,
        2834: 0,
        2835: 0,
        2836: 0,
        2837: 0,
        2838: 0,
        2839: 0,
        2840: 0,
        2841: 0,
        2842: 0,
        2843: 0,
        2844: 0,
        2845: 0,
        2846: 0,
        2847: 0,
        2848: 0,
        2849: 0,
        2850: 0,
        2851: 0,
        2852: 0,
        2853: 0,
        2854: 0,
        2855: 0,
        2856: 0,
        2857: 0,
        2858: 0,
        2859: 0,
        2860: 0,
        2861: 0,
        2862: 0,
        2863: 0,
        2864: 0,
        2865: 0,
        2866: 0,
        2867: 1,
        2868: 1,
        2869: 1,
        2870: 2,
        2871: 2,
        2872: 2,
        2873: 2,
        2874: 2,
        2875: 2,
        2876: 2,
        2877: 2,
        2878: 2,
        2879: 2,
        2880: 2,
        2881: 2,
        2882: 2,
        2883: 2,
        2884: 2,
        2885: 2,
        2886: 2,
        2887: 2,
        2888: 2,
        2891: 2,
        2892: 2,
        2893: 2,
        2894: 2,
        2895: 2,
        2896: 1,
        2897: 1,
        2898: 1,
        2899: 2,
        2900: 2,
        2901: 1,
        2902: 2,
        2903: 2,
        2904: 2,
        2905: 2,
        2906: 2,
        2907: 2,
        2908: 2,
        2909: 1,
        2910: 1,
        2911: 2,
        2912: 2,
        2913: 1,
        2914: 1,
        2915: 2,
        2916: 2,
        2917: 2,
        2918: 2,
        2919: 2,
        2920: 2,
        2921: 1,
        2922: 1,
        2923: 1,
        2924: 2,
        2925: 2,
        2926: 2,
        2927: 2,
        2928: 2,
        2929: 2,
        2930: 2,
        2931: 0,
        2932: 0,
        2933: 0,
        2934: 0,
        2935: 0,
        2936: 0,
        2937: 0,
        2938: 0,
        2939: 0,
        2940: 0,
        2941: 0,
        2942: 0,
        2943: 0,
        2944: 0,
        2945: 0,
        2946: 0,
        2947: 0,
        2948: 0,
        2949: 0,
        2950: 0,
        2951: 0,
        2952: 0,
        2953: 0,
        2954: 0,
        2955: 0,
        2956: 0,
        2957: 0,
        2958: 0,
        2959: 0,
        2960: 0,
        2961: 0,
        2962: 0,
        2964: 2,
        2965: 2,
        2966: 2,
        2967: 2,
        2968: 2,
        2969: 0,
        2970: 0,
        2971: 0,
        2972: 0,
        2973: 0,
        2975: 0,
        2976: 0,
        2977: 0,
        2978: 0,
        2979: 0,
        2980: 0,
        2981: 0,
        2982: 0,
        2983: 0,
        2984: 0,
        2985: 0,
        2986: 0,
        2987: 0,
        2988: 0,
        2989: 0,
        2990: 0,
        2991: 0,
        2992: 1,
        2993: 0,
        2994: 1,
        2995: 0,
        2996: 0,
        2997: 0,
        2998: 0,
        2999: 0,
        3E3: 0,
        3001: 0,
        3002: 0,
        3003: 0,
        3004: 0,
        3005: 0,
        3006: 0,
        3007: 0,
        3008: 0,
        3009: 0,
        3010: 0,
        3011: 0,
        3012: 0,
        3013: 0,
        3014: 0,
        3015: 0,
        3016: 0,
        3017: 0,
        3018: 0,
        3019: 0,
        3020: 0,
        3021: 0,
        3022: 0,
        3023: 0,
        3024: 0,
        3025: 0,
        3026: 0,
        3027: 0,
        3028: 0,
        3029: 0,
        3030: 0,
        3031: 0,
        3032: 0,
        3033: 0,
        3034: 0,
        3035: 0,
        3036: 0,
        3037: 0,
        3038: 0,
        3039: 0,
        3040: 0,
        3041: 0,
        3042: 0,
        3043: 0,
        3044: 0,
        3045: 0,
        3046: 0,
        3047: 0,
        3048: 0,
        3049: 0,
        3050: 0,
        3051: 0,
        3054: 0,
        3055: 0,
        3056: 0,
        3057: 0,
        3058: 0,
        3059: 0,
        3060: 0,
        3061: 0,
        3062: 0,
        3063: 0,
        3064: 0,
        3065: 0,
        3066: 0,
        3067: 0,
        3068: 0,
        3069: 0,
        3070: 0,
        3071: 0,
        3072: 0,
        3073: 0,
        3074: 0,
        3075: 0,
        3076: 0,
        3077: 0,
        3078: 0,
        3079: 0,
        3080: 1,
        3081: 0,
        3082: 0,
        3083: 0,
        3084: 0,
        3085: 0,
        3086: 0,
        3087: 0,
        3088: 0,
        3089: 2,
        3090: 0,
        3091: 2,
        3092: 0,
        3093: 0,
        3094: 0,
        3095: 0,
        3096: 0,
        3097: 0,
        3098: 0,
        3099: 0,
        3100: 0,
        3101: 0,
        3102: 2,
        3106: 0,
        3107: 0,
        3108: 0,
        3109: 0,
        3110: 0,
        3111: 0,
        3112: 0,
        3113: 0,
        3114: 0,
        3115: 0,
        3116: 0,
        3117: 0,
        3118: 0,
        3119: 0,
        3120: 0,
        3121: 0,
        3122: 0,
        3123: 0,
        3124: 0,
        3125: 0,
        3126: 0,
        3127: 0,
        3128: 0,
        3129: 0,
        3130: 0,
        3131: 0,
        3132: 0,
        3133: 0,
        3134: 0,
        3135: 0,
        3136: 0,
        3137: 0,
        3138: 0,
        3141: 0,
        3142: 0,
        3146: 0,
        3147: 0,
        3148: 0,
        3149: 0,
        3150: 0,
        3151: 0,
        3153: 0,
        3154: 0,
        3155: 0,
        3156: 0,
        3157: 0,
        3158: 0,
        3159: 0,
        3160: 0,
        3161: 0,
        3162: 0,
        3163: 0,
        3164: 0,
        3165: 0,
        3166: 0,
        3167: 13,
        3168: 0,
        3169: 0,
        3170: 0,
        3171: 0,
        3172: 0,
        3174: 0,
        3175: 0,
        3176: 0,
        3177: 0,
        3178: 0,
        3179: 0,
        3180: 0,
        3181: 0,
        3182: 0,
        3183: 0,
        3184: 0,
        3185: 0,
        3186: 0,
        3187: 0,
        3188: 0,
        3189: 0,
        3190: 0,
        3191: 0,
        3192: 0,
        3193: 0,
        3194: 0,
        3195: 0,
        3196: 0,
        3197: 0,
        3198: 0,
        3199: 0,
        3200: 0,
        3201: 0,
        3202: 0,
        3203: 0,
        3294: 0,
        3295: 0,
        3296: 0,
        3297: 0,
        3298: 0,
        3299: 0,
        3300: 0,
        3301: 0,
        3302: 0,
        3303: 0,
        3304: 0,
        3305: 0,
        3306: 0,
        3307: 0,
        3308: 0,
        3309: 0,
        3310: 0,
        3311: 0,
        3312: 0,
        3313: 0,
        3314: 0,
        3315: 0,
        3316: 0,
        3317: 0,
        3318: 0,
        3319: 0,
        3320: 0,
        3321: 0,
        3322: 0,
        3323: 0,
        3324: 0,
        3325: 0,
        3326: 0,
        3327: 0,
        3328: 0,
        3329: 0,
        3330: 0,
        3331: 0,
        3332: 0,
        3333: 0,
        3334: 0,
        3335: 0,
        3336: 0,
        3337: 0,
        3338: 0,
        3339: 0,
        3340: 0,
        3341: 0,
        3342: 0,
        3343: 0,
        3344: 0,
        3345: 0,
        3346: 0,
        3347: 0,
        3348: 0,
        3349: 0,
        3350: 0,
        3351: 0,
        3352: 0,
        3353: 0,
        3354: 0,
        3355: 0,
        3356: 0,
        3357: 0,
        3358: 0,
        3359: 2,
        3360: 0,
        3361: 1,
        3362: 0,
        3363: 2,
        3364: 0,
        3365: 2,
        3366: 3,
        3367: 0,
        3368: 0,
        3369: 0,
        3370: 0,
        3371: 0,
        3372: 0,
        3373: 0,
        3374: 0,
        3375: 0,
        3376: 0,
        3377: 0,
        3378: 0,
        3379: 0,
        3380: 0,
        3381: 0,
        3382: 0,
        3383: 0,
        3384: 0,
        3385: 0,
        3386: 0,
        3387: 0,
        3388: 0,
        3389: 0,
        3390: 0,
        3391: 0,
        3392: 0,
        3393: 0,
        3394: 0,
        3395: 0,
        3396: 0,
        3397: 0,
        3398: 0,
        3399: 0,
        3400: 0,
        3401: 0,
        3402: 0,
        3403: 0,
        3404: 2,
        3405: 0,
        3406: 0,
        3407: 3,
        3408: 0,
        3409: 0,
        3410: 0,
        3411: 0,
        3412: 0,
        3413: 0,
        3414: 0,
        3415: 0,
        3416: 0,
        3417: 2,
        3418: 2,
        3419: 2,
        3420: 2,
        3421: 2,
        3422: 2,
        3423: 2,
        3424: 2,
        3425: 2,
        3426: 2,
        3427: 2,
        3428: 2,
        3429: 2,
        3430: 2,
        3431: 2,
        3432: 2,
        3433: 2,
        3434: 2,
        3435: 2,
        3436: 2,
        3437: 2,
        3438: 2,
        3439: 0,
        3440: 0,
        3441: 2,
        3442: 2,
        3443: 2,
        3444: 2,
        3445: 2,
        3446: 2,
        3447: 0,
        3448: 0,
        3449: 0,
        3450: 0,
        3451: 2,
        3452: 2,
        3453: 2,
        3454: 2,
        3455: 2,
        3456: 2,
        3457: 2,
        3458: 2,
        3459: 2,
        3460: 0,
        3461: 0,
        3462: 0,
        3463: 0,
        3464: 0,
        3465: 0,
        3466: 0,
        3467: 0,
        3468: 0,
        3469: 0,
        3470: 0,
        3471: 0,
        3472: 0,
        3473: 0,
        3474: 0,
        3475: 0,
        3476: 0,
        3477: 0,
        3478: 0,
        3479: 1,
        3480: 0,
        3481: 1,
        3482: 0,
        3483: 1,
        3484: 0,
        3485: 2,
        3486: 0,
        3487: 2,
        3488: 0,
        3489: 0,
        3490: 2,
        3491: 0,
        3492: 2,
        3493: 0,
        3494: 2,
        3495: 0,
        3496: 2,
        3497: 0,
        3498: 2,
        3499: 0,
        3500: 2,
        3501: 0,
        3502: 2,
        3503: 0,
        3504: 2,
        3505: 0,
        3506: 2,
        3507: 0,
        3508: 2,
        3509: 0,
        3510: 2,
        3511: 0,
        3512: 2,
        3513: 0,
        3514: 0,
        3515: 2,
        3516: 0,
        3517: 2,
        3518: 0,
        3519: 2,
        3520: 0,
        3521: 2,
        3522: 0,
        3523: 2,
        3524: 0,
        3525: 2,
        3526: 0,
        3527: 2,
        3528: 0,
        3529: 2,
        3530: 0,
        3531: 2,
        3532: 0,
        3533: 2,
        3534: 0,
        3535: 2,
        3536: 0,
        3537: 2,
        3538: 0,
        3539: 2,
        3540: 0,
        3541: 2,
        3542: 0,
        3543: 2,
        3544: 0,
        3545: 2,
        3546: 0,
        3547: 2,
        3548: 0,
        3549: 2,
        3550: 0,
        3551: 2,
        3552: 0,
        3553: 2,
        3554: 0,
        3555: 0,
        3556: 0,
        3557: 0,
        3558: 0,
        3559: 0,
        3560: 2,
        3561: 2,
        3562: 2,
        3563: 2,
        3564: 2,
        3565: 2,
        3566: 2,
        3567: 2,
        3568: 2,
        3569: 2,
        3570: 2,
        3571: 0,
        3572: 0,
        3573: 0,
        3574: 0,
        3575: 0,
        3576: 0,
        3577: 0,
        3578: 0,
        3579: 0,
        3580: 0,
        3581: 0,
        3582: 2,
        3583: 0,
        3584: 2,
        3585: 0,
        3586: 2,
        3587: 0,
        3588: 1,
        3589: 0,
        3590: 1,
        3591: 0,
        3592: 0,
        3593: 1,
        3594: 0,
        3595: 0,
        3596: 0,
        3597: 0,
        3598: 2,
        3599: 0,
        3600: 2,
        3601: 0,
        3602: 0,
        3603: 0,
        3604: 0,
        3605: 1,
        3606: 0,
        3607: 0,
        3608: 2,
        3609: 0,
        3610: 2,
        3611: 0,
        3612: 2,
        3613: 0,
        3614: 2,
        3615: 0,
        3616: 2,
        3617: 0,
        3618: 2,
        3619: 0,
        3620: 2,
        3621: 0,
        3622: 2,
        3623: 0,
        3624: 2,
        3625: 0,
        3626: 2,
        3627: 0,
        3628: 2,
        3629: 0,
        3630: 2,
        3631: 0,
        3632: 2,
        3633: 0,
        3634: 1,
        3635: 0,
        3636: 1,
        3637: 0,
        3638: 0,
        3639: 0,
        3640: 2,
        3641: 0,
        3642: 2,
        3643: 0,
        3644: 1,
        3645: 0,
        3646: 1,
        3647: 0,
        3648: 1,
        3649: 0,
        3650: 2,
        3651: 0,
        3652: 2,
        3653: 0,
        3654: 2,
        3655: 0,
        3656: 1,
        3657: 0,
        3658: 2,
        3659: 0,
        3660: 2,
        3661: 0,
        3662: 2,
        3663: 0,
        3664: 2,
        3665: 0,
        3666: 0,
        3667: 0,
        3668: 2,
        3669: 0,
        3670: 2,
        3671: 0,
        3672: 2,
        3673: 0,
        3674: 2,
        3675: 0,
        3676: 1,
        3677: 2,
        3678: 0,
        3679: 1,
        3680: 2,
        3681: 0,
        3682: 1,
        3683: 2,
        3684: 0,
        3685: 0,
        3686: 2,
        3687: 0,
        3688: 2,
        3689: 0,
        3690: 2,
        3691: 0,
        3692: 2,
        3693: 0,
        3694: 0,
        3695: 0,
        3696: 2,
        3697: 0,
        3698: 2,
        3699: 0,
        3700: 2,
        3701: 0,
        3702: 0,
        3703: 0,
        3704: 0,
        3705: 0,
        3706: 0,
        3707: 0,
        3708: 0,
        3709: 0,
        3710: 0,
        3711: 0,
        3712: 0,
        3713: 0,
        3714: 0,
        3715: 0,
        3716: 0,
        3717: 0,
        3718: 0,
        3719: 0,
        3720: 0,
        3721: 0,
        3722: 0,
        3723: 0,
        3724: 0,
        3725: 0,
        3726: 0,
        3727: 0,
        3728: 2,
        3729: 2,
        3730: 2,
        3731: 2,
        3732: 2,
        3733: 2,
        3734: 2,
        3735: 2,
        3736: 2,
        3737: 2,
        3738: 2,
        3739: 2,
        3740: 0,
        3741: 0,
        3742: 0,
        3743: 0,
        3744: 0,
        3745: 0,
        3746: 0,
        3747: 0,
        3748: 0,
        3749: 0,
        3750: 0,
        3751: 0,
        3753: 2,
        3754: 2,
        3755: 2,
        3756: 2,
        3757: 2,
        3758: 2,
        3759: 2,
        3760: 2,
        3761: 0,
        3762: 0,
        3763: 0,
        3764: 0,
        3765: 0,
        3766: 0,
        3767: 0,
        3768: 0,
        3769: 0,
        3770: 0,
        3771: 0,
        3772: 0,
        3773: 0,
        3775: 0,
        3776: 0,
        3777: 0,
        3779: 0,
        3780: 0,
        3781: 0,
        3783: 0,
        3784: 0,
        3785: 0,
        3788: 0,
        3789: 0,
        3790: 0,
        3791: 0,
        3793: 0,
        3794: 0,
        3797: 0,
        3798: 0,
        3799: 0,
        3800: 0,
        3801: 0,
        3802: 0,
        3812: 0,
        3814: 0,
        3815: 0,
        3816: 0,
        3825: 0,
        3826: 0,
        3827: 0,
        3828: 0,
        3829: 0,
        3832: 0,
        3833: 0,
        3834: 0,
        3835: 0,
        3836: 0,
        3837: 0,
        3838: 0,
        3839: 0,
        3840: 0,
        3841: 0,
        3844: 0,
        3845: 0,
        3846: 0,
        3847: 0,
        3848: 0,
        3849: 0,
        3850: 0,
        3851: 0,
        3852: 0,
        3854: 0,
        3857: 0,
        3873: 0,
        3874: 0,
        3875: 0,
        3876: 0,
        3877: 0,
        3878: 0,
        3879: 0,
        3880: 0,
        3881: 0,
        3882: 0,
        3883: 0,
        3884: 0,
        3885: 0,
        3890: 0,
        3891: 0,
        3892: 0,
        3893: 0,
        3907: 0,
        3908: 0,
        3909: 0,
        3910: 0,
        3911: 0,
        3912: 0,
        3920: 0,
        3942: 0,
        3943: 0,
        3944: 0,
        3945: 0,
        3946: 0,
        3947: 0,
        3948: 0,
        3949: 0,
        3950: 0,
        3968: 0,
        3969: 0,
        3970: 0,
        3973: 0,
        3974: 0,
        3975: 0,
        3976: 0,
        3978: 0,
        3979: 0,
        3986: 0,
        3987: 0,
        3988: 0,
        3989: 0,
        3991: 2,
        3992: 2,
        3994: 0,
        3995: 0,
        3996: 0,
        3997: 0,
        4026: 0,
        4037: 0,
        4038: 0,
        4048: 0,
        4049: 0,
        4050: 0,
        4051: 0,
        4056: 0,
        4057: 0,
        4058: 0,
        4059: 0,
        4060: 0,
        4061: 0,
        4062: 0,
        4063: 0,
        4071: 0,
        4082: 0,
        4083: 0,
        4093: 0,
        4094: 0,
        4095: 0,
        4096: 0,
        4217: 2,
        4399: 2,
        4400: 2,
        4401: 2,
        4402: 2,
        4403: 2,
        4404: 2,
        4405: 2,
        4406: 2,
        4407: 2,
        4408: 2,
        4409: 2,
        4410: 2,
        4411: 2,
        4412: 2,
        4413: 2,
        4414: 0,
        4415: 0,
        4417: 0,
        4418: 2,
        4419: 2,
        4420: 2,
        4421: 2,
        4422: 2,
        4423: 2,
        4424: 2,
        4425: 2,
        4426: 2,
        4427: 2,
        4428: 2,
        4429: 2,
        4430: 2,
        4431: 2,
        4432: 2,
        4433: 2,
        4434: 0,
        4437: 0,
        4438: 2,
        4439: 2,
        4455: 2,
        4456: 2,
        4457: 2,
        4462: 0,
        4467: 0,
        4471: 0,
        4474: 0,
        4484: 0,
        4485: 0,
        4486: 0,
        4487: 0,
        4488: 0,
        4489: 0,
        4491: 0,
        4492: 0,
        4493: 0,
        4494: 0,
        4495: 0,
        4496: 0,
        4497: 0,
        4498: 0,
        4499: 0,
        4500: 0,
        4501: 0,
        4502: 0,
        4503: 0,
        4504: 0,
        4505: 0,
        4506: 0,
        4507: 0,
        4508: 0,
        4509: 0,
        4510: 0,
        4511: 0,
        4512: 0,
        4513: 0,
        4514: 0,
        4515: 0,
        4516: 0,
        4517: 0,
        4518: 0,
        4519: 0,
        4520: 0,
        4521: 0,
        4522: 0,
        4523: 0,
        4524: 0,
        4525: 0,
        4526: 0,
        4527: 0,
        4528: 0,
        4529: 0,
        4530: 0,
        4531: 0,
        4532: 0,
        4533: 0,
        4534: 0,
        4535: 0,
        4536: 0,
        4537: 0,
        4538: 0,
        4539: 0,
        4540: 0,
        4541: 0,
        4542: 0,
        4543: 0,
        4544: 0,
        4545: 0,
        4546: 0,
        4547: 0,
        4548: 0,
        4549: 0,
        4550: 0,
        4551: 0,
        4552: 0,
        4553: 0,
        4554: 0,
        4559: 0,
        4568: 0,
        4569: 0,
        4570: 0,
        4571: 0,
        4572: 0,
        4573: 0,
        4574: 0,
        4575: 0,
        4576: 0,
        4577: 0,
        4578: 0,
        4579: 0,
        4580: 0,
        4581: 0,
        4582: 0,
        4583: 0,
        4584: 0,
        4585: 0,
        4586: 0,
        4587: 0,
        4588: 0,
        4589: 0,
        4647: 0,
        4652: 0,
        4653: 0,
        4654: 0,
        4655: 0,
        4656: 0,
        4766: 0,
        4767: 0,
        4768: 0,
        4769: 0,
        4770: 0,
        4771: 0,
        4772: 0,
        4773: 0,
        4774: 0,
        4775: 0,
        4776: 0,
        4777: 0,
        4778: 0,
        4779: 0,
        4780: 0,
        4781: 0,
        4782: 0,
        4783: 0,
        4784: 0,
        4785: 0,
        4786: 0,
        4787: 0,
        4788: 0,
        4789: 0,
        4790: 0,
        4791: 0,
        4792: 0,
        4793: 0,
        4794: 0,
        4795: 0,
        4796: 0,
        4797: 0,
        4798: 0,
        4799: 0,
        4800: 0,
        4822: 0,
        4826: 0,
        4839: 0,
        5014: 0,
        5015: 0,
        5016: 0,
        5018: 0,
        5048: 0,
        5069: 0,
        5070: 0,
        5071: 0,
        5072: 0,
        5105: 0,
        5106: 0,
        5107: 0,
        5108: 0,
        5109: 0,
        5110: 0,
        5111: 0,
        5112: 0,
        5113: 0,
        5114: 0,
        5115: 0,
        5116: 0,
        5117: 0,
        5118: 0,
        5119: 0,
        5120: 0,
        5121: 0,
        5122: 0,
        5123: 0,
        5124: 0,
        5125: 0,
        5126: 0,
        5127: 0,
        5128: 0,
        5129: 0,
        5130: 0,
        5167: 0,
        5168: 0,
        5173: 0,
        5174: 0,
        5175: 0,
        5176: 0,
        5177: 0,
        5178: 0,
        5179: 0,
        5180: 0,
        5181: 0,
        5182: 0,
        5183: 0,
        5184: 0,
        5185: 0,
        5186: 0,
        5187: 0,
        5188: 0,
        5221: 0,
        5223: 0,
        5234: 0,
        5235: 0,
        5243: 0,
        5247: 0,
        5253: 0,
        5254: 0,
        5255: 0,
        5256: 0,
        5257: 0,
        5258: 0,
        5259: 0,
        5266: 0,
        5269: 0,
        5270: 0,
        5271: 0,
        5272: 0,
        5273: 0,
        5274: 0,
        5275: 0,
        5292: 0,
        5293: 0,
        5294: 0,
        5295: 0,
        5296: 0,
        5297: 0,
        5298: 0,
        5299: 0,
        5300: 0,
        5301: 0,
        5302: 0,
        5303: 0,
        5304: 0,
        5305: 0,
        5306: 0,
        5307: 0,
        5308: 0,
        5309: 0,
        5310: 0,
        5311: 0,
        5316: 0,
        5320: 0,
        5321: 0,
        5325: 0,
        5329: 0,
        5330: 0,
        5331: 0,
        5337: 0,
        5343: 0,
        5344: 0,
        5345: 0,
        5346: 0,
        5347: 0,
        5348: 0,
        5349: 0,
        5355: 0,
        5356: 0,
        5357: 0,
        5361: 0,
        5362: 0,
        5367: 0,
        5382: 0,
        5383: 0,
        5387: 0,
        5388: 0,
        5389: 0,
        5396: 0,
        5456: 0,
        5457: 0,
        5459: 0,
        5460: 0,
        5461: 0,
        5462: 0,
        5463: 0,
        5469: 0,
        5472: 4,
        5479: 0,
        5480: 0,
        5481: 0,
        5482: 0,
        5490: 0,
        5513: 0,
        5514: 0,
        5518: 0,
        5519: 0,
        5520: 0,
        5523: 0,
        5530: 0,
        5531: 0,
        5532: 0,
        5533: 0,
        5534: 0,
        5535: 0,
        5536: 0,
        5537: 0,
        5538: 0,
        5539: 0,
        5550: 0,
        5551: 0,
        5552: 0,
        5559: 0,
        5562: 0,
        5563: 0,
        5564: 0,
        5565: 0,
        5566: 0,
        5567: 0,
        5568: 0,
        5569: 0,
        5570: 0,
        5571: 0,
        5572: 0,
        5573: 0,
        5574: 0,
        5575: 0,
        5576: 0,
        5577: 0,
        5578: 0,
        5579: 0,
        5580: 0,
        5581: 0,
        5582: 0,
        5583: 0,
        5588: 1,
        5589: 3,
        5596: 0,
        5623: 2,
        5624: 2,
        5625: 2,
        5627: 0,
        5629: 0,
        5631: 0,
        5632: 0,
        5633: 0,
        5634: 0,
        5635: 0,
        5636: 0,
        5637: 0,
        5638: 0,
        5639: 0,
        5641: 0,
        5643: 0,
        5644: 0,
        5646: 2,
        5649: 0,
        5650: 0,
        5651: 0,
        5652: 0,
        5653: 0,
        5654: 2,
        5655: 2,
        5659: 0,
        5663: 0,
        5664: 0,
        5665: 0,
        5666: 0,
        5667: 0,
        5668: 0,
        5669: 0,
        5670: 0,
        5671: 0,
        5672: 0,
        5673: 0,
        5674: 0,
        5675: 0,
        5676: 0,
        5677: 0,
        5678: 0,
        5679: 0,
        5680: 0,
        5682: 0,
        5683: 0,
        5684: 0,
        5685: 0,
        5700: 0,
        5825: 0,
        5836: 0,
        5837: 0,
        5839: 0,
        5842: 0,
        5844: 0,
        5858: 0,
        5875: 0,
        5876: 0,
        5877: 0,
        5879: 0,
        5880: 0,
        5887: 0,
        5890: 0,
        5921: 0,
        5922: 0,
        5923: 0,
        5924: 0,
        5925: 0,
        5926: 0,
        5927: 0,
        5928: 0,
        5929: 0,
        5930: 0,
        5931: 0,
        5932: 0,
        5933: 0,
        5934: 0,
        5935: 0,
        5936: 0,
        5937: 0,
        5938: 0,
        5939: 0,
        5940: 0,
        6050: 0,
        6051: 0,
        6052: 0,
        6053: 0,
        6054: 0,
        6055: 0,
        6056: 0,
        6057: 0,
        6058: 0,
        6059: 0,
        6060: 0,
        6061: 0,
        6062: 0,
        6063: 0,
        6064: 0,
        6065: 0,
        6066: 0,
        6067: 0,
        6068: 0,
        6069: 0,
        6070: 0,
        6071: 0,
        6072: 0,
        6073: 0,
        6074: 0,
        6075: 0,
        6076: 0,
        6077: 0,
        6078: 0,
        6079: 0,
        6080: 0,
        6081: 0,
        6082: 0,
        6083: 0,
        6084: 0,
        6085: 0,
        6086: 0,
        6087: 0,
        6088: 0,
        6089: 0,
        6090: 0,
        6091: 0,
        6092: 0,
        6093: 0,
        6094: 0,
        6095: 0,
        6096: 0,
        6097: 0,
        6098: 0,
        6099: 0,
        6100: 0,
        6101: 0,
        6102: 0,
        6103: 0,
        6104: 0,
        6105: 0,
        6106: 0,
        6107: 0,
        6108: 0,
        6109: 0,
        6110: 0,
        6111: 0,
        6112: 0,
        6113: 0,
        6114: 0,
        6115: 0,
        6116: 0,
        6117: 0,
        6118: 0,
        6119: 0,
        6120: 0,
        6121: 0,
        6122: 0,
        6123: 0,
        6124: 0,
        6125: 0,
        6128: 1,
        6129: 1,
        6141: 1,
        6210: 0,
        6211: 0,
        6244: 0,
        6245: 0,
        6246: 0,
        6247: 0,
        6248: 0,
        6249: 0,
        6250: 0,
        6251: 0,
        6252: 0,
        6253: 0,
        6254: 0,
        6255: 0,
        6256: 0,
        6257: 0,
        6258: 0,
        6259: 0,
        6260: 0,
        6261: 0,
        6262: 0,
        6263: 0,
        6264: 0,
        6265: 0,
        6266: 0,
        6267: 0,
        6268: 0,
        6269: 0,
        6270: 0,
        6271: 0,
        6272: 0,
        6273: 0,
        6274: 0,
        6275: 0,
        6316: 0,
        6328: 0,
        6329: 0,
        6330: 0,
        6331: 0,
        6332: 0,
        6333: 0,
        6334: 0,
        6335: 0,
        6336: 0,
        6337: 0,
        6338: 0,
        6339: 0,
        6340: 0,
        6341: 0,
        6342: 0,
        6343: 0,
        6344: 0,
        6345: 0,
        6346: 0,
        6347: 0,
        6348: 0,
        6350: 0,
        6351: 0,
        6352: 0,
        6353: 0,
        6354: 0,
        6391: 1,
        20002: 0,
        20003: 0,
        20004: 0,
        20005: 0,
        20006: 0,
        20007: 0,
        20008: 0,
        20009: 0,
        20010: 0,
        20011: 0,
        20012: 0,
        20013: 0,
        20014: 0,
        20015: 0,
        20016: 0,
        20017: 0,
        20018: 0,
        20019: 0,
        20020: 0,
        20021: 0,
        20022: 0,
        20023: 0,
        20024: 0,
        20025: 0,
        20026: 0,
        20027: 0,
        20028: 0,
        20029: 0,
        20030: 0,
        20031: 0,
        20032: 0,
        20062: 0,
        20063: 0,
        20064: 0,
        20065: 0,
        20066: 0,
        20067: 0,
        20068: 0,
        20069: 0,
        20070: 0,
        20071: 0,
        20072: 0,
        20073: 0,
        20074: 0,
        20075: 0,
        20076: 0,
        20077: 0,
        20078: 0,
        20079: 0,
        20080: 0,
        20081: 0,
        20082: 0,
        20083: 0,
        20084: 0,
        20085: 0,
        20086: 0,
        20087: 0,
        20088: 0,
        20089: 0,
        20090: 0,
        20091: 0,
        20092: 0,
        20135: 0,
        20136: 0,
        20137: 0,
        20138: 0,
        20248: 0,
        20249: 0,
        20250: 0,
        20251: 0,
        20252: 0,
        20253: 0,
        20254: 0,
        20255: 0,
        20256: 0,
        20257: 0,
        20258: 0,
        20348: 0,
        20349: 0,
        20350: 0,
        20351: 0,
        20352: 0,
        20353: 0,
        20354: 0,
        20355: 0,
        20356: 0,
        20357: 0,
        20358: 0,
        20436: 0,
        20437: 0,
        20438: 0,
        20439: 0,
        20440: 0,
        20499: 0,
        20538: 0,
        20539: 0,
        20790: 0,
        20791: 0,
        20822: 0,
        20823: 0,
        20824: 0,
        20934: 0,
        20935: 0,
        20936: 0,
        21035: 0,
        21036: 0,
        21037: 0,
        21095: 0,
        21096: 0,
        21097: 0,
        21148: 0,
        21149: 0,
        21150: 0,
        21291: 0,
        21292: 0,
        21413: 0,
        21414: 0,
        21415: 0,
        21416: 0,
        21417: 0,
        21418: 0,
        21419: 0,
        21420: 0,
        21421: 0,
        21422: 0,
        21423: 0,
        21473: 0,
        21474: 0,
        21475: 0,
        21476: 0,
        21477: 0,
        21478: 0,
        21479: 0,
        21480: 0,
        21481: 0,
        21482: 0,
        21483: 0,
        21500: 0,
        21780: 0,
        21781: 0,
        21782: 0,
        21817: 0,
        21818: 0,
        21891: 0,
        21892: 0,
        21893: 0,
        21894: 0,
        21896: 0,
        21897: 0,
        21898: 0,
        21899: 0,
        22032: 0,
        22033: 0,
        22091: 0,
        22092: 0,
        22171: 0,
        22172: 0,
        22173: 0,
        22174: 0,
        22175: 0,
        22176: 0,
        22177: 0,
        22181: 0,
        22182: 0,
        22183: 0,
        22184: 0,
        22185: 0,
        22186: 0,
        22187: 0,
        22191: 0,
        22192: 0,
        22193: 0,
        22194: 0,
        22195: 0,
        22196: 0,
        22197: 0,
        22234: 0,
        22235: 0,
        22236: 0,
        22332: 0,
        22391: 0,
        22392: 0,
        22521: 0,
        22522: 0,
        22523: 0,
        22524: 0,
        22525: 0,
        22700: 0,
        22770: 0,
        22780: 0,
        22832: 0,
        22991: 0,
        22992: 0,
        22993: 0,
        22994: 0,
        23028: 0,
        23029: 0,
        23030: 0,
        23031: 0,
        23032: 0,
        23033: 0,
        23034: 0,
        23035: 0,
        23036: 0,
        23037: 0,
        23038: 0,
        23090: 0,
        23095: 0,
        23239: 0,
        23240: 0,
        23433: 0,
        23700: 0,
        23830: 0,
        23831: 0,
        23832: 0,
        23833: 0,
        23834: 0,
        23835: 0,
        23836: 0,
        23837: 0,
        23838: 0,
        23839: 0,
        23840: 0,
        23841: 0,
        23842: 0,
        23843: 0,
        23844: 0,
        23845: 0,
        23846: 0,
        23847: 0,
        23848: 0,
        23849: 0,
        23850: 0,
        23851: 0,
        23852: 0,
        23853: 0,
        23866: 0,
        23867: 0,
        23868: 0,
        23869: 0,
        23870: 0,
        23871: 0,
        23872: 0,
        23877: 0,
        23878: 0,
        23879: 0,
        23880: 0,
        23881: 0,
        23882: 0,
        23883: 0,
        23884: 0,
        23886: 0,
        23887: 0,
        23888: 0,
        23889: 0,
        23890: 0,
        23891: 0,
        23892: 0,
        23893: 0,
        23894: 0,
        23946: 0,
        23947: 0,
        23948: 0,
        24047: 0,
        24048: 0,
        24100: 3,
        24200: 0,
        24305: 0,
        24306: 0,
        24311: 0,
        24312: 0,
        24313: 0,
        24342: 0,
        24343: 0,
        24344: 0,
        24345: 0,
        24346: 0,
        24347: 0,
        24370: 10,
        24371: 10,
        24372: 10,
        24373: 10,
        24374: 10,
        24375: 0,
        24376: 0,
        24377: 0,
        24378: 0,
        24379: 0,
        24380: 0,
        24381: 0,
        24382: 10,
        24383: 0,
        24500: 0,
        24547: 0,
        24548: 0,
        24571: 9,
        24600: 0,
        24718: 0,
        24719: 0,
        24720: 0,
        24721: 0,
        24817: 0,
        24818: 0,
        24819: 0,
        24820: 0,
        24821: 0,
        24877: 0,
        24878: 0,
        24879: 0,
        24880: 0,
        24881: 0,
        24882: 0,
        24891: 0,
        24892: 0,
        24893: 0,
        25E3: 0,
        25231: 0,
        25391: 0,
        25392: 0,
        25393: 0,
        25394: 0,
        25395: 0,
        25828: 0,
        25829: 0,
        25830: 0,
        25831: 0,
        25832: 0,
        25833: 0,
        25834: 0,
        25835: 0,
        25836: 0,
        25837: 0,
        25838: 0,
        25884: 0,
        25932: 0,
        26191: 0,
        26192: 0,
        26193: 0,
        26194: 0,
        26195: 0,
        26237: 0,
        26331: 0,
        26332: 0,
        26391: 0,
        26392: 0,
        26393: 0,
        26432: 0,
        26591: 0,
        26592: 0,
        26632: 0,
        26692: 0,
        26701: 0,
        26702: 0,
        26703: 0,
        26704: 0,
        26705: 0,
        26706: 0,
        26707: 0,
        26708: 0,
        26709: 0,
        26710: 0,
        26711: 0,
        26712: 0,
        26713: 0,
        26714: 0,
        26715: 0,
        26716: 0,
        26717: 0,
        26718: 0,
        26719: 0,
        26720: 0,
        26721: 0,
        26722: 0,
        26729: 2,
        26730: 2,
        26731: 2,
        26732: 2,
        26733: 2,
        26734: 2,
        26735: 2,
        26736: 2,
        26737: 2,
        26738: 2,
        26739: 2,
        26740: 2,
        26741: 2,
        26742: 2,
        26743: 2,
        26744: 2,
        26745: 2,
        26746: 2,
        26747: 2,
        26748: 2,
        26749: 2,
        26750: 2,
        26751: 2,
        26752: 2,
        26753: 2,
        26754: 2,
        26755: 2,
        26756: 2,
        26757: 2,
        26758: 2,
        26759: 2,
        26760: 2,
        26761: 2,
        26762: 2,
        26763: 2,
        26764: 2,
        26765: 2,
        26766: 2,
        26767: 2,
        26768: 2,
        26769: 2,
        26770: 2,
        26771: 2,
        26772: 2,
        26773: 2,
        26774: 2,
        26775: 2,
        26776: 2,
        26777: 2,
        26778: 2,
        26779: 2,
        26780: 2,
        26781: 2,
        26782: 2,
        26783: 2,
        26784: 2,
        26785: 2,
        26786: 2,
        26787: 2,
        26788: 2,
        26789: 2,
        26790: 2,
        26791: 2,
        26792: 2,
        26793: 2,
        26794: 2,
        26795: 2,
        26796: 2,
        26797: 2,
        26798: 2,
        26799: 2,
        26801: 2,
        26802: 2,
        26803: 2,
        26811: 2,
        26812: 2,
        26813: 2,
        26847: 2,
        26848: 2,
        26849: 2,
        26850: 2,
        26851: 2,
        26852: 2,
        26853: 2,
        26854: 2,
        26855: 2,
        26856: 2,
        26857: 2,
        26858: 2,
        26859: 2,
        26860: 2,
        26861: 2,
        26862: 2,
        26863: 2,
        26864: 2,
        26865: 2,
        26866: 2,
        26867: 2,
        26868: 2,
        26869: 2,
        26870: 2,
        26891: 0,
        26892: 0,
        26893: 0,
        26894: 0,
        26895: 0,
        26896: 0,
        26897: 0,
        26898: 0,
        26899: 0,
        26901: 0,
        26902: 0,
        26903: 0,
        26904: 0,
        26905: 0,
        26906: 0,
        26907: 0,
        26908: 0,
        26909: 0,
        26910: 0,
        26911: 0,
        26912: 0,
        26913: 0,
        26914: 0,
        26915: 0,
        26916: 0,
        26917: 0,
        26918: 0,
        26919: 0,
        26920: 0,
        26921: 0,
        26922: 0,
        26923: 0,
        26929: 0,
        26930: 0,
        26931: 0,
        26932: 0,
        26933: 0,
        26934: 0,
        26935: 0,
        26936: 0,
        26937: 0,
        26938: 0,
        26939: 0,
        26940: 0,
        26941: 0,
        26942: 0,
        26943: 0,
        26944: 0,
        26945: 0,
        26946: 0,
        26948: 0,
        26949: 0,
        26950: 0,
        26951: 0,
        26952: 0,
        26953: 0,
        26954: 0,
        26955: 0,
        26956: 0,
        26957: 0,
        26958: 0,
        26959: 0,
        26960: 0,
        26961: 0,
        26962: 0,
        26963: 0,
        26964: 0,
        26965: 0,
        26966: 0,
        26967: 0,
        26968: 0,
        26969: 0,
        26970: 0,
        26971: 0,
        26972: 0,
        26973: 0,
        26974: 0,
        26975: 0,
        26976: 0,
        26977: 0,
        26978: 0,
        26979: 0,
        26980: 0,
        26981: 0,
        26982: 0,
        26983: 0,
        26984: 0,
        26985: 0,
        26986: 0,
        26987: 0,
        26988: 0,
        26989: 0,
        26990: 0,
        26991: 0,
        26992: 0,
        26993: 0,
        26994: 0,
        26995: 0,
        26996: 0,
        26997: 0,
        26998: 0,
        27037: 0,
        27038: 0,
        27039: 0,
        27040: 0,
        27120: 0,
        27200: 0,
        27205: 0,
        27206: 0,
        27207: 0,
        27208: 0,
        27209: 0,
        27210: 0,
        27211: 0,
        27212: 0,
        27213: 0,
        27214: 0,
        27215: 0,
        27216: 0,
        27217: 0,
        27218: 0,
        27219: 0,
        27220: 0,
        27221: 0,
        27222: 0,
        27223: 0,
        27224: 0,
        27225: 0,
        27226: 0,
        27227: 0,
        27228: 0,
        27229: 0,
        27230: 0,
        27231: 0,
        27232: 0,
        27258: 0,
        27259: 0,
        27260: 0,
        27291: 6,
        27292: 6,
        27391: 0,
        27392: 0,
        27393: 0,
        27394: 0,
        27395: 0,
        27396: 0,
        27397: 0,
        27398: 0,
        27429: 0,
        27492: 0,
        27493: 0,
        27500: 0,
        27561: 0,
        27562: 0,
        27563: 0,
        27564: 0,
        27571: 0,
        27572: 0,
        27573: 0,
        27574: 0,
        27581: 0,
        27582: 0,
        27583: 0,
        27584: 0,
        27591: 0,
        27592: 0,
        27593: 0,
        27594: 0,
        27700: 0,
        28191: 0,
        28192: 0,
        28193: 0,
        28232: 0,
        28348: 0,
        28349: 0,
        28350: 0,
        28351: 0,
        28352: 0,
        28353: 0,
        28354: 0,
        28355: 0,
        28356: 0,
        28357: 0,
        28358: 0,
        28402: 0,
        28403: 0,
        28404: 0,
        28405: 0,
        28406: 0,
        28407: 0,
        28408: 0,
        28409: 0,
        28410: 0,
        28411: 0,
        28412: 0,
        28413: 0,
        28414: 0,
        28415: 0,
        28416: 0,
        28417: 0,
        28418: 0,
        28419: 0,
        28420: 0,
        28421: 0,
        28422: 0,
        28423: 0,
        28424: 0,
        28425: 0,
        28426: 0,
        28427: 0,
        28428: 0,
        28429: 0,
        28430: 0,
        28431: 0,
        28432: 0,
        28462: 0,
        28463: 0,
        28464: 0,
        28465: 0,
        28466: 0,
        28467: 0,
        28468: 0,
        28469: 0,
        28470: 0,
        28471: 0,
        28472: 0,
        28473: 0,
        28474: 0,
        28475: 0,
        28476: 0,
        28477: 0,
        28478: 0,
        28479: 0,
        28480: 0,
        28481: 0,
        28482: 0,
        28483: 0,
        28484: 0,
        28485: 0,
        28486: 0,
        28487: 0,
        28488: 0,
        28489: 0,
        28490: 0,
        28491: 0,
        28492: 0,
        28600: 0,
        28991: 0,
        28992: 0,
        29100: 0,
        29101: 0,
        29118: 0,
        29119: 0,
        29120: 0,
        29121: 0,
        29122: 0,
        29168: 0,
        29169: 0,
        29170: 0,
        29171: 0,
        29172: 0,
        29177: 0,
        29178: 0,
        29179: 0,
        29180: 0,
        29181: 0,
        29182: 0,
        29183: 0,
        29184: 0,
        29185: 0,
        29187: 0,
        29188: 0,
        29189: 0,
        29190: 0,
        29191: 0,
        29192: 0,
        29193: 0,
        29194: 0,
        29195: 0,
        29220: 0,
        29221: 0,
        29333: 0,
        29635: 0,
        29636: 0,
        29701: 0,
        29738: 0,
        29739: 0,
        29849: 0,
        29850: 0,
        29871: 8,
        29872: 7,
        29873: 0,
        29900: 0,
        29901: 0,
        29902: 0,
        29903: 0,
        30161: 0,
        30162: 0,
        30163: 0,
        30164: 0,
        30165: 0,
        30166: 0,
        30167: 0,
        30168: 0,
        30169: 0,
        30170: 0,
        30171: 0,
        30172: 0,
        30173: 0,
        30174: 0,
        30175: 0,
        30176: 0,
        30177: 0,
        30178: 0,
        30179: 0,
        30200: 5,
        30339: 0,
        30340: 0,
        30491: 0,
        30492: 0,
        30493: 0,
        30494: 0,
        30591: 0,
        30592: 0,
        30729: 0,
        30730: 0,
        30731: 0,
        30732: 0,
        30791: 0,
        30792: 0,
        30800: 0,
        31028: 0,
        31121: 0,
        31154: 0,
        31170: 0,
        31171: 0,
        31251: 0,
        31252: 0,
        31253: 0,
        31254: 0,
        31255: 0,
        31256: 0,
        31257: 0,
        31258: 0,
        31259: 0,
        31265: 0,
        31266: 0,
        31267: 0,
        31268: 0,
        31275: 0,
        31276: 0,
        31277: 0,
        31278: 0,
        31279: 0,
        31281: 0,
        31282: 0,
        31283: 0,
        31284: 0,
        31285: 0,
        31286: 0,
        31287: 0,
        31288: 0,
        31289: 0,
        31290: 0,
        31291: 0,
        31292: 0,
        31293: 0,
        31294: 0,
        31295: 0,
        31296: 0,
        31297: 0,
        31370: 0,
        31461: 0,
        31462: 0,
        31463: 0,
        31464: 0,
        31465: 0,
        31466: 0,
        31467: 0,
        31468: 0,
        31469: 0,
        31491: 0,
        31492: 0,
        31493: 0,
        31494: 0,
        31495: 0,
        31528: 0,
        31529: 0,
        31600: 0,
        31700: 0,
        31838: 0,
        31839: 0,
        31900: 0,
        31901: 0,
        31917: 0,
        31918: 0,
        31919: 0,
        31920: 0,
        31921: 0,
        31922: 0,
        31965: 0,
        31966: 0,
        31967: 0,
        31968: 0,
        31969: 0,
        31970: 0,
        31971: 0,
        31972: 0,
        31973: 0,
        31974: 0,
        31975: 0,
        31976: 0,
        31977: 0,
        31978: 0,
        31979: 0,
        31980: 0,
        31981: 0,
        31982: 0,
        31983: 0,
        31984: 0,
        31985: 0,
        31986: 0,
        31987: 0,
        31988: 0,
        31989: 0,
        31990: 0,
        31991: 0,
        31992: 0,
        31993: 0,
        31994: 0,
        31995: 0,
        31996: 0,
        31997: 0,
        31998: 0,
        31999: 0,
        32E3: 0,
        32001: 2,
        32002: 2,
        32003: 2,
        32005: 2,
        32006: 2,
        32007: 2,
        32008: 2,
        32009: 2,
        32010: 2,
        32011: 2,
        32012: 2,
        32013: 2,
        32014: 2,
        32015: 2,
        32016: 2,
        32017: 2,
        32018: 2,
        32019: 2,
        32020: 2,
        32021: 2,
        32022: 2,
        32023: 2,
        32024: 2,
        32025: 2,
        32026: 2,
        32027: 2,
        32028: 2,
        32029: 2,
        32030: 2,
        32031: 2,
        32033: 2,
        32034: 2,
        32035: 2,
        32036: 2,
        32037: 2,
        32038: 2,
        32039: 2,
        32040: 2,
        32041: 2,
        32042: 2,
        32043: 2,
        32044: 2,
        32045: 2,
        32046: 2,
        32047: 2,
        32048: 2,
        32049: 2,
        32050: 2,
        32051: 2,
        32052: 2,
        32053: 2,
        32054: 2,
        32055: 2,
        32056: 2,
        32057: 2,
        32058: 2,
        32059: 2,
        32060: 2,
        32061: 0,
        32062: 0,
        32064: 2,
        32065: 2,
        32066: 2,
        32067: 2,
        32074: 2,
        32075: 2,
        32076: 2,
        32077: 2,
        32081: 0,
        32082: 0,
        32083: 0,
        32084: 0,
        32085: 0,
        32086: 0,
        32098: 0,
        32099: 2,
        32100: 0,
        32104: 0,
        32107: 0,
        32108: 0,
        32109: 0,
        32110: 0,
        32111: 0,
        32112: 0,
        32113: 0,
        32114: 0,
        32115: 0,
        32116: 0,
        32117: 0,
        32118: 0,
        32119: 0,
        32120: 0,
        32121: 0,
        32122: 0,
        32123: 0,
        32124: 0,
        32125: 0,
        32126: 0,
        32127: 0,
        32128: 0,
        32129: 0,
        32130: 0,
        32133: 0,
        32134: 0,
        32135: 0,
        32136: 0,
        32137: 0,
        32138: 0,
        32139: 0,
        32140: 0,
        32141: 0,
        32142: 0,
        32143: 0,
        32144: 0,
        32145: 0,
        32146: 0,
        32147: 0,
        32148: 0,
        32149: 0,
        32150: 0,
        32151: 0,
        32152: 0,
        32153: 0,
        32154: 0,
        32155: 0,
        32156: 0,
        32157: 0,
        32158: 0,
        32161: 0,
        32164: 2,
        32165: 2,
        32166: 2,
        32167: 2,
        32180: 0,
        32181: 0,
        32182: 0,
        32183: 0,
        32184: 0,
        32185: 0,
        32186: 0,
        32187: 0,
        32188: 0,
        32189: 0,
        32190: 0,
        32191: 0,
        32192: 0,
        32193: 0,
        32194: 0,
        32195: 0,
        32196: 0,
        32197: 0,
        32198: 0,
        32199: 0,
        32201: 0,
        32202: 0,
        32203: 0,
        32204: 0,
        32205: 0,
        32206: 0,
        32207: 0,
        32208: 0,
        32209: 0,
        32210: 0,
        32211: 0,
        32212: 0,
        32213: 0,
        32214: 0,
        32215: 0,
        32216: 0,
        32217: 0,
        32218: 0,
        32219: 0,
        32220: 0,
        32221: 0,
        32222: 0,
        32223: 0,
        32224: 0,
        32225: 0,
        32226: 0,
        32227: 0,
        32228: 0,
        32229: 0,
        32230: 0,
        32231: 0,
        32232: 0,
        32233: 0,
        32234: 0,
        32235: 0,
        32236: 0,
        32237: 0,
        32238: 0,
        32239: 0,
        32240: 0,
        32241: 0,
        32242: 0,
        32243: 0,
        32244: 0,
        32245: 0,
        32246: 0,
        32247: 0,
        32248: 0,
        32249: 0,
        32250: 0,
        32251: 0,
        32252: 0,
        32253: 0,
        32254: 0,
        32255: 0,
        32256: 0,
        32257: 0,
        32258: 0,
        32259: 0,
        32260: 0,
        32301: 0,
        32302: 0,
        32303: 0,
        32304: 0,
        32305: 0,
        32306: 0,
        32307: 0,
        32308: 0,
        32309: 0,
        32310: 0,
        32311: 0,
        32312: 0,
        32313: 0,
        32314: 0,
        32315: 0,
        32316: 0,
        32317: 0,
        32318: 0,
        32319: 0,
        32320: 0,
        32321: 0,
        32322: 0,
        32323: 0,
        32324: 0,
        32325: 0,
        32326: 0,
        32327: 0,
        32328: 0,
        32329: 0,
        32330: 0,
        32331: 0,
        32332: 0,
        32333: 0,
        32334: 0,
        32335: 0,
        32336: 0,
        32337: 0,
        32338: 0,
        32339: 0,
        32340: 0,
        32341: 0,
        32342: 0,
        32343: 0,
        32344: 0,
        32345: 0,
        32346: 0,
        32347: 0,
        32348: 0,
        32349: 0,
        32350: 0,
        32351: 0,
        32352: 0,
        32353: 0,
        32354: 0,
        32355: 0,
        32356: 0,
        32357: 0,
        32358: 0,
        32359: 0,
        32360: 0,
        32601: 0,
        32602: 0,
        32603: 0,
        32604: 0,
        32605: 0,
        32606: 0,
        32607: 0,
        32608: 0,
        32609: 0,
        32610: 0,
        32611: 0,
        32612: 0,
        32613: 0,
        32614: 0,
        32615: 0,
        32616: 0,
        32617: 0,
        32618: 0,
        32619: 0,
        32620: 0,
        32621: 0,
        32622: 0,
        32623: 0,
        32624: 0,
        32625: 0,
        32626: 0,
        32627: 0,
        32628: 0,
        32629: 0,
        32630: 0,
        32631: 0,
        32632: 0,
        32633: 0,
        32634: 0,
        32635: 0,
        32636: 0,
        32637: 0,
        32638: 0,
        32639: 0,
        32640: 0,
        32641: 0,
        32642: 0,
        32643: 0,
        32644: 0,
        32645: 0,
        32646: 0,
        32647: 0,
        32648: 0,
        32649: 0,
        32650: 0,
        32651: 0,
        32652: 0,
        32653: 0,
        32654: 0,
        32655: 0,
        32656: 0,
        32657: 0,
        32658: 0,
        32659: 0,
        32660: 0,
        32661: 0,
        32662: 0,
        32664: 2,
        32665: 2,
        32666: 2,
        32667: 2,
        32701: 0,
        32702: 0,
        32703: 0,
        32704: 0,
        32705: 0,
        32706: 0,
        32707: 0,
        32708: 0,
        32709: 0,
        32710: 0,
        32711: 0,
        32712: 0,
        32713: 0,
        32714: 0,
        32715: 0,
        32716: 0,
        32717: 0,
        32718: 0,
        32719: 0,
        32720: 0,
        32721: 0,
        32722: 0,
        32723: 0,
        32724: 0,
        32725: 0,
        32726: 0,
        32727: 0,
        32728: 0,
        32729: 0,
        32730: 0,
        32731: 0,
        32732: 0,
        32733: 0,
        32734: 0,
        32735: 0,
        32736: 0,
        32737: 0,
        32738: 0,
        32739: 0,
        32740: 0,
        32741: 0,
        32742: 0,
        32743: 0,
        32744: 0,
        32745: 0,
        32746: 0,
        32747: 0,
        32748: 0,
        32749: 0,
        32750: 0,
        32751: 0,
        32752: 0,
        32753: 0,
        32754: 0,
        32755: 0,
        32756: 0,
        32757: 0,
        32758: 0,
        32759: 0,
        32760: 0,
        32761: 0,
        32766: 0,
        53001: 0,
        53002: 0,
        53003: 0,
        53004: 0,
        53008: 0,
        53009: 0,
        53010: 0,
        53011: 0,
        53012: 0,
        53013: 0,
        53014: 0,
        53015: 0,
        53016: 0,
        53017: 0,
        53018: 0,
        53019: 0,
        53021: 0,
        53022: 0,
        53023: 0,
        53024: 0,
        53025: 0,
        53026: 0,
        53027: 0,
        53028: 0,
        53029: 0,
        53030: 0,
        53031: 0,
        53032: 0,
        53034: 0,
        53042: 0,
        53043: 0,
        53044: 0,
        53045: 0,
        53046: 0,
        53048: 0,
        53049: 0,
        54001: 0,
        54002: 0,
        54003: 0,
        54004: 0,
        54008: 0,
        54009: 0,
        54010: 0,
        54011: 0,
        54012: 0,
        54013: 0,
        54014: 0,
        54015: 0,
        54016: 0,
        54017: 0,
        54018: 0,
        54019: 0,
        54021: 0,
        54022: 0,
        54023: 0,
        54024: 0,
        54025: 0,
        54026: 0,
        54027: 0,
        54028: 0,
        54029: 0,
        54030: 0,
        54031: 0,
        54032: 0,
        54034: 0,
        54042: 0,
        54043: 0,
        54044: 0,
        54045: 0,
        54046: 0,
        54048: 0,
        54049: 0,
        54050: 0,
        54051: 0,
        54052: 0,
        54053: 0,
        65061: 2,
        65062: 2,
        65161: 0,
        65163: 0,
        102001: 0,
        102002: 0,
        102003: 0,
        102004: 0,
        102005: 0,
        102006: 0,
        102007: 0,
        102008: 0,
        102009: 0,
        102010: 0,
        102011: 0,
        102012: 0,
        102013: 0,
        102014: 0,
        102015: 0,
        102016: 0,
        102017: 0,
        102018: 0,
        102019: 0,
        102020: 0,
        102021: 0,
        102022: 0,
        102023: 0,
        102024: 0,
        102025: 0,
        102026: 0,
        102027: 0,
        102028: 0,
        102029: 0,
        102030: 0,
        102031: 0,
        102032: 0,
        102033: 0,
        102034: 0,
        102035: 0,
        102036: 0,
        102037: 0,
        102038: 0,
        102039: 0,
        102040: 0,
        102041: 2,
        102042: 0,
        102043: 0,
        102044: 0,
        102045: 0,
        102046: 0,
        102047: 0,
        102048: 0,
        102049: 0,
        102050: 0,
        102051: 0,
        102052: 0,
        102053: 0,
        102054: 0,
        102055: 0,
        102056: 0,
        102057: 0,
        102058: 0,
        102059: 0,
        102060: 0,
        102061: 0,
        102062: 0,
        102063: 0,
        102064: 11,
        102065: 0,
        102066: 0,
        102067: 0,
        102068: 14,
        102069: 15,
        102070: 0,
        102071: 0,
        102072: 0,
        102073: 0,
        102074: 0,
        102075: 0,
        102076: 0,
        102077: 0,
        102078: 0,
        102079: 0,
        102080: 0,
        102081: 0,
        102082: 0,
        102083: 0,
        102084: 0,
        102085: 0,
        102086: 0,
        102087: 0,
        102088: 0,
        102089: 0,
        102090: 0,
        102091: 0,
        102092: 0,
        102093: 0,
        102094: 0,
        102095: 0,
        102096: 0,
        102097: 0,
        102098: 0,
        102099: 0,
        102100: 0,
        102101: 0,
        102102: 0,
        102103: 0,
        102104: 0,
        102105: 0,
        102106: 0,
        102107: 0,
        102108: 0,
        102109: 0,
        102110: 0,
        102111: 0,
        102112: 0,
        102113: 0,
        102114: 0,
        102115: 0,
        102116: 0,
        102117: 0,
        102118: 2,
        102119: 1,
        102120: 2,
        102121: 2,
        102122: 0,
        102123: 0,
        102124: 0,
        102125: 0,
        102126: 0,
        102127: 0,
        102128: 0,
        102129: 0,
        102130: 0,
        102131: 0,
        102132: 0,
        102133: 0,
        102134: 0,
        102135: 0,
        102136: 0,
        102137: 0,
        102138: 0,
        102139: 0,
        102140: 0,
        102141: 0,
        102142: 0,
        102143: 0,
        102144: 0,
        102145: 0,
        102146: 0,
        102147: 0,
        102148: 0,
        102149: 0,
        102150: 0,
        102151: 0,
        102152: 0,
        102153: 0,
        102154: 0,
        102155: 0,
        102156: 0,
        102157: 0,
        102158: 0,
        102159: 0,
        102160: 0,
        102161: 0,
        102162: 0,
        102163: 0,
        102164: 0,
        102165: 0,
        102166: 0,
        102167: 0,
        102168: 0,
        102169: 0,
        102170: 0,
        102171: 0,
        102172: 0,
        102173: 0,
        102174: 0,
        102175: 0,
        102176: 0,
        102177: 0,
        102178: 0,
        102179: 0,
        102180: 0,
        102181: 0,
        102182: 0,
        102183: 0,
        102184: 0,
        102185: 0,
        102186: 0,
        102187: 0,
        102188: 0,
        102189: 0,
        102190: 0,
        102191: 0,
        102192: 0,
        102193: 0,
        102194: 0,
        102195: 0,
        102196: 0,
        102197: 0,
        102198: 0,
        102199: 0,
        102200: 0,
        102201: 0,
        102202: 0,
        102203: 0,
        102204: 0,
        102205: 0,
        102206: 0,
        102207: 0,
        102208: 0,
        102209: 0,
        102210: 0,
        102211: 0,
        102212: 0,
        102213: 0,
        102214: 0,
        102215: 0,
        102216: 0,
        102217: 2,
        102218: 0,
        102219: 2,
        102220: 2,
        102221: 0,
        102222: 0,
        102223: 0,
        102224: 0,
        102225: 0,
        102226: 0,
        102227: 0,
        102228: 0,
        102229: 0,
        102230: 0,
        102231: 0,
        102232: 0,
        102233: 0,
        102234: 0,
        102235: 0,
        102236: 0,
        102237: 0,
        102238: 0,
        102239: 0,
        102240: 0,
        102241: 0,
        102242: 0,
        102243: 0,
        102244: 0,
        102245: 0,
        102246: 0,
        102247: 0,
        102248: 0,
        102249: 0,
        102250: 0,
        102251: 0,
        102252: 0,
        102253: 0,
        102254: 0,
        102255: 0,
        102256: 0,
        102257: 0,
        102258: 0,
        102259: 0,
        102260: 0,
        102261: 0,
        102262: 0,
        102263: 0,
        102264: 0,
        102265: 0,
        102266: 0,
        102267: 0,
        102268: 0,
        102269: 0,
        102270: 0,
        102271: 0,
        102272: 0,
        102273: 0,
        102274: 0,
        102275: 0,
        102276: 0,
        102277: 0,
        102278: 0,
        102279: 0,
        102280: 0,
        102281: 0,
        102282: 0,
        102283: 0,
        102284: 0,
        102285: 0,
        102286: 0,
        102287: 0,
        102288: 0,
        102289: 0,
        102290: 0,
        102291: 0,
        102292: 0,
        102293: 0,
        102294: 0,
        102295: 0,
        102296: 0,
        102297: 0,
        102298: 0,
        102299: 0,
        102300: 0,
        102301: 0,
        102302: 0,
        102303: 0,
        102304: 0,
        102305: 0,
        102306: 0,
        102307: 0,
        102308: 0,
        102309: 0,
        102310: 0,
        102311: 0,
        102312: 0,
        102313: 0,
        102314: 0,
        102315: 0,
        102316: 0,
        102317: 0,
        102318: 0,
        102319: 0,
        102320: 0,
        102321: 0,
        102322: 0,
        102323: 0,
        102324: 0,
        102325: 0,
        102326: 0,
        102327: 0,
        102328: 0,
        102329: 0,
        102330: 0,
        102331: 0,
        102332: 0,
        102333: 0,
        102334: 0,
        102335: 0,
        102336: 0,
        102337: 0,
        102338: 0,
        102339: 0,
        102340: 0,
        102341: 0,
        102342: 0,
        102343: 0,
        102344: 0,
        102345: 0,
        102346: 0,
        102347: 0,
        102348: 0,
        102349: 0,
        102350: 0,
        102351: 0,
        102352: 0,
        102353: 0,
        102354: 0,
        102355: 0,
        102356: 0,
        102357: 0,
        102358: 0,
        102359: 0,
        102360: 0,
        102361: 0,
        102362: 0,
        102363: 0,
        102364: 0,
        102365: 0,
        102366: 0,
        102367: 0,
        102368: 0,
        102369: 0,
        102370: 0,
        102371: 0,
        102372: 0,
        102373: 0,
        102374: 0,
        102375: 0,
        102376: 0,
        102377: 0,
        102378: 1,
        102379: 1,
        102380: 0,
        102381: 1,
        102382: 0,
        102383: 0,
        102384: 0,
        102385: 0,
        102386: 0,
        102387: 0,
        102388: 0,
        102389: 2,
        102390: 2,
        102391: 2,
        102392: 2,
        102393: 2,
        102394: 2,
        102395: 2,
        102396: 2,
        102397: 2,
        102398: 2,
        102401: 0,
        102402: 0,
        102403: 0,
        102404: 0,
        102405: 0,
        102406: 0,
        102407: 0,
        102408: 0,
        102409: 0,
        102410: 0,
        102411: 0,
        102412: 0,
        102413: 0,
        102414: 0,
        102415: 0,
        102416: 0,
        102417: 0,
        102418: 0,
        102419: 0,
        102420: 0,
        102421: 0,
        102422: 0,
        102423: 0,
        102424: 0,
        102425: 0,
        102426: 0,
        102427: 0,
        102428: 0,
        102429: 0,
        102430: 0,
        102431: 0,
        102432: 0,
        102433: 0,
        102434: 0,
        102435: 0,
        102436: 0,
        102437: 0,
        102438: 0,
        102439: 0,
        102440: 0,
        102441: 0,
        102442: 0,
        102443: 0,
        102444: 0,
        102445: 2,
        102446: 2,
        102447: 2,
        102450: 0,
        102451: 0,
        102452: 0,
        102461: 2,
        102462: 2,
        102463: 2,
        102464: 2,
        102465: 2,
        102466: 2,
        102467: 2,
        102468: 2,
        102469: 0,
        102470: 0,
        102471: 0,
        102472: 0,
        102473: 0,
        102474: 0,
        102475: 0,
        102476: 0,
        102477: 0,
        102478: 0,
        102479: 0,
        102480: 0,
        102481: 0,
        102482: 0,
        102483: 0,
        102484: 0,
        102485: 0,
        102486: 0,
        102487: 0,
        102488: 0,
        102489: 0,
        102490: 0,
        102491: 0,
        102492: 0,
        102493: 0,
        102494: 0,
        102495: 0,
        102496: 0,
        102500: 1,
        102501: 1,
        102502: 1,
        102503: 1,
        102504: 1,
        102505: 1,
        102506: 1,
        102507: 1,
        102508: 1,
        102509: 1,
        102510: 1,
        102511: 1,
        102512: 1,
        102513: 1,
        102514: 1,
        102515: 1,
        102516: 1,
        102517: 1,
        102518: 1,
        102519: 1,
        102520: 0,
        102521: 0,
        102522: 0,
        102523: 0,
        102524: 0,
        102525: 2,
        102526: 2,
        102527: 2,
        102528: 2,
        102529: 2,
        102530: 0,
        102531: 0,
        102532: 0,
        102533: 0,
        102534: 0,
        102535: 0,
        102536: 0,
        102537: 0,
        102538: 0,
        102539: 0,
        102540: 0,
        102541: 0,
        102542: 0,
        102543: 0,
        102544: 0,
        102545: 0,
        102546: 0,
        102547: 0,
        102548: 0,
        102549: 0,
        102570: 0,
        102571: 0,
        102572: 0,
        102573: 0,
        102574: 0,
        102575: 0,
        102576: 0,
        102577: 0,
        102578: 0,
        102579: 0,
        102580: 0,
        102581: 0,
        102582: 0,
        102583: 0,
        102584: 0,
        102585: 0,
        102586: 0,
        102587: 0,
        102588: 0,
        102589: 2,
        102590: 0,
        102591: 0,
        102592: 0,
        102593: 0,
        102594: 0,
        102595: 0,
        102596: 0,
        102597: 0,
        102598: 0,
        102599: 2,
        102600: 2,
        102601: 0,
        102602: 0,
        102603: 0,
        102604: 2,
        102605: 0,
        102606: 0,
        102607: 0,
        102608: 0,
        102609: 0,
        102610: 0,
        102611: 0,
        102612: 0,
        102613: 0,
        102614: 0,
        102615: 0,
        102616: 0,
        102617: 0,
        102618: 0,
        102619: 0,
        102620: 0,
        102621: 0,
        102622: 0,
        102623: 0,
        102624: 0,
        102625: 0,
        102626: 0,
        102627: 0,
        102628: 0,
        102629: 2,
        102630: 2,
        102631: 2,
        102632: 2,
        102633: 2,
        102634: 2,
        102635: 2,
        102636: 2,
        102637: 2,
        102638: 2,
        102639: 2,
        102640: 2,
        102641: 2,
        102642: 2,
        102643: 2,
        102644: 2,
        102645: 2,
        102646: 2,
        102647: 0,
        102648: 2,
        102649: 2,
        102650: 2,
        102651: 2,
        102652: 2,
        102653: 2,
        102654: 2,
        102655: 2,
        102656: 2,
        102657: 2,
        102658: 2,
        102659: 2,
        102660: 2,
        102661: 2,
        102662: 2,
        102663: 2,
        102664: 2,
        102665: 2,
        102666: 2,
        102667: 2,
        102668: 2,
        102669: 2,
        102670: 2,
        102671: 2,
        102672: 2,
        102673: 2,
        102674: 2,
        102675: 2,
        102676: 2,
        102677: 2,
        102678: 2,
        102679: 2,
        102680: 2,
        102681: 2,
        102682: 2,
        102683: 2,
        102684: 2,
        102685: 2,
        102686: 2,
        102687: 2,
        102688: 2,
        102689: 2,
        102690: 2,
        102691: 2,
        102692: 2,
        102693: 2,
        102694: 2,
        102695: 2,
        102696: 2,
        102697: 2,
        102698: 2,
        102699: 2,
        102700: 2,
        102701: 0,
        102702: 0,
        102703: 0,
        102704: 2,
        102705: 2,
        102707: 2,
        102708: 2,
        102709: 2,
        102710: 2,
        102711: 2,
        102712: 2,
        102713: 2,
        102714: 2,
        102715: 2,
        102716: 2,
        102717: 2,
        102718: 2,
        102719: 2,
        102720: 2,
        102721: 2,
        102722: 2,
        102723: 2,
        102724: 2,
        102725: 2,
        102726: 2,
        102727: 2,
        102728: 2,
        102729: 2,
        102730: 2,
        102733: 2,
        102734: 2,
        102735: 2,
        102736: 2,
        102737: 2,
        102738: 2,
        102739: 2,
        102740: 2,
        102741: 2,
        102742: 2,
        102743: 2,
        102744: 2,
        102745: 2,
        102746: 2,
        102747: 2,
        102748: 2,
        102749: 2,
        102750: 2,
        102751: 2,
        102752: 2,
        102753: 2,
        102754: 2,
        102755: 2,
        102756: 2,
        102757: 2,
        102758: 2,
        102761: 2,
        102762: 0,
        102763: 2,
        102764: 0,
        102765: 0,
        102766: 2,
        102767: 0,
        102768: 0,
        102769: 0,
        102770: 0,
        102771: 0,
        102772: 0,
        102773: 0,
        102774: 0,
        102775: 0,
        102776: 0,
        102777: 0,
        102778: 0,
        102779: 0,
        102780: 0,
        102781: 0,
        102782: 0,
        102783: 0,
        102784: 0,
        102785: 0,
        102786: 0,
        102787: 0,
        102788: 0,
        102789: 0,
        102790: 0,
        102791: 0,
        102792: 0,
        102793: 0,
        102794: 0,
        102795: 0,
        102796: 0,
        102797: 0,
        102798: 0,
        102962: 0,
        102963: 0,
        102964: 0,
        102965: 0,
        102966: 0,
        102967: 0,
        102968: 0,
        102969: 0,
        102970: 1,
        102971: 0,
        102972: 0,
        102973: 0,
        102974: 2,
        102975: 0,
        102976: 0,
        102977: 0,
        102978: 0,
        102979: 0,
        102980: 0,
        102981: 0,
        102982: 0,
        102983: 0,
        102984: 0,
        102985: 0,
        102986: 0,
        102987: 0,
        102988: 0,
        102989: 0,
        102990: 1,
        102991: 1,
        102992: 1,
        102993: 0,
        102994: 0,
        102995: 2,
        102996: 2,
        102997: 0,
        102998: 0,
        102999: 0,
        103E3: 0,
        103001: 0,
        103002: 0,
        103003: 2,
        103004: 2,
        103005: 2,
        103006: 2,
        103007: 2,
        103008: 2,
        103009: 0,
        103010: 0,
        103011: 0,
        103012: 2,
        103013: 2,
        103014: 2,
        103015: 0,
        103016: 2,
        103017: 0,
        103018: 2,
        103019: 0,
        103020: 0,
        103021: 0,
        103022: 2,
        103023: 2,
        103024: 2,
        103025: 0,
        103026: 0,
        103027: 2,
        103028: 2,
        103029: 0,
        103030: 0,
        103031: 0,
        103032: 2,
        103033: 2,
        103034: 2,
        103035: 0,
        103036: 0,
        103037: 2,
        103038: 2,
        103039: 0,
        103040: 0,
        103041: 2,
        103042: 2,
        103043: 0,
        103044: 0,
        103045: 2,
        103046: 2,
        103047: 0,
        103048: 0,
        103049: 2,
        103050: 2,
        103051: 0,
        103052: 2,
        103053: 0,
        103054: 2,
        103055: 0,
        103056: 2,
        103057: 0,
        103058: 0,
        103059: 2,
        103060: 2,
        103061: 0,
        103062: 0,
        103063: 2,
        103064: 2,
        103065: 0,
        103066: 0,
        103067: 0,
        103068: 0,
        103069: 2,
        103070: 0,
        103071: 0,
        103072: 2,
        103073: 2,
        103074: 0,
        103075: 0,
        103076: 0,
        103077: 1,
        103078: 1,
        103079: 1,
        103080: 0,
        103081: 0,
        103082: 0,
        103083: 2,
        103084: 2,
        103085: 2,
        103086: 0,
        103087: 0,
        103088: 2,
        103089: 2,
        103090: 0,
        103091: 0,
        103092: 0,
        103093: 0,
        103094: 1,
        103095: 0,
        103096: 2,
        103097: 0,
        103098: 0,
        103099: 0,
        103100: 2,
        103101: 2,
        103102: 2,
        103103: 0,
        103104: 2,
        103105: 0,
        103106: 2,
        103107: 0,
        103108: 0,
        103109: 0,
        103110: 2,
        103111: 2,
        103112: 2,
        103113: 0,
        103114: 0,
        103115: 0,
        103116: 0,
        103117: 2,
        103118: 2,
        103119: 2,
        103120: 2,
        103121: 0,
        103122: 2,
        103123: 0,
        103124: 0,
        103125: 1,
        103126: 1,
        103127: 0,
        103128: 0,
        103129: 2,
        103130: 2,
        103131: 0,
        103132: 0,
        103133: 2,
        103134: 2,
        103135: 0,
        103136: 0,
        103137: 1,
        103138: 1,
        103139: 0,
        103140: 2,
        103141: 0,
        103142: 2,
        103143: 0,
        103144: 2,
        103145: 0,
        103146: 1,
        103147: 0,
        103148: 0,
        103149: 2,
        103150: 2,
        103151: 0,
        103152: 2,
        103153: 0,
        103154: 0,
        103155: 0,
        103156: 0,
        103157: 0,
        103158: 2,
        103159: 2,
        103160: 2,
        103161: 2,
        103162: 2,
        103163: 0,
        103164: 0,
        103165: 0,
        103166: 1,
        103167: 1,
        103168: 1,
        103169: 2,
        103170: 2,
        103171: 2,
        103172: 0,
        103173: 2,
        103174: 0,
        103175: 0,
        103176: 2,
        103177: 2,
        103178: 0,
        103179: 0,
        103180: 2,
        103181: 2,
        103182: 0,
        103183: 0,
        103184: 2,
        103185: 2,
        103186: 0,
        103187: 0,
        103188: 0,
        103189: 2,
        103190: 2,
        103191: 2,
        103192: 0,
        103193: 0,
        103194: 0,
        103195: 0,
        103196: 2,
        103197: 2,
        103198: 2,
        103199: 2,
        103200: 0,
        103201: 0,
        103202: 0,
        103203: 0,
        103204: 0,
        103205: 0,
        103206: 0,
        103207: 0,
        103208: 0,
        103209: 0,
        103210: 0,
        103211: 0,
        103212: 0,
        103213: 0,
        103214: 0,
        103215: 0,
        103216: 0,
        103217: 0,
        103218: 0,
        103219: 0,
        103220: 0,
        103221: 0,
        103222: 0,
        103223: 0,
        103224: 0,
        103225: 1,
        103226: 1,
        103227: 1,
        103228: 0,
        103229: 0,
        103230: 2,
        103231: 2,
        103232: 0,
        103233: 0,
        103234: 0,
        103235: 0,
        103236: 0,
        103237: 0,
        103238: 2,
        103239: 2,
        103240: 2,
        103241: 2,
        103242: 2,
        103243: 2,
        103244: 0,
        103245: 0,
        103246: 0,
        103247: 2,
        103248: 2,
        103249: 2,
        103250: 0,
        103251: 2,
        103252: 0,
        103253: 2,
        103254: 0,
        103255: 0,
        103256: 0,
        103257: 2,
        103258: 2,
        103259: 2,
        103260: 0,
        103261: 0,
        103262: 2,
        103263: 2,
        103264: 0,
        103265: 0,
        103266: 0,
        103267: 2,
        103268: 2,
        103269: 2,
        103270: 0,
        103271: 0,
        103272: 2,
        103273: 2,
        103274: 0,
        103275: 0,
        103276: 2,
        103277: 2,
        103278: 0,
        103279: 0,
        103280: 2,
        103281: 2,
        103282: 0,
        103283: 0,
        103284: 2,
        103285: 2,
        103286: 0,
        103287: 2,
        103288: 0,
        103289: 2,
        103290: 0,
        103291: 2,
        103292: 0,
        103293: 0,
        103294: 2,
        103295: 2,
        103296: 0,
        103297: 0,
        103298: 2,
        103299: 2,
        103300: 0,
        103301: 0,
        103302: 0,
        103303: 0,
        103304: 0,
        103305: 0,
        103306: 0,
        103307: 0,
        103308: 0,
        103309: 0,
        103310: 0,
        103311: 0,
        103312: 0,
        103313: 0,
        103314: 0,
        103315: 0,
        103316: 0,
        103317: 0,
        103318: 0,
        103319: 0,
        103320: 0,
        103321: 0,
        103322: 0,
        103323: 0,
        103324: 0,
        103325: 0,
        103326: 0,
        103327: 0,
        103328: 0,
        103329: 0,
        103330: 0,
        103331: 0,
        103332: 0,
        103333: 0,
        103334: 0,
        103335: 0,
        103336: 0,
        103337: 0,
        103338: 0,
        103339: 0,
        103340: 0,
        103341: 0,
        103342: 0,
        103343: 0,
        103344: 0,
        103345: 0,
        103346: 0,
        103347: 0,
        103348: 0,
        103349: 0,
        103350: 0,
        103351: 0,
        103352: 0,
        103353: 0,
        103354: 0,
        103355: 0,
        103356: 0,
        103357: 0,
        103358: 0,
        103359: 0,
        103360: 0,
        103361: 0,
        103362: 0,
        103363: 0,
        103364: 0,
        103365: 0,
        103366: 0,
        103367: 0,
        103368: 0,
        103369: 0,
        103370: 0,
        103371: 0,
        103372: 0,
        103373: 0,
        103374: 0,
        103375: 0,
        103376: 2,
        103377: 0,
        103378: 0,
        103379: 2,
        103380: 2,
        103381: 0,
        103382: 0,
        103383: 0,
        103384: 1,
        103385: 1,
        103386: 1,
        103387: 0,
        103388: 0,
        103389: 0,
        103390: 2,
        103391: 2,
        103392: 2,
        103393: 0,
        103394: 0,
        103395: 2,
        103396: 2,
        103397: 0,
        103398: 0,
        103399: 0,
        103400: 2,
        103401: 2,
        103402: 2,
        103403: 2,
        103404: 2,
        103405: 2,
        103406: 2,
        103407: 2,
        103408: 2,
        103409: 2,
        103410: 2,
        103411: 2,
        103412: 2,
        103413: 2,
        103414: 2,
        103415: 2,
        103416: 2,
        103417: 2,
        103418: 2,
        103419: 2,
        103420: 2,
        103421: 2,
        103422: 2,
        103423: 2,
        103424: 2,
        103425: 2,
        103426: 2,
        103427: 2,
        103428: 2,
        103429: 2,
        103430: 2,
        103431: 2,
        103432: 2,
        103433: 2,
        103434: 2,
        103435: 2,
        103436: 2,
        103437: 2,
        103438: 2,
        103439: 2,
        103440: 2,
        103441: 2,
        103442: 2,
        103443: 2,
        103444: 2,
        103445: 2,
        103446: 2,
        103447: 2,
        103448: 2,
        103449: 2,
        103450: 2,
        103451: 2,
        103452: 2,
        103453: 2,
        103454: 2,
        103455: 2,
        103456: 2,
        103457: 2,
        103458: 2,
        103459: 2,
        103460: 2,
        103461: 2,
        103462: 2,
        103463: 2,
        103464: 2,
        103465: 2,
        103466: 2,
        103467: 2,
        103468: 2,
        103469: 2,
        103470: 2,
        103471: 2,
        103472: 0,
        103473: 1,
        103474: 0,
        103475: 2,
        103476: 0,
        103477: 0,
        103478: 0,
        103479: 2,
        103480: 2,
        103481: 2,
        103482: 0,
        103483: 2,
        103484: 0,
        103485: 2,
        103486: 0,
        103487: 0,
        103488: 0,
        103489: 2,
        103490: 2,
        103491: 2,
        103492: 0,
        103493: 0,
        103494: 0,
        103495: 0,
        103496: 2,
        103497: 2,
        103498: 2,
        103499: 2,
        103500: 0,
        103501: 2,
        103502: 0,
        103503: 0,
        103504: 1,
        103505: 1,
        103506: 0,
        103507: 0,
        103508: 2,
        103509: 2,
        103510: 0,
        103511: 0,
        103512: 2,
        103513: 2,
        103514: 0,
        103515: 2,
        103516: 0,
        103517: 2,
        103518: 0,
        103519: 2,
        103520: 0,
        103521: 1,
        103522: 0,
        103523: 0,
        103524: 2,
        103525: 2,
        103526: 0,
        103527: 2,
        103528: 0,
        103529: 0,
        103530: 0,
        103531: 0,
        103532: 0,
        103533: 0,
        103534: 0,
        103535: 0,
        103536: 0,
        103537: 0,
        103538: 0,
        103539: 0,
        103540: 0,
        103541: 0,
        103542: 0,
        103543: 0,
        103544: 2,
        103545: 2,
        103546: 2,
        103547: 2,
        103548: 2,
        103549: 0,
        103550: 0,
        103551: 0,
        103552: 1,
        103553: 1,
        103554: 1,
        103555: 2,
        103556: 2,
        103557: 2,
        103558: 0,
        103559: 0,
        103560: 0,
        103561: 2,
        103562: 2,
        103563: 0,
        103564: 0,
        103565: 2,
        103566: 2,
        103567: 0,
        103568: 0,
        103569: 2,
        103570: 2,
        103571: 0,
        103572: 0,
        103573: 0,
        103574: 2,
        103575: 2,
        103576: 2,
        103577: 0,
        103578: 0,
        103579: 0,
        103580: 0,
        103581: 2,
        103582: 2,
        103583: 2,
        103584: 0,
        103585: 2,
        103600: 0,
        103601: 0,
        103602: 0,
        103603: 0,
        103604: 0,
        103605: 0,
        103606: 0,
        103607: 0,
        103608: 0,
        103609: 0,
        103610: 0,
        103611: 0,
        103612: 0,
        103613: 0,
        103614: 0,
        103615: 0,
        103616: 0,
        103617: 0,
        103618: 0,
        103619: 0,
        103620: 0,
        103621: 0,
        103622: 0,
        103623: 0,
        103624: 0,
        103625: 0,
        103626: 0,
        103627: 0,
        103628: 0,
        103629: 0,
        103630: 0,
        103631: 0,
        103632: 0,
        103633: 0,
        103634: 0,
        103635: 0,
        103636: 0,
        103637: 0,
        103638: 0,
        103639: 0,
        103640: 0,
        103641: 0,
        103642: 0,
        103643: 0,
        103644: 0,
        103645: 0,
        103646: 0,
        103647: 0,
        103648: 0,
        103649: 0,
        103650: 0,
        103651: 0,
        103652: 0,
        103653: 0,
        103654: 0,
        103655: 0,
        103656: 0,
        103657: 0,
        103658: 0,
        103659: 0,
        103660: 0,
        103661: 0,
        103662: 0,
        103663: 0,
        103664: 0,
        103665: 0,
        103666: 0,
        103667: 0,
        103668: 0,
        103669: 0,
        103670: 0,
        103671: 0,
        103672: 0,
        103673: 0,
        103674: 0,
        103675: 0,
        103676: 0,
        103677: 0,
        103678: 0,
        103679: 0,
        103680: 0,
        103681: 0,
        103682: 0,
        103683: 0,
        103684: 0,
        103685: 0,
        103686: 0,
        103687: 0,
        103688: 0,
        103689: 0,
        103690: 0,
        103691: 0,
        103692: 0,
        103693: 0,
        103694: 0,
        103695: 2,
        103700: 2,
        103701: 2,
        103702: 2,
        103703: 2,
        103704: 2,
        103705: 2,
        103706: 2,
        103707: 2,
        103708: 2,
        103709: 2,
        103710: 2,
        103711: 2,
        103712: 2,
        103713: 2,
        103714: 2,
        103715: 2,
        103716: 2,
        103717: 2,
        103718: 2,
        103719: 2,
        103720: 2,
        103721: 2,
        103722: 2,
        103723: 2,
        103724: 2,
        103725: 2,
        103726: 2,
        103727: 2,
        103728: 2,
        103729: 2,
        103730: 2,
        103731: 2,
        103732: 2,
        103733: 2,
        103734: 2,
        103735: 2,
        103736: 2,
        103737: 2,
        103738: 2,
        103739: 2,
        103740: 2,
        103741: 2,
        103742: 2,
        103743: 2,
        103744: 2,
        103745: 2,
        103746: 2,
        103747: 2,
        103748: 2,
        103749: 2,
        103750: 2,
        103751: 2,
        103752: 2,
        103753: 2,
        103754: 2,
        103755: 2,
        103756: 2,
        103757: 2,
        103758: 2,
        103759: 2,
        103760: 2,
        103761: 2,
        103762: 2,
        103763: 2,
        103764: 2,
        103765: 2,
        103766: 2,
        103767: 2,
        103768: 2,
        103769: 2,
        103770: 2,
        103771: 2,
        103772: 2,
        103773: 2,
        103774: 2,
        103775: 2,
        103776: 2,
        103777: 2,
        103778: 2,
        103779: 2,
        103780: 2,
        103781: 2,
        103782: 2,
        103783: 2,
        103784: 2,
        103785: 2,
        103786: 2,
        103787: 2,
        103788: 2,
        103789: 2,
        103790: 2,
        103791: 2,
        103792: 2,
        103793: 2,
        103794: 0,
        103795: 0,
        103796: 0,
        103797: 0,
        103798: 0,
        103799: 0,
        103800: 0,
        103801: 0,
        103802: 0,
        103803: 0,
        103804: 0,
        103805: 0,
        103806: 0,
        103807: 0,
        103808: 0,
        103809: 0,
        103810: 0,
        103811: 0,
        103812: 0,
        103813: 0,
        103814: 0,
        103815: 0,
        103816: 0,
        103817: 0,
        103818: 0,
        103819: 0,
        103820: 0,
        103821: 0,
        103822: 0,
        103823: 0,
        103824: 0,
        103825: 0,
        103826: 0,
        103827: 0,
        103828: 0,
        103829: 0,
        103830: 0,
        103831: 0,
        103832: 0,
        103833: 0,
        103834: 0,
        103835: 0,
        103836: 0,
        103837: 0,
        103838: 0,
        103839: 0,
        103840: 0,
        103841: 0,
        103842: 0,
        103843: 0,
        103844: 0,
        103845: 0,
        103846: 0,
        103847: 0,
        103848: 0,
        103849: 0,
        103850: 0,
        103851: 0,
        103852: 0,
        103853: 0,
        103854: 0,
        103855: 0,
        103856: 0,
        103857: 0,
        103858: 0,
        103859: 0,
        103860: 0,
        103861: 0,
        103862: 0,
        103863: 0,
        103864: 0,
        103865: 0,
        103866: 0,
        103867: 0,
        103868: 0,
        103869: 0,
        103870: 0,
        103871: 0,
        103900: 2,
        103901: 2,
        103902: 2,
        103903: 2,
        103904: 2,
        103905: 2,
        103906: 2,
        103907: 2,
        103908: 2,
        103909: 2,
        103910: 2,
        103911: 2,
        103912: 2,
        103913: 2,
        103914: 2,
        103915: 2,
        103916: 2,
        103917: 2,
        103918: 2,
        103919: 2,
        103920: 2,
        103921: 2,
        103922: 2,
        103923: 2,
        103924: 2,
        103925: 2,
        103926: 2,
        103927: 2,
        103928: 2,
        103929: 2,
        103930: 2,
        103931: 2,
        103932: 2,
        103933: 2,
        103934: 2,
        103935: 2,
        103936: 2,
        103937: 2,
        103938: 2,
        103939: 2,
        103940: 2,
        103941: 2,
        103942: 2,
        103943: 2,
        103944: 2,
        103945: 2,
        103946: 2,
        103947: 2,
        103948: 2,
        103949: 2,
        103950: 2,
        103951: 2,
        103952: 2,
        103953: 2,
        103954: 2,
        103955: 2,
        103956: 2,
        103957: 2,
        103958: 2,
        103959: 2,
        103960: 2,
        103961: 2,
        103962: 2,
        103963: 2,
        103964: 2,
        103965: 2,
        103966: 2,
        103967: 2,
        103968: 2,
        103969: 2,
        103970: 2,
        103971: 2
    }
});
},
'esri/geometry/screenUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/lang", "dojo/sniff", "../kernel", "./Point", "./ScreenPoint", "./Polyline", "./Polygon", "./Multipoint", "./Extent"], function(B, F, C, G, t, D, x, y, z, A) {
    var E = function() {
        return 9 > C("ie") ? function(b, n, p, a, g, e, f, c, h) {
            var d = [],
                l = Math.round,
                r, s = f.length,
                m, k, u, q, v, w;
            for (r = 0; r < s; r++)
                if (m = f[r], q = c ? c(m[0][0], m[0][1], h) : m[0], 1 < (u = m.length)) {
                    v = l((q[0] - b) * p + g);
                    w = l((n - q[1]) * a + e);
                    q = c ? c(m[1][0], m[1][1], h) : m[1];
                    k = l((q[0] - b) * p + g);
                    q = l((n - q[1]) * a + e);
                    d.push("M", v + "," + w, "L", k + "," + q);
                    for (k = 2; k < u; k++) q =
                        c ? c(m[k][0], m[k][1], h) : m[k], v = l((q[0] - b) * p + g), w = l((n - q[1]) * a + e), d.push(v + "," + w)
                } else v = l((q[0] - b) * p + g), w = l((n - q[1]) * a + e), d.push("M", v + "," + w);
            return d
        } : function(b, n, p, a, g, e, f, c, h) {
            var d = [],
                l, r, s, m, k, u, q = Math.round;
            l = 0;
            for (s = f ? f.length : 0; l < s; l++) {
                k = f[l];
                d.push("M");
                r = 0;
                for (m = k ? k.length : 0; r < m; r++) u = c ? c(k[r][0], k[r][1], h) : k[r], d.push(q((u[0] - b) * p + g) + "," + q((n - u[1]) * a + e))
            }
            return d
        }
    }();
    return {
        toScreenPoint: function(b, n, p, a, g) {
            var e = b.spatialReference,
                f = a.spatialReference,
                c = a.x;
            a = a.y;
            e && (f && !e.equals(f) &&
                e._canProject(f)) && (e = e.isWebMercator() ? t.lngLatToXY(c, a) : t.xyToLngLat(c, a, !0), c = e[0], a = e[1]);
            c = (c - b.xmin) * (n / b.getWidth());
            a = (b.ymax - a) * (p / b.getHeight());
            g || (c = Math.round(c), a = Math.round(a));
            return new D(c, a)
        },
        toScreenGeometry: function(b, n, p, a) {
            var g = b.xmin,
                e = b.ymax,
                f = n / b.getWidth(),
                c = p / b.getHeight(),
                h = B.forEach,
                d = Math.round;
            if (a instanceof t) return new t(d((a.x - g) * f), d((e - a.y) * c));
            if (a instanceof z) {
                b = new z;
                var l = b.points;
                h(a.points, function(a, b) {
                    l[b] = [d((a[0] - g) * f), d((e - a[1]) * c)]
                });
                return b
            }
            if (a instanceof A) return new A(d((a.xmin - g) * f), d((e - a.ymin) * c), d((a.xmax - g) * f), d((e - a.ymax) * f));
            if (a instanceof x) {
                b = new x;
                var r = b.paths,
                    s;
                h(a.paths, function(a, b) {
                    s = r[b] = [];
                    h(a, function(a, b) {
                        s[b] = [d((a[0] - g) * f), d((e - a[1]) * c)]
                    })
                });
                return b
            }
            if (a instanceof y) {
                b = new y;
                var m = b.rings,
                    k;
                h(a.rings, function(a, b) {
                    k = m[b] = [];
                    h(a, function(a, b) {
                        k[b] = [d((a[0] - g) * f), d((e - a[1]) * c)]
                    })
                });
                return b
            }
        },
        _toScreenPath: function(b, n, p, a, g, e) {
            var f = a instanceof x,
                c = b.spatialReference,
                h = a.spatialReference,
                d, l;
            c && (h && !c.equals(h) && c._canProject(h)) &&
                (c.isWebMercator() ? d = t.lngLatToXY : (d = t.xyToLngLat, l = !0));
            return E(b.xmin, b.ymax, n / b.getWidth(), p / b.getHeight(), g, e, f ? a.paths : a.rings, d, l)
        },
        toMapPoint: function(b, n, p, a) {
            return new t(b.xmin + a.x / (n / b.getWidth()), b.ymax - a.y / (p / b.getHeight()), b.spatialReference)
        },
        toMapGeometry: function(b, n, p, a) {
            var g = b.xmin,
                e = b.ymax,
                f = b.spatialReference,
                c = n / b.getWidth(),
                h = p / b.getHeight(),
                d = B.forEach;
            if (a instanceof t) return new t(g + a.x / c, e - a.y / h, f);
            if (a instanceof z) {
                b = new z(f);
                var l = b.points;
                d(a.points, function(a, b) {
                    l[b] = [g + a[0] / c, e - a[1] / h]
                });
                return b
            }
            if (a instanceof A) return new A(g + a.xmin / c, e - a.ymin / h, g + a.xmax / c, e - a.ymax / h, f);
            if (a instanceof x) {
                b = new x(f);
                var r = b.paths,
                    s;
                d(a.paths, function(a, b) {
                    s = r[b] = [];
                    d(a, function(a, b) {
                        s[b] = [g + a[0] / c, e - a[1] / h]
                    })
                });
                return b
            }
            if (a instanceof y) {
                b = new y(f);
                var m = b.rings,
                    k;
                d(a.rings, function(a, b) {
                    k = m[b] = [];
                    d(a, function(a, b) {
                        k[b] = [g + a[0] / c, e - a[1] / h]
                    })
                });
                return b
            }
        }
    }
});
},
'esri/geometry/Polyline':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../SpatialReference", "./Geometry", "./Point", "./Extent"], function(f, h, d, C, D, z, A, B, g, v) {
    var y = {
        type: "polyline",
        paths: null
    };
    f = f(B, {
        declaredClass: "esri.geometry.Polyline",
        constructor: function(a) {
            d.mixin(this, y);
            this.paths = [];
            this._path = 0;
            a && (d.isArray(a) ? this.paths = d.isArray(a[0][0]) ? a : [a] : a.paths ? d.mixin(this, a) : this.spatialReference = a, this.spatialReference && (this.spatialReference = new A(this.spatialReference)));
            this.verifySR()
        },
        _extent: null,
        addPath: function(a) {
            this._extent = null;
            this._path = this.paths.length;
            this.paths[this._path] = [];
            d.isArray(a[0]) ? h.forEach(a, this._addPointArr, this) : h.forEach(a, this._addPoint, this);
            return this
        },
        _addPointArr: function(a) {
            this.paths[this._path].push(a)
        },
        _addPoint: function(a) {
            this.paths[this._path].push([a.x, a.y])
        },
        _insertPoints: function(a, b) {
            this._extent = null;
            this._path = b;
            this.paths[this._path] || (this.paths[this._path] = []);
            h.forEach(a, this._addPoint, this)
        },
        _validateInputs: function(a,
            b) {
            return null !== a && void 0 !== a && (0 > a || a >= this.paths.length) || null !== b && void 0 !== a && (0 > b || b >= this.paths[a].length) ? !1 : !0
        },
        getPoint: function(a, b) {
            if (this._validateInputs(a, b)) return new g(this.paths[a][b], this.spatialReference)
        },
        setPoint: function(a, b, c) {
            if (this._validateInputs(a, b)) return this._extent = null, this.paths[a][b] = [c.x, c.y], this
        },
        insertPoint: function(a, b, c) {
            if (this._validateInputs(a) && z.isDefined(b) && 0 <= b && b <= this.paths[a].length) return this._extent = null, this.paths[a].splice(b, 0, [c.x, c.y]),
                this
        },
        removePath: function(a) {
            if (this._validateInputs(a, null)) {
                this._extent = null;
                a = this.paths.splice(a, 1)[0];
                var b, c = a.length,
                    e = this.spatialReference;
                for (b = 0; b < c; b++) a[b] = new g(a[b], e);
                return a
            }
        },
        removePoint: function(a, b) {
            if (this._validateInputs(a, b)) return this._extent = null, new g(this.paths[a].splice(b, 1)[0], this.spatialReference)
        },
        getExtent: function() {
            var a;
            if (this._extent) return a = new v(this._extent), a._partwise = this._partwise, a;
            a = this.paths;
            var b = a.length;
            if (b && a[0].length) {
                var c, e, d, f, k, l, m, h,
                    g = f = a[0][0][0],
                    w = k = a[0][0][1],
                    n = Math.min,
                    p = Math.max,
                    q = this.spatialReference,
                    x = [],
                    r, s, t, u;
                for (l = 0; l < b; l++) {
                    c = a[l];
                    r = s = c[0] && c[0][0];
                    t = u = c[0] && c[0][1];
                    h = c.length;
                    for (m = 0; m < h; m++) e = c[m], d = e[0], e = e[1], g = n(g, d), w = n(w, e), f = p(f, d), k = p(k, e), r = n(r, d), t = n(t, e), s = p(s, d), u = p(u, e);
                    x.push(new v({
                        xmin: r,
                        ymin: t,
                        xmax: s,
                        ymax: u,
                        spatialReference: q ? q.toJson() : null
                    }))
                }
                this._extent = {
                    xmin: g,
                    ymin: w,
                    xmax: f,
                    ymax: k,
                    spatialReference: q ? q.toJson() : null
                };
                this._partwise = 1 < x.length ? x : null;
                a = new v(this._extent);
                a._partwise = this._partwise;
                return a
            }
        },
        toJson: function() {
            var a = {
                    paths: d.clone(this.paths)
                },
                b = this.spatialReference;
            b && (a.spatialReference = b.toJson());
            return a
        }
    });
    f.defaultProps = y;
    return f
});
},
'esri/geometry/Polygon':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../SpatialReference", "./Geometry", "./Point", "./Extent", "./mathUtils"], function(A, m, k, E, F, B, C, D, n, v, y) {
    var z = {
            type: "polygon",
            rings: null
        },
        l = A(D, {
            declaredClass: "esri.geometry.Polygon",
            constructor: function(a) {
                k.mixin(this, z);
                this.rings = [];
                this._ring = 0;
                a && (k.isArray(a) ? this.rings = k.isArray(a[0][0]) ? a : [a] : a.rings ? k.mixin(this, a) : this.spatialReference = a, this.spatialReference && (this.spatialReference = new C(this.spatialReference)));
                this.verifySR()
            },
            _extent: null,
            addRing: function(a) {
                this._extent = this._centroid = null;
                this._ring = this.rings.length;
                this.rings[this._ring] = [];
                k.isArray(a[0]) ? m.forEach(a, this._addPointArr, this) : m.forEach(a, this._addPoint, this);
                return this
            },
            _addPointArr: function(a) {
                this.rings[this._ring].push(a)
            },
            _addPoint: function(a) {
                this.rings[this._ring].push([a.x, a.y])
            },
            _insertPoints: function(a, b) {
                this._extent = this._centroid = null;
                this._ring = b;
                this.rings[this._ring] || (this.rings[this._ring] = []);
                m.forEach(a, this._addPoint,
                    this)
            },
            _validateInputs: function(a, b) {
                return null !== a && void 0 !== a && (0 > a || a >= this.rings.length) || null !== b && void 0 !== a && (0 > b || b >= this.rings[a].length) ? !1 : !0
            },
            getPoint: function(a, b) {
                if (this._validateInputs(a, b)) return new n(this.rings[a][b], this.spatialReference)
            },
            setPoint: function(a, b, c) {
                if (this._validateInputs(a, b)) return this._extent = this._centroid = null, this.rings[a][b] = [c.x, c.y], this
            },
            insertPoint: function(a, b, c) {
                if (this._validateInputs(a) && B.isDefined(b) && 0 <= b && b <= this.rings[a].length) return this._extent =
                    this._centroid = null, this.rings[a].splice(b, 0, [c.x, c.y]), this
            },
            removeRing: function(a) {
                if (this._validateInputs(a, null)) {
                    this._extent = this._centroid = null;
                    a = this.rings.splice(a, 1)[0];
                    var b, c = a.length,
                        d = this.spatialReference;
                    for (b = 0; b < c; b++) a[b] = new n(a[b], d);
                    return a
                }
            },
            removePoint: function(a, b) {
                if (this._validateInputs(a, b)) return this._extent = this._centroid = null, new n(this.rings[a].splice(b, 1)[0], this.spatialReference)
            },
            getExtent: function() {
                var a;
                if (this._extent) return a = new v(this._extent), a._partwise =
                    this._partwise, a;
                a = this.rings;
                var b = a.length;
                if (b && a[0].length) {
                    var c, d, e, g, h, f, p, q, l = g = a[0][0][0],
                        w = h = a[0][0][1],
                        k = Math.min,
                        m = Math.max,
                        n = this.spatialReference,
                        x = [],
                        r, s, t, u;
                    for (f = 0; f < b; f++) {
                        c = a[f];
                        r = s = c[0] && c[0][0];
                        t = u = c[0] && c[0][1];
                        q = c.length;
                        for (p = 0; p < q; p++) d = c[p], e = d[0], d = d[1], l = k(l, e), w = k(w, d), g = m(g, e), h = m(h, d), r = k(r, e), t = k(t, d), s = m(s, e), u = m(u, d);
                        x.push(new v({
                            xmin: r,
                            ymin: t,
                            xmax: s,
                            ymax: u,
                            spatialReference: n ? n.toJson() : null
                        }))
                    }
                    this._extent = {
                        xmin: l,
                        ymin: w,
                        xmax: g,
                        ymax: h,
                        spatialReference: n ? n.toJson() : null
                    };
                    this._partwise = 1 < x.length ? x : null;
                    a = new v(this._extent);
                    a._partwise = this._partwise;
                    return a
                }
            },
            contains: function(a) {
                var b = this.rings,
                    c, d = !1,
                    e, g, h, f, p, q, k = b.length;
                c = this.spatialReference;
                e = a.spatialReference;
                var l = a.x;
                a = a.y;
                c && (e && !c.equals(e) && c._canProject(e)) && (a = c.isWebMercator() ? n.lngLatToXY(l, a) : n.xyToLngLat(l, a, !0), l = a[0], a = a[1]);
                for (q = 0; q < k; q++) {
                    c = b[q];
                    h = c.length;
                    for (p = f = 0; p < h; p++)
                        if (f++, f === h && (f = 0), e = c[p], g = c[f], (e[1] < a && g[1] >= a || g[1] < a && e[1] >= a) && e[0] + (a - e[1]) / (g[1] - e[1]) * (g[0] - e[0]) <
                            l) d = !d
                }
                return d
            },
            getCentroid: function() {
                if (null != this._centroid) return this._centroid;
                var a, b, c, d, e = [],
                    g, h;
                m.forEach(this.rings, function(d) {
                    a = b = c = 0;
                    m.forEach(d, function(e, l) {
                        l < d.length - 1 && (g = d[l + 1], h = e[0] * g[1] - g[0] * e[1], a += (e[0] + g[0]) * h, b += (e[1] + g[1]) * h, c += h)
                    });
                    0 < c && (c *= -1);
                    e.push([a, b, c / 2])
                });
                e.sort(function(a, c) {
                    return a[2] - c[2]
                });
                d = 6 * e[0][2];
                return this._centroid = new n(e[0][0] / d, e[0][1] / d, this.spatialReference)
            },
            isClockwise: function(a) {
                var b = 0,
                    c, d = a.length,
                    e = k.isArray(a[0]) ? function(a, c) {
                        return a[0] *
                            c[1] - c[0] * a[1]
                    } : function(a, c) {
                        return a.x * c.y - c.x * a.y
                    };
                for (c = 0; c < d; c++) b += e(a[c], a[(c + 1) % d]);
                return 0 >= b / 2
            },
            isSelfIntersecting: function(a) {
                a = a || this;
                var b, c, d, e, g, h, f, l = a.rings.length,
                    k;
                for (d = 0; d < l; d++) {
                    for (b = 0; b < a.rings[d].length - 1; b++) {
                        g = [
                            [a.rings[d][b][0], a.rings[d][b][1]],
                            [a.rings[d][b + 1][0], a.rings[d][b + 1][1]]
                        ];
                        for (c = d + 1; c < l; c++)
                            for (e = 0; e < a.rings[c].length - 1; e++)
                                if (h = [
                                        [a.rings[c][e][0], a.rings[c][e][1]],
                                        [a.rings[c][e + 1][0], a.rings[c][e + 1][1]]
                                    ], (f = y._getLineIntersection2(g, h)) && !(f[0] === g[0][0] &&
                                        f[1] === g[0][1] || f[0] === h[0][0] && f[1] === h[0][1] || f[0] === g[1][0] && f[1] === g[1][1] || f[0] === h[1][0] && f[1] === h[1][1])) return !0
                    }
                    e = a.rings[d].length;
                    if (!(4 >= e))
                        for (b = 0; b < e - 3; b++) {
                            k = e - 1;
                            0 === b && (k = e - 2);
                            g = [
                                [a.rings[d][b][0], a.rings[d][b][1]],
                                [a.rings[d][b + 1][0], a.rings[d][b + 1][1]]
                            ];
                            for (c = b + 2; c < k; c++)
                                if (h = [
                                        [a.rings[d][c][0], a.rings[d][c][1]],
                                        [a.rings[d][c + 1][0], a.rings[d][c + 1][1]]
                                    ], (f = y._getLineIntersection2(g, h)) && !(f[0] === g[0][0] && f[1] === g[0][1] || f[0] === h[0][0] && f[1] === h[0][1] || f[0] === g[1][0] && f[1] === g[1][1] ||
                                        f[0] === h[1][0] && f[1] === h[1][1])) return !0
                        }
                }
                return !1
            },
            toJson: function() {
                var a = {
                        rings: k.clone(this.rings)
                    },
                    b = this.spatialReference;
                b && (a.spatialReference = b.toJson());
                return a
            }
        });
    l.defaultProps = z;
    l.createEllipse = function(a) {
        var b = a.center.x,
            c = a.center.y,
            d = a.longAxis,
            e = a.shortAxis,
            g = a.numberOfPoints,
            h = a.map,
            f, k, m;
        a = [];
        var n = 2 * Math.PI / g;
        for (k = 0; k < g; k++) f = Math.cos(k * n), m = Math.sin(k * n), f = h.toMap({
            x: d * f + b,
            y: e * m + c
        }), a.push(f);
        a.push(a[0]);
        b = new l(h.spatialReference);
        b.addRing(a);
        return b
    };
    l.createCircle = function(a) {
        return l.createEllipse({
            center: a.center,
            longAxis: a.r,
            shortAxis: a.r,
            numberOfPoints: a.numberOfPoints,
            map: a.map
        })
    };
    l.fromExtent = function(a) {
        var b = a.normalize();
        a = a.spatialReference;
        return new l({
            rings: m.map(b, function(a) {
                return [
                    [a.xmin, a.ymin],
                    [a.xmin, a.ymax],
                    [a.xmax, a.ymax],
                    [a.xmax, a.ymin],
                    [a.xmin, a.ymin]
                ]
            }),
            spatialReference: a ? a.toJson() : null
        })
    };
    return l
});
},
'esri/geometry/Multipoint':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../SpatialReference", "./Geometry", "./Point", "./Extent"], function(b, c, s, t, q, r, e, m) {
    var f = {
        type: "multipoint",
        points: null
    };
    b = b(r, {
        declaredClass: "esri.geometry.Multipoint",
        constructor: function(a) {
            c.mixin(this, f);
            this.points = [];
            a && (a.points ? c.mixin(this, a) : this.spatialReference = a, this.spatialReference && (this.spatialReference = new q(this.spatialReference)));
            this.verifySR()
        },
        _extent: null,
        addPoint: function(a) {
            this._extent = null;
            c.isArray(a) ?
                this.points.push(a) : this.points.push([a.x, a.y]);
            return this
        },
        removePoint: function(a) {
            if (this._validateInputs(a)) return this._extent = null, new e(this.points.splice(a, 1)[0], this.spatialReference)
        },
        getExtent: function() {
            if (this._extent) return new m(this._extent);
            var a = this.points,
                n = a.length;
            if (n) {
                var d = a[0],
                    b, c, h = b = d[0],
                    k = c = d[1],
                    e = Math.min,
                    f = Math.max,
                    p = this.spatialReference,
                    l, g;
                for (g = 0; g < n; g++) d = a[g], l = d[0], d = d[1], h = e(h, l), k = e(k, d), b = f(b, l), c = f(c, d);
                this._extent = {
                    xmin: h,
                    ymin: k,
                    xmax: b,
                    ymax: c,
                    spatialReference: p ?
                        p.toJson() : null
                };
                return new m(this._extent)
            }
        },
        _validateInputs: function(a) {
            return null === a || 0 > a || a >= this.points.length ? !1 : !0
        },
        getPoint: function(a) {
            if (this._validateInputs(a)) return a = this.points[a], new e(a[0], a[1], this.spatialReference)
        },
        setPoint: function(a, b) {
            if (this._validateInputs(a)) return this._extent = null, this.points[a] = [b.x, b.y], this
        },
        toJson: function() {
            var a = {
                    points: c.clone(this.points)
                },
                b = this.spatialReference;
            b && (a.spatialReference = b.toJson());
            return a
        }
    });
    b.defaultProps = f;
    return b
});
},
'esri/layers/GraphicsLayer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/dom-attr", "dojo/dom-construct", "dojo/dom-style", "dojox/gfx", "dojox/gfx/matrix", "./layer", "../kernel", "../lang", "../sniff", "../Color", "../domUtils", "../symbols/MarkerSymbol", "../symbols/SimpleMarkerSymbol", "../geometry/Point", "../geometry/ScreenPoint", "../geometry/Extent", "../geometry/mathUtils", "../geometry/screenUtils", "../PluginTarget"], function(x, v, y, n, I, N, G, A, u, S, T, O, H, U, D, V, w, P, J, B, Q, K, W) {
    var L, M = -1 !== A.renderer.toLowerCase().indexOf("svg"),
        E = -1 !== A.renderer.toLowerCase().indexOf("canvas"),
        t = 9 > H("ie"),
        R = H("esri-touch"),
        X = x(null, {
            declaredClass: "esri.layers._GraphicsContainer",
            _setMap: function(a, b) {
                var c, e = this._connects = [];
                this._map = a;
                E ? (c = N.create("div", {
                        style: "overflow: visible; position: absolute;"
                    }, b), this._surface = {
                        getEventSource: function() {
                            return c
                        }
                    }, e.push(v.connect(c, "onmousedown", this, this._canvasDownHandler)), e.push(v.connect(c, "onmouseup", this, this._canvasUpHandler)), e.push(v.connect(c, "onclick", this, this._canvasClickHandler)),
                    L.prototype._canvas = !0) : (c = (this._surface = A.createSurface(b, a.width, a.height)).getEventSource(), G.set(c = t ? c.parentNode : c, {
                    overflow: "visible",
                    position: "absolute"
                }));
                e.push(v.connect(a, "onResize", this, "_onResizeHandler"));
                return c
            },
            _onResizeHandler: function(a, b, c) {
                a = this._surface.getEventSource();
                var e = this._map,
                    d;
                t && G.set(a = a.parentNode, {
                    width: b + "px",
                    height: c + "px",
                    clip: "rect(0px " + b + "px " + c + "px 0px)"
                });
                I.set(a, "width", b);
                I.set(a, "height", c);
                this._surface.declaredClass || n.forEach(a.childNodes, function(a) {
                    I.set(a,
                        "width", b);
                    I.set(a, "height", c)
                });
                e.loaded && (e.graphics.suspended || (e.graphics._resized = !0), n.forEach(e.graphicsLayerIds, function(a) {
                    d = e.getLayer(a);
                    d.suspended || (d._resized = !0)
                }))
            },
            _cleanUp: function() {
                n.forEach(this._connects, v.disconnect, v);
                this._map = this._surface = null
            },
            _processEvent: function(a) {
                var b = this._map;
                a.screenPoint = new J(a.pageX - b.position.x, a.pageY - b.position.y);
                a.mapPoint = b.toMap(a.screenPoint)
            },
            _canvasDownHandler: function(a) {
                this._processEvent(a);
                this._downPt = a.screenPoint.x + "," + a.screenPoint.y
            },
            _canvasUpHandler: function(a) {
                this._processEvent(a);
                this._upPt = a.screenPoint.x + "," + a.screenPoint.y
            },
            _tolerance: 15,
            _isPrimaryMatch: function(a, b, c, e) {
                if (!a.visible || !b) return !1;
                var d = b.getTransformedBoundingBox(),
                    g;
                return d ? (g = new B(d[0].x, d[0].y, d[2].x, d[2].y), delete g.spatialReference, R ? g.intersects(c) : g.contains(e)) : n.some(b.children || [], function(a) {
                    d = a.getTransformedBoundingBox();
                    g = new B(d[0].x, d[0].y, d[2].x, d[2].y);
                    delete g.spatialReference;
                    return R ? g.intersects(c) : g.contains(e)
                })
            },
            _canvasClickHandler: function(a) {
                if (this._downPt &&
                    this._upPt && this._downPt === this._upPt) {
                    this._processEvent(a);
                    var b = this._map,
                        c = n.map(b.graphicsLayerIds, function(a) {
                            return b.getLayer(a)
                        });
                    c.push(b.graphics);
                    c.reverse();
                    var c = n.filter(c, function(a) {
                            return a.loaded && a._mouseEvents && !a.suspended && (!O.isDefined(a.opacity) || 0 < a.opacity)
                        }),
                        e = a.screenPoint,
                        d = this._tolerance,
                        g = e.x - d,
                        f = e.y + d,
                        h = e.x + d,
                        d = e.y - d,
                        k = new B(g, d, h, f),
                        g = b.toMap(new J(g, f)),
                        h = b.toMap(new J(h, d)),
                        f = g.spatialReference._getInfo(),
                        l = new B(B.prototype._normalizeX(g.x, f).x, g.y, B.prototype._normalizeX(h.x,
                            f).x, h.y, g.spatialReference),
                        m;
                    delete k.spatialReference;
                    n.some(c, function(a) {
                        a = n.filter(a.graphics, function(a) {
                            return this._isPrimaryMatch(a, a.getDojoShape(), k, e) || !(!a._bgShape || !this._isPrimaryMatch(a, a._bgShape, k, e))
                        }, this);
                        a.reverse();
                        if (0 < a.length) {
                            var c;
                            n.some(a, function(a) {
                                return a.geometry && l.intersects(a.geometry) ? (c = a, !0) : !1
                            });
                            if (c) return m = c, !0
                        }
                        return !1
                    }, this);
                    if (m && (c = m.getLayer())) a.graphic = m, c.onClick(a)
                }
            }
        });
    L = x(S, {
        declaredClass: "esri.layers._GraphicsLayer",
        managedSuspension: !0,
        surfaceType: E ?
            "canvas-2d" : A.renderer,
        _eventMap: {
            "graphic-add": ["graphic"],
            "graphic-remove": ["graphic"],
            "renderer-change": ["renderer"]
        },
        constructor: function(a, b) {
            if (a && (y.isString(a) || y.isObject(a) && (a.layerDefinition || a.query))) a = b;
            this._params = y.mixin({
                displayOnPan: !0,
                drawMode: !0,
                styling: !0
            }, a || {});
            var c = this._params.dataAttributes;
            "string" === typeof c && (c = [c]);
            this.styling = M ? this._params.styling : !0;
            this.dataAttributes = c;
            this.infoTemplate = a && a.infoTemplate;
            this.graphics = [];
            this._draw = y.hitch(this, this._draw);
            this._refresh =
                y.hitch(this, this._refresh);
            this.registerConnectEvents()
        },
        getNode: function() {
            return this._div && this._div.getEventSource()
        },
        setDrawMode: function(a) {
            this._params.drawMode = a
        },
        renderer: null,
        _setMap: function(a, b) {
            this.inherited(arguments);
            this._map = a;
            this._wrap = a.wrapAround180;
            this._srInfo = a.spatialReference._getInfo();
            this._canvas ? (b = A.createSurface(b.getEventSource(), a.width, a.height), G.set(b.rawNode, "position", "absolute"), this._div = b.createGroup(), this._renderProto = this._div.constructor.prototype._render,
                this._div._render = y.hitch(this, this._canvasRender)) : this._div = b.createGroup();
            this._bgGroup = this._div.createGroup();
            this._div.getEventSource().id = this.id + "_layer";
            var c = this.opacity;
            O.isDefined(c) && 1 > c && this.setOpacity(c, !0);
            return this._div
        },
        _unsetMap: function(a, b) {
            n.forEach(this.graphics, function(a) {
                a._shape = null
            });
            this._canvas ? (b = this._div.getParent(), b._parent = {}, N.destroy(b.rawNode), b.destroy()) : (this._div.clear(), b.remove(this._div), N.destroy(this._div.getEventSource()));
            this._map = this._div =
                null;
            clearTimeout(this._wakeTimer);
            this._wakeTimer = null;
            this._disableDrawConnectors();
            this.inherited(arguments)
        },
        _onZoomStartHandler: function() {
            D.hide(this._div.getEventSource())
        },
        _onExtentChangeHandler: function(a, b, c, e) {
            clearTimeout(this._wakeTimer);
            this._wakeTimer = null;
            c ? (a = this._map.__visibleRect, b = this._div, this._evalSDRenderer(), this._refresh(!0), b.setTransform(u.translate({
                    x: a.x,
                    y: a.y
                })), this._renderProto && b.surface.pendingRender ? this._dirty = !0 : this.suspended || D.show(b.getEventSource())) : this._resized &&
                (this._refresh(!1), this._resized = !1);
            if (0 < this.graphics.length) this.onUpdate()
        },
        _canvasRender: function() {
            var a = this._div;
            this._dirty && (delete this._dirty, this.suspended || D.show(a.getEventSource()));
            return this._renderProto.apply(a, arguments)
        },
        _refresh: function(a) {
            var b = this.graphics,
                c = b.length,
                e, d = this._draw;
            for (e = 0; e < c; e++) d(b[e], a)
        },
        refresh: function() {
            this._refresh(!0)
        },
        redraw: function() {
            this._refresh(!0)
        },
        _onPanHandler: function(a, b) {
            this._panDx = b.x;
            this._panDy = b.y;
            var c = this._map.__visibleRect;
            this._div.setTransform(u.translate({
                x: c.x + b.x,
                y: c.y + b.y
            }))
        },
        _onPanEndUpdateHandler: function(a, b) {
            if (!this._params._child && (b.x !== this._panDx || b.y !== this._panDy)) {
                var c = this._map.__visibleRect;
                this._div.setTransform(u.translate({
                    x: c.x,
                    y: c.y
                }))
            }
            this._refresh(!1);
            if (this.graphics.length) this.onUpdate()
        },
        _onPanStartHandler: function() {
            D.hide(this._div.getEventSource())
        },
        _onPanEndHandler: function() {
            var a = this._map.__visibleRect,
                b = this._div;
            b.setTransform(u.translate({
                x: a.x,
                y: a.y
            }));
            this._refresh(!1);
            this._renderProto &&
                b.surface.pendingRender ? this._dirty = !0 : D.show(b.getEventSource());
            if (this.graphics.length) this.onUpdate()
        },
        onSuspend: function() {
            this.inherited(arguments);
            D.hide(this._div.getEventSource());
            clearTimeout(this._wakeTimer);
            this._wakeTimer = null;
            this._disableDrawConnectors()
        },
        onResume: function(a) {
            this.inherited(arguments);
            a.firstOccurrence && this._evalSDRenderer();
            this._enableDrawConnectors();
            this._wakeTimer = this._wakeTimer || setTimeout(y.hitch(this, function() {
                this.suspended || this._onExtentChangeHandler(null,
                    null, !0)
            }), 0)
        },
        _enableDrawConnectors: function() {
            var a = this._map,
                b = v.connect;
            this._disableDrawConnectors();
            this._params.displayOnPan ? (this._params._child || (this._onPanHandler_connect = b(a, "onPan", this, "_onPanHandler")), this._onPanEndHandler_connect = b(a, "onPanEnd", this, "_onPanEndUpdateHandler")) : (this._onPanStartHandler_connect = b(a, "onPanStart", this, "_onPanStartHandler"), this._onPanEndHandler_connect = b(a, "onPanEnd", this, "_onPanEndHandler"));
            this._onZoomStartHandler_connect = b(a, "onZoomStart", this, "_onZoomStartHandler");
            this._onExtentChangeHandler_connect = b(a, "onExtentChange", this, "_onExtentChangeHandler")
        },
        _disableDrawConnectors: function() {
            var a = v.disconnect;
            a(this._onExtentChangeHandler_connect);
            a(this._onZoomStartHandler_connect);
            a(this._onPanHandler_connect);
            a(this._onPanStartHandler_connect);
            a(this._onPanEndHandler_connect);
            this._onExtentChangeHandler_connect = this._onZoomStartHandler_connect = this._onPanHandler_connect = this._onPanStartHandler_connect = this._onPanEndHandler_connect = null
        },
        _updateExtent: function(a) {
            var b =
                a.geometry;
            if (b) {
                if (!(a._extent = b.getExtent())) {
                    var c, e;
                    if ("esri.geometry.Point" === b.declaredClass) c = b.x, e = b.y;
                    else if ("esri.geometry.Multipoint" === b.declaredClass) c = b.points[0][0], e = b.points[0][1];
                    else {
                        a._extent = null;
                        return
                    }
                    a._extent = new B(c, e, c, e, b.spatialReference)
                }
            } else a._extent = null
        },
        _intersects: function(a, b, c) {
            var e = a.spatialReference,
                d = b.spatialReference,
                g = e && d && !e.equals(d) && e._canProject(d) && 4326 === d.wkid;
            if (this._wrap && !c) {
                c = [];
                var e = a._getFrameWidth(),
                    f = this._srInfo,
                    h = a._clip ? a._getAvailExtent() :
                    a.extent,
                    k, l, m, q, p = [];
                k = b._partwise;
                g && (h = a.geographicExtent, f = d._getInfo());
                a = h._getParts(f);
                if (k && k.length) {
                    b = [];
                    d = 0;
                    for (g = k.length; d < g; d++) b = b.concat(k[d]._getParts(f))
                } else b = b._getParts(f);
                d = 0;
                for (g = b.length; d < g; d++) {
                    m = b[d];
                    f = 0;
                    for (h = a.length; f < h; f++)
                        if (q = a[f], q.extent.intersects(m.extent)) {
                            k = 0;
                            for (l = m.frameIds.length; k < l; k++) c.push((q.frameIds[0] - m.frameIds[k]) * e)
                        }
                }
                d = 0;
                for (g = c.length; d < g; d++) k = c[d], n.indexOf(c, k) === d && p.push(k);
                return p.length ? p : null
            }
            return (g ? a.geographicExtent : a.extent).intersects(b) ? [0] : null
        },
        _defaultMarker: {
            type: "simplemarkersymbol",
            style: "square",
            size: 1,
            xoffset: 0,
            yoffset: 0,
            angle: 0
        },
        _draw: function(a, b) {
            if (this._params.drawMode && this._map && !this.suspended) try {
                var c = a._extent,
                    e, d, g = !M || this.styling,
                    f = M && this.dataAttributes,
                    h = a.getDojoShape(),
                    k;
                if (a.visible && c && (e = this._intersects(this._map, c, a.geometry._originOnly)) && (d = g ? this._getSymbol(a) : this._defaultMarker)) {
                    if (!a._offsets || a._offsets.join(",") !== e.join(",") ? a._offsets = e : k = !0, !h || b || !k) {
                        var l = a.geometry.type,
                            c = {
                                graphic: a
                            },
                            m = a._bgShape,
                            q = g && !a.symbol ? this._getRenderer(a) : null,
                            p = q && q.backgroundFillSymbol;
                        if ("point" === l) this._isInvalidShape(d, h) && this._removeShape(a), a._shape = this._drawPoint(this._div, a.geometry, d, a.getDojoShape(), e, q, a), g && this._symbolizePoint(a.getDojoShape(), d, q, a);
                        else if ("multipoint" === l) this._drawMarkers(a, d, e, q), g && this._symbolizeMarkers(a, d, q);
                        else {
                            var n, l = d,
                                C, F;
                            g && (l = (n = d.isInstanceOf(V) ? d : null) ? p : d);
                            l && l === p && (C = this._bgGroup);
                            m && !C && this._removeBgShape(a);
                            l && (!C && this._isInvalidShape(l, a._shape) &&
                                this._removeShape(a, !1), F = this._drawShape(a, e, C || this._div, C ? m : a.getDojoShape()), g && this._symbolizeShape(F, l, !p && q, a), a[C ? "_bgShape" : "_shape"] = F);
                            n && (this._isInvalidShape(n, a._shape) && this._removeShape(a, !1), F = this._drawPoint(this._div, a.geometry.getCentroid(), n, a._shape, e, q, a), this._symbolizePoint(F, n, q, a), a._shape = F)
                        }
                        E || (a._bgShape && this._initNode(a, a._bgShape, a._bgShape !== m, c, f), a._shape && this._initNode(a, a._shape, a._shape !== h, c, f));
                        c.node = a.getNode();
                        this.onGraphicDraw(c)
                    }
                } else h && this._removeShape(a)
            } catch (Y) {
                this._errorHandler(Y,
                    a)
            }
        },
        _initNode: function(a, b, c, e, d) {
            if (b = b && b.getNode()) b.e_graphic = a, this._addDataAttrs(a, d, b), c && (e.node = b, this.onGraphicNodeAdd(e))
        },
        _removeShape: function(a, b) {
            var c = a.getDojoShape(),
                e = c && c.getNode();
            c && (c.removeShape(), c.destroy());
            a._shape = a._offsets = null;
            !1 !== b && this._removeBgShape(a);
            if (e && (e.e_graphic = null, !E)) this.onGraphicNodeRemove({
                graphic: a,
                node: e
            })
        },
        _removeBgShape: function(a) {
            var b = a._bgShape,
                c = b && b.getNode();
            b && (b.removeShape(), b.destroy(), a._bgShape = null);
            if (c && (c.e_graphic = null, !E)) this.onGraphicNodeRemove({
                graphic: a,
                node: c
            })
        },
        _addDataAttrs: function(a, b, c) {
            var e = a.attributes,
                d, g = b ? b.length : 0,
                f = this._getRenderer(a);
            if (c && e) {
                for (d = 0; d < g; d++)(c = b[d]) && a.attr("data-" + c, e[c]);
                !this.styling && f && (f.getBreakIndex ? (b = f.getBreakIndex(a), a.attr("data-class-break", -1 !== b ? b : null)) : f.getUniqueValueInfo && (b = f.getUniqueValueInfo(a), a.attr("data-unique-value", b ? b.value : null)))
            }
        },
        _drawShape: function(a, b, c, e) {
            a = a.geometry;
            var d = a.type,
                g = this._map,
                f = g.extent,
                h = g.width,
                k = g.height,
                g = g.__visibleRect,
                l = [],
                m, q;
            m = "extent" === d;
            if ("rect" ===
                d || m) l = {
                x: 0,
                y: 0,
                spatialReference: a.spatialReference
            }, l.x = m ? a.xmin : a.x, l.y = m ? a.ymax : a.y, d = K.toScreenPoint(f, h, k, l), l.x = m ? a.xmax : a.x + a.width, l.y = m ? a.ymin : a.y + a.height, a = K.toScreenPoint(f, h, k, l), b = {
                x: d.x - g.x + b[0],
                y: d.y - g.y,
                width: Math.abs(a.x - d.x),
                height: Math.abs(a.y - d.y)
            }, 0 === b.width && (b.width = 1), 0 === b.height && (b.height = 1), e = this._drawRect(c, e, b);
            else if ("polyline" === d || "polygon" === d) {
                m = 0;
                for (q = b.length; m < q; m++) l = l.concat(K._toScreenPath(f, h, k, a, -g.x + b[m], -g.y));
                e = this._drawPath(c, e, l);
                this._rendererLimits &&
                    ("polyline" === d ? this._clipPolyline(e, a) : this._clipPolygon(e, a))
            }
            return e
        },
        _drawRect: function(a, b, c) {
            return b ? b.setShape(c) : a.createRect(c)
        },
        _drawImage: function(a, b, c) {
            return b ? b.setShape(c) : a.createImage(c)
        },
        _drawCircle: function(a, b, c) {
            return b ? b.setShape(c) : a.createCircle(c)
        },
        _drawPath: function() {
            return t ? function(a, b, c, e) {
                c = e ? c : c.join(" ");
                if (b) return b.setShape(c);
                b = a.createObject(e ? A.Path : A.EsriPath, c);
                a._overrideSize(b.getEventSource());
                return b
            } : function(a, b, c, e) {
                c = e ? c : c.join(" ");
                return b ?
                    b.setShape(c) : a.createPath(c)
            }
        }(),
        _drawText: function(a, b, c) {
            return b ? b.setShape(c) : a.createText(c)
        },
        _evalSDRenderer: function(a) {
            var b = this._map,
                c = this.renderer,
                e, d = this._rndForScale;
            b && (b.loaded && c && c.getRendererInfo) && (e = "zoom" === c.rangeType ? c.getRendererInfoByZoom(b.getZoom()) : c.getRendererInfoByScale(b.getScale()));
            this._rndForScale = e && e.renderer;
            !a && this._rndForScale != d && this.emit("renderer-change", {
                renderer: this._rndForScale
            })
        },
        _getRenderer: function(a) {
            var b = this._rndForScale || this.renderer;
            a && (b && b.getObservationRenderer) && (b = b.getObservationRenderer(a));
            return b
        },
        _getSymbol: function(a) {
            var b = this._getRenderer();
            return a.symbol || b && b.getSymbol(a)
        },
        _getVariable: function(a, b) {
            return a ? a[b] || n.filter(a.visualVariables, function(a) {
                return a.type === b
            })[0] : null
        },
        _applyOpacity: function(a, b, c, e) {
            b = b.getOpacity(e, {
                opacityInfo: c
            });
            null != b && (a = new U(a), a.a = b);
            return a
        },
        _symbolizeShape: function(a, b, c, e) {
            var d = b.getStroke(),
                g = b.getFill();
            b = b.type;
            var f, h, k = this._getVariable(c, "sizeInfo"),
                l = this._getVariable(c,
                    "colorInfo"),
                m = this._getVariable(c, "opacityInfo"),
                k = k ? c.getSize(e, {
                    sizeInfo: k,
                    resolution: this._map.getResolutionInMeters()
                }) : null;
            if (c && (l || m) && "picturefillsymbol" !== b) - 1 !== b.indexOf("linesymbol") ? (f = d && d.color, l && (f = c.getColor(e, {
                colorInfo: l
            }) || f), f && m && (f = this._applyOpacity(f, c, m, e))) : g && g.toCss && (h = g, l && (h = c.getColor(e, {
                colorInfo: l
            }) || h), h && m && (h = this._applyOpacity(h, c, m, e)));
            a.setStroke(null == k && !f ? d : y.mixin({}, d, k && {
                width: k
            }, f && {
                color: f
            })).setFill(h || g)
        },
        _smsToPath: function() {
            return t ? function(a,
                b, c, e, d, g, f, h, k) {
                switch (b) {
                    case a.STYLE_SQUARE:
                        return ["M", d + "," + f, "L", g + "," + f, g + "," + h, d + "," + h, "X", "E"];
                    case a.STYLE_CROSS:
                        return ["M", c + "," + f, "L", c + "," + h, "M", d + "," + e, "L", g + "," + e, "E"];
                    case a.STYLE_X:
                        return ["M", d + "," + f, "L", g + "," + h, "M", d + "," + h, "L", g + "," + f, "E"];
                    case a.STYLE_DIAMOND:
                        return ["M", c + "," + f, "L", g + "," + e, c + "," + h, d + "," + e, "X", "E"];
                    case a.STYLE_TARGET:
                        return ["M", d + "," + f, "L", g + "," + f, g + "," + h, d + "," + h, d + "," + f, "M", d - k + "," + e, "L", d + "," + e, "M", c + "," + (f - k), "L", c + "," + f, "M", g + k + "," + e, "L", g + "," + e, "M", c + "," + (h +
                            k), "L", c + "," + h, "E"]
                }
            } : function(a, b, c, e, d, g, f, h, k) {
                switch (b) {
                    case a.STYLE_SQUARE:
                        return ["M", d + "," + f, g + "," + f, g + "," + h, d + "," + h, "Z"];
                    case a.STYLE_CROSS:
                        return ["M", c + "," + f, c + "," + h, "M", d + "," + e, g + "," + e];
                    case a.STYLE_X:
                        return ["M", d + "," + f, g + "," + h, "M", d + "," + h, g + "," + f];
                    case a.STYLE_DIAMOND:
                        return ["M", c + "," + f, g + "," + e, c + "," + h, d + "," + e, "Z"];
                    case a.STYLE_TARGET:
                        return ["M", d + "," + f, g + "," + f, g + "," + h, d + "," + h, d + "," + f, "M", d - k + "," + e, d + "," + e, "M", c + "," + (f - k), c + "," + f, "M", g + k + "," + e, g + "," + e, "M", c + "," + (h + k), c + "," + h]
                }
            }
        }(),
        _pathStyles: {
            square: 1,
            cross: 1,
            x: 1,
            diamond: 1,
            target: 1
        },
        _typeMaps: {
            picturemarkersymbol: "image",
            picturefillsymbol: "path",
            simplefillsymbol: "path",
            simplelinesymbol: "path",
            cartographiclinesymbol: "path",
            textsymbol: "text"
        },
        _isInvalidShape: function(a, b) {
            var c = b && b.shape && b.shape.type,
                e = a && a.type,
                d = a && a.style;
            "rect" === c && (c = "path");
            e && (d = this._typeMaps[e] || d);
            this._pathStyles[d] && (d = "path");
            return "shieldlabelsymbol" === e ? !0 : !(!c || !(d && c !== d))
        },
        _drawPoint: function(a, b, c, e, d, g, f) {
            var h = c.type,
                k = this._map,
                l = k.__visibleRect,
                m = K.toScreenPoint(k.extent,
                    k.width, k.height, b).offset(-l.x + d[0], -l.y),
                l = m.x,
                q = m.y,
                p;
            b = [];
            var n = g && g.rotationInfo ? g.getRotationAngle(f) : null,
                C = this._getVariable(g, "sizeInfo");
            g = C ? g.getSize(f, {
                sizeInfo: C,
                shape: c.style,
                resolution: k.getResolutionInMeters()
            }) : null;
            n && b.push(u.rotategAt(n, m));
            (0 !== c.xoffset || 0 !== c.yoffset) && b.push(u.translate(c.xoffset, -c.yoffset));
            0 !== c.angle && b.push(u.rotategAt(c.angle, m));
            if ("simplemarkersymbol" === h) switch (p = c.style, h = Math.round, g = null != g ? g : c.size, p) {
                case w.STYLE_SQUARE:
                case w.STYLE_CROSS:
                case w.STYLE_X:
                case w.STYLE_DIAMOND:
                    c =
                        isNaN(g) ? 16 : g / 2;
                    p = this._drawPath(a, e, this._smsToPath(w, p, l, q, h(l - c), h(l + c), h(q - c), h(q + c)));
                    break;
                case w.STYLE_TARGET:
                    m = c._targetWidth / 2;
                    g = c._targetHeight / 2;
                    p = this._drawPath(a, e, this._smsToPath(w, p, l, q, h(l - m), h(l + m), h(q - g), h(q + g), c._spikeSize));
                    break;
                case w.STYLE_PATH:
                    p = this._drawPath(a, e, c.path, !0);
                    c = p.getBoundingBox();
                    a = this._getScaleMatrix(c, g);
                    (1 !== a.xx || 1 !== a.yy) && b.push(u.scaleAt(a.xx, a.yy, m));
                    b.push(u.translate(-(c.x + c.width / 2) + l, -(c.y + c.height / 2) + q));
                    break;
                default:
                    c = isNaN(g) ? 16 : g / 2, p = this._drawCircle(a,
                        e, {
                            cx: l,
                            cy: q,
                            r: c
                        })
            } else "shieldlabelsymbol" === h ? (p = c.width, m = c.height, e = a.createGroup(), p = a.createImage({
                    x: l - p / 2,
                    y: q - m / 2,
                    width: p,
                    height: m,
                    src: c.url
                }), e.add(p), null != c.font && (q += 0.2 * c.getHeight(), a = a.createText({
                    type: "text",
                    text: c.text,
                    x: l,
                    y: q,
                    align: "middle",
                    decoration: c.decoration,
                    rotated: c.rotated,
                    kerning: c.kerning
                }), a.setFont(c.font), a.setFill(c.color), e.add(a)), p = e) : "picturemarkersymbol" === h ? (p = null != g ? g : c.width, m = null != g ? g : c.height, p = this._drawImage(a, e, {
                    x: l - p / 2,
                    y: q - m / 2,
                    width: p,
                    height: m,
                    src: c.url
                })) :
                "textsymbol" === h && (p = this._drawText(a, e, {
                    type: "text",
                    text: c.text,
                    x: l,
                    y: q,
                    align: c.getSVGAlign(),
                    decoration: c.decoration || c.font && c.font.decoration,
                    rotated: c.rotated,
                    kerning: c.kerning
                }), M && (a = p.getNode(), l = c.getSVGBaseline(), c = c.getSVGBaselineShift(), a && (a.setAttribute("dominant-baseline", l), c && a.setAttribute("baseline-shift", c))));
            p.setTransform(u.multiply(b));
            p._wrapOffsets = d;
            return p
        },
        _getScaleMatrix: function(a, b) {
            var c = a.width / a.height,
                e = 1,
                d = 1;
            isNaN(b) || (1 < c ? (e = b / a.width, d = b / c / a.height) : (d = b / a.height,
                e = b * c / a.width));
            return {
                xx: e,
                yy: d
            }
        },
        _symbolizePoint: function(a, b, c, e) {
            var d = b.type;
            if (!("shieldlabelsymbol" === d || "picturemarkersymbol" === d)) {
                var g;
                if ("textsymbol" === d) a.setFont(b.font).setFill(b.getFill());
                else {
                    g = b.getStroke();
                    b = b.getFill();
                    if (c) {
                        var f = this._getVariable(c, "colorInfo"),
                            h = this._getVariable(c, "opacityInfo");
                        f && (b = c.getColor(e, {
                            colorInfo: f
                        }) || b);
                        b && h && (b = this._applyOpacity(b, c, h, e))
                    }
                    "simplemarkersymbol" === d && a.setFill(b).setStroke(g)
                }
            }
        },
        _drawMarkers: function(a, b, c, e) {
            var d = a.geometry,
                g = d.points,
                f = a.getDojoShape() || this._div.createGroup(),
                h, k, l = g.length,
                m = [],
                q = 0,
                p, n = c ? c.length : 0;
            f.children[0] && this._isInvalidShape(b, f.children[0]) && f.clear();
            for (k = 0; k < l; k++) {
                h = g[k];
                for (p = 0; p < n; p++) m[0] = c[p], this._drawPoint(f, {
                    x: h[0],
                    y: h[1],
                    spatialReference: d.spatialReference
                }, b, f.children[q++], m, e, a)
            }
            b = f.children.length;
            if (l * c.length < b)
                for (k = b - 1; k >= l * c.length; k--) f.children[k].removeShape();
            a._shape = f
        },
        _symbolizeMarkers: function(a, b, c) {
            var e = a.getDojoShape().children,
                d, g = e.length;
            for (d = 0; d < g; d++) this._symbolizePoint(e[d],
                b, c, a)
        },
        _errorHandler: function(a, b) {
            a.message = b ? "Unable to draw graphic (geometry:" + (b.geometry ? b.geometry.declaredClass : null) + ", symbol:" + (b.symbol ? b.symbol.declaredClass : null) + "): " + a.message : "Unable to draw graphic (null): " + a.message;
            this.inherited(arguments)
        },
        _rendererLimits: function() {
            var a, b, c;
            H("ff") ? (a = 16125, b = -32250, c = 32250) : t ? (a = 1E5, b = -1E5, c = 1E5) : H("chrome") && 6 > H("chrome") && (a = 8150, b = -1E4, c = 1E4);
            if (a) return {
                clipLimit: a,
                rangeMin: b,
                rangeMax: c,
                clipBBox: [-a, -a, a, a],
                clipSegments: [
                    [
                        [-a, -a],
                        [a, -a]
                    ],
                    [
                        [a, -a],
                        [a, a]
                    ],
                    [
                        [a, a],
                        [-a, a]
                    ],
                    [
                        [-a, a],
                        [-a, -a]
                    ]
                ]
            }
        }(),
        _clipPolyline: function(a, b) {
            var c = this._getCorners(a, b),
                e = c.br,
                d = this._rendererLimits,
                g = d.rangeMin,
                f = d.rangeMax,
                h = d.clipBBox,
                k = d.clipSegments,
                d = this._isPointWithinRange,
                l = this._isPointWithinBBox,
                m = this._getClipperIntersection,
                q = this._getPlaneIndex;
            if (!d(c.tl, g, f) || !d(e, g, f)) {
                t && this._createSegments(a);
                var p = [];
                n.forEach(a.segments, function(a) {
                    a = a.args;
                    var c = a.length,
                        b = [],
                        e;
                    for (e = 0; e < c; e += 2) {
                        var d = [a[e], a[e + 1]],
                            g = [a[e + 2], a[e + 3]],
                            f = l(d, h),
                            n = l(g,
                                h);
                        if (f ^ n) {
                            if (n = m([d, g], k)) f ? (e ? b.push(n[1]) : b.push(d, n[1]), p.push(b), b = []) : b.push(n[1], g)
                        } else f ? e ? b.push(g) : b.push(d, g) : (n = q(d, h), f = q(g, h), -1 === n || (-1 === f || n === f) || (d = m([d, g], k, !0), 0 < d.length && (d[n] || (n = d[n[0]] ? n[0] : n[1]), d[f] || (f = d[f[0]] ? f[0] : f[1]), g = d[n], d = d[f], g && b.push(g), d && (b.push(d), p.push(b), b = []))))
                    }
                    p.push(b)
                });
                a.setShape(this._getPathStringFromPaths(p))
            }
        },
        _clipPolygon: function(a, b) {
            var c = this._getCorners(a, b),
                e = c.br,
                d = this._rendererLimits,
                g = d.clipLimit,
                f = d.rangeMin,
                h = d.rangeMax,
                k = d.clipBBox,
                l = d.clipSegments,
                d = this._isPointWithinRange,
                m = this._isPointWithinBBox,
                q = this._getClipperIntersection,
                p = this._getPlaneIndex,
                v = Q._pointLineDistance;
            if (!d(c.tl, f, h) || !d(e, f, h)) t && this._createSegments(a), c = n.map(a.segments, function(a) {
                var b = a.args,
                    c = b.length,
                    e = [];
                a = [];
                var d;
                for (d = 0; d < c; d += 2) {
                    var f = [b[d], b[d + 1]],
                        h = [b[d + 2], b[d + 3]];
                    if (d === c - 2) {
                        e.push(f);
                        break
                    }
                    var s = m(f, k),
                        r = m(h, k);
                    e.push(f);
                    if (s ^ r) {
                        if (r = q([f, h], l)) f = r[1], f[s ? "inOut" : "outIn"] = !0, e.push(f), a.push([s ? "INOUT" : "OUTIN", e.length - 1, r[0]])
                    } else if (!s) {
                        var s =
                            p(f, k),
                            z = p(h, k); - 1 === s || (-1 === z || s === z) || (r = q([f, h], l, !0), 0 < r.length ? (r[s] || (s = r[s[0]] ? s[0] : s[1]), r[z] || (z = r[z[0]] ? z[0] : z[1]), f = r[s], h = r[z], f && (f.outIn = !0, e.push(f), a.push(["OUTIN", e.length - 1, s])), h && (h.inOut = !0, e.push(h), a.push(["INOUT", e.length - 1, z]))) : y.isArray(s) && y.isArray(z) && (r = s.concat(z), r.sort(), "0123" === r.join("") && (r = [], 3 === s[0] + s[1] ? r.push([g, -g], [-g, g]) : r.push([-g, -g], [g, g]), s = v(r[0], [f, h]), f = v(r[1], [f, h]), e.push(s < f ? r[0] : r[1]))))
                    }
                }
                var t = k[0],
                    u = k[1],
                    w = k[2],
                    x = k[3];
                n.forEach(e, function(a) {
                    a[0] <
                        t && (a[1] >= u && a[1] <= x ? a[0] = t : (a[0] = t, a[1] = a[1] < u ? u : x))
                });
                n.forEach(e, function(a) {
                    a[1] < u && (a[0] >= t && a[0] <= w ? a[1] = u : (a[1] = u, a[0] = a[0] < t ? t : w))
                });
                n.forEach(e, function(a) {
                    a[0] > w && (a[1] >= u && a[1] <= x ? a[0] = w : (a[0] = w, a[1] = a[1] < u ? u : x))
                });
                n.forEach(e, function(a) {
                    a[1] > x && (a[0] >= t && a[0] <= w ? a[1] = x : (a[1] = x, a[0] = a[0] < t ? t : w))
                });
                b = 0;
                c = a.length;
                if (0 < c) {
                    do {
                        h = a[b];
                        d = a[(b + 1) % c];
                        if (h[2] === d[2] && "INOUT" === h[0] && "OUTIN" === d[0])
                            if (f = h[1], d = d[1], f < d)
                                for (f += 1; f < d; f++) e[f][2] = !0;
                            else if (f > d) {
                            for (f += 1; f < e.length; f++) e[f][2] = !0;
                            for (f = 0; f < d; f++) e[f][2] = !0
                        }
                        b = (b + 1) % c
                    } while (0 !== b)
                }
                c = e[0];
                b = e[e.length - 1];
                c[2] && (b[2] = !0, n.some(a, function(a) {
                    return 1 === a[1] ? (e.splice(e.length - 1, 0, y.clone(e[1])), !0) : !1
                }));
                e = n.filter(e, function(a) {
                    return a[2] ? !1 : !0
                });
                for (b = 0; b < e.length - 1; b++)
                    if (c = e[b], (d = e[b + 1]) && !(c[0] !== d[0] || c[1] !== d[1])) d.outIn ? c.outIn = !0 : d.inOut && (c.inOut = !0), e.splice(b + 1, 1);
                c = Math.abs;
                a = [];
                for (b = 0; b < e.length - 1; b++) {
                    h = e[b];
                    f = h[0];
                    h = h[1];
                    s = c(f) === g;
                    r = c(h) === g;
                    d = e[b + 1];
                    z = d[0];
                    d = d[1];
                    var A = c(z) === g,
                        B = c(d) === g;
                    s && B ? a.push([b + 1, [f, d]]) : r && A && a.push([b + 1, [z, h]])
                }
                for (b = a.length - 1; 0 <= b; b--) d = a[b], f = e[d[0] - 1], c = e[d[0]], !f.outIn && (!f.inOut && !c.outIn && !c.inOut) && e.splice(d[0], 0, d[1]);
                c = e[0];
                b = e[e.length - 1];
                (c[0] !== b[0] || c[1] !== b[1]) && e.push(c);
                return e
            }), a.setShape(this._getPathStringFromPaths(c))
        },
        _getCorners: function(a, b) {
            if (t) {
                var c = this._map,
                    e = b.getExtent(),
                    d = e.spatialReference,
                    g = c.toScreen(new P(e.xmin, e.ymax, d)),
                    c = c.toScreen(new P(e.xmax, e.ymin, d));
                return {
                    tl: g,
                    br: c
                }
            }
            g = a.getTransformedBoundingBox();
            return {
                tl: g[0],
                br: g[2]
            }
        },
        _createSegments: function(a) {
            a.shape.path = a.vmlPath;
            a.segmented = !1;
            a._confirmSegmented();
            var b = a.segments;
            1 < b.length && (a.segments = n.filter(b, function(a, b, d) {
                b = d[b + 1];
                return "M" === a.action && b && "L" === b.action ? (a.args = a.args.concat(b.args), !0) : !1
            }))
        },
        _getPathStringFromPaths: function(a) {
            t ? (a = n.map(a, function(a) {
                return "m " + n.map(a, function(a, b) {
                    return (1 === b ? "l " : "") + a.join(",")
                }).join(" ")
            }), a.push("e")) : a = n.map(a, function(a) {
                return "M " + n.map(a, function(a) {
                    return a.join(",")
                }).join(" ")
            });
            return a.join(" ")
        },
        _isPointWithinBBox: function(a, b) {
            var c = b[1],
                e = b[2],
                d = b[3],
                g = a[0],
                f = a[1];
            return g > b[0] && g < e && f > c && f < d ? !0 : !1
        },
        _isPointWithinRange: function(a, b, c) {
            var e = a.x;
            a = a.y;
            return e < b || a < b || e > c || a > c ? !1 : !0
        },
        _getClipperIntersection: function(a, b, c) {
            var e, d = Q._getLineIntersection2,
                g = Math.round,
                f = {
                    length: 0
                };
            for (e = 0; 4 > e; e++) {
                var h = d(a, b[e]);
                if (h)
                    if (h[0] = g(h[0]), h[1] = g(h[1]), c) f[e] = h, f.length++;
                    else return [e, h]
            }
            return c ? f : null
        },
        _getPlaneIndex: function(a, b) {
            var c = a[0],
                e = a[1],
                d = b[0],
                g = b[1],
                f = b[2],
                h = b[3];
            return c <= d ? e >=
                g && e <= h ? 3 : e < g ? [0, 3] : [2, 3] : e <= g ? c >= d && c <= f ? 0 : c < d ? [3, 0] : [1, 0] : c >= f ? e >= g && e <= h ? 1 : e < g ? [0, 1] : [2, 1] : e >= h ? c >= d && c <= f ? 2 : c < d ? [3, 2] : [1, 2] : -1
        },
        onGraphicAdd: function() {},
        onGraphicRemove: function() {},
        onGraphicNodeAdd: function() {},
        onGraphicNodeRemove: function() {},
        onGraphicDraw: function() {},
        onGraphicsClear: function() {},
        onRendererChange: function() {},
        onOpacityChange: function() {},
        setInfoTemplate: function(a) {
            this.infoTemplate = a
        },
        add: function(a, b) {
            if (a._graphicsLayer === this) return a;
            b || this.graphics.push(a);
            a._graphicsLayer =
                this;
            a._layer = this;
            this._updateExtent(a);
            this._draw(a);
            if (!b) this.onGraphicAdd(a);
            return a
        },
        remove: function(a, b) {
            if (!b) {
                var c;
                if (-1 === (c = n.indexOf(this.graphics, a))) return null;
                a = this.graphics.splice(c, 1)[0]
            }
            a.getDojoShape() && this._removeShape(a);
            a._shape = a._graphicsLayer = null;
            this.onGraphicRemove(a);
            return a
        },
        clear: function(a, b) {
            for (var c = this.graphics; 0 < c.length;) this.remove(c[0]);
            if (!b) this.onGraphicsClear()
        },
        _setIEOpacity: function(a, b) {
            var c = a && a.getNode();
            if (c) {
                var e = a.strokeStyle,
                    d = c.stroke;
                e && d && (d.opacity = e.color.a * b);
                e = a.fillStyle;
                d = c.fill;
                e && d && ("tile" === d.type ? G.set(c, "opacity", b) : d.opacity = e.a * b)
            }
        },
        setOpacity: function(a, b) {
            if (b || this.opacity != a) {
                var c = this._div;
                c && (t ? (n.forEach(this.graphics, function(b) {
                    this._setIEOpacity(b._shape, a);
                    this._setIEOpacity(b._bgShape, a)
                }, this), c._esriIeOpacity = a, this._bgGroup._esriIeOpacity = a) : this._canvas ? G.set(c.getEventSource(), "opacity", a) : c.getEventSource().setAttribute("opacity", a));
                this.opacity = a;
                if (!b) this.onOpacityChange(a)
            }
        },
        setRenderer: function(a) {
            this.renderer =
                a;
            this._evalSDRenderer(!0);
            this.emit("renderer-change", {
                renderer: this._rndForScale || a
            })
        }
    });
    x = x([L, W], {
        declaredClass: "esri.layers.GraphicsLayer",
        constructor: function() {
            this.enableMouseEvents = y.hitch(this, this.enableMouseEvents);
            this.disableMouseEvents = y.hitch(this, this.disableMouseEvents);
            this._processEvent = y.hitch(this, this._processEvent);
            this._initLayer()
        },
        _initLayer: function() {
            this.loaded = !0;
            this.onLoad(this)
        },
        _setMap: function() {
            var a = this.inherited("_setMap", arguments);
            this.enableMouseEvents();
            return a
        },
        _unsetMap: function() {
            this.disableMouseEvents();
            this.inherited("_unsetMap", arguments)
        },
        _processEvent: function(a) {
            var b = this._map,
                c = a.target,
                e;
            a.screenPoint = new J(a.pageX - b.position.x, a.pageY - b.position.y);
            for (a.mapPoint = b.toMap(a.screenPoint); c && !(e = c.e_graphic);) c = c.parentNode;
            if (e) return a.graphic = e, a
        },
        _onMouseOverHandler: function(a) {
            if (this._processEvent(a)) this.onMouseOver(a)
        },
        _onMouseMoveHandler: function(a) {
            if (this._processEvent(a)) this.onMouseMove(a)
        },
        _onMouseDragHandler: function(a) {
            if (this._processEvent(a)) this.onMouseDrag(a)
        },
        _onMouseOutHandler: function(a) {
            if (this._processEvent(a)) this.onMouseOut(a)
        },
        _onMouseDownHandler: function(a) {
            this._downGr = this._downPt = null;
            this._processEvent(a) && (v.disconnect(this._onmousemove_connect), v.disconnect(this._onmousedrag_connect), this._onmousedrag_connect = v.connect(this._div.getEventSource(), "onmousemove", this, "_onMouseDragHandler"), this._downGr = a.graphic, this._downPt = a.screenPoint.x + "," + a.screenPoint.y, this.onMouseDown(a))
        },
        _onMouseUpHandler: function(a) {
            this._upGr = this._upPt = null;
            this._processEvent(a) &&
                (v.disconnect(this._onmousedrag_connect), v.disconnect(this._onmousemove_connect), this._onmousemove_connect = v.connect(this._div.getEventSource(), "onmousemove", this, "_onMouseMoveHandler"), this._upGr = a.graphic, this._upPt = a.screenPoint.x + "," + a.screenPoint.y, this.onMouseUp(a))
        },
        _onClickHandler: function(a) {
            if (this._processEvent(a)) {
                var b = this._downGr,
                    c = this._upGr;
                b && (c && b === c && this._downPt === this._upPt) && (t && (T._ieGraphic = a.graphic), this.onClick(a))
            }
        },
        _onDblClickHandler: function(a) {
            if (this._processEvent(a)) this.onDblClick(a)
        },
        onMouseOver: function() {},
        onMouseMove: function() {},
        onMouseDrag: function() {},
        onMouseOut: function() {},
        onMouseDown: function() {},
        onMouseUp: function() {},
        onClick: function() {},
        onDblClick: function() {},
        enableMouseEvents: function() {
            if (!this._mouseEvents) {
                var a = v.connect,
                    b = this._div.getEventSource();
                E || (this._onmouseover_connect = a(b, "onmouseover", this, "_onMouseOverHandler"), this._onmousemove_connect = a(b, "onmousemove", this, "_onMouseMoveHandler"), this._onmouseout_connect = a(b, "onmouseout", this, "_onMouseOutHandler"),
                    this._onmousedown_connect = a(b, "onmousedown", this, "_onMouseDownHandler"), this._onmouseup_connect = a(b, "onmouseup", this, "_onMouseUpHandler"), this._onclick_connect = a(b, "onclick", this, "_onClickHandler"), this._ondblclick_connect = a(b, "ondblclick", this, "_onDblClickHandler"));
                this._mouseEvents = !0
            }
        },
        disableMouseEvents: function() {
            if (this._mouseEvents) {
                var a = v.disconnect;
                a(this._onmouseover_connect);
                a(this._onmousemove_connect);
                a(this._onmousedrag_connect);
                a(this._onmouseout_connect);
                a(this._onmousedown_connect);
                a(this._onmouseup_connect);
                a(this._onclick_connect);
                a(this._ondblclick_connect);
                this._mouseEvents = !1
            }
        }
    });
    x._GraphicsContainer = X;
    x._GraphicsLayer = L;
    return x
});
},
'dojox/gfx':function(){
define(["dojo/_base/lang", "./gfx/_base", "./gfx/renderer!"], 
  function(lang, gfxBase, renderer){
	// module:
	//		dojox/gfx
	// summary:
	//		This the root of the Dojo Graphics package
	gfxBase.switchTo(renderer);
	return gfxBase;
});

},
'dojox/gfx/renderer':function(){
define(["./_base","dojo/_base/lang", "dojo/_base/sniff", "dojo/_base/window", "dojo/_base/config"],
  function(g, lang, has, win, config){
  //>> noBuildResolver
	var currentRenderer = null;

	has.add("vml", function(global, document, element){
		element.innerHTML = "<v:shape adj=\"1\"/>";
		var supported = ("adj" in element.firstChild);
		element.innerHTML = "";
		return supported;
	});

	return {
		// summary:
		//		This module is an AMD loader plugin that loads the appropriate graphics renderer
		//		implementation based on detected environment and current configuration settings.
		
		load: function(id, require, load){
			// tags:
			//      private
			if(currentRenderer && id != "force"){
				load(currentRenderer);
				return;
			}
			var renderer = config.forceGfxRenderer,
				renderers = !renderer && (lang.isString(config.gfxRenderer) ?
					config.gfxRenderer : "svg,vml,canvas,silverlight").split(","),
				silverlightObject, silverlightFlag;

			while(!renderer && renderers.length){
				switch(renderers.shift()){
					case "svg":
						// the next test is from https://github.com/phiggins42/has.js
						if("SVGAngle" in win.global){
							renderer = "svg";
						}
						break;
					case "vml":
						if(has("vml")){
							renderer = "vml";
						}
						break;
					case "silverlight":
						try{
							if(has("ie")){
								silverlightObject = new ActiveXObject("AgControl.AgControl");
								if(silverlightObject && silverlightObject.IsVersionSupported("1.0")){
									silverlightFlag = true;
								}
							}else{
								if(navigator.plugins["Silverlight Plug-In"]){
									silverlightFlag = true;
								}
							}
						}catch(e){
							silverlightFlag = false;
						}finally{
							silverlightObject = null;
						}
						if(silverlightFlag){
							renderer = "silverlight";
						}
						break;
					case "canvas":
						if(win.global.CanvasRenderingContext2D){
							renderer = "canvas";
						}
						break;
				}
			}

			if (renderer === 'canvas' && config.canvasEvents !== false) {
				renderer = "canvasWithEvents";
			}

			if(config.isDebug){
				console.log("gfx renderer = " + renderer);
			}

			function loadRenderer(){
				require(["dojox/gfx/" + renderer], function(module){
					g.renderer = renderer;
					// memorize the renderer module
					currentRenderer = module;
					// now load it
					load(module);
				});
			}
			if(renderer == "svg" && typeof window.svgweb != "undefined"){
				window.svgweb.addOnLoad(loadRenderer);
			}else{
				loadRenderer();
			}
		}
	};
});

},
'esri/layers/layer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/config", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/_base/json", "dojo/has", "../Evented", "../kernel", "../lang", "../request", "../deferredUtils", "../urlUtils", "../SpatialReference", "../geometry/Extent"], function(m, n, d, f, p, q, w, r, h, c, s, t, u, k, v) {
    var l = m([r], {
        declaredClass: "esri.layers.Layer",
        _eventMap: {
            error: ["error"],
            load: ["layer"],
            "opacity-change": ["opacity"],
            "update-end": ["error"],
            "visibility-change": ["visible"]
        },
        constructor: function(a, b) {
            if (a && f.isString(a)) this._url =
                u.urlToObject(this.url = a);
            else if (this.url = this._url = null, (b = b || a) && (b.layerDefinition || b.query)) b = null;
            this.spatialReference = new k(4326);
            this.initialExtent = new v(-180, -90, 180, 90, new k(4326));
            this._map = this._div = null;
            this.normalization = !0;
            b && (b.id && (this.id = b.id), !1 === b.visible && (this.visible = !1), c.isDefined(b.opacity) && (this.opacity = b.opacity), c.isDefined(b.minScale) && this.setMinScale(b.minScale), c.isDefined(b.maxScale) && this.setMaxScale(b.maxScale), this.attributionDataUrl = b.attributionDataUrl ||
                "", this.hasAttributionData = !!this.attributionDataUrl, c.isDefined(b.showAttribution) && (this.showAttribution = b.showAttribution), this.className = b.className, this.refreshInterval = b.refreshInterval || 0);
            this._errorHandler = f.hitch(this, this._errorHandler);
            this.refresh = f.hitch(this, this.refresh);
            if (this.managedSuspension) {
                var e = this._setMap;
                this._setMap = function(a) {
                    var b = e.apply(this, arguments);
                    this.evaluateSuspension();
                    if (this.suspended && !a.loaded) var c = d.connect(a, "onLoad", this, function() {
                        d.disconnect(c);
                        c = null;
                        this.evaluateSuspension()
                    });
                    return b
                }
            }
            this.registerConnectEvents()
        },
        id: null,
        visible: !0,
        opacity: 1,
        loaded: !1,
        loadError: null,
        minScale: 0,
        maxScale: 0,
        visibleAtMapScale: !1,
        suspended: !0,
        attributionDataUrl: "",
        hasAttributionData: !1,
        showAttribution: !0,
        refreshInterval: 0,
        _errorHandler: function(a) {
            this.loaded || (this.loadError = a);
            this.onError(a)
        },
        _setMap: function(a, b, e, g) {
            this._map = a;
            this._lyrZEHandle = d.connect(a, "onZoomEnd", this, this._processMapScale);
            if (a.loaded) this.visibleAtMapScale = this._isMapAtVisibleScale();
            else var c = d.connect(a, "onLoad", this, function() {
                d.disconnect(c);
                c = null;
                this._processMapScale()
            })
        },
        _unsetMap: function(a, b) {
            d.disconnect(this._lyrZEHandle);
            this._toggleRT();
            this._map = this._lyrZEHandle = null;
            this.suspended = !0
        },
        _cleanUp: function() {
            this._map = this._div = null
        },
        _fireUpdateStart: function() {
            this.updating || (this.updating = !0, this.attr("data-updating", ""), this._toggleRT(), this.onUpdateStart(), this._map && this._map._incr())
        },
        _fireUpdateEnd: function(a, b) {
            this.updating && (this.updating = !1, this.attr("data-updating"),
                this._toggleRT(!0), this.onUpdateEnd(a, b), this._map && this._map._decr())
        },
        _getToken: function() {
            var a = this._url,
                b = this.credential;
            return a && a.query && a.query.token || b && b.token || void 0
        },
        _findCredential: function() {
            this.credential = h.id && this._url && h.id.findCredential(this._url.path)
        },
        _useSSL: function() {
            var a = this._url,
                b = /^http:/i;
            this.url && (this.url = this.url.replace(b, "https:"));
            a && a.path && (a.path = a.path.replace(b, "https:"))
        },
        refresh: function() {},
        show: function() {
            this.setVisibility(!0)
        },
        hide: function() {
            this.setVisibility(!1)
        },
        setMinScale: function(a) {
            this.setScaleRange(a)
        },
        setMaxScale: function(a) {
            this.setScaleRange(null, a)
        },
        setScaleRange: function(a, b) {
            var e = c.isDefined(a),
                g = c.isDefined(b);
            this.loaded || (this._hasMin = this._hasMin || e, this._hasMax = this._hasMax || g);
            var d = this.minScale,
                f = this.maxScale;
            this.minScale = (e ? a : this.minScale) || 0;
            this.maxScale = (g ? b : this.maxScale) || 0;
            if (d !== this.minScale || f !== this.maxScale) this.onScaleRangeChange(), this._processMapScale()
        },
        suspend: function() {
            this._suspended = !0;
            this.evaluateSuspension()
        },
        resume: function() {
            this._suspended = !1;
            this.evaluateSuspension()
        },
        canResume: function() {
            return this.loaded && this._map && this._map.loaded && this.visible && this.visibleAtMapScale && !this._suspended
        },
        evaluateSuspension: function() {
            this.canResume() ? this.suspended && this._resume() : this.suspended || this._suspend()
        },
        _suspend: function() {
            this.suspended = !0;
            this.attr("data-suspended", "");
            this._toggleRT();
            this.onSuspend();
            if (this._map) this._map.onLayerSuspend(this)
        },
        _resume: function() {
            this.suspended = !1;
            this.attr("data-suspended");
            var a = void 0 === this._resumedOnce,
                b = this.className,
                e = this.getNode();
            if (a && (this._resumedOnce = !0, b && e)) {
                var c = e.getAttribute("class") || "";
                RegExp("(^|\\s)" + b + "(\\s|$)", "i").test(c) || e.setAttribute("class", c + ((c ? " " : "") + b))
            }
            this._toggleRT(!0);
            this.onResume({
                firstOccurrence: a
            });
            if (this._map) this._map.onLayerResume(this)
        },
        _processMapScale: function() {
            var a = this.visibleAtMapScale;
            this.visibleAtMapScale = this._isMapAtVisibleScale();
            a !== this.visibleAtMapScale && (this.onScaleVisibilityChange(), this.evaluateSuspension())
        },
        isVisibleAtScale: function(a) {
            return a ? l.prototype._isMapAtVisibleScale.apply(this, arguments) : !1
        },
        _isMapAtVisibleScale: function(a) {
            if (!a && (!this._map || !this._map.loaded)) return !1;
            a = a || this._map.getScale();
            var b = this.minScale,
                e = this.maxScale,
                c = !b,
                d = !e;
            !c && a <= b && (c = !0);
            !d && a >= e && (d = !0);
            return c && d
        },
        getAttributionData: function() {
            var a = this.attributionDataUrl,
                b = new p(t._dfdCanceller);
            this.hasAttributionData && a ? (b._pendingDfd = s({
                url: a,
                content: {
                    f: "json"
                },
                handleAs: "json",
                callbackParamName: "callback"
            }), b._pendingDfd.then(function(a) {
                    b.callback(a)
                },
                function(a) {
                    b.errback(a)
                })) : (a = Error("Layer does not have attribution data"), a.log = n.isDebug, b.errback(a));
            return b
        },
        getResourceInfo: function() {
            var a = this.resourceInfo;
            return f.isString(a) ? q.fromJson(a) : f.clone(a)
        },
        getMap: function() {
            return this._map
        },
        getNode: function() {
            return this._div
        },
        attr: function(a, b) {
            var c = this.getNode();
            c && (null == b ? c.removeAttribute(a) : c.setAttribute(a, b));
            return this
        },
        setRefreshInterval: function(a) {
            var b = this.refreshInterval;
            this.refreshInterval = a;
            this._toggleRT();
            a && !this.updating &&
                !this.suspended && this._toggleRT(!0);
            if (b !== a) this.onRefreshIntervalChange();
            return this
        },
        _toggleRT: function(a) {
            a && this.refreshInterval ? (clearTimeout(this._refreshT), this._refreshT = setTimeout(this.refresh, 6E4 * this.refreshInterval)) : this._refreshT && (clearTimeout(this._refreshT), this._refreshT = null)
        },
        setNormalization: function(a) {
            this.normalization = a
        },
        setVisibility: function(a) {
            this.visible !== a && (this.visible = a, this.onVisibilityChange(this.visible), this.evaluateSuspension());
            this.attr("data-hidden", a ?
                null : "")
        },
        onLoad: function() {},
        onVisibilityChange: function() {},
        onScaleRangeChange: function() {},
        onScaleVisibilityChange: function() {},
        onSuspend: function() {},
        onResume: function() {},
        onUpdate: function() {},
        onUpdateStart: function() {},
        onUpdateEnd: function() {},
        onRefreshIntervalChange: function() {},
        onError: function() {}
    });
    return l
});
},
'esri/Color':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/Color", "dojo/has", "./kernel"], function(b, e, c, d) {
    b = b([e], {
        declaredClass: "esri.Color"
    });
    b.toJsonColor = function(a) {
        return a && [a.r, a.g, a.b, 1 < a.a ? a.a : Math.round(255 * a.a)]
    };
    b.toDojoColor = function(a) {
        return a && new e([a[0], a[1], a[2], a[3] / 255])
    };
    d = "named blendColors fromRgb fromHex fromArray fromString".split(" ");
    for (c = 0; c < d.length; c++) b[d[c]] = e[d[c]];
    return b
});
},
'esri/domUtils':function(){
//>>built
define(["dojo/_base/connect", "dojo/_base/lang", "dojo/dom-style", "dojo/has", "./kernel"], function(n, r, p, q, s) {
    return {
        show: function(a) {
            a && (a.style.display = "block")
        },
        hide: function(a) {
            a && (a.style.display = "none")
        },
        toggle: function(a) {
            a.style.display = "none" === a.style.display ? "block" : "none"
        },
        documentBox: 8 >= q("ie") ? {
            w: document.documentElement.clientWidth,
            h: document.documentElement.clientHeight
        } : {
            w: window.innerWidth,
            h: window.innerHeight
        },
        setScrollable: function(a) {
            var f = 0,
                g = 0,
                h = 0,
                k = 0,
                l = 0,
                m = 0;
            return [n.connect(a,
                "ontouchstart",
                function(d) {
                    f = d.touches[0].screenX;
                    g = d.touches[0].screenY;
                    h = a.scrollWidth;
                    k = a.scrollHeight;
                    l = a.clientWidth;
                    m = a.clientHeight
                }), n.connect(a, "ontouchmove", function(d) {
                d.preventDefault();
                var e = a.firstChild;
                e instanceof Text && (e = a.childNodes[1]);
                var b = e._currentX || 0,
                    c = e._currentY || 0,
                    b = b + (d.touches[0].screenX - f);
                0 < b ? b = 0 : 0 > b && Math.abs(b) + l > h && (b = -1 * (h - l));
                e._currentX = b;
                c += d.touches[0].screenY - g;
                0 < c ? c = 0 : 0 > c && Math.abs(c) + m > k && (c = -1 * (k - m));
                e._currentY = c;
                p.set(e, {
                    "-webkit-transition-property": "-webkit-transform",
                    "-webkit-transform": "translate(" + b + "px, " + c + "px)"
                });
                f = d.touches[0].screenX;
                g = d.touches[0].screenY
            })]
        }
    }
});
},
'esri/symbols/MarkerSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "./Symbol"], function(f, e, h, b, k, g) {
    return f(g, {
        declaredClass: "esri.symbol.MarkerSymbol",
        angle: 0,
        xoffset: 0,
        yoffset: 0,
        size: 12,
        constructor: function(a) {
            a && e.isObject(a) && (this.size = "auto" === this.size ? this.size : b.pt2px(this.size), this.xoffset = b.pt2px(this.xoffset), this.yoffset = b.pt2px(this.yoffset), this.angle && (this.angle *= -1))
        },
        setAngle: function(a) {
            this.angle = a;
            return this
        },
        setSize: function(a) {
            this.size = a;
            return this
        },
        setOffset: function(a, b) {
            this.xoffset = a;
            this.yoffset = b;
            return this
        },
        toJson: function() {
            var a = b.px2pt(this.size),
                a = isNaN(a) ? void 0 : a,
                c = b.px2pt(this.xoffset),
                c = isNaN(c) ? void 0 : c,
                d = b.px2pt(this.yoffset),
                d = isNaN(d) ? void 0 : d;
            return e.mixin(this.inherited("toJson", arguments), {
                size: "auto" === this.size ? this.size : a,
                angle: this.angle && -1 * this.angle,
                xoffset: c,
                yoffset: d
            })
        }
    })
});
},
'esri/symbols/Symbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../Color"], function(d, c, f, g, e, b) {
    return d(null, {
        declaredClass: "esri.symbol.Symbol",
        color: new b([0, 0, 0, 1]),
        type: null,
        constructor: function(a) {
            if (a && c.isObject(a) && (c.mixin(this, a), this.color && e.isDefined(this.color[0]) && (this.color = b.toDojoColor(this.color)), (a = this.type) && 0 === a.indexOf("esri"))) this.type = {
                esriSMS: "simplemarkersymbol",
                esriPMS: "picturemarkersymbol",
                esriSLS: "simplelinesymbol",
                esriCLS: "cartographiclinesymbol",
                esriSFS: "simplefillsymbol",
                esriPFS: "picturefillsymbol",
                esriTS: "textsymbol",
                esriSHD: "shieldlabelsymbol"
            }[a]
        },
        setColor: function(a) {
            this.color = a;
            return this
        },
        toJson: function() {
            return {
                color: b.toJsonColor(this.color)
            }
        }
    })
});
},
'esri/symbols/SimpleMarkerSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Color", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "./MarkerSymbol", "./SimpleLineSymbol"], function(d, m, s, u, p, v, q, t, r) {
    var e = {
            STYLE_CIRCLE: "circle",
            STYLE_SQUARE: "square",
            STYLE_CROSS: "cross",
            STYLE_X: "x",
            STYLE_DIAMOND: "diamond",
            STYLE_PATH: "path",
            STYLE_TARGET: "target"
        },
        n = {
            style: e.STYLE_CIRCLE,
            color: [255, 255, 255, 0.25],
            size: 12,
            angle: 0,
            xoffset: 0,
            yoffset: 0
        };
    d = d(t, {
        declaredClass: "esri.symbol.SimpleMarkerSymbol",
        type: "simplemarkersymbol",
        _styles: {
            circle: "esriSMSCircle",
            square: "esriSMSSquare",
            cross: "esriSMSCross",
            x: "esriSMSX",
            diamond: "esriSMSDiamond",
            path: "esriSMSPath"
        },
        constructor: function(a, b, c, d) {
            a ? m.isString(a) ? (this.style = a, b && (this.size = b), c && (this.outline = c), d && (this.color = d)) : (this.style = q.valueOf(this._styles, this.style), a.outline && (this.outline = new r(a.outline))) : (m.mixin(this, n), this.size = p.pt2px(this.size), this.outline = new r(this.outline), this.color = new s(this.color));
            this.style || (this.style = e.STYLE_CIRCLE)
        },
        setStyle: function(a) {
            this.style = a;
            return this
        },
        setPath: function(a) {
            this.path = a;
            this.setStyle(e.STYLE_PATH);
            return this
        },
        setOutline: function(a) {
            this.outline = a;
            return this
        },
        getStroke: function() {
            return this.outline && this.outline.getStroke()
        },
        getFill: function() {
            return this.color
        },
        _setDim: function(a, b, c) {
            this._targetWidth = a;
            this._targetHeight = b;
            this._spikeSize = c
        },
        getShapeDescriptors: function() {
            var a, b, c, d = this.style,
                l = (this.size || p.pt2px(n.size)) / 2,
                f = 0 - l,
                h = 0 + l,
                k = 0 - l,
                g = 0 + l;
            switch (d) {
                case e.STYLE_CIRCLE:
                    a = {
                        type: "circle",
                        cx: 0,
                        cy: 0,
                        r: l
                    };
                    b = this.getFill();
                    if (c = this.getStroke()) c.style = c.style || "Solid";
                    break;
                case e.STYLE_CROSS:
                    a = {
                        type: "path",
                        path: "M " + f + ",0 L " + h + ",0 M 0," + k + " L 0," + g + " E"
                    };
                    b = null;
                    c = this.getStroke();
                    break;
                case e.STYLE_DIAMOND:
                    a = {
                        type: "path",
                        path: "M " + f + ",0 L 0," + k + " L " + h + ",0 L 0," + g + " L " + f + ",0 E"
                    };
                    b = this.getFill();
                    c = this.getStroke();
                    break;
                case e.STYLE_SQUARE:
                    a = {
                        type: "path",
                        path: "M " + f + "," + g + " L " + f + "," + k + " L " + h + "," + k + " L " + h + "," + g + " L " + f + "," + g + " E"
                    };
                    b = this.getFill();
                    c = this.getStroke();
                    break;
                case e.STYLE_X:
                    a = {
                        type: "path",
                        path: "M " +
                            f + "," + g + " L " + h + "," + k + " M " + f + "," + k + " L " + h + "," + g + " E"
                    };
                    b = null;
                    c = this.getStroke();
                    break;
                case e.STYLE_PATH:
                    a = {
                        type: "path",
                        path: this.path || ""
                    }, b = this.getFill(), c = this.getStroke()
            }
            return {
                defaultShape: a,
                fill: b,
                stroke: c
            }
        },
        toJson: function() {
            var a = m.mixin(this.inherited("toJson", arguments), {
                    type: "esriSMS",
                    style: this._styles[this.style]
                }),
                b = this.outline;
            b && (a.outline = b.toJson());
            a.path = this.path;
            return q.fixJson(a)
        }
    });
    m.mixin(d, e);
    d.defaultProps = n;
    return d
});
},
'esri/symbols/SimpleLineSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Color", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "./LineSymbol"], function(a, b, h, m, k, n, e, l) {
    var c = {
            STYLE_SOLID: "solid",
            STYLE_DASH: "dash",
            STYLE_DOT: "dot",
            STYLE_DASHDOT: "dashdot",
            STYLE_DASHDOTDOT: "longdashdotdot",
            STYLE_NULL: "none",
            STYLE_SHORTDASH: "shortdash",
            STYLE_SHORTDOT: "shortdot",
            STYLE_SHORTDASHDOT: "shortdashdot",
            STYLE_SHORTDASHDOTDOT: "shortdashdotdot",
            STYLE_LONGDASH: "longdash",
            STYLE_LONGDASHDOT: "longdashdot"
        },
        f = {
            color: [0, 0, 0, 1],
            style: c.STYLE_SOLID,
            width: 1
        };
    a = a(l, {
        declaredClass: "esri.symbol.SimpleLineSymbol",
        type: "simplelinesymbol",
        _styles: {
            solid: "esriSLSSolid",
            dash: "esriSLSDash",
            dot: "esriSLSDot",
            dashdot: "esriSLSDashDot",
            longdashdotdot: "esriSLSDashDotDot",
            none: "esriSLSNull",
            insideframe: "esriSLSInsideFrame",
            shortdash: "esriSLSShortDash",
            shortdot: "esriSLSShortDot",
            shortdashdot: "esriSLSShortDashDot",
            shortdashdotdot: "esriSLSShortDashDotDot",
            longdash: "esriSLSLongDash",
            longdashdot: "esriSLSLongDashDot"
        },
        constructor: function(d, a, g) {
            d ? b.isString(d) ? (this.style =
                d, a && (this.color = a), g && (this.width = g)) : this.style = e.valueOf(this._styles, d.style) || c.STYLE_SOLID : (b.mixin(this, f), this.color = new h(this.color), this.width = k.pt2px(this.width))
        },
        setStyle: function(a) {
            this.style = a;
            return this
        },
        getStroke: function() {
            return this.style === c.STYLE_NULL || 0 === this.width ? null : {
                color: this.color,
                style: this.style,
                width: this.width
            }
        },
        getFill: function() {
            return null
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "path",
                    path: "M -15,0 L 15,0 E"
                },
                fill: null,
                stroke: this.getStroke()
            }
        },
        toJson: function() {
            return e.fixJson(b.mixin(this.inherited("toJson", arguments), {
                type: "esriSLS",
                style: this._styles[this.style]
            }))
        }
    });
    b.mixin(a, c);
    a.defaultProps = f;
    return a
});
},
'esri/symbols/LineSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "./Symbol"], function(d, b, f, c, g, e) {
    return d(e, {
        declaredClass: "esri.symbol.LineSymbol",
        constructor: function(a) {
            b.isObject(a) ? this.width = c.pt2px(this.width) : this.width = 12
        },
        setWidth: function(a) {
            this.width = a;
            return this
        },
        toJson: function() {
            var a = c.px2pt(this.width),
                a = isNaN(a) ? void 0 : a;
            return b.mixin(this.inherited("toJson", arguments), {
                width: a
            })
        }
    })
});
},
'esri/layers/TileInfo':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../lang", "../SpatialReference", "../geometry/Point", "./LOD"], function(e, f, c, l, m, g, d, h, k) {
    return e(null, {
        declaredClass: "esri.layers.TileInfo",
        constructor: function(a) {
            f.mixin(this, a);
            this.width = this.cols;
            this.height = this.rows;
            a = this.spatialReference;
            var b = this.origin;
            a && (a = this.spatialReference = new d(a.toJson ? a.toJson() : a));
            b && (this.origin = new h(b.toJson ? b.toJson() : b), !b.spatialReference && a && this.origin.setSpatialReference(new d(a.toJson())));
            this.lods = c.map(this.lods, function(a) {
                return new k(a)
            })
        },
        toJson: function() {
            return g.fixJson({
                rows: this.rows,
                cols: this.cols,
                dpi: this.dpi,
                format: this.format,
                compressionQuality: this.compressionQuality,
                origin: this.origin && this.origin.toJson(),
                spatialReference: this.spatialReference && this.spatialReference.toJson(),
                lods: this.lods && c.map(this.lods, function(a) {
                    return a.toJson()
                })
            })
        }
    })
});
},
'esri/layers/LOD':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang"], function(a, b, d, e, c) {
    return a(null, {
        declaredClass: "esri.layers.LOD",
        constructor: function(a) {
            b.mixin(this, a)
        },
        toJson: function() {
            return c.fixJson({
                level: this.level,
                levelValue: this.levelValue,
                resolution: this.resolution,
                scale: this.scale
            })
        }
    })
});
},
'esri/layers/ArcGISTiledMapServiceLayer':function(){
//>>built
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/has", "dojo/io-query", "../kernel", "../urlUtils", "../SpatialReference", "./TiledMapServiceLayer", "./ArcGISMapServiceLayer", "./TileInfo", "./TimeInfo", "./TileMap"], function(l, m, e, n, p, x, h, y, k, q, r, s, t, u, v) {
    return m([r, s], {
        declaredClass: "esri.layers.ArcGISTiledMapServiceLayer",
        _agolAttrs: "Canvas/World_Dark_Gray_Base Canvas/World_Dark_Gray_Reference Canvas/World_Light_Gray_Base Canvas/World_Light_Gray_Reference Ocean/World_Ocean_Base Ocean/World_Ocean_Reference Ocean_Basemap Reference/World_Boundaries_and_Places Reference/World_Boundaries_and_Places_Alternate Reference/World_Transportation World_Imagery World_Street_Map World_Topo_Map".split(" "),
        constructor: function(a, b) {
            b && (b.roundrobin && (l.deprecated(this.declaredClass + " : Constructor option 'roundrobin' deprecated. Use option 'tileServers'."), b.tileServers = b.roundrobin), this._setTileServers(b.tileServers), this._loadCallback = b.loadCallback);
            this._params = e.mixin({}, this._url.query);
            if (n.some(["servicesdev.arcgisonline.com/arcgis/rest/services", "services.arcgisonline.com/arcgis/rest/services", "servicesqa.arcgisonline.com/arcgis/rest/services"], function(b) {
                    return -1 < a.toLowerCase().indexOf(b.toLowerCase())
                })) {
                if (this.resampling = !(b && !1 === b.resampling)) this.tileMap = new v(this)
            } else this.resampling = b && null != b.resampling ? b.resampling : void 0;
            this._initLayer = e.hitch(this, this._initLayer);
            var c = b && b.resourceInfo;
            c ? this._initLayer(c) : (this._load = e.hitch(this, this._load), this._load())
        },
        _TILE_FORMATS: {
            PNG: "png",
            PNG8: "png",
            PNG24: "png",
            PNG32: "png",
            JPG: "jpg",
            JPEG: "jpg",
            GIF: "gif"
        },
        _setTileServers: function(a) {
            if (a && 0 < a.length) {
                this.tileServers = a;
                var b, c = a.length;
                for (b = 0; b < c; b++) a[b] = k.urlToObject(a[b]).path
            }
        },
        _initLayer: function(a, b) {
            this.inherited(arguments);
            this.resourceInfo = p.toJson(a);
            this.tileInfo = new t(a.tileInfo);
            this.resampling = null == this.resampling ? !!a.resampling : this.resampling;
            !this.spatialReference && this.tileInfo.spatialReference && (this.spatialReference = new q(this.tileInfo.spatialReference.toJson()));
            this.isPNG32 = "PNG24" === this.tileInfo.format || "PNG32" === this.tileInfo.format;
            a.timeInfo && (this.timeInfo = new u(a.timeInfo));
            var c = this._url.path,
                f = this._loadCallback,
                w = "file:" === window.location.protocol ? "http:" : window.location.protocol,
                d = c.match(/^https?\:\/\/(server|services)\.arcgisonline\.com\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/mapserver/i),
                d = d && d[2];
            if (!this.tileServers)
                if (a.tileServers) this._setTileServers(a.tileServers);
                else {
                    var g = -1 !== c.search(/^https?\:\/\/server\.arcgisonline\.com/i),
                        e = -1 !== c.search(/^https?\:\/\/services\.arcgisonline\.com/i);
                    if (g || e) this._setTileServers([c, c.replace(g ? /server\.arcgisonline/i : /services\.arcgisonline/i, g ? "services.arcgisonline" : "server.arcgisonline")])
                }
            if (d) {
                d = d.toLowerCase();
                for (c = 0; c < this._agolAttrs.length; c++)
                    if (g = this._agolAttrs[c], g.toLowerCase() === d) {
                        this.hasAttributionData = !0;
                        this.attributionDataUrl =
                            this.attributionDataUrl || w + "//static.arcgis.com/attribution/" + g;
                        break
                    }
            }
            this.loaded = !0;
            this.onLoad(this);
            f && (delete this._loadCallback, f(this))
        },
        getTileUrl: function(a, b, c) {
            var f = this.tileServers,
                e = this._getToken(),
                d = this._url.query;
            a = (f ? f[b % f.length] : this._url.path) + "/tile/" + a + "/" + b + "/" + c;
            this.resampling && !this.tileMap && (a += "?blankTile\x3dfalse");
            d && (a = this.resampling && !this.tileMap ? a + ("\x26" + h.objectToQuery(d)) : a + ("?" + h.objectToQuery(d)));
            if (e && (!d || !d.token)) a += (-1 === a.indexOf("?") ? "?" : "\x26") + "token\x3d" +
                e;
            a = this.addTimestampToURL(a);
            return k.addProxy(a)
        }
    })
});
},
'esri/layers/TiledMapServiceLayer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/url", "dojo/dom-construct", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojox/collections/ArrayList", "dojox/gfx/matrix", "../kernel", "../config", "../sniff", "../domUtils", "../tileUtils", "../geometry/Point", "../geometry/Rect", "../geometry/Extent", "./layer"], function(P, s, E, A, J, q, K, L, m, M, N, v, Q, x, O, F, z, B, R, S) {
    var C = Q.defaults.map.zoomDuration;
    return P(S, {
        declaredClass: "esri.layers.TiledMapServiceLayer",
        constructor: function(a,
            c) {
            s.connect(this, "onLoad", this, "_initTiledLayer");
            this._lowestLevel = (this._displayLevels = c ? c.displayLevels : null) ? this._displayLevels[0] : 0;
            this.resampling = c ? c.resampling : void 0;
            this._resamplingTolerance = c ? c.resamplingTolerance : null;
            this.exclusionAreas = c ? c.exclusionAreas : null;
            var d = E.hitch;
            this._addImage = d(this, this._addImage);
            this._tileLoadHandler = d(this, this._tileLoadHandler);
            this._tileErrorHandler = d(this, this._tileErrorHandler);
            this._tilePopPop = d(this, this._tilePopPop);
            this._cleanUpRemovedImages =
                d(this, this._cleanUpRemovedImages);
            this._fireOnUpdateEvent = d(this, this._fireOnUpdateEvent);
            this._transitionEnd = d(this, this._transitionEnd);
            this._tileMapCallback = d(this, this._tileMapCallback)
        },
        opacity: 1,
        isPNG32: !1,
        _multiple: 1,
        _initTiledLayer: function() {
            var a = this.tileInfo,
                c = a.lods;
            this.resampling = null != this.resampling ? this.resampling : !1;
            this._tileW = a.width;
            this._tileH = a.height;
            var d = this.scales = [],
                b = this._displayLevels,
                e = "esri.layers.WMTSLayer" === this.declaredClass && 96 != a.dpi,
                f = -Infinity,
                h = Infinity,
                g = this.fullExtent,
                m = new z(g.xmin, g.ymax),
                g = new z(g.xmax, g.ymin),
                l = F.getContainingTileCoords,
                k, p, r, q = c.length;
            for (r = 0; r < q; r++)
                if (p = c[r], e && (p.scale = 96 * p.scale / a.dpi), k = l(a, m, p), p.startTileRow = 0 > k.row ? 0 : k.row, p.startTileCol = 0 > k.col ? 0 : k.col, k = l(a, g, p), p.endTileRow = k.row, p.endTileCol = k.col, !b || -1 !== A.indexOf(b, p.level)) d[r] = p.scale, f = p.scale > f ? p.scale : f, h = p.scale < h ? p.scale : h;
            e && (a.dpi = 96); - Infinity !== f && !this._hasMin && this.setMinScale(f);
            Infinity !== h && !this._hasMax && this.setMaxScale(h);
            this.setExclusionAreas(this.exclusionAreas);
            this._patchIE = 6 <= x("ie") && 7 > x("ie") && (this.isPNG32 || "Mixed" === a.format)
        },
        _isMapAtVisibleScale: function() {
            var a = this.inherited(arguments);
            if (a) {
                var c;
                c = this._map;
                var a = this.scales,
                    d = c.getScale(),
                    b = !1,
                    e = c.width > c.height ? c.width : c.height;
                for (c = 0; c < a.length; c++)
                    if (Math.abs(a[c] - d) / a[c] < 1 / e) {
                        b = !0;
                        break
                    }
                a = b
            }
            return a
        },
        _setMap: function(a, c, d, b) {
            this.inherited(arguments);
            this._map = a;
            var e = this._div = q.create("div", null, c),
                f = a.__visibleDelta,
                h = s.connect,
                g = v._css.names,
                u = {
                    position: "absolute",
                    width: a.width + "px",
                    height: a.height + "px",
                    overflow: "visible"
                };
            "css-transforms" === a.navigationMode ? (u[g.transform] = v._css.translate(-f.x, -f.y), m.set(e, u), delete u[g.transform], u[g.transition] = g.transformName + " " + C + "ms ease", m.set(this._active = q.create("div", null, e), u), this._active._remove = 0, this._passives = []) : (u.left = -f.x + "px", u.top = -f.y + "px", m.set(e, u));
            this._onResizeHandler_connect = h(a, "onResize", this, "_onResizeHandler");
            this._opacityChangeHandler_connect = h(this, "onOpacityChange", this, "_opacityChangeHandler");
            f = this.tileInfo;
            h = f.spatialReference;
            g = h._getInfo();
            (this._wrap = a.wrapAround180 && h._isWrappable() && Math.abs(g.origin[0] - f.origin.x) <= g.dx) && F._addFrameInfo(f, g);
            this.setExclusionAreas(this.exclusionAreas);
            this.evaluateSuspension();
            if (this.suspended && !a.loaded) var l = s.connect(a, "onLoad", this, function() {
                s.disconnect(l);
                l = null;
                this.setExclusionAreas(this.exclusionAreas);
                this.evaluateSuspension()
            });
            return e
        },
        _unsetMap: function(a, c) {
            this.suspended || this._suspendImpl();
            q.destroy(this._div);
            this._map = this._div = null;
            var d =
                s.disconnect;
            d(this._onResizeHandler_connect);
            d(this._opacityChangeHandler_connect);
            this.inherited(arguments)
        },
        onSuspend: function() {
            this.inherited(arguments);
            this._suspendImpl()
        },
        _suspendImpl: function() {
            O.hide(this._div);
            clearTimeout(this._wakeTimer);
            this._wakeTimer = null;
            this._disableDrawConnectors();
            var a = this._tiles,
                c = this._tileIds,
                d = this._loadingList,
                b, e, f = s.disconnect,
                h = q.destroy;
            d && 0 < d.count && (d.forEach(function(c) {
                if (b = a[c]) f(b._onload_connect), f(b._onerror_connect), f(b._onabort_connect), b._onload_connect =
                    b._onerror_connect = b._onabort_connect = null
            }), d.clear(), this._fireUpdateEnd());
            this._removeList.clear();
            for (d = c.length - 1; 0 <= d; d--)(b = (e = c[d]) && a[e]) && h(b);
            if ("css-transforms" === this._map.navigationMode) {
                c = this._active;
                e = this._passives;
                var g;
                this._noDom = 0;
                for (d = e.length - 1; 0 <= d; d--) g = e[d], g._endHandle && f(g._endHandle), g._matrix = g._multiply = g._endHandle = null, g._marked = g._remove = 0, e.splice(d, 1), h(g);
                c._matrix = c._multiply = null;
                c._marked = c._remove = 0
            }
            this._tileIds = this._tiles = this._tileBounds = this._ct = this._loadingList =
                this._removeList = this._standby = null
        },
        onResume: function() {
            this.inherited(arguments);
            this._tileIds = [];
            this._tiles = [];
            this._tileBounds = [];
            this._ct = null;
            this._removeList = new M;
            this._loadingList = new M;
            O.show(this._div);
            this._enableDrawConnectors();
            this._wakeTimer = this._wakeTimer || setTimeout(E.hitch(this, function() {
                this.suspended || this._onExtentChangeHandler(this._map.extent, null, !0, this._map.__LOD)
            }), 0)
        },
        _enableDrawConnectors: function() {
            var a = this._map,
                c = s.connect;
            if ("css-transforms" === a.navigationMode) {
                if (this._onScaleHandler_connect =
                    c(a, "onScale", this, this._onScaleHandler), x("esri-touch") || x("esri-pointer")) {
                    this._standby = [];
                    var d = this,
                        b = function() {
                            d._noDom = 1
                        };
                    this._onPanStartHandler_connect = c(a, "onPanStart", b);
                    this._onZoomStartHandler_connect = c(a, "onZoomStart", b)
                }
            } else this._onZoomHandler_connect = c(a, "onZoom", this, "_onZoomHandler");
            this._onPanHandler_connect = c(a, "onPan", this, "_onPanHandler");
            this._onExtentChangeHandler_connect = c(a, "onExtentChange", this, "_onExtentChangeHandler")
        },
        _disableDrawConnectors: function() {
            var a = s.disconnect;
            a(this._onPanHandler_connect);
            a(this._onZoomHandler_connect);
            a(this._onScaleHandler_connect);
            a(this._onExtentChangeHandler_connect);
            a(this._onPanStartHandler_connect);
            a(this._onZoomStartHandler_connect);
            this._onPanHandler_connect = this._onZoomHandler_connect = this._onScaleHandler_connect = this._onExtentChangeHandler_connect = this._onPanStartHandler_connect = this._onZoomStartHandler_connect = null
        },
        _onResizeHandler: function(a, c, d) {
            a = {
                width: c + "px",
                height: d + "px"
            };
            c = m.set;
            c(this._div, a);
            if ("css-transforms" ===
                this._map.navigationMode) {
                this._active && c(this._active, a);
                for (d = this._passives.length - 1; 0 <= d; d--) c(this._passives[d], a)
            }
        },
        _onExtentChangeHandler: function(a, c, d, b) {
            c = this._map;
            var e = this._standby,
                f;
            clearTimeout(this._wakeTimer);
            this._wakeTimer = null;
            if (!c._isPanningOrZooming()) {
                if ("css-transforms" === c.navigationMode) {
                    if (d)
                        for (b = this._passives.length - 1; 0 <= b; b--) f = this._passives[b], m.set(f, v._css.names.transition, "none"), f._marked ? (this._passives.splice(b, 1), f.parentNode && f.parentNode.removeChild(f),
                            q.destroy(f)) : 0 < f.childNodes.length && (f._multiply = f._multiply ? N.multiply(f._matrix, f._multiply) : f._matrix);
                    this._noDom = 0;
                    if (e && e.length)
                        for (b = e.length - 1; 0 <= b; b--) f = e[b], m.set(f, "visibility", "visible"), this._tilePopPop(f), e.splice(b, 1)
                }
                this._fireUpdateStart();
                this._rrIndex = 0;
                b = F.getCandidateTileInfo(c, this.tileInfo, a);
                a = c.__visibleDelta;
                if (!this._ct || b.lod.level !== this._ct.lod.level || d) {
                    f = b && this._ct && b.lod.level !== this._ct.lod.level;
                    this._ct = b;
                    var h = this._tiles,
                        g = this._tileIds,
                        u = this._tileBounds,
                        l = this._removeList,
                        k, p = g.length;
                    this._cleanUpRemovedImages();
                    for (b = 0; b < p; b++) e = g[b], k = h[e], u[e] = g[b] = null, "css-transforms" === c.navigationMode && (f && k.parentNode && c.fadeOnZoom) && (k._fadeOut = f, k.parentNode._remove++), l.add(k);
                    d && (this._tileIds = [], this._tiles = [], this._tileBounds = [])
                }
                b = a.x;
                d = a.y;
                "css-transforms" === c.navigationMode ? (e = {}, e[v._css.names.transform] = v._css.translate(b, d), m.set(this._div, e)) : m.set(this._div, {
                    left: b + "px",
                    top: d + "px"
                });
                this.__coords_dx = b;
                this.__coords_dy = d;
                this._updateImages(new B(0,
                    0, a.width, a.height));
                0 === this._loadingList.count ? (this._cleanUpRemovedImages(), this.onUpdate(), this._fireUpdateEnd()) : this._fireOnUpdate = !0;
                d = this._tileW;
                h = this._tileH;
                a = new B(-a.x, -a.y, a.width, a.height);
                for (b = this._tileIds.length - 1; 0 <= b; b--)(e = this._tileIds[b]) ? (f = this._tiles[e], g = L.getMarginBox(f), g = new B(g.l, g.t, d, h), "css-transforms" === c.navigationMode && (g.x = f._left, g.y = f._top), a.intersects(g) ? this._tileBounds[e] = g : (this._loadingList.contains(e) && this._tilePopPop(f), q.destroy(f), this._tileIds.splice(b,
                    1), delete this._tileBounds[e], delete this._tiles[e])) : (this._tileIds.splice(b, 1), delete this._tileBounds[e], delete this._tiles[e])
            }
        },
        _onPanHandler: function(a, c) {
            var d = this._map,
                b = d.__visibleDelta.offset(c.x, c.y);
            this.__coords_dx = this.__coords_dy = 0;
            "css-transforms" === d.navigationMode ? (d = {}, d[v._css.names.transform] = v._css.translate(b.x, b.y), m.set(this._div, d), !x("esri-touch") && !x("esri-pointer") && this._updateImages({
                x: -b.x,
                y: -b.y,
                width: b.width,
                height: b.height
            })) : (m.set(this._div, {
                left: b.x + "px",
                top: b.y +
                    "px"
            }), this._updateImages({
                x: -b.x,
                y: -b.y,
                width: b.width,
                height: b.height
            }));
            0 < this._loadingList.count && (this._fireUpdateStart(), this._fireOnUpdate = !0)
        },
        _onScaleHandler: function(a, c) {
            var d, b = {},
                e = v._css.names,
                f = this._map;
            for (d = this._passives.length - 1; 0 <= d; d--) {
                var h = this._passives[d];
                0 === h.childNodes.length ? (this._passives.splice(d, 1), q.destroy(h)) : ("none" === h.style[e.transition] && m.set(h, e.transition, e.transformName + " " + C + "ms ease"), m.set(h, e.transition, c ? "none" : e.transformName + " " + C + "ms ease"), h._matrix =
                    a, b[e.transform] = v._css.matrix(h._multiply ? N.multiply(a, h._multiply) : a), m.set(h, b))
            }
            this._active && 0 === this._active.childNodes.length || (m.set(this._active, e.transition, c ? "none" : e.transformName + " " + C + "ms ease"), this._active._matrix = a, b[e.transform] = v._css.matrix(this._active._matrix), m.set(this._active, b), this._passives.push(this._active), b = {
                position: "absolute",
                width: f.width + "px",
                height: f.height + "px",
                overflow: "visible"
            }, b[e.transition] = e.transformName + " " + C + "ms ease", m.set(this._active = q.create("div",
                null, this._div), b), this._active._remove = 0, f.fadeOnZoom && q.place(this._active, this._div, "first"))
        },
        _onZoomHandler: function(a, c, d) {
            a = L.getMarginBox(this._div);
            d = d.offset(-a.l, -a.t);
            if (!this._previousScale || 1 === c) this._previousScale = 1;
            var b, e = this._tileW * c,
                f = this._tileH * c,
                h = this._tileBounds,
                g = this._tiles,
                u = this._previousScale,
                l = this._multiple,
                k = m.set,
                p, r;
            if ((a = x("ie")) && 8 > a) A.forEach(this._tileIds, function(a) {
                r = "";
                b = h[a];
                p = g[a].style.margin.split(" ");
                A.forEach(p, function(a) {
                    "" !== r && (r += " ");
                    a = parseFloat(a);
                    r += a / u * c + "px"
                });
                k(g[a], {
                    left: b.x - (e - b.width) * (d.x - b.x) / b.width + "px",
                    top: b.y - (f - b.height) * (d.y - b.y) / b.height + "px",
                    margin: 1 !== l && -1 === r.indexOf("NaN") ? r : "",
                    zoom: c
                })
            });
            else {
                var q = e * l,
                    T = f * l,
                    n, v;
                A.forEach(this._tileIds, function(a) {
                    r = "";
                    b = h[a];
                    n = b.x - (e - b.width) * (d.x - b.x) / b.width;
                    v = b.y - (f - b.height) * (d.y - b.y) / b.height;
                    p = g[a].style.margin.split(" ");
                    A.forEach(p, function(a) {
                        "" !== r && (r += " ");
                        a = parseFloat(a);
                        r += a / u * c + "px"
                    });
                    k(g[a], {
                        left: n + "px",
                        top: v + "px",
                        margin: 1 !== l && -1 === r.indexOf("NaN") ? r : "",
                        width: q + "px",
                        height: T + "px"
                    })
                })
            }
            this._previousScale = c
        },
        _updateImages: function(a) {
            if (this._ct) {
                var c, d = this._tileW,
                    b = this._tileH,
                    e = this._ct;
                c = e.lod;
                var e = e.tile,
                    f = e.offsets,
                    h = e.coords,
                    g = h.row,
                    h = h.col,
                    m = c.level,
                    l = this.opacity,
                    k = this._tileIds,
                    p = this._loadingList,
                    r = this._addImage,
                    q = this._map.id,
                    v = this.id,
                    n = a.x,
                    s = a.y,
                    x = c.startTileRow,
                    z = c.endTileRow,
                    C = c.startTileCol,
                    E = c.endTileCol,
                    F = A.indexOf,
                    y, t, B = f.x - this.__coords_dx,
                    G = f.y - this.__coords_dy;
                t = d - B + -a.x;
                var w = b - G + -a.y;
                y = Math.ceil;
                t = 0 < t ? t % d : d - Math.abs(t) % d;
                w = 0 < w ? w % b : b -
                    Math.abs(w) % b;
                n = 0 < n ? Math.floor((n + B) / d) : y((n - (d - B)) / d);
                s = 0 < s ? Math.floor((s + G) / b) : y((s - (b - G)) / b);
                G = n + y((a.width - t) / d);
                a = s + y((a.height - w) / b);
                var D, H, I;
                this._wrap && (D = c._frameInfo, H = D[0], I = D[1], D = D[2]);
                for (w = n; w <= G; w++)
                    for (n = s; n <= a; n++) y = g + n, t = h + w, this._wrap && (t < I ? (t %= H, t = t < I ? t + H : t) : t > D && (t %= H)), !this._isExcluded(m, y, t) && (y >= x && y <= z && t >= C && t <= E) && (c = q + "_" + v + "_tile_" + m + "_" + n + "_" + w, -1 === F(k, c) && (p.add(c), k.push(c), r(m, n, y, w, t, c, d, b, l, e, f)))
            }
        },
        _cleanUpRemovedImages: function() {
            var a = this._removeList,
                c = q.destroy,
                d, b = v._css.names;
            a.forEach(function(a) {
                a._fadeOut || (a.style.filter = "", a.style.zoom = 1, c(a))
            });
            if ("css-transforms" === this._map.navigationMode)
                for (d = this._passives.length - 1; 0 <= d; d--) {
                    var e = this._passives[d];
                    0 === e.childNodes.length ? (this._passives.splice(d, 1), c(e)) : this._map.fadeOnZoom && (!e._marked && e._remove === e.childNodes.length) && (e._marked = 1, 2048 > v._css.getScaleFromMatrix(m.get(e, b.transform)) ? (m.set(e, b.transition, "opacity 0.65s"), m.set(e, "opacity", 0), s.disconnect(e._endHandle), e._endHandle = s.connect(e,
                        b.endEvent, this._transitionEnd)) : this._transitionEnd({
                        propertyName: "opacity",
                        target: e
                    }))
                }
            a.clear()
        },
        _transitionEnd: function(a) {
            var c = a.target;
            "opacity" === a.propertyName && (s.disconnect(c._endHandle), c._endHandle = null, a = A.indexOf(this._passives, c), -1 < a && this._passives.splice(a, 1), c.parentNode && c.parentNode.removeChild(c), q.destroy(c))
        },
        _addImage: function(a, c, d, b, e, f, h, g, u, l, k) {
            if (this._patchIE) l = this._tiles[f] = q.create("div"), l.id = f, K.add(l, "layerTile"), m.set(l, {
                left: h * b - k.x + "px",
                top: g * c - k.y + "px",
                width: h +
                    "px",
                height: g + "px",
                filter: "progid:DXImageTransform.Microsoft.AlphaImageLoader(src\x3d'" + this.getTileUrl(a, d, e) + "', sizingMethod\x3d'scale')"
            }), 1 > u && m.set(l, "opacity", u), a = l.appendChild(q.create("div")), m.set(a, {
                opacity: 0,
                width: h + "px",
                height: g + "px"
            }), this._div.appendChild(l), this._loadingList.remove(f), this._fireOnUpdateEvent();
            else {
                l = this._tiles[f] = q.create("img");
                var p = s.connect;
                l.id = f;
                K.add(l, "layerTile");
                b = h * b - k.x;
                k = g * c - k.y;
                c = this._map;
                var r = v._css.names;
                h = {
                    width: h + "px",
                    height: g + "px",
                    visibility: "hidden"
                };
                "css-transforms" === c.navigationMode ? (h[r.transform] = v._css.translate(b, k), m.set(l, h), l._left = b, l._top = k) : (h.left = b + "px", h.top = k + "px", m.set(l, h));
                1 > u && m.set(l, "opacity", u);
                l._onload_connect = p(l, "onload", this, "_tileLoadHandler");
                l._onerror_connect = p(l, "onerror", E.hitch(this, "_tileErrorHandler", d, e));
                l._onabort_connect = p(l, "onabort", this, "_tileAbortHandler");
                if (this.tileMap) this.tileMap.getTile(a, d, e, f, this._tileMapCallback);
                else if (f = this.getTileUrl(a, d, e, l)) this._failedRequests && this._failedRequests[f] ?
                    (m.set(l, this._failedRequests[f].css), l.src = this._failedRequests[f].src, this._multiple = parseInt(this._failedRequests[f].css.width) / this._tileW) : (this._multiple = 1, l.src = f);
                "css-transforms" === c.navigationMode ? this._active.appendChild(l) : this._div.appendChild(l)
            }
        },
        _tileMapCallback: function(a, c) {
            var d, b;
            !this.suspended && this._tiles[c.id] && (this._multiple = 2 * (c.level - a.level) || 1, b = this._tiles[c.id], d = this.tileMap.style(a, c), m.set(b, d), b.src = this.getTileUrl(a.level, a.row, a.col))
        },
        getTileUrl: function(a, c,
            d) {},
        _reCheckTS: /[\?\&]_ts=/ig,
        _reReplaceTS: /([\?\&]_ts=)[0-9]+/ig,
        addTimestampToURL: function(a) {
            var c = this._refreshTS;
            c && (a = this._reCheckTS.test(a) ? a.replace(this._reReplaceTS, "$$$1" + c) : a + ((-1 === a.indexOf("?") ? "?" : "\x26") + "_ts\x3d" + c));
            return a
        },
        refresh: function() {
            this.suspended || (this._refreshTS = (new Date).getTime(), this._onExtentChangeHandler(this._map.extent, null, !0, this._map.__LOD))
        },
        _tilePopPop: function(a) {
            var c = s.disconnect;
            c(a._onload_connect);
            c(a._onerror_connect);
            c(a._onabort_connect);
            a._onload_connect =
                a._onerror_connect = a._onabort_connect = null;
            this._loadingList.remove(a.id);
            this._fireOnUpdateEvent()
        },
        _tileLoadHandler: function(a) {
            a = a.currentTarget;
            this._noDom ? this._standby.push(a) : (m.set(a, "visibility", "visible"), this._tilePopPop(a))
        },
        _tileAbortHandler: function(a) {
            a = a.currentTarget;
            this.onError(Error("Unable to load tile: " + a.src));
            m.set(a, "visibility", "hidden");
            this._tilePopPop(a)
        },
        _tileErrorHandler: function(a, c, d) {
            d = d.currentTarget;
            var b, e, f = !0;
            if (this.tileMap || !this.resampling) f = !1;
            else if (b =
                new J(d.src), b = b.path.split("/"), b = parseInt(b[b.length - 3]), e = this._ct.lod.level - b + 1, this._multiple = Math.pow(2, e), b === this._lowestLevel || 0 === this._resamplingTolerance || this._resamplingTolerance && Math.log(this._multiple) / Math.LN2 > this._resamplingTolerance) f = !1;
            f ? this._resample(d, a, c) : (this.onError(Error("Unable to load tile: " + d.src)), m.set(d, "visibility", "hidden"), this._tilePopPop(d))
        },
        _resample: function(a, c, d) {
            var b = (new J(a.src)).path.split("/"),
                e = this._multiple,
                f = parseInt(b[b.length - 3]) - 1,
                h = parseInt(c /
                    e),
                g = parseInt(d / e),
                b = d % e,
                u = c % e,
                h = this.getTileUrl(f, h, g);
            c = this.getTileUrl(f + Math.log(e) / Math.LN2, c, d);
            e = {
                width: this._tileW * e + "px",
                height: this._tileH * e + "px",
                margin: "-" + this._tileW * u + "px 0 0 " + ("-" + this._tileH * b + "px")
            };
            this._failedRequests || (this._failedRequests = {});
            this._failedRequests[c] = {
                src: h,
                css: e
            };
            m.set(a, e);
            x("chrome") && a.setAttribute("src", null);
            a.src = h
        },
        _fireOnUpdateEvent: function() {
            0 === this._loadingList.count && (this._cleanUpRemovedImages(), this._fireOnUpdate && (this._fireOnUpdate = !1, this.onUpdate(),
                this._fireUpdateEnd()))
        },
        setOpacity: function(a) {
            if (this.opacity != a) this.onOpacityChange(this.opacity = a)
        },
        onOpacityChange: function() {},
        _opacityChangeHandler: function(a) {
            var c = m.set,
                d, b, e;
            if ("css-transforms" === this._map.navigationMode) {
                if (this._active) {
                    e = this._active.childNodes;
                    for (d = e.length - 1; 0 <= d; d--) c(e[d], "opacity", a)
                }
                for (d = this._passives.length - 1; 0 <= d; d--) {
                    e = this._passives[d].childNodes;
                    for (b = e.length - 1; 0 <= b; b--) c(e[b], "opacity", a)
                }
            } else {
                e = this._div.childNodes;
                for (d = e.length - 1; 0 <= d; d--) c(e[d],
                    "opacity", a)
            }
        },
        setExclusionAreas: function(a) {
            this.exclusionAreas = a;
            if (this.loaded && this._map && this._map.loaded) {
                var c = this._map.spatialReference,
                    d = this.tileInfo,
                    b = d.origin,
                    e = d.lods,
                    f = e[0].level,
                    h = e[e.length - 1].level,
                    g, m, l, k, p, r, s, q, n;
                if (!this.exclusionAreas || !this.exclusionAreas.length) this._exclusionsPerZoom = null;
                else {
                    this._exclusionsPerZoom = [];
                    m = 0;
                    for (l = a.length; m < l; m++)
                        if (g = a[m], (n = g.geometry) && "extent" === n.type && n.xmin <= n.xmax && n.ymin <= n.ymax) {
                            if (!c.equals(n.spatialReference))
                                if (c._canProject(n.spatialReference)) c.isWebMercator() ?
                                    (q = z.lngLatToXY(n.xmin, n.ymin), n = z.lngLatToXY(n.xmax, n.ymax)) : (q = z.xyToLngLat(n.xmin, n.ymin, !0), n = z.xyToLngLat(n.xmax, n.ymax, !0)), n = new R(q[0], q[1], n[0], n[1], c);
                                else continue;
                            s = -1;
                            if (g.minZoom && -1 !== g.minZoom) s = g.minZoom;
                            else if (g.minScale && -1 !== g.minScale) {
                                k = 0;
                                for (p = e.length; k < p; k++)
                                    if (e[k].scale <= g.minScale) {
                                        s = e[k].level;
                                        break
                                    }
                            }
                            s = Math.max(s, f);
                            q = -1;
                            if (g.maxZoom && -1 !== g.maxZoom) q = g.maxZoom;
                            else if (g.maxScale && -1 !== g.maxScale) {
                                k = 0;
                                for (p = e.length; k < p; k++)
                                    if (e[k].scale < g.maxScale) {
                                        q = e[k - 1].level;
                                        break
                                    } else if (e[k].scale ===
                                    g.maxScale) {
                                    q = e[k].level;
                                    break
                                }
                            }
                            q = -1 === q ? h : Math.min(q, h);
                            for (g = s; g <= q; g++) {
                                k = 0;
                                for (p = e.length; k < p; k++)
                                    if (e[k].level === g) {
                                        r = e[k];
                                        break
                                    }
                                r && (this._exclusionsPerZoom[g] || (this._exclusionsPerZoom[g] = []), k = 1 / r.resolution / d.rows, p = 1 / r.resolution / d.cols, this._exclusionsPerZoom[g].push({
                                    rowFrom: Math.floor((b.y - n.ymax) * k),
                                    rowTo: Math.ceil((b.y - n.ymin) * k),
                                    colFrom: Math.floor((n.xmin - b.x) * p),
                                    colTo: Math.ceil((n.xmax - b.x) * p)
                                }))
                            }
                        }
                }
                this.suspended || this._onExtentChangeHandler(this._map.extent, null, !0, this._map.__LOD)
            }
        },
        _isExcluded: function(a, c, d) {
            var b, e, f;
            if (!this._exclusionsPerZoom) return !1;
            b = this._exclusionsPerZoom[a];
            if (!b) return !1;
            e = 0;
            for (f = b.length; e < f; e++)
                if (a = b[e], c >= a.rowFrom && c < a.rowTo && d >= a.colFrom && d < a.colTo) return !0;
            return !1
        }
    })
});
},
'dojox/collections/ArrayList':function(){
define(["dojo/_base/kernel", "dojo/_base/array", "./_base"], function(dojo, darray, dxc){

	dxc.ArrayList=function(/*array?*/ arr){
		// summary:
		//		Returns a new object of type dojox.collections.ArrayList
		var items=[];
		if(arr) items=items.concat(arr);
		this.count=items.length;
		this.add=function(/*object*/ obj){
			// summary:
			//		Add an element to the collection.
			items.push(obj);
			this.count=items.length;
		};
		this.addRange=function(/*array*/ a){
			// summary:
			//		Add a range of objects to the ArrayList
			if(a.getIterator){
				var e=a.getIterator();
				while(!e.atEnd()){
					this.add(e.get());
				}
				this.count=items.length;
			}else{
				for(var i=0; i<a.length; i++){
					items.push(a[i]);
				}
				this.count=items.length;
			}
		};
		this.clear=function(){
			// summary:
			//		Clear all elements out of the collection, and reset the count.
			items.splice(0, items.length);
			this.count=0;
		};
		this.clone=function(){
			// summary:
			//		Clone the array list
			return new dxc.ArrayList(items);	//	dojox.collections.ArrayList
		};
		this.contains=function(/*object*/ obj){
			// summary:
			//		Check to see if the passed object is a member in the ArrayList
			for(var i=0; i < items.length; i++){
				if(items[i] == obj) {
					return true;	//	bool
				}
			}
			return false;	//	bool
		};
		this.forEach=function(/*function*/ fn, /*object?*/ scope){
			// summary:
			//		functional iterator, following the mozilla spec.
			dojo.forEach(items, fn, scope);
		};
		this.getIterator=function(){
			// summary:
			//		Get an Iterator for this object
			return new dxc.Iterator(items);	//	dojox.collections.Iterator
		};
		this.indexOf=function(/*object*/ obj){
			// summary:
			//		Return the numeric index of the passed object; will return -1 if not found.
			for(var i=0; i < items.length; i++){
				if(items[i] == obj) {
					return i;	//	int
				}
			}
			return -1;	// int
		};
		this.insert=function(/*int*/ i, /*object*/ obj){
			// summary:
			//		Insert the passed object at index i
			items.splice(i,0,obj);
			this.count=items.length;
		};
		this.item=function(/*int*/ i){
			// summary:
			//		return the element at index i
			return items[i];	//	object
		};
		this.remove=function(/*object*/ obj){
			// summary:
			//		Look for the passed object, and if found, remove it from the internal array.
			var i=this.indexOf(obj);
			if(i >=0) {
				items.splice(i,1);
			}
			this.count=items.length;
		};
		this.removeAt=function(/*int*/ i){
			// summary:
			//		Remove the element located at the given index.
			items.splice(i,1);
			this.count=items.length;
		};
		this.reverse=function(){
			// summary:
			//		Reverse the internal array
			items.reverse();
		};
		this.sort=function(/*function?*/ fn){
			// summary:
			//		sort the internal array
			if(fn){
				items.sort(fn);
			}else{
				items.sort();
			}
		};
		this.setByIndex=function(/*int*/ i, /*object*/ obj){
			// summary:
			//		Set an element in the array by the passed index.
			items[i]=obj;
			this.count=items.length;
		};
		this.toArray=function(){
			// summary:
			//		Return a new array with all of the items of the internal array concatenated.
			return [].concat(items);
		};
		this.toString=function(/*string*/ delim){
			// summary:
			//		implementation of toString, follows [].toString();
			return items.join((delim||","));
		};
	};
	return dxc.ArrayList;
});

},
'dojox/collections/_base':function(){
define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array"], 
  function(dojo, lang, arr){
	var collections = lang.getObject("dojox.collections", true);

	collections.DictionaryEntry=function(/*string*/ k, /*object*/ v){
		// summary:
		//		return an object of type dojox.collections.DictionaryEntry
		this.key=k;
		this.value=v;
		this.valueOf=function(){
			return this.value; 	//	object
		};
		this.toString=function(){
			return String(this.value);	//	string
		};
	}

	/*	Iterators
	 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
	 *	work with the Collections included in this module.  However, they *can*
	 *	be used with arrays and objects, respectively, should one choose to do so.
	 */
	collections.Iterator=function(/*array*/ a){
		// summary:
		//		return an object of type dojox.collections.Iterator
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			// summary:
			//		Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			// summary:
			//		Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/*function*/ fn, /*object?*/ scope){
			// summary:
			//		Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function(){
			// summary:
			//		reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	}

	/*	Notes:
	 *	The DictionaryIterator no longer supports a key and value property;
	 *	the reality is that you can use this to iterate over a JS object
	 *	being used as a hashtable.
	 */
	collections.DictionaryIterator=function(/*object*/ obj){
		// summary:
		//		return an object of type dojox.collections.DictionaryIterator
		var a=[];	//	Create an indexing array
		var testObject={};
		for(var p in obj){
			if(!testObject[p]){
				a.push(obj[p]);	//	fill it up
			}
		}
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			// summary:
			//		Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			// summary:
			//		Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/*function*/ fn, /*object?*/ scope){
			// summary:
			//		Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function() {
			// summary:
			//		reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	};

	return collections;
});

},
'esri/layers/ArcGISMapServiceLayer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../lang", "../request", "../SpatialReference", "../geometry/Extent", "./LayerInfo"], function(c, k, l, q, r, f, m, n, g, p) {
    return c(null, {
        declaredClass: "esri.layers.ArcGISMapServiceLayer",
        infoTemplates: null,
        constructor: function(a, d) {
            this.layerInfos = [];
            d && (this.infoTemplates = d.infoTemplates || null);
            var e = this._params = {},
                b = this._url.query ? this._url.query.token : null;
            b && (e.token = b)
        },
        setInfoTemplates: function(a) {
            this.infoTemplates = a
        },
        _load: function() {
            m({
                url: this._url.path,
                content: k.mixin({
                    f: "json"
                }, this._params),
                callbackParamName: "callback",
                load: this._initLayer,
                error: this._errorHandler
            })
        },
        spatialReference: null,
        initialExtent: null,
        fullExtent: null,
        description: null,
        units: null,
        _initLayer: function(a, d) {
            try {
                this._findCredential();
                (this.credential && this.credential.ssl || a && a._ssl) && this._useSSL();
                this.description = a.description;
                this.copyright = a.copyrightText;
                this.spatialReference = a.spatialReference && new n(a.spatialReference);
                this.initialExtent = a.initialExtent && new g(a.initialExtent);
                this.fullExtent = a.fullExtent && new g(a.fullExtent);
                this.units = a.units;
                this.maxRecordCount = a.maxRecordCount;
                this.maxImageHeight = a.maxImageHeight;
                this.maxImageWidth = a.maxImageWidth;
                this.supportsDynamicLayers = a.supportsDynamicLayers;
                var e = this.layerInfos = [],
                    b = a.layers,
                    h = this._defaultVisibleLayers = [];
                l.forEach(b, function(a, b) {
                    e[b] = new p(a);
                    a.defaultVisibility && h.push(a.id)
                });
                this.visibleLayers || (this.visibleLayers = h);
                this.version = a.currentVersion;
                this.version || (this.version = "capabilities" in a || "tables" in
                    a ? 10 : "supportedImageFormatTypes" in a ? 9.31 : 9.3);
                this.capabilities = a.capabilities;
                f.isDefined(a.minScale) && !this._hasMin && this.setMinScale(a.minScale);
                f.isDefined(a.maxScale) && !this._hasMax && this.setMaxScale(a.maxScale)
            } catch (c) {
                this._errorHandler(c)
            }
        }
    })
});
},
'esri/layers/LayerInfo':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang"], function(a, b, d, e, c) {
    return a(null, {
        declaredClass: "esri.layers.LayerInfo",
        constructor: function(a) {
            b.mixin(this, a)
        },
        toJson: function() {
            return c.fixJson({
                defaultVisibility: this.defaultVisibility,
                id: this.id,
                maxScale: this.maxScale,
                minScale: this.minScale,
                name: this.name,
                parentLayerId: this.parentLayerId,
                subLayerIds: this.subLayerIds
            })
        }
    })
});
},
'esri/layers/TimeInfo':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../TimeExtent", "./TimeReference", "./LayerTimeOptions"], function(b, c, g, h, d, e, f) {
    b = b(null, {
        declaredClass: "esri.layers.TimeInfo",
        constructor: function(a) {
            null !== a && (c.mixin(this, a), a.exportOptions && (this.exportOptions = new f(a.exportOptions)), this.timeExtent = null, a.timeExtent && 2 === a.timeExtent.length && (this.timeExtent = new d(a.timeExtent)), this.timeReference = new e(a.timeReference))
        }
    });
    c.mixin(b, {
        UNIT_CENTURIES: "esriTimeUnitsCenturies",
        UNIT_DAYS: "esriTimeUnitsDays",
        UNIT_DECADES: "esriTimeUnitsDecades",
        UNIT_HOURS: "esriTimeUnitsHours",
        UNIT_MILLISECONDS: "esriTimeUnitsMilliseconds",
        UNIT_MINUTES: "esriTimeUnitsMinutes",
        UNIT_MONTHS: "esriTimeUnitsMonths",
        UNIT_SECONDS: "esriTimeUnitsSeconds",
        UNIT_UNKNOWN: "esriTimeUnitsUnknown",
        UNIT_WEEKS: "esriTimeUnitsWeeks",
        UNIT_YEARS: "esriTimeUnitsYears"
    });
    return b
});
},
'esri/TimeExtent':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "./kernel"], function(l, m, n, p) {
    var k = l(null, {
        declaredClass: "esri.TimeExtent",
        constructor: function(a) {
            if (1 < arguments.length) this._create(arguments[0], arguments[1]);
            else if (a)
                if (m.isArray(a)) {
                    var c = a[0],
                        b = a[1];
                    this.startTime = null === c || "null" === c ? null : new Date(c);
                    this.endTime = null === b || "null" === b ? null : new Date(b)
                } else a instanceof Date && this._create(a, null)
        },
        offset: function(a, c) {
            var b = new k,
                d = this.startTime,
                e = this.endTime;
            d && (b.startTime = this._getOffsettedDate(d,
                a, c));
            e && (b.endTime = this._getOffsettedDate(e, a, c));
            return b
        },
        intersection: function(a) {
            return this._intersection(this, a)
        },
        toJson: function() {
            var a = [],
                c = this.startTime;
            a.push(c ? c.getTime() : "null");
            c = this.endTime;
            a.push(c ? c.getTime() : "null");
            return a
        },
        _create: function(a, c) {
            this.startTime = a ? new Date(a.getTime()) : null;
            this.endTime = c ? new Date(c.getTime()) : null
        },
        _refData: {
            esriTimeUnitsMilliseconds: {
                getter: "getUTCMilliseconds",
                setter: "setUTCMilliseconds",
                multiplier: 1
            },
            esriTimeUnitsSeconds: {
                getter: "getUTCSeconds",
                setter: "setUTCSeconds",
                multiplier: 1
            },
            esriTimeUnitsMinutes: {
                getter: "getUTCMinutes",
                setter: "setUTCMinutes",
                multiplier: 1
            },
            esriTimeUnitsHours: {
                getter: "getUTCHours",
                setter: "setUTCHours",
                multiplier: 1
            },
            esriTimeUnitsDays: {
                getter: "getUTCDate",
                setter: "setUTCDate",
                multiplier: 1
            },
            esriTimeUnitsWeeks: {
                getter: "getUTCDate",
                setter: "setUTCDate",
                multiplier: 7
            },
            esriTimeUnitsMonths: {
                getter: "getUTCMonth",
                setter: "setUTCMonth",
                multiplier: 1
            },
            esriTimeUnitsYears: {
                getter: "getUTCFullYear",
                setter: "setUTCFullYear",
                multiplier: 1
            },
            esriTimeUnitsDecades: {
                getter: "getUTCFullYear",
                setter: "setUTCFullYear",
                multiplier: 10
            },
            esriTimeUnitsCenturies: {
                getter: "getUTCFullYear",
                setter: "setUTCFullYear",
                multiplier: 100
            }
        },
        _intersection: function(a, c) {
            if (a && c) {
                var b = a.startTime,
                    d = a.endTime,
                    e = c.startTime,
                    f = c.endTime,
                    b = b ? b.getTime() : -Infinity,
                    e = e ? e.getTime() : -Infinity,
                    d = d ? d.getTime() : Infinity,
                    f = f ? f.getTime() : Infinity,
                    g, h;
                e >= b && e <= d ? g = e : b >= e && b <= f && (g = b);
                d >= e && d <= f ? h = d : f >= b && f <= d && (h = f);
                if (!isNaN(g) && !isNaN(h)) return b = new k, b.startTime = -Infinity ===
                    g ? null : new Date(g), b.endTime = Infinity === h ? null : new Date(h), b
            }
            return null
        },
        _getOffsettedDate: function(a, c, b) {
            var d = this._refData;
            a = new Date(a.getTime());
            c && b && (d = d[b], a[d.setter](a[d.getter]() + c * d.multiplier));
            return a
        }
    });
    return k
});
},
'esri/layers/TimeReference':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel"], function(b, c, d, e) {
    return b(null, {
        declaredClass: "esri.layers.TimeReference",
        constructor: function(a) {
            a && c.mixin(this, a)
        }
    })
});
},
'esri/layers/LayerTimeOptions':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang"], function(b, c, e, f, d) {
    return b(null, {
        declaredClass: "esri.layers.LayerTimeOptions",
        constructor: function(a) {
            a && c.mixin(this, a)
        },
        toJson: function() {
            return d.fixJson({
                timeDataCumulative: this.timeDataCumulative,
                timeOffset: this.timeOffset,
                timeOffsetUnits: this.timeOffsetUnits,
                useTime: this.useTime
            })
        }
    })
});
},
'esri/layers/TileMap':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/Deferred", "dojo/io-query", "../request", "../urlUtils"], function(l, k, m, n, p, q, r) {
    return l(null, {
        declaredClass: "esri.layers.TileMap",
        constructor: function(a) {
            this.layer = a;
            this._tileMaps = {}
        },
        getTile: function(a, b, c, d, e) {
            a = {
                id: d,
                level: a,
                row: b,
                col: c
            };
            b = this._getResamplingBudget();
            0 < b ? this._process({
                tile: a,
                requestedTile: a,
                callback: e,
                resamplingBudget: b
            }) : (e || this.callback).call(this, a, a)
        },
        statusOf: function(a, b, c) {
            var d = this._getResamplingBudget();
            a = {
                level: a,
                row: b,
                col: c
            };
            if (0 === d) return 1;
            for (; 0 <= d;) {
                b = this._tileToTileMap(a);
                if (!this._tileMaps[b.uid]) return -1;
                b = this._tileMaps[b.uid];
                if (!b.promise.isFulfilled()) return -1;
                if (this._isTileAvailable(a, b)) return 1;
                a = this._parentTile(a);
                if (!a) break;
                d--
            }
            return 0
        },
        style: function(a, b) {
            if (!(a.level === b.level && a.row === b.row && a.col === b.col)) {
                for (var c = this.layer.tileInfo, d = c.lods, e = c.cols, c = c.rows, f, g, h = d.length - 1; !f || !g;) !f && d[h].level === a.level && (f = d[h]), !g && d[h].level === b.level && (g = d[h]), h--;
                d = Math.round(f.resolution /
                    g.resolution);
                return {
                    width: e * d + "px",
                    height: c * d + "px",
                    margin: "-" + b.row % d * c + "px 0 0 -" + b.col % d * e + "px"
                }
            }
        },
        _process: function(a) {
            var b = a.tile,
                c = this._tileToTileMap(b),
                d = this._parentTile(b);
            this._getTileMap(c).then(k.hitch(this, function(e) {
                c = e;
                this._isTileAvailable(b, c) ? (a.callback || this.callback).call(this, b, a.requestedTile) : 0 < a.resamplingBudget && d ? (a.resamplingBudget--, a.tile = d, this._process(a)) : (a.callback || this.callback).call(this, a.requestedTile, a.requestedTile)
            }), k.hitch(this, function() {
                (a.callback ||
                    this.callback).call(this, a.requestedTile, a.requestedTile)
            }))
        },
        _getTileMap: function(a) {
            var b, c, d, e, f = null;
            this._tileMaps[a.uid] ? (a = this._tileMaps[a.uid], b = a.promise) : (this._tileMaps[a.uid] = a, c = new n, q({
                url: this._getTileMapUrl(a.level, a.row, a.col),
                handleAs: "json",
                callbackParamName: "callback",
                timeout: 3E3,
                load: function(b) {
                    k.mixin(a, b);
                    if (a.data && 0 < a.data.length) {
                        e = a.data.length;
                        if (1 === e) f = a.data[0];
                        else {
                            f = a.data[0];
                            for (d = 1; d < e; d++)
                                if (a.data[d] !== f) {
                                    f = null;
                                    break
                                }
                        }
                        null !== f && (delete a.data, a.value = f)
                    }
                    c.resolve(a)
                },
                error: function(a) {
                    c.reject()
                }
            }), b = a.promise = c.promise);
            return b
        },
        _parentTile: function(a) {
            var b = this.layer.tileInfo.lods,
                c, d, e = null;
            m.some(b, function(b, e) {
                return a.level === b.level ? (c = b, d = e, !0) : !1
            });
            0 < d && (b = b[d - 1], e = {
                id: a.id,
                level: b.level,
                row: Math.floor(a.row * c.resolution / b.resolution + 0.01),
                col: Math.floor(a.col * c.resolution / b.resolution + 0.01)
            });
            return e
        },
        _tileToTileMap: function(a) {
            var b = 8 * Math.floor(a.row / 8),
                c = 8 * Math.floor(a.col / 8);
            return {
                uid: a.level + "_" + b + "_" + c,
                level: a.level,
                row: b,
                col: c
            }
        },
        _isTileAvailable: function(a,
            b) {
            var c, d;
            b.valid ? void 0 !== b.value ? c = b.value : (c = b.location.left, d = b.location.top, c = (a.row - d) * b.location.width + (a.col - c), c = c < b.data.length ? b.data[c] : 0) : c = 0;
            return c
        },
        _getTileMapUrl: function(a, b, c) {
            var d = this.layer,
                e = d.tileServers,
                f = d._getToken(),
                g = d._url.query;
            a = (e ? e[b % e.length] : d._url.path) + "/tilemap/" + a + "/" + b + "/" + c + "/8/8";
            g && (a += "?" + p.objectToQuery(g));
            if (f && (!g || !g.token)) a += (-1 === a.indexOf("?") ? "?" : "\x26") + "token\x3d" + f;
            a = d.addTimestampToURL(a);
            return r.addProxy(a)
        },
        _getResamplingBudget: function() {
            var a =
                this.layer,
                b = 0;
            if (a.resampling && (b = a._resamplingTolerance, null === b || void 0 === b)) b = a.tileInfo.lods.length;
            return b
        }
    })
});
},
'esri/layers/OpenStreetMapLayer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../urlUtils", "../SpatialReference", "../geometry/Extent", "./TiledMapServiceLayer", "./TileInfo"], function(c, h, k, l, d, e, b, f, g) {
    return c(f, {
        declaredClass: "esri.layers.OpenStreetMapLayer",
        constructor: function(a) {
            this.spatialReference = new e({
                wkid: 102100
            });
            this.tileInfo = new g({
                rows: 256,
                cols: 256,
                dpi: 96,
                format: "PNG8",
                compressionQuality: 0,
                origin: {
                    x: -2.0037508342787E7,
                    y: 2.0037508342787E7
                },
                spatialReference: {
                    wkid: 102100
                },
                lods: [{
                    level: 0,
                    scale: 5.91657527591555E8,
                    resolution: 156543.033928
                }, {
                    level: 1,
                    scale: 2.95828763795777E8,
                    resolution: 78271.5169639999
                }, {
                    level: 2,
                    scale: 1.47914381897889E8,
                    resolution: 39135.7584820001
                }, {
                    level: 3,
                    scale: 7.3957190948944E7,
                    resolution: 19567.8792409999
                }, {
                    level: 4,
                    scale: 3.6978595474472E7,
                    resolution: 9783.93962049996
                }, {
                    level: 5,
                    scale: 1.8489297737236E7,
                    resolution: 4891.96981024998
                }, {
                    level: 6,
                    scale: 9244648.868618,
                    resolution: 2445.98490512499
                }, {
                    level: 7,
                    scale: 4622324.434309,
                    resolution: 1222.99245256249
                }, {
                    level: 8,
                    scale: 2311162.217155,
                    resolution: 611.49622628138
                }, {
                    level: 9,
                    scale: 1155581.108577,
                    resolution: 305.748113140558
                }, {
                    level: 10,
                    scale: 577790.554289,
                    resolution: 152.874056570411
                }, {
                    level: 11,
                    scale: 288895.277144,
                    resolution: 76.4370282850732
                }, {
                    level: 12,
                    scale: 144447.638572,
                    resolution: 38.2185141425366
                }, {
                    level: 13,
                    scale: 72223.819286,
                    resolution: 19.1092570712683
                }, {
                    level: 14,
                    scale: 36111.909643,
                    resolution: 9.55462853563415
                }, {
                    level: 15,
                    scale: 18055.954822,
                    resolution: 4.77731426794937
                }, {
                    level: 16,
                    scale: 9027.977411,
                    resolution: 2.38865713397468
                }, {
                    level: 17,
                    scale: 4513.988705,
                    resolution: 1.19432856685505
                }, {
                    level: 18,
                    scale: 2256.994353,
                    resolution: 0.597164283559817
                }, {
                    level: 19,
                    scale: 1128.497176,
                    resolution: 0.298582141647617
                }]
            });
            this.fullExtent = new b({
                xmin: -2.003750834E7,
                ymin: -2.003750834E7,
                xmax: 2.003750834E7,
                ymax: 2.003750834E7,
                spatialReference: {
                    wkid: 102100
                }
            });
            this.initialExtent = new b({
                xmin: -2.003750834E7,
                ymin: -2.003750834E7,
                xmax: 2.003750834E7,
                ymax: 2.003750834E7,
                spatialReference: {
                    wkid: 102100
                }
            });
            this.tileServers = a && a.tileServers || ["http://a.tile.openstreetmap.org", "http://b.tile.openstreetmap.org", "http://c.tile.openstreetmap.org"];
            this.serversLength = this.tileServers.length;
            this._displayLevels = a ? a.displayLevels : null;
            this.copyright = a && a.copyright || "Map data \x26copy; OpenStreetMap contributors, CC-BY-SA";
            this.loaded = !0;
            this.onLoad(this);
            (a = a && a.loadCallback) && a(this)
        },
        getTileUrl: function(a, b, c) {
            a = this.tileServers[b % this.serversLength] + "/" + a + "/" + c + "/" + b + ".png";
            a = this.addTimestampToURL(a);
            return d.addProxy(a)
        }
    })
});
},
'esri/dijit/Popup':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/kernel", "dojo/has", "dojo/window", "dojo/Stateful", "dojo/query", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dijit/registry", "../kernel", "../lang", "../domUtils", "../geometry/Polyline", "../geometry/Polygon", "../InfoWindowBase", "../PopupBase", "dojo/i18n!../nls/jsapi", "dojo/NodeList-dom", "require", "require"], function(D, y, q, f, g, E, F, G, O, B, t, e, C, A, n, H, P, u, I, J, K, L, M, N) {
    return D([L, M, G], {
        declaredClass: "esri.dijit.Popup",
        offsetX: 3,
        offsetY: 3,
        zoomFactor: 4,
        marginLeft: 25,
        marginTop: 25,
        highlight: !0,
        pagingControls: !0,
        pagingInfo: !0,
        keepHighlightOnHide: !1,
        popupWindow: !0,
        titleInBody: !0,
        anchor: "auto",
        visibleWhenEmpty: !0,
        hideDelay: 1E3,
        location: null,
        constructor: function(a, c) {
            this.initialize();
            y.mixin(this, a);
            this.domNode = B.byId(c);
            var b = this._nls = y.mixin({}, N.widgets.popup),
                d = this.domNode;
            e.add(d, "esriPopup");
            (this._isRTL = !A.isBodyLtr()) && n.set(d, "direction", "rtl");
            t.set(d, "innerHTML", "\x3cdiv class\x3d'esriPopupWrapper' style\x3d'position: absolute;'\x3e\x3cdiv class\x3d'sizer'\x3e\x3cdiv class\x3d'titlePane'\x3e\x3cdiv class\x3d'spinner hidden' title\x3d'" +
                b.NLS_searching + "...'\x3e\x3c/div\x3e\x3cdiv class\x3d'title'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton prev hidden' title\x3d'" + b.NLS_prevFeature + "'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton next hidden' title\x3d'" + b.NLS_nextFeature + "'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton maximize' title\x3d'" + b.NLS_maximize + "'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton close' title\x3d'" + b.NLS_close + "'\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'sizer content'\x3e\x3cdiv class\x3d'contentPane'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'sizer'\x3e\x3cdiv class\x3d'actionsPane'\x3e\x3cdiv class\x3d'actionList hidden'\x3e\x3ca title\x3d" +
                b.NLS_zoomTo + " class\x3d'action zoomTo' href\x3d'javascript:void(0);'\x3e\x3cspan\x3e" + b.NLS_zoomTo + "\x3c/span\x3e\x3c/a\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'pointer hidden'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'outerPointer hidden'\x3e\x3c/div\x3e");
            this._sizers = g.query(".sizer", d);
            b = g.query(".titlePane", d)[0];
            B.setSelectable(b, !1);
            this._title = g.query(".title", b)[0];
            this._prevFeatureButton = g.query(".prev", b)[0];
            this._nextFeatureButton = g.query(".next", b)[0];
            this._maxButton =
                g.query(".maximize", b)[0];
            this._spinner = g.query(".spinner", b)[0];
            this._contentPane = g.query(".contentPane", d)[0];
            this._positioner = g.query(".esriPopupWrapper", d)[0];
            this._pointer = g.query(".pointer", d)[0];
            this._outerPointer = g.query(".outerPointer", d)[0];
            this._actionList = g.query(".actionsPane .actionList", d)[0];
            this._eventConnections = [f.connect(g.query(".close", b)[0], "onclick", this, this.hide), f.connect(this._prevFeatureButton, "onclick", this, this.selectPrevious), f.connect(this._nextFeatureButton, "onclick",
                this, this.selectNext), f.connect(this._maxButton, "onclick", this, this._toggleSize), f.connect(g.query(".zoomTo", this._actionList)[0], "onclick", this, this._zoomToFeature), f.connect(this, "onClearFeatures", this, this._featuresCleared), f.connect(this, "onSelectionChange", this, this._featureSelected), f.connect(this, "onDfdComplete", this, this._updateUI)];
            E("esri-touch") && (d = I.setScrollable(this._contentPane), this._eventConnections.push(d[0], d[1]));
            this._toggleVisibility(!1)
        },
        onMaximize: function() {},
        onRestore: function() {},
        setMap: function(a) {
            this.inherited(arguments);
            C.place(this.domNode, a.root);
            this.highlight && this.enableHighlight(a);
            this._maxHeight = n.get(this._contentPane, "maxHeight")
        },
        unsetMap: function() {
            this.disableHighlight(this.map);
            this.inherited(arguments)
        },
        setTitle: function(a) {
            if (this.popupWindow) {
                if (!u.isDefined(a) || "" === a) a = "\x26nbsp;";
                this.destroyDijits(this._title);
                this.place(a, this._title);
                this.isShowing && (this.startupDijits(this._title), this.reposition())
            }
        },
        setContent: function(a) {
            if (this.popupWindow) {
                if (!u.isDefined(a) ||
                    "" === a) a = "\x26nbsp;";
                this.destroyDijits(this._contentPane);
                this.place(a, this._contentPane);
                this.isShowing && (this.startupDijits(this._contentPane), this.reposition())
            }
        },
        show: function(a, c) {
            if (this.popupWindow)
                if (this._delayHide = !1, a) {
                    var b = this.map,
                        d;
                    a.spatialReference ? (this.location = a, d = b.toScreen(a)) : (this.location = b.toMap(a), d = a);
                    var p = b._getFrameWidth();
                    if (-1 !== p && (d.x %= p, 0 > d.x && (d.x += p), b.width > p))
                        for (b = (b.width - p) / 2; d.x < b;) d.x += p;
                    this._maximized ? this.restore() : this._setPosition(d);
                    c && c.closestFirst &&
                        this.showClosestFirst(this.location);
                    this.isShowing || (this._toggleVisibility(!0), this._followMap(), this.startupDijits(this._title), this.startupDijits(this._contentPane), this.reposition(), this.showHighlight(), this.onShow())
                } else this._toggleVisibility(!0)
        },
        hide: function() {
            this.isShowing && (this._toggleVisibility(!1), this._unfollowMap(), this.keepHighlightOnHide || this.hideHighlight(), this.onHide())
        },
        resize: function(a, c) {
            this.popupWindow && (this._sizers.style({
                width: a + "px"
            }), n.set(this._contentPane, "maxHeight",
                c + "px"), this._maxHeight = c, this.isShowing && this.reposition())
        },
        reposition: function() {
            this.popupWindow && this.map && (this.location && !this._maximized && this.isShowing) && this._setPosition(this.map.toScreen(this.location))
        },
        maximize: function() {
            var a = this.map;
            if (a && !this._maximized && this.popupWindow) {
                this._maximized = !0;
                var c = this._maxButton;
                e.remove(c, "maximize");
                e.add(c, "restore");
                t.set(c, "title", this._nls.NLS_restore);
                var c = this.marginLeft,
                    b = this.marginTop,
                    d = a.width - 2 * c,
                    a = a.height - 2 * b;
                n.set(this.domNode, {
                    left: this._isRTL ? null : c + "px",
                    right: this._isRTL ? c + "px" : null,
                    top: b + "px",
                    bottom: null
                });
                n.set(this._positioner, {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                });
                this._savedWidth = n.get(this._sizers[0], "width");
                this._savedHeight = n.get(this._contentPane, "maxHeight");
                this._sizers.style({
                    width: d + "px"
                });
                n.set(this._contentPane, {
                    maxHeight: a - 65 + "px",
                    height: a - 65 + "px"
                });
                this._showPointer("");
                this._unfollowMap();
                e.add(this.domNode, "esriPopupMaximized");
                this.onMaximize()
            }
        },
        restore: function() {
            if (this.map && this._maximized &&
                this.popupWindow) {
                this._maximized = !1;
                var a = this._maxButton;
                e.remove(a, "restore");
                e.add(a, "maximize");
                t.set(a, "title", this._nls.NLS_maximize);
                n.set(this._contentPane, "height", null);
                this.resize(this._savedWidth, this._savedHeight);
                this._savedWidth = this._savedHeight = null;
                this.show(this.location);
                this._followMap();
                e.remove(this.domNode, "esriPopupMaximized");
                this.onRestore()
            }
        },
        startup: function() {},
        destroy: function() {
            this.map && this.unsetMap();
            this.cleanup();
            this.isShowing && this.hide();
            this.destroyDijits(this._title);
            this.destroyDijits(this._content);
            q.forEach(this._eventConnections, f.disconnect);
            C.destroy(this.domNode);
            this._sizers = this._contentPane = this._actionList = this._positioner = this._pointer = this._outerPointer = this._title = this._prevFeatureButton = this._nextFeatureButton = this._spinner = this._eventConnections = this._pagerScope = this._targetLocation = this._nls = this._maxButton = null
        },
        selectNext: function() {
            this.select(this.selectedIndex + 1)
        },
        selectPrevious: function() {
            this.select(this.selectedIndex - 1)
        },
        setFeatures: function() {
            this.inherited(arguments);
            this._updateUI()
        },
        postscript: null,
        _highlightSetter: function(a) {
            var c = this.highlight,
                b = this.map;
            this.highlight = a;
            if (b && a !== c)
                if (a) {
                    if (this.enableHighlight(b), a = this.features && this.features[this.selectedIndex]) this.updateHighlight(b, a), this.showHighlight()
                } else this.disableHighlight(b)
        },
        _pagingControlsSetter: function(a) {
            var c = this.pagingControls,
                b = this.map;
            this.pagingControls = a;
            b && a !== c && this._updatePagingControls()
        },
        _pagingInfoSetter: function(a) {
            var c = this.pagingInfo,
                b = this.map;
            this.pagingInfo = a;
            b &&
                (a !== c && this.features && this.features.length) && this._updatePagingInfo()
        },
        _popupWindowSetter: function(a) {
            var c = this.popupWindow,
                b = this.map;
            this.popupWindow = a;
            b && a !== c && (a ? (this._updateUI(), this._updateWindow()) : (this.hide(), this.showHighlight()))
        },
        _anchorSetter: function(a) {
            var c = this.anchor;
            this.anchor = a;
            this.map && a !== c && this.reposition()
        },
        _featuresCleared: function() {
            this.setTitle("\x26nbsp;");
            this.setContent("\x26nbsp;");
            this._setPagerCallbacks(this);
            this._updateUI();
            this.hideHighlight()
        },
        _featureSelected: function() {
            this._updateUI();
            this._updateWindow()
        },
        _updateWindow: function() {
            var a = this.selectedIndex;
            if (0 <= a) {
                var c = this.features[a].getContent(),
                    b;
                !this.titleInBody && c && y.isString(c.id) && (b = H.byId(c.id)) && (b.set && /_PopupRenderer/.test(b.declaredClass)) && b.set("showTitle", !1);
                this.setContent(c);
                this.updateHighlight(this.map, this.features[a]);
                this.showHighlight()
            }
        },
        _toggleVisibility: function(a) {
            this._setVisibility(a);
            this.isShowing = a
        },
        _setVisibility: function(a) {
            n.set(this.domNode, "visibility", a ? "visible" : "hidden");
            e.toggle(this.domNode,
                "esriPopupVisible", a)
        },
        _waitAndHide: function(a) {
            var c = this;
            this._delayHide = !0;
            setTimeout(function() {
                c._delayHide && (c._delayHide = !1, c.hide())
            }, a)
        },
        _followMap: function() {
            this._unfollowMap();
            var a = this.map;
            this._handles = [f.connect(a, "onPanStart", this, this._onPanStart), f.connect(a, "onPan", this, this._onPan), f.connect(a, "onZoomStart", this, this._onZoomStart), f.connect(a, "onExtentChange", this, this._onExtentChange)]
        },
        _unfollowMap: function() {
            var a = this._handles;
            a && (q.forEach(a, f.disconnect), this._handles = null)
        },
        _onPanStart: function() {
            var a = this.domNode.style;
            this._panOrigin = {
                left: a.left,
                top: a.top,
                right: a.right,
                bottom: a.bottom
            }
        },
        _onPan: function(a, c) {
            var b = this._panOrigin,
                d = c.x,
                p = c.y,
                e = b.left,
                h = b.top,
                r = b.right,
                b = b.bottom;
            e && (e = parseFloat(e) + d + "px");
            h && (h = parseFloat(h) + p + "px");
            r && (r = parseFloat(r) - d + "px");
            b && (b = parseFloat(b) - p + "px");
            n.set(this.domNode, {
                left: e,
                top: h,
                right: r,
                bottom: b
            })
        },
        _onZoomStart: function() {
            this._setVisibility(!1)
        },
        _onExtentChange: function(a, c, b) {
            b && (this._setVisibility(!0), this.show(this._targetLocation ||
                this.location));
            this._targetLocation = null
        },
        _toggleSize: function() {
            this._maximized ? this.restore() : this.maximize()
        },
        _setPosition: function(a) {
            var c = a.x,
                b = a.y;
            a = this.offsetX || 0;
            var d = this.offsetY || 0,
                e = 0,
                f = 0,
                h = A.position(this.map.container, !0),
                r = h.w,
                g = h.h,
                l = "Left",
                m = "bottom",
                s = A.getContentBox(this._positioner),
                q = s.w / 2,
                y = s.h / 2,
                v = n.get(this._sizers[0], "height") + this._maxHeight + n.get(this._sizers[2], "height"),
                z = v / 2,
                t = 0,
                u = 0,
                w = c,
                x = b,
                k = this.anchor.toLowerCase();
            if ("auto" === k) {
                if (k = F.getBox) k = k(), t = Math.max(k.l,
                    h.x), r = Math.min(k.l + k.w, h.x + h.w), u = Math.max(k.t, h.y), g = Math.min(k.t + k.h, h.y + h.h), w += h.x, x += h.y;
                h = x - u >= v;
                v = g - x >= v;
                k = r - w >= s.w;
                s = w - t >= s.w;
                x - u > z && g - x >= z && (k ? (m = "", l = "Left") : s && (m = "", l = "Right"));
                l && m && (w - t > q && r - w >= q) && (h ? (l = "", m = "bottom") : v && (l = "", m = "top"));
                l && m && (k && h ? (l = "Left", m = "bottom") : k && v ? (l = "Left", m = "top") : s && v ? (l = "Right", m = "top") : s && h && (l = "Right", m = "bottom"))
            } else m = l = "", -1 !== k.indexOf("top") ? m = "bottom" : -1 !== k.indexOf("bottom") && (m = "top"), -1 !== k.indexOf("left") ? l = "Right" : -1 !== k.indexOf("right") &&
                (l = "Left");
            z = m + l;
            switch (z) {
                case "top":
                case "bottom":
                    f = 14;
                    break;
                case "Left":
                case "Right":
                    e = 13;
                    break;
                case "topLeft":
                case "topRight":
                case "bottomLeft":
                case "bottomRight":
                    f = 14, e = -16
            }
            n.set(this.domNode, {
                left: c + "px",
                top: b + "px",
                right: null,
                bottom: null
            });
            c = {
                left: null,
                right: null,
                top: null,
                bottom: null
            };
            l ? c[l.toLowerCase()] = e + a + "px" : c.left = -q + "px";
            m ? c[m] = f + d + "px" : c.top = -y + "px";
            n.set(this._positioner, c);
            this._showPointer(z)
        },
        _showPointer: function(a) {
            e.remove(this._pointer, "top bottom right left topLeft topRight bottomRight bottomLeft hidden".split(" "));
            e.remove(this._outerPointer, ["right", "left", "hidden"]);
            "Right" === a || "Left" === a ? (a = a.toLowerCase(), e.add(this._outerPointer, a)) : e.add(this._pointer, a)
        },
        _setPagerCallbacks: function(a, c, b) {
            if (this.pagingControls && !(a === this && (!this._pagerScope || this._pagerScope === this)) && a !== this._pagerScope) {
                this._pagerScope = a;
                a === this && (c = this.selectPrevious, b = this.selectNext);
                var d = this._eventConnections;
                f.disconnect(d[1]);
                f.disconnect(d[2]);
                c && (d[1] = f.connect(this._prevFeatureButton, "onclick", a, c));
                b && (d[2] = f.connect(this._nextFeatureButton,
                    "onclick", a, b))
            }
        },
        _getLocation: function(a) {
            var c = this.map,
                b, d, e = 0,
                f;
            if (a = a && a.geometry) switch (a.type) {
                case "point":
                    b = a;
                    break;
                case "multipoint":
                    b = a.getPoint(0);
                    d = a.getExtent();
                    break;
                case "polyline":
                    b = a.getPoint(0, 0);
                    d = a.getExtent(); - 1 !== c._getFrameWidth() && (q.forEach(a.paths, function(a) {
                        a = (new J({
                            paths: [a, c.spatialReference]
                        })).getExtent();
                        var b = Math.abs(a.ymax - a.ymin),
                            d = Math.abs(a.xmax - a.xmin),
                            b = d > b ? d : b;
                        b > e && (e = b, f = a)
                    }), f.spatialReference = d.spatialReference, d = f);
                    break;
                case "polygon":
                    b = a.getPoint(0,
                        0), d = a.getExtent(), -1 !== c._getFrameWidth() && (q.forEach(a.rings, function(a) {
                        a = (new K({
                            rings: [a, c.spatialReference]
                        })).getExtent();
                        var b = Math.abs(a.ymax - a.ymin),
                            d = Math.abs(a.xmax - a.xmin),
                            b = d > b ? d : b;
                        b > e && (e = b, f = a)
                    }), f.spatialReference = d.spatialReference, d = f)
            }
            return [b, d]
        },
        _zoomToFeature: function(a) {
            a.preventDefault();
            var c = this.features,
                b = this.selectedIndex;
            a = this.map;
            if (c) {
                b = this._getLocation(c[b]);
                c = b[0];
                b = b[1];
                c || (c = this.location);
                if (!b || !b.intersects(this.location)) this.location = c;
                if (b && b.getWidth() &&
                    b.getHeight()) a.setExtent(b, !0);
                else {
                    var d = a.getNumLevels(),
                        b = a.getLevel(),
                        e = a.getMaxZoom(),
                        f = this.zoomFactor || 1;
                    0 < d ? b !== e && (d = b + f, d > e && (d = e), a.navigationManager._wheelZoom({
                        value: d - b,
                        mapPoint: c
                    }, !0)) : a.navigationManager._wheelZoom({
                        value: 2 * (1 / Math.pow(2, f)),
                        mapPoint: c
                    }, !0)
                }
            }
        },
        _updatePagingControls: function() {
            var a = this._prevFeatureButton,
                c = this._nextFeatureButton,
                b = this.selectedIndex,
                d = this.features ? this.features.length : 0;
            this.pagingControls && 1 < d ? (0 === b ? e.add(a, "hidden") : e.remove(a, "hidden"), b ===
                d - 1 ? e.add(c, "hidden") : e.remove(c, "hidden")) : (e.add(a, "hidden"), e.add(c, "hidden"))
        },
        _updatePagingInfo: function() {
            var a = this.features ? this.features.length : 0,
                c = this._nls,
                b = "\x26nbsp;";
            this.pagingInfo && (1 < a && c.NLS_pagingInfo) && (b = u.substitute({
                index: this.selectedIndex + 1,
                total: a
            }, c.NLS_pagingInfo));
            if (a && (c = this.getSelectedFeature(), a = c.getInfoTemplate(), c = c.getTitle(), (!a || /esri\.InfoTemplate/.test(a.declaredClass) || !this.titleInBody) && c)) b = c + ("\x26nbsp;" === b ? "" : " " + b);
            this.setTitle(b)
        },
        _updateUI: function() {
            if (this.popupWindow) {
                var a =
                    this.features,
                    c = this.deferreds,
                    b = a ? a.length : 0,
                    d = this._spinner,
                    f = this._actionList,
                    g = this._nls;
                this._updatePagingControls();
                this._updatePagingInfo();
                b ? e.remove(f, "hidden") : e.add(f, "hidden");
                c && c.length ? a ? e.remove(d, "hidden") : this.setContent("\x3cdiv style\x3d'text-align: center;'\x3e" + g.NLS_searching + "...\x3c/div\x3e") : (e.add(d, "hidden"), b || (this.setContent("\x3cdiv style\x3d'text-align: center;'\x3e" + g.NLS_noInfo + ".\x3c/div\x3e"), this.visibleWhenEmpty || this._waitAndHide(this.hideDelay)))
            }
        }
    })
});
},
'esri/InfoWindowBase':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/Deferred", "dojo/dom-construct", "dojo/has", "dijit/registry", "./kernel", "./lang", "./geometry/ScreenPoint"], function(l, f, g, e, m, n, q, h, r, k, p) {
    return l(null, {
        declaredClass: "esri.InfoWindowBase",
        constructor: function() {
            var a = f.hitch;
            this.__set_title = a(this, this.__set_title);
            this.__err_title = a(this, this.__err_title);
            this.__set_content = a(this, this.__set_content);
            this.__err_content = a(this, this.__err_content)
        },
        setMap: function(a) {
            this.map =
                a
        },
        unsetMap: function(a) {
            delete this.map
        },
        setTitle: function() {},
        setContent: function() {},
        show: function() {},
        hide: function() {},
        resize: function() {},
        onShow: function() {},
        onHide: function() {},
        place: function(a, b) {
            k.isDefined(a) ? f.isObject(a) ? n.place(a, b, "only") : b.innerHTML = a : b.innerHTML = ""
        },
        startupDijits: function(a) {
            this._processDijits(a)
        },
        destroyDijits: function(a) {
            this._processDijits(a, !0)
        },
        _processDijits: function(a, b) {
            if (a && 1 === a.children.length) {
                var c = a.children[0];
                if (c) {
                    var d = h.byNode(c),
                        c = d ? [d] : h.findWidgets(c);
                    g.forEach(c, function(a) {
                        if (b) {
                            if (a._started && !a._destroyed) try {
                                a.destroyRecursive ? a.destroyRecursive() : a.destroy && a.destroy()
                            } catch (c) {
                                console.debug("An error occurred when destroying a widget embedded within InfoWindow: " + c.message)
                            }
                        } else if (!a._started) try {
                            a.startup()
                        } catch (d) {
                            console.debug("An error occurred when starting a widget embedded within InfoWindow: " + d.message)
                        }
                    })
                }
            }
        },
        __registerMapListeners: function() {
            this.__unregisterMapListeners();
            var a = this.map;
            this.__handles = [e.connect(a, "onPan", this,
                this.__onMapPan), e.connect(a, "onZoomStart", this, this.__onMapZmStart), e.connect(a, "onExtentChange", this, this.__onMapExtChg)]
        },
        __unregisterMapListeners: function() {
            var a = this.__handles;
            a && (g.forEach(a, e.disconnect, e), this.__handles = null)
        },
        __onMapPan: function(a, b) {
            this.move(b, !0)
        },
        __onMapZmStart: function() {
            this.__mcoords = this.mapCoords || this.map.toMap(new p(this.coords));
            this.hide(null, !0)
        },
        __onMapExtChg: function(a, b, c) {
            a = this.map;
            var d = this.mapCoords;
            d ? this.show(d, null, !0) : (b = c ? a.toScreen(this.__mcoords) :
                this.coords.offset(b && b.x || 0, b && b.y || 0), this.show(b, null, !0))
        },
        __setValue: function(a, b) {
            this[a].innerHTML = "";
            var c = "_dfd" + a,
                d = this[c];
            d && -1 === d.fired && (d.cancel(), this[c] = null);
            k.isDefined(b) && (b instanceof m ? (this[c] = b, b.addCallbacks(this["__set" + a], this["__err" + a])) : this.__render(a, b))
        },
        __set_title: function(a) {
            this._dfd_title = null;
            this.__render("_title", a)
        },
        __err_title: function(a) {
            this._dfd_title = null
        },
        __set_content: function(a) {
            this._dfd_content = null;
            this.__render("_content", a)
        },
        __err_content: function(a) {
            this._dfd_content =
                null
        },
        __render: function(a, b) {
            var c = this[a];
            this.place(b, c);
            this.isShowing && (this.startupDijits(c), "_title" === a && this._adjustContentArea && this._adjustContentArea())
        }
    })
});
},
'esri/PopupBase':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/Color", "dojo/_base/Deferred", "dojo/has", "./kernel", "./graphic", "./geometry/Point", "./geometry/jsonUtils", "./geometry/mathUtils", "./geometry/webMercatorUtils", "./symbols/SimpleMarkerSymbol", "./symbols/SimpleLineSymbol", "./symbols/CartographicLineSymbol", "./symbols/SimpleFillSymbol", "./tasks/query", "./Evented", "require"], function(v, n, d, p, w, E, F, x, y, z, A, s, t, q, r, u, B, C) {
    function D(a) {
        return "sizeInfo" === a.type
    }
    return v(C, {
        declaredClass: "esri.PopupBase",
        _featureLayers: {},
        _updateEndHandles: [],
        _evtMap: {
            "set-features": !0,
            "clear-features": !0,
            "selection-change": !0,
            "dfd-complete": !0
        },
        onSetFeatures: function() {},
        onClearFeatures: function() {},
        onSelectionChange: function() {},
        onDfdComplete: function() {},
        initialize: function() {
            this.count = 0;
            this.selectedIndex = -1;
            this.on("clear-features", n.hitch(this, this._resetUpdateEndListeners));
            this.on("dfd-complete", n.hitch(this, this._processFeatures));
            this.on("set-features", n.hitch(this, this._processFeatures))
        },
        cleanup: function() {
            this.features =
                this.deferreds = null;
            this._resetUpdateEndListeners()
        },
        setFeatures: function(a) {
            if (a && a.length) {
                this.clearFeatures();
                var b, c;
                a[0] instanceof w ? c = a : b = a;
                b ? this._updateFeatures(null, b) : (this.deferreds = c, c = c.slice(0), d.forEach(c, function(a) {
                    a.addBoth(n.hitch(this, this._updateFeatures, a))
                }, this))
            }
        },
        clearFeatures: function() {
            this.features = this.deferreds = this._marked = null;
            this.count = 0;
            var a = this.selectedIndex;
            this.selectedIndex = -1;
            if (-1 < a) this.onSelectionChange();
            this.onClearFeatures()
        },
        getSelectedFeature: function() {
            var a =
                this.features;
            if (a) return a[this.selectedIndex]
        },
        select: function(a) {
            0 > a || a >= this.count || (this.selectedIndex = a, this.onSelectionChange())
        },
        enableHighlight: function(a) {
            this._highlighted = a.graphics.add(new x(new y(0, 0, a.spatialReference)));
            this._highlighted.hide();
            this.markerSymbol || (a = this.markerSymbol = new t, a.setStyle(t.STYLE_TARGET), a._setDim(16, 16, 0), a.setOutline(new r(q.STYLE_SOLID, new p([0, 255, 255]), 2, r.CAP_ROUND, r.JOIN_ROUND)), a.setColor(new p([0, 0, 0, 0])));
            this.lineSymbol || (this.lineSymbol = new q(q.STYLE_SOLID,
                new p([0, 255, 255]), 2));
            this.fillSymbol || (this.fillSymbol = new u(u.STYLE_NULL, new q(q.STYLE_SOLID, new p([0, 255, 255]), 2), new p([0, 0, 0, 0])))
        },
        disableHighlight: function(a) {
            var b = this._highlighted;
            b && (b.hide(), a.graphics.remove(b), delete this._highlighted);
            this.markerSymbol = this.lineSymbol = this.fillSymbol = null
        },
        showHighlight: function() {
            var a = this.features && this.features[this.selectedIndex];
            this._highlighted && (a && a.geometry) && this._highlighted.show()
        },
        hideHighlight: function() {
            this._highlighted && this._highlighted.hide()
        },
        updateHighlight: function(a, b) {
            var c = b.geometry,
                f = this._highlighted;
            if (!c || !f) f && f.hide();
            else {
                f.hide();
                !f._graphicsLayer && a && a.graphics.add(f);
                f.setGeometry(z.fromJson(c.toJson()));
                var e;
                switch (c.type) {
                    case "point":
                    case "multipoint":
                        e = this.markerSymbol;
                        e.setOffset(0, 0);
                        e.setAngle(0);
                        var g = b.getLayer();
                        if (g) {
                            var c = g._getSymbol(b),
                                l, h, d = 0,
                                m = 0,
                                k = 0;
                            if (c) {
                                g = !b.symbol ? g._getRenderer(b) : null;
                                if (d = this._getSizeInfo(g)) l = h = g.getSize(b, {
                                    sizeInfo: d,
                                    shape: c.style,
                                    resolution: a && a.getResolutionInMeters && a.getResolutionInMeters()
                                });
                                else switch (c.type) {
                                    case "simplemarkersymbol":
                                        l = h = c.size || 0;
                                        break;
                                    case "picturemarkersymbol":
                                        l = c.width || 0, h = c.height || 0
                                }
                                d = c.xoffset || 0;
                                m = c.yoffset || 0;
                                k = c.angle || 0
                            }
                            l && h && e._setDim(l + 1, h + 1, 0);
                            e.setOffset(d, m);
                            e.setAngle(k)
                        }
                        break;
                    case "polyline":
                        e = this.lineSymbol;
                        break;
                    case "polygon":
                        e = this.fillSymbol
                }
                f.setSymbol(e)
            }
        },
        showClosestFirst: function(a) {
            var b = this.features;
            if (b && b.length) {
                if (1 < b.length) {
                    var c, f = Infinity,
                        e = -1,
                        g, l = A.getLength,
                        h, d = a.spatialReference,
                        m, k;
                    a = a.normalize();
                    for (c = b.length - 1; 0 <= c; c--)
                        if (g =
                            b[c].geometry) {
                            m = g.spatialReference;
                            h = 0;
                            try {
                                k = "point" === g.type ? g : g.getExtent().getCenter(), k = k.normalize(), d && (m && !d.equals(m) && d._canProject(m)) && (k = d.isWebMercator() ? s.geographicToWebMercator(k) : s.webMercatorToGeographic(k)), h = l(a, k)
                            } catch (n) {}
                            0 < h && h < f && (f = h, e = c)
                        }
                    0 < e && (b.splice(0, 0, b.splice(e, 1)[0]), this.select(0))
                }
            } else this.deferreds && (this._marked = a)
        },
        _unbind: function(a) {
            a = d.indexOf(this.deferreds, a);
            if (-1 !== a) return this.deferreds.splice(a, 1), !this.deferreds.length ? (this.deferreds = null, 2) : 1
        },
        _fireComplete: function(a) {
            var b = this._marked;
            b && (this._marked = null, this.showClosestFirst(b));
            this.onDfdComplete(a)
        },
        _updateFeatures: function(a, b) {
            if (a) {
                if (this.deferreds) {
                    var c = this._unbind(a);
                    if (c)
                        if (b && b instanceof Error) {
                            if (this._fireComplete(b), 2 === c) this.onSetFeatures()
                        } else if (b && b.length)
                        if (this.features) {
                            var f = d.filter(b, function(a) {
                                return -1 === d.indexOf(this.features, a)
                            }, this);
                            this.features = this.features.concat(f);
                            this.count = this.features.length;
                            this._fireComplete();
                            if (2 === c) this.onSetFeatures()
                        } else {
                            this.features =
                                b;
                            this.count = b.length;
                            this.selectedIndex = 0;
                            this._fireComplete();
                            if (2 === c) this.onSetFeatures();
                            this.select(0)
                        } else if (this._fireComplete(), 2 === c) this.onSetFeatures()
                }
            } else this.features = b, this.count = b.length, this.selectedIndex = 0, this.onSetFeatures(), this.select(0)
        },
        _getSizeInfo: function(a) {
            return a ? a.sizeInfo || d.filter(a.visualVariables, D)[0] : null
        },
        _resetUpdateEndListeners: function() {
            this._featureLayers = {};
            d.forEach(this._updateEndHandles, function(a) {
                a.remove()
            });
            this._updateEndHandles = []
        },
        _processFeatures: function() {
            d.forEach(this.features,
                function(a) {
                    if ((a = a.getLayer()) && !this._featureLayers[a.id] && 1 === a.currentMode && a.objectIdField && a.hasXYFootprint && a.queryFeatures && ("esriGeometryPolygon" === a.geometryType || "esriGeometryPolyline" === a.geometryType || a.hasXYFootprint())) this._featureLayers[a.id] = a, a = a.on("update-end", n.hitch(this, this._fLyrUpdateEndHandler)), this._updateEndHandles.push(a)
                }, this)
        },
        _fLyrUpdateEndHandler: function(a) {
            if (!a.error) {
                var b = this,
                    c = a.target,
                    f = {},
                    e = [];
                d.forEach(this.features, function(a) {
                    if (a.getLayer() === c) {
                        var b =
                            a.attributes[c.objectIdField];
                        f[b] = a;
                        e.push(b)
                    }
                });
                e.length && (a = new B, a.objectIds = e, c.queryFeatures(a, function(a) {
                    d.forEach(a.features, function(a) {
                        var b = f[a.attributes[c.objectIdField]];
                        b.geometry !== a.geometry && (b.setGeometry(a.geometry), this._highlighted && b === this.getSelectedFeature() && this._highlighted.setGeometry(a.geometry))
                    }, b)
                }))
            }
        }
    })
});
},
'esri/graphic':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "./kernel", "./domUtils", "./lang", "./InfoTemplate", "./geometry/jsonUtils", "./symbols/jsonUtils"], function(e, f, n, p, g, h, k, l, m) {
    e = e(null, {
        declaredClass: "esri.Graphic",
        constructor: function(a, b, c, d) {
            a && !a.declaredClass ? (this.geometry = a.geometry ? l.fromJson(a.geometry) : null, this.symbol = a.symbol ? m.fromJson(a.symbol) : null, this.attributes = a.attributes || null, this.infoTemplate = a.infoTemplate ? new k(a.infoTemplate) : null) : (this.geometry = a, this.symbol = b, this.attributes =
                c, this.infoTemplate = d)
        },
        _shape: null,
        _graphicsLayer: null,
        _visible: !0,
        visible: !0,
        getDojoShape: function() {
            return this._shape
        },
        getShapes: function() {
            var a = [];
            this._shape && a.push(this._shape);
            this._bgShape && a.push(this._bgShape);
            return a
        },
        getNode: function() {
            var a = this._shape && this._shape.getNode();
            return a && a.nodeType ? a : null
        },
        getNodes: function() {
            var a = this.getShapes(),
                b, c, d = a.length,
                e = [];
            for (c = 0; c < d; c++)(b = a[c] && a[c].getNode()) && b.nodeType && e.push(b);
            return e
        },
        getLayer: function() {
            return this._layer
        },
        draw: function() {
            var a =
                this._graphicsLayer;
            a && a._draw(this, !0);
            return this
        },
        setGeometry: function(a) {
            this.geometry = a;
            if (a = this._graphicsLayer) a._updateExtent(this), a._draw(this, !0);
            return this
        },
        setSymbol: function(a, b) {
            var c = this._graphicsLayer,
                d = this._shape;
            this.symbol = a;
            c && (b && d && c._removeShape(this), c._draw(this, !0));
            return this
        },
        setAttributes: function(a) {
            this.attributes = a;
            return this
        },
        setInfoTemplate: function(a) {
            this.infoTemplate = a;
            return this
        },
        getInfoTemplate: function() {
            return this._getEffInfoTemplate()
        },
        _getEffInfoTemplate: function() {
            var a =
                this.getLayer();
            return this.infoTemplate || a && a.infoTemplate
        },
        getTitle: function() {
            var a = this.getInfoTemplate(),
                b = a && a.title;
            if (f.isFunction(b)) b = b.call(a, this);
            else if (f.isString(b)) var c = (a = this.getLayer()) && a._getDateOpts,
                b = h.substitute(this.attributes, b, {
                    first: !0,
                    dateFormat: c && c.call(a)
                });
            return b
        },
        getContent: function() {
            var a = this.getInfoTemplate(),
                b = a && a.content;
            if (f.isFunction(b)) b = b.call(a, this);
            else if (f.isString(b)) var c = (a = this.getLayer()) && a._getDateOpts,
                b = h.substitute(this.attributes, b, {
                    dateFormat: c && c.call(a)
                });
            return b
        },
        attr: function(a, b) {
            var c = this.getNodes(),
                d, e = c.length;
            for (d = 0; d < e; d++) null == b ? c[d].removeAttribute(a) : c[d].setAttribute(a, b);
            return this
        },
        show: function() {
            this.visible = this._visible = !0;
            var a, b, c;
            if (this.getShapes().length) {
                a = this.getNodes();
                c = a.length;
                this.attr("data-hidden");
                for (b = 0; b < c; b++) g.show(a[b])
            } else this._graphicsLayer && this._graphicsLayer._draw(this, !0);
            return this
        },
        hide: function() {
            this.visible = this._visible = !1;
            var a = this._graphicsLayer,
                b, c;
            if (a)
                if ("canvas-2d" ===
                    a.surfaceType) a._removeShape(this);
                else if (a = this.getNodes(), c = a.length) {
                this.attr("data-hidden", "");
                for (b = 0; b < c; b++) g.hide(a[b])
            }
            return this
        },
        toJson: function() {
            var a = {};
            this.geometry && (a.geometry = this.geometry.toJson());
            this.attributes && (a.attributes = f.mixin({}, this.attributes));
            this.symbol && (a.symbol = this.symbol.toJson());
            this.infoTemplate && (a.infoTemplate = this.infoTemplate.toJson());
            return a
        }
    });
    e.prototype.getShape = e.prototype.getDojoShape;
    return e
});
},
'esri/InfoTemplate':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "./kernel", "./lang"], function(b, c, e, f, d) {
    return b(null, {
        declaredClass: "esri.InfoTemplate",
        constructor: function(a, b) {
            a && c.isObject(a) && !c.isFunction(a) ? c.mixin(this, a) : (this.title = a || "${*}", this.content = b || "${*}")
        },
        setTitle: function(a) {
            this.title = a;
            return this
        },
        setContent: function(a) {
            this.content = a;
            return this
        },
        toJson: function() {
            return d.fixJson({
                title: this.title,
                content: this.content
            })
        }
    })
});
},
'esri/geometry/jsonUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "../kernel", "./Point", "./Polyline", "./Polygon", "./Multipoint", "./Extent"], function(g, h, k, b, c, d, e, f) {
    return {
        fromJson: function(a) {
            if (void 0 !== a.x && void 0 !== a.y) return new b(a);
            if (void 0 !== a.paths) return new c(a);
            if (void 0 !== a.rings) return new d(a);
            if (void 0 !== a.points) return new e(a);
            if (void 0 !== a.xmin && void 0 !== a.ymin && void 0 !== a.xmax && void 0 !== a.ymax) return new f(a)
        },
        getJsonType: function(a) {
            return a instanceof b ? "esriGeometryPoint" : a instanceof c ? "esriGeometryPolyline" :
                a instanceof d ? "esriGeometryPolygon" : a instanceof f ? "esriGeometryEnvelope" : a instanceof e ? "esriGeometryMultipoint" : null
        },
        getGeometryType: function(a) {
            return "esriGeometryPoint" === a ? b : "esriGeometryPolyline" === a ? c : "esriGeometryPolygon" === a ? d : "esriGeometryEnvelope" === a ? f : "esriGeometryMultipoint" === a ? e : null
        }
    }
});
},
'esri/symbols/jsonUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "../kernel", "./SimpleMarkerSymbol", "./PictureMarkerSymbol", "./SimpleLineSymbol", "./CartographicLineSymbol", "./SimpleFillSymbol", "./PictureFillSymbol", "./TextSymbol"], function(l, m, n, d, e, f, c, g, h, k) {
    return {
        fromJson: function(a) {
            var b = null;
            switch (a.type) {
                case "esriSMS":
                    b = new d(a);
                    break;
                case "esriPMS":
                    b = new e(a);
                    break;
                case "esriTS":
                    b = new k(a);
                    break;
                case "esriSLS":
                    b = void 0 !== a.cap ? new c(a) : new f(a);
                    break;
                case "esriCLS":
                    b = new c(a);
                    break;
                case "esriSFS":
                    b = new g(a);
                    break;
                case "esriPFS":
                    b =
                        new h(a)
            }
            return b
        },
        getShapeDescriptors: function(a) {
            return a && a.getShapeDescriptors ? a.getShapeDescriptors() : {
                defaultShape: null,
                fill: null,
                stroke: null
            }
        }
    }
});
},
'esri/symbols/PictureMarkerSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/sniff", "dojox/gfx/_base", "../kernel", "../lang", "../urlUtils", "./MarkerSymbol"], function(d, f, h, e, n, k, l, m) {
    var g = {
        url: "",
        width: 12,
        height: 12,
        angle: 0,
        xoffset: 0,
        yoffset: 0
    };
    d = d(m, {
        declaredClass: "esri.symbol.PictureMarkerSymbol",
        type: "picturemarkersymbol",
        constructor: function(a, c, b) {
            a ? f.isString(a) ? (this.url = a, c && (this.width = c), b && (this.height = b)) : (this.width = e.pt2px(a.width), this.height = e.pt2px(a.height), c = a.imageData, !(9 > h("ie")) && c && (b = this.url, this.url =
                "data:" + (a.contentType || "image") + ";base64," + c, this.imageData = b)) : (f.mixin(this, g), this.width = e.pt2px(this.width), this.height = e.pt2px(this.height))
        },
        getStroke: function() {
            return null
        },
        getFill: function() {
            return null
        },
        setWidth: function(a) {
            this.width = a;
            return this
        },
        setHeight: function(a) {
            this.height = a;
            return this
        },
        setUrl: function(a) {
            a !== this.url && (delete this.imageData, delete this.contentType);
            this.url = a;
            return this
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "image",
                    x: -Math.round(this.width /
                        2),
                    y: -Math.round(this.height / 2),
                    width: this.width,
                    height: this.height,
                    src: this.url || ""
                },
                fill: null,
                stroke: null
            }
        },
        toJson: function() {
            var a = this.url,
                c = this.imageData;
            if (0 === a.indexOf("data:")) var b = a,
                a = c,
                c = b.indexOf(";base64,") + 8,
                c = b.substr(c);
            if (f.isString(a) && (0 === a.indexOf("/") || 0 === a.indexOf("//") || 0 === a.indexOf("./") || 0 === a.indexOf("../"))) a = l.getAbsoluteUrl(a);
            var b = e.px2pt(this.width),
                b = isNaN(b) ? void 0 : b,
                d = e.px2pt(this.height),
                d = isNaN(d) ? void 0 : d,
                a = k.fixJson(f.mixin(this.inherited("toJson", arguments), {
                    type: "esriPMS",
                    url: a,
                    imageData: c,
                    contentType: this.contentType,
                    width: b,
                    height: d
                }));
            delete a.color;
            delete a.size;
            a.imageData || delete a.imageData;
            return a
        }
    });
    d.defaultProps = g;
    return d
});
},
'esri/symbols/CartographicLineSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Color", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "./SimpleLineSymbol"], function(b, d, m, p, e, q, f, n) {
    var c = {
            STYLE_SOLID: "solid",
            STYLE_DASH: "dash",
            STYLE_DOT: "dot",
            STYLE_DASHDOT: "dashdot",
            STYLE_DASHDOTDOT: "longdashdotdot",
            STYLE_NULL: "none",
            STYLE_INSIDE_FRAME: "insideframe",
            STYLE_SHORTDASH: "shortdash",
            STYLE_SHORTDOT: "shortdot",
            STYLE_SHORTDASHDOT: "shortdashdot",
            STYLE_SHORTDASHDOTDOT: "shortdashdotdot",
            STYLE_LONGDASH: "longdash",
            STYLE_LONGDASHDOT: "longdashdot",
            CAP_BUTT: "butt",
            CAP_ROUND: "round",
            CAP_SQUARE: "square",
            JOIN_MITER: "miter",
            JOIN_ROUND: "round",
            JOIN_BEVEL: "bevel"
        },
        g = {
            color: [0, 0, 0, 1],
            style: c.STYLE_SOLID,
            width: 1,
            cap: c.CAP_BUTT,
            join: c.JOIN_MITER,
            miterLimit: 10
        };
    b = b(n, {
        declaredClass: "esri.symbol.CartographicLineSymbol",
        type: "cartographiclinesymbol",
        _caps: {
            butt: "esriLCSButt",
            round: "esriLCSRound",
            square: "esriLCSSquare"
        },
        _joins: {
            miter: "esriLJSMiter",
            round: "esriLJSRound",
            bevel: "esriLJSBevel"
        },
        constructor: function(a, b, c, h, k, l) {
            a ? d.isString(a) ? (this.style = a,
                b && (this.color = b), void 0 !== c && (this.width = c), h && (this.cap = h), k && (this.join = k), void 0 !== l && (this.miterLimit = l)) : (this.cap = f.valueOf(this._caps, a.cap), this.join = f.valueOf(this._joins, a.join), this.width = e.pt2px(a.width), this.miterLimit = e.pt2px(a.miterLimit)) : (d.mixin(this, g), this.color = new m(this.color), this.width = e.pt2px(this.width), this.miterLimit = e.pt2px(this.miterLimit))
        },
        setCap: function(a) {
            this.cap = a;
            return this
        },
        setJoin: function(a) {
            this.join = a;
            return this
        },
        setMiterLimit: function(a) {
            this.miterLimit =
                a;
            return this
        },
        getStroke: function() {
            return d.mixin(this.inherited("getStroke", arguments), {
                cap: this.cap,
                join: this.join === c.JOIN_MITER ? this.miterLimit : this.join
            })
        },
        getFill: function() {
            return null
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "path",
                    path: "M -15,0 L 15,0 E"
                },
                fill: null,
                stroke: this.getStroke()
            }
        },
        toJson: function() {
            var a = e.px2pt(this.miterLimit),
                a = isNaN(a) ? void 0 : a;
            return f.fixJson(d.mixin(this.inherited("toJson", arguments), {
                type: "esriCLS",
                cap: this._caps[this.cap],
                join: this._joins[this.join],
                miterLimit: a
            }))
        }
    });
    d.mixin(b, c);
    b.defaultProps = g;
    return b
});
},
'esri/symbols/SimpleFillSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Color", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "./FillSymbol", "./SimpleLineSymbol", "require"], function(b, d, g, n, h, p, e, k, l, m) {
    var c = {
            STYLE_SOLID: "solid",
            STYLE_NULL: "none",
            STYLE_HORIZONTAL: "horizontal",
            STYLE_VERTICAL: "vertical",
            STYLE_FORWARD_DIAGONAL: "forwarddiagonal",
            STYLE_BACKWARD_DIAGONAL: "backwarddiagonal",
            STYLE_CROSS: "cross",
            STYLE_DIAGONAL_CROSS: "diagonalcross",
            STYLE_FORWARDDIAGONAL: "forwarddiagonal",
            STYLE_BACKWARDDIAGONAL: "backwarddiagonal",
            STYLE_DIAGONALCROSS: "diagonalcross"
        },
        f = {
            style: c.STYLE_SOLID,
            color: [0, 0, 0, 0.25]
        };
    b = b(k, {
        declaredClass: "esri.symbol.SimpleFillSymbol",
        type: "simplefillsymbol",
        patternUrlPrefix: m.toUrl("../images/symbol/sfs/"),
        _styles: {
            solid: "esriSFSSolid",
            none: "esriSFSNull",
            horizontal: "esriSFSHorizontal",
            vertical: "esriSFSVertical",
            forwarddiagonal: "esriSFSForwardDiagonal",
            backwarddiagonal: "esriSFSBackwardDiagonal",
            cross: "esriSFSCross",
            diagonalcross: "esriSFSDiagonalCross"
        },
        constructor: function(a, b, c) {
            a ? d.isString(a) ? (this.style =
                a, void 0 !== b && (this.outline = b), void 0 !== c && (this.color = c)) : this.style = e.valueOf(this._styles, a.style) : (d.mixin(this, f), this.outline = new l(this.outline), this.color = new g(this.color))
        },
        setStyle: function(a) {
            this.style = a;
            return this
        },
        getStroke: function() {
            return this.outline && this.outline.getStroke()
        },
        getFill: function() {
            var a = this.style;
            return a === c.STYLE_NULL ? null : a === c.STYLE_SOLID ? this.color : d.mixin({}, h.defaultPattern, {
                src: this.patternUrlPrefix + a + ".png",
                width: 10,
                height: 10
            })
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "path",
                    path: "M -10,-10 L 10,0 L 10,10 L -10,10 L -10,-10 E"
                },
                fill: this.getFill(),
                stroke: this.getStroke()
            }
        },
        toJson: function() {
            return e.fixJson(d.mixin(this.inherited("toJson", arguments), {
                type: "esriSFS",
                style: this._styles[this.style]
            }))
        }
    });
    d.mixin(b, c);
    b.defaultProps = f;
    return b
});
},
'esri/symbols/FillSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./Symbol", "./SimpleLineSymbol"], function(b, c, f, g, d, e) {
    return b(d, {
        declaredClass: "esri.symbol.FillSymbol",
        constructor: function(a) {
            a && (c.isObject(a) && a.outline) && (this.outline = new e(a.outline))
        },
        setOutline: function(a) {
            this.outline = a;
            return this
        },
        toJson: function() {
            var a = this.inherited("toJson", arguments);
            this.outline && (a.outline = this.outline.toJson());
            return a
        }
    })
});
},
'esri/symbols/PictureFillSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/sniff", "dojox/gfx/_base", "../kernel", "../lang", "../urlUtils", "./FillSymbol"], function(e, g, l, d, q, m, n, p) {
    var k = {
        xoffset: 0,
        yoffset: 0,
        width: 12,
        height: 12
    };
    e = e(p, {
        declaredClass: "esri.symbol.PictureFillSymbol",
        type: "picturefillsymbol",
        xscale: 1,
        yscale: 1,
        xoffset: 0,
        yoffset: 0,
        constructor: function(a, b, c, f) {
            a ? g.isString(a) ? (this.url = a, void 0 !== b && (this.outline = b), void 0 !== c && (this.width = c), void 0 !== f && (this.height = f)) : (this.xoffset = d.pt2px(a.xoffset), this.yoffset =
                d.pt2px(a.yoffset), this.width = d.pt2px(a.width), this.height = d.pt2px(a.height), b = a.imageData, !(9 > l("ie")) && b && (c = this.url, this.url = "data:" + (a.contentType || "image") + ";base64," + b, this.imageData = c)) : (g.mixin(this, k), this.width = d.pt2px(this.width), this.height = d.pt2px(this.height))
        },
        setWidth: function(a) {
            this.width = a;
            return this
        },
        setHeight: function(a) {
            this.height = a;
            return this
        },
        setOffset: function(a, b) {
            this.xoffset = a;
            this.yoffset = b;
            return this
        },
        setUrl: function(a) {
            a !== this.url && (delete this.imageData, delete this.contentType);
            this.url = a;
            return this
        },
        setXScale: function(a) {
            this.xscale = a;
            return this
        },
        setYScale: function(a) {
            this.yscale = a;
            return this
        },
        getStroke: function() {
            return this.outline && this.outline.getStroke()
        },
        getFill: function() {
            return g.mixin({}, d.defaultPattern, {
                src: this.url,
                width: this.width * this.xscale,
                height: this.height * this.yscale,
                x: this.xoffset,
                y: this.yoffset
            })
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "path",
                    path: "M -10,-10 L 10,0 L 10,10 L -10,10 L -10,-10 E"
                },
                fill: this.getFill(),
                stroke: this.getStroke()
            }
        },
        toJson: function() {
            var a = this.url,
                b = this.imageData;
            if (0 === a.indexOf("data:")) var c = a,
                a = b,
                b = c.indexOf(";base64,") + 8,
                b = c.substr(b);
            if (g.isString(a) && (0 === a.indexOf("/") || 0 === a.indexOf("//") || 0 === a.indexOf("./") || 0 === a.indexOf("../"))) a = n.getAbsoluteUrl(a);
            var c = d.px2pt(this.width),
                c = isNaN(c) ? void 0 : c,
                f = d.px2pt(this.height),
                f = isNaN(f) ? void 0 : f,
                e = d.px2pt(this.xoffset),
                e = isNaN(e) ? void 0 : e,
                h = d.px2pt(this.yoffset),
                h = isNaN(h) ? void 0 : h,
                a = m.fixJson(g.mixin(this.inherited("toJson", arguments), {
                    type: "esriPFS",
                    url: a,
                    imageData: b,
                    contentType: this.contentType,
                    width: c,
                    height: f,
                    xoffset: e,
                    yoffset: h,
                    xscale: this.xscale,
                    yscale: this.yscale
                }));
            a.imageData || delete a.imageData;
            return a
        }
    });
    e.defaultProps = k;
    return e
});
},
'esri/symbols/TextSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "../Color", "./Symbol", "./Font"], function(d, f, s, c, t, k, l, n, g) {
    var m = {
            type: "textsymbol",
            x: 0,
            y: 0,
            text: "",
            rotated: !1,
            kerning: !0,
            color: [0, 0, 0, 1],
            font: c.defaultFont,
            angle: 0,
            xoffset: 0,
            yoffset: 0,
            horizontalAlignment: "center"
        },
        p = {
            start: "left",
            middle: "center",
            end: "right"
        },
        q = {
            left: "start",
            center: "middle",
            right: "end",
            justify: "start"
        },
        r = {
            top: "text-before-edge",
            middle: "central",
            baseline: "alphabetic",
            bottom: "text-after-edge"
        },
        h = document.createElement("canvas");
    d = d(n, {
        declaredClass: "esri.symbol.TextSymbol",
        angle: 0,
        xoffset: 0,
        yoffset: 0,
        constructor: function(a, b, e) {
            f.mixin(this, m);
            this.font = new g(this.font);
            this.color = new l(this.color);
            a && (f.isObject(a) ? (f.mixin(this, a), this.color && k.isDefined(this.color[0]) && (this.color = l.toDojoColor(this.color)), this.type = "textsymbol", this.font = new g(this.font), this.xoffset = c.pt2px(this.xoffset), this.yoffset = c.pt2px(this.yoffset), this.angle && (this.angle *= -1)) : (this.text = a, b && (this.font = b),
                e && (this.color = e)));
            this.setAlign(this.align || this.getSVGAlign())
        },
        setFont: function(a) {
            this.font = a;
            return this
        },
        setSize: function(a) {
            this.font.size = a;
            return this
        },
        setAngle: function(a) {
            this.angle = a;
            return this
        },
        setOffset: function(a, b) {
            this.xoffset = a;
            this.yoffset = b;
            return this
        },
        setAlign: function(a) {
            this.align = a;
            this.setHorizontalAlignment(a && p[a.toLowerCase()] || "center");
            return this
        },
        setHorizontalAlignment: function(a) {
            this.horizontalAlignment = a;
            return this
        },
        getSVGAlign: function() {
            var a = this.horizontalAlignment;
            return a = a && q[a.toLowerCase()] || "middle"
        },
        setVerticalAlignment: function(a) {
            this.verticalAlignment = a;
            return this
        },
        getSVGBaseline: function() {
            var a = this.verticalAlignment;
            return a && r[a.toLowerCase()] || "alphabetic"
        },
        getSVGBaselineShift: function() {
            return "bottom" === this.verticalAlignment ? "super" : null
        },
        setDecoration: function(a) {
            this.decoration = a;
            this.font || this.setFont(new g);
            this.font.setDecoration(a);
            return this
        },
        setRotated: function(a) {
            this.rotated = a;
            return this
        },
        setKerning: function(a) {
            this.kerning = a;
            return this
        },
        setText: function(a) {
            this.text = a;
            return this
        },
        getStroke: function() {
            return null
        },
        getFill: function() {
            return this.color
        },
        getWidth: function() {
            var a = h && h.getContext && h.getContext("2d");
            if (a) {
                var b = this.font;
                a.font = (b.style ? b.style : c.defaultFont.style) + " " + (b.weight ? b.weight : c.defaultFont.weight) + " " + (b.size ? b.size : c.defaultFont.size) + "px " + (b.family ? b.family : c.defaultFont.family);
                return a.measureText(this.text).width
            }
            var a = this.getHeight(),
                b = 0,
                e, d;
            for (e = 0; e < this.text.length; e++) d = this.text.charAt(e),
                b = d == d.toUpperCase() ? b + 0.7 * a : b + 0.5 * a;
            return b
        },
        getHeight: function() {
            return c.normalizedLength(this.font.size)
        },
        toJson: function() {
            var a = c.px2pt(this.xoffset),
                b = c.px2pt(this.yoffset),
                a = isNaN(a) ? void 0 : a,
                b = isNaN(b) ? void 0 : b;
            return k.fixJson(f.mixin(this.inherited("toJson", arguments), {
                type: "esriTS",
                backgroundColor: this.backgroundColor,
                borderLineColor: this.borderLineColor,
                borderLineSize: this.borderLineSize,
                haloSize: this.haloSize,
                haloColor: this.haloColor,
                verticalAlignment: this.verticalAlignment,
                horizontalAlignment: this.horizontalAlignment,
                rightToLeft: this.rightToLeft,
                width: this.width,
                angle: this.angle && -1 * this.angle,
                xoffset: a,
                yoffset: b,
                text: this.text,
                rotated: this.rotated,
                kerning: this.kerning,
                font: this.font.toJson()
            }))
        }
    });
    f.mixin(d, {
        ALIGN_START: "start",
        ALIGN_MIDDLE: "middle",
        ALIGN_END: "end",
        DECORATION_NONE: "none",
        DECORATION_UNDERLINE: "underline",
        DECORATION_OVERLINE: "overline",
        DECORATION_LINETHROUGH: "line-through"
    });
    d.defaultProps = m;
    return d
});
},
'esri/symbols/Font':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/sniff", "dojox/gfx/_base", "../kernel", "../lang"], function(c, d, h, e, l, k) {
    c = c(null, {
        declaredClass: "esri.symbol.Font",
        constructor: function(a, b, c, f, g) {
            a ? d.isObject(a) ? d.mixin(this, a) : (this.size = a, parseFloat(this.size) == this.size && (this.size += "px"), void 0 !== b && (this.style = b), void 0 !== c && (this.variant = c), void 0 !== f && (this.weight = f), void 0 !== g && (this.family = g)) : d.mixin(this, e.defaultFont);
            parseFloat(this.size) == this.size && (this.size += "pt");
            9 > h("ie") && (this.size &&
                d.isString(this.size) && -1 < this.size.indexOf("em")) && (this.size = e.pt2px(12 * parseFloat(this.size)) + "px");
            this.size = this._convert2PxSize(this.size)
        },
        setSize: function(a) {
            this.size = this._convert2PxSize(a);
            return this
        },
        _convert2PxSize: function(a) {
            var b;
            parseFloat(a) == a ? b = a : d.isString(a) && (-1 < a.indexOf("pt") ? b = e.pt2px(parseFloat(a)) : -1 < a.indexOf("px") ? b = parseFloat(a) : -1 < a.indexOf("em") ? b = e.pt2px(12 * parseFloat(a)) : -1 < a.indexOf("%") && (b = e.pt2px(0.12 * parseFloat(a))));
            return b
        },
        setStyle: function(a) {
            this.style =
                a;
            return this
        },
        setVariant: function(a) {
            this.variant = a;
            return this
        },
        setWeight: function(a) {
            this.weight = a;
            return this
        },
        setFamily: function(a) {
            this.family = a;
            return this
        },
        setDecoration: function(a) {
            this.decoration = a;
            return this
        },
        toJson: function() {
            return k.fixJson({
                size: e.px2pt(this.size),
                style: this.style,
                variant: this.variant,
                decoration: this.decoration,
                weight: this.weight,
                family: this.family
            })
        }
    });
    d.mixin(c, {
        STYLE_NORMAL: "normal",
        STYLE_ITALIC: "italic",
        STYLE_OBLIQUE: "oblique",
        VARIANT_NORMAL: "normal",
        VARIANT_SMALLCAPS: "small-caps",
        WEIGHT_NORMAL: "normal",
        WEIGHT_BOLD: "bold",
        WEIGHT_BOLDER: "bolder",
        WEIGHT_LIGHTER: "lighter"
    });
    return c
});
},
'esri/tasks/query':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/has", "../kernel", "../geometry/jsonUtils", "./SpatialRelationship", "require", "require", "require"], function(p, q, r, c, u, v, s, t) {
    var d = p(null, {
        declaredClass: "esri.tasks.Query",
        constructor: function() {
            this.spatialRelationship = d.SPATIAL_REL_INTERSECTS
        },
        text: null,
        where: "",
        geometry: null,
        groupByFieldsForStatistics: null,
        objectIds: null,
        returnGeometry: !1,
        returnDistinctValues: !1,
        orderByFields: null,
        outSpatialReference: null,
        outFields: null,
        outStatistics: null,
        timeExtent: null,
        relationParam: null,
        pixelSize: null,
        distance: null,
        units: null,
        resultOffset: null,
        resultRecordCount: null,
        quantizationParameters: null,
        _units: {
            meters: "esriSRUnit_Meter",
            kilometers: "esriSRUnit_Kilometer",
            feet: "esriSRUnit_Foot",
            miles: "esriSRUnit_StatuteMile",
            "nautical-miles": "esriSRUnit_NauticalMile",
            "us-nautical-miles": "esriSRUnit_USNauticalMile"
        },
        toJson: function(e) {
            var a = {
                    text: this.text,
                    where: this.where,
                    returnGeometry: this.returnGeometry,
                    spatialRel: this.spatialRelationship,
                    maxAllowableOffset: this.maxAllowableOffset,
                    geometryPrecision: this.geometryPrecision
                },
                b = e && e.geometry || this.geometry,
                g = this.objectIds,
                h = this.outFields,
                f = this.outSpatialReference,
                k = this.groupByFieldsForStatistics,
                l = this.orderByFields,
                m = this.outStatistics;
            e = this.distance;
            b && (a.geometry = b, a.geometryType = s.getJsonType(b), a.inSR = b.spatialReference.wkid || c.toJson(b.spatialReference.toJson()));
            g && (a.objectIds = g.join(","));
            h && (a.outFields = h.join(","));
            this.returnDistinctValues && (a.returnDistinctValues = !0);
            k && (a.groupByFieldsForStatistics = k.join(","));
            l && (a.orderByFields = l.join(","));
            if (m) {
                var n = [];
                r.forEach(m, function(a) {
                    n.push(a.toJson())
                });
                a.outStatistics = c.toJson(n)
            }
            null !== f ? a.outSR = f.wkid || c.toJson(f.toJson()) : b && (a.outSR = b.spatialReference.wkid || c.toJson(b.spatialReference.toJson()));
            b = this.timeExtent;
            a.time = b ? b.toJson().join(",") : null;
            if ((b = this.relationParam) && this.spatialRelationship === d.SPATIAL_REL_RELATION) a.relationParam = b;
            e && (a.distance = this.distance, this.hasOwnProperty("units") ? a.units =
                this._units[this.units] || this._units.meters : (console.warn("esri/tasks/query::no distance unit provided, defaulting to meters"), a.units = this._units.meters));
            this.hasOwnProperty("start") && (a.resultOffset = this.start, a.resultRecordCount = 10, "" === a.where && (a.where = "1\x3d1"));
            this.hasOwnProperty("num") && (a.resultRecordCount = this.num);
            a.pixelSize = this.pixelSize ? c.toJson(this.pixelSize.toJson()) : null;
            a.multipatchOption = this.multipatchOption;
            this.quantizationParameters && (a.quantizationParameters = c.toJson(this.quantizationParameters));
            a._ts = this._ts;
            return a
        }
    });
    q.mixin(d, t);
    return d
});
},
'esri/tasks/SpatialRelationship':function(){
//>>built
define(["dojo/_base/lang", "dojo/has", "../kernel"], function(a, b, c) {
    return {
        SPATIAL_REL_INTERSECTS: "esriSpatialRelIntersects",
        SPATIAL_REL_CONTAINS: "esriSpatialRelContains",
        SPATIAL_REL_CROSSES: "esriSpatialRelCrosses",
        SPATIAL_REL_ENVELOPEINTERSECTS: "esriSpatialRelEnvelopeIntersects",
        SPATIAL_REL_INDEXINTERSECTS: "esriSpatialRelIndexIntersects",
        SPATIAL_REL_OVERLAPS: "esriSpatialRelOverlaps",
        SPATIAL_REL_TOUCHES: "esriSpatialRelTouches",
        SPATIAL_REL_WITHIN: "esriSpatialRelWithin",
        SPATIAL_REL_RELATION: "esriSpatialRelRelation"
    }
});
},
'esri/plugins/popupManager':function(){
//>>built
define(["../PopupManager"], function(c) {
    return {
        add: function(a, b) {
            a.popupManager || (a.popupManager = new c(b), a.popupManager.setMap(a))
        },
        remove: function(a) {
            var b = a.popupManager;
            b && (b.unsetMap(), a.popupManager = void 0)
        }
    }
});
},
'esri/PopupManager':function(){
//>>built
define(["./geometry/Extent", "./geometry/ScreenPoint", "./kernel", "./layerUtils", "./tasks/query", "dijit/registry", "dojo/_base/array", "dojo/_base/declare", "dojo/_base/Deferred", "dojo/_base/lang", "dojo/has", "dojo/on", "dojo/promise/all", "dojo/Stateful", "require"], function(E, u, M, C, F, G, f, H, v, w, N, I, J, K, L) {
    var x;
    return H(K, {
        declaredClass: "esri.PopupManager",
        enabled: !1,
        map: null,
        _mapClickHandle: null,
        _featureLayersCache: {},
        constructor: function(a) {
            this._mapClickHandler = w.hitch(this, this._mapClickHandler)
        },
        setMap: function(a) {
            if (this.map)
                if (a !==
                    this.map) this.unsetMap();
                else return;
            this.map = a;
            this._setupClickHandler()
        },
        unsetMap: function() {
            this.map && (this.map = null);
            this._mapClickHandle && (this._mapClickHandle.remove(), this._mapClickHandle = null)
        },
        getMapLayer: function(a) {
            var c;
            if (a && (c = a.getLayer()))
                if (a = c.id, this._featureLayersCache[a]) {
                    var b = a.lastIndexOf("_"); - 1 < b && (a = a.substring(0, b), c = this.map.getLayer(a))
                }
            return c
        },
        _enabledSetter: function(a) {
            this.enabled = a;
            this._setupClickHandler()
        },
        _setupClickHandler: function() {
            this._mapClickHandle && (this._mapClickHandle.remove(),
                this._mapClickHandle = null);
            this.enabled && this.map && (this._mapClickHandle = this.map.on("click", this._mapClickHandler))
        },
        _mapClickHandler: function(a) {
            var c = this.map.infoWindow,
                b = a.graphic;
            c && this.map.loaded && (c.clearFeatures && c.setFeatures ? this._showPopup(a) : b && b.getInfoTemplate() && this._showInfoWindow(b, a.mapPoint))
        },
        _showPopup: function(a) {
            var c = this.map,
                b = c.infoWindow,
                d = this,
                m = [],
                g = [c.graphics].concat(f.map(c.graphicsLayerIds, c.getLayer, c));
            f.forEach(g, function(a) {
                a && (a.loaded && a.infoTemplate && !a.suspended) &&
                    m.push(a)
            });
            var n = [];
            f.forEach(c.layerIds, function(a) {
                (a = c.getLayer(a)) && (a.loaded && !a.suspended) && ("esri.layers.ArcGISImageServiceLayer" === a.declaredClass && a.infoTemplate ? m.push(a) : ("esri.layers.ArcGISDynamicMapServiceLayer" === a.declaredClass || "esri.layers.ArcGISTiledMapServiceLayer" === a.declaredClass) && a.infoTemplates && n.push(a))
            });
            this._getSubLayerFeatureLayers(n).then(function(g) {
                m = m.concat(g);
                g = null;
                a.graphic && a.graphic.getInfoTemplate() && (g = a.graphic);
                if (m.length || g) {
                    var k = d._calculateClickTolerance(m),
                        r = a.screenPoint,
                        e = c.toMap(new u(r.x - k, r.y + k)),
                        k = c.toMap(new u(r.x + k, r.y - k)),
                        s = new E(e.x, e.y, k.x, k.y, c.spatialReference),
                        l = new F,
                        p = !!g,
                        n = !0,
                        e = f.map(m, function(b) {
                            var e;
                            l.timeExtent = b.useMapTime ? c.timeExtent : null;
                            if ("esri.layers.ArcGISImageServiceLayer" === b.declaredClass) l.geometry = a.mapPoint, n = !1, e = b.queryVisibleRasters(l, {
                                rasterAttributeTableFieldPrefix: "Raster.",
                                returnDomainValues: !0
                            }), e.addCallback(function() {
                                var a = b.getVisibleRasters();
                                p = p || 0 < a.length;
                                return a
                            });
                            else if (d._featureLayersCache[b.id] ||
                                "function" === typeof b.queryFeatures && (0 === b.currentMode || 1 === b.currentMode)) l.geometry = s, e = b.queryFeatures(l), e.addCallback(function(a) {
                                a = a.features;
                                p = p || 0 < a.length;
                                return a
                            });
                            else {
                                e = new v;
                                var g = f.filter(b.graphics, function(a) {
                                    return a && a.visible && s.intersects(a.geometry)
                                });
                                p = p || 0 < g.length;
                                e.resolve(g)
                            }
                            return e
                        });
                    g && (k = new v, k.resolve([g]), e.unshift(k));
                    !f.some(e, function(a) {
                        return !a.isFulfilled()
                    }) && !p ? (b.hide(), b.clearFeatures()) : (b.setFeatures(e), b.show(a.mapPoint, {
                        closestFirst: n
                    }))
                }
            })
        },
        _getSubLayerFeatureLayers: function(a,
            c) {
            var b = c || new v,
                d = [],
                m = a.length,
                g = Math.floor(this.map.extent.getWidth() / this.map.width),
                n = this.map.getScale(),
                u = !1,
                k = this,
                r = 0;
            a: for (; r < m; r++) {
                var e = a[r],
                    s = e.dynamicLayerInfos || e.layerInfos;
                if (s) {
                    var l = null;
                    if (e._params && (e._params.layers || e._params.dynamicLayers)) l = e.visibleLayers;
                    for (var l = C._getVisibleLayers(s, l), p = C._getLayersForScale(n, s), w = s.length, z = 0; z < w; z++) {
                        var y = s[z],
                            q = y.id,
                            t = e.infoTemplates[q];
                        if (!y.subLayerIds && t && t.infoTemplate && -1 < f.indexOf(l, q) && -1 < f.indexOf(p, q)) {
                            if (!x) {
                                u = !0;
                                break a
                            }
                            var A =
                                e.id + "_" + q,
                                h = this._featureLayersCache[A];
                            if (!h || !h.loadError) h || ((h = t.layerUrl) || (h = y.source ? this._getLayerUrl(e.url, "/dynamicLayer") : this._getLayerUrl(e.url, q)), h = new x(h, {
                                    id: A,
                                    drawMode: !1,
                                    mode: x.MODE_SELECTION,
                                    outFields: this._getOutFields(t.infoTemplate),
                                    resourceInfo: t.resourceInfo,
                                    source: y.source
                                }), this._featureLayersCache[A] = h), h.setDefinitionExpression(e.layerDefinitions && e.layerDefinitions[q]), h.setGDBVersion(e.gdbVersion), h.setInfoTemplate(t.infoTemplate), h.setMaxAllowableOffset(g), h.setUseMapTime(!!e.useMapTime),
                                e.layerDrawingOptions && (e.layerDrawingOptions[q] && e.layerDrawingOptions[q].renderer) && h.setRenderer(e.layerDrawingOptions[q].renderer), d.push(h)
                        }
                    }
                }
            }
            if (u) {
                var D = new v;
                L(["./layers/FeatureLayer"], function(a) {
                    x = a;
                    D.resolve()
                });
                D.then(function() {
                    k._getSubLayerFeatureLayers(a, b)
                })
            } else {
                var B = [];
                f.forEach(d, function(a) {
                    if (!a.loaded) {
                        var b = new v;
                        I.once(a, "load, error", function() {
                            b.resolve()
                        });
                        B.push(b.promise)
                    }
                });
                B.length ? J(B).then(function() {
                    d = f.filter(d, function(a) {
                        return !a.loadError && a.isVisibleAtScale(n)
                    });
                    b.resolve(d)
                }) : (d = f.filter(d, function(a) {
                    return a.isVisibleAtScale(n)
                }), b.resolve(d))
            }
            return b.promise
        },
        _getLayerUrl: function(a, c) {
            var b = a.indexOf("?");
            return -1 === b ? a + "/" + c : a.substring(0, b) + "/" + c + a.substring(b)
        },
        _getOutFields: function(a) {
            var c;
            a.info && "esri.dijit.PopupTemplate" === a.declaredClass ? (c = [], f.forEach(a.info.fieldInfos, function(a) {
                var d = a.fieldName && a.fieldName.toLowerCase();
                d && ("shape" !== d && 0 !== d.indexOf("relationships/")) && c.push(a.fieldName)
            })) : c = ["*"];
            return c
        },
        _calculateClickTolerance: function(a) {
            var c =
                6,
                b, d;
            f.forEach(a, function(a) {
                if (b = a.renderer) "esri.renderer.SimpleRenderer" === b.declaredClass ? ((d = b.symbol) && d.xoffset && (c = Math.max(c, Math.abs(d.xoffset))), d && d.yoffset && (c = Math.max(c, Math.abs(d.yoffset)))) : ("esri.renderer.UniqueValueRenderer" === b.declaredClass || "esri.renderer.ClassBreaksRenderer" === b.declaredClass) && f.forEach(b.infos, function(a) {
                    (d = a.symbol) && d.xoffset && (c = Math.max(c, Math.abs(d.xoffset)));
                    d && d.yoffset && (c = Math.max(c, Math.abs(d.yoffset)))
                })
            });
            return c
        },
        _showInfoWindow: function(a,
            c) {
            var b = this.map.infoWindow,
                d = a.geometry,
                d = d && "point" === d.type ? d : c,
                f = a.getContent();
            b.setTitle(a.getTitle());
            if (f && w.isString(f.id)) {
                var g = G.byId(f.id);
                g && (g.set && /_PopupRenderer/.test(g.declaredClass)) && g.set("showTitle", !1)
            }
            b.setContent(f);
            b.show(d)
        }
    })
});
},
'esri/layerUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/has", "./kernel"], function(l, g, k, m, n) {
    return {
        _serializeLayerDefinitions: function(a) {
            var b = [],
                c = !1,
                e = /[:;]/;
            if (a && (g.forEach(a, function(a, d) {
                    a && (b.push([d, a]), !c && e.test(a) && (c = !0))
                }), 0 < b.length)) {
                var d;
                c ? (d = {}, g.forEach(b, function(a) {
                    d[a[0]] = a[1]
                }), d = k.toJson(d)) : (d = [], g.forEach(b, function(a) {
                    d.push(a[0] + ":" + a[1])
                }), d = d.join(";"));
                return d
            }
            return null
        },
        _serializeTimeOptions: function(a, b) {
            if (a) {
                var c = [];
                g.forEach(a, function(a, d) {
                    if (a) {
                        var f =
                            a.toJson();
                        b && -1 !== g.indexOf(b, d) && (f.useTime = !1);
                        c.push('"' + d + '":' + k.toJson(f))
                    }
                });
                if (c.length) return "{" + c.join(",") + "}"
            }
        },
        _getVisibleLayers: function(a, b) {
            var c = [],
                e, d, f;
            if (!a) return c;
            if (b) {
                c = b.concat();
                for (f = 0; f < a.length; f++) e = a[f], d = g.indexOf(a, e.id), e.subLayerIds && -1 < d && (c.splice(d, 1), c = c.concat(e.subLayerIds))
            } else c = this._getDefaultVisibleLayers(a);
            return c
        },
        _getDefaultVisibleLayers: function(a) {
            var b = [],
                c;
            if (!a) return b;
            for (c = 0; c < a.length; c++) 0 <= a[c].parentLayerId && -1 === g.indexOf(b, a[c].parentLayerId) &&
                g.some(a, function(b) {
                    return b.id === a[c].parentLayerId
                }) || a[c].defaultVisibility && b.push(a[c].id);
            return b
        },
        _getLayersForScale: function(a, b) {
            var c = [];
            if (0 < a && b) {
                var e;
                for (e = 0; e < b.length; e++)
                    if (!(0 <= b[e].parentLayerId && -1 === g.indexOf(c, b[e].parentLayerId) && g.some(b, function(a) {
                            return a.id === b[e].parentLayerId
                        })) && 0 <= b[e].id) {
                        var d = !0,
                            f = b[e].maxScale,
                            h = b[e].minScale;
                        if (0 < f || 0 < h) 0 < f && 0 < h ? d = f <= a && a <= h : 0 < f ? d = f <= a : 0 < h && (d = a <= h);
                        d && c.push(b[e].id)
                    }
            }
            return c
        }
    }
});
},
'esri/MapNavigationManager':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/event", "dojo/mouse", "dojo/keys", "./kernel", "./MouseEvents", "./TouchEvents", "./PointerEvents", "./config", "./sniff", "./lang", "./fx", "./graphic", "./tileUtils", "./geometry/ScreenPoint", "./geometry/Extent", "./geometry/Rect", "./geometry/mathUtils", "./symbols/SimpleFillSymbol"], function(u, g, v, p, w, q, d, H, r, x, y, n, k, z, A, B, C, h, m, s, D, E) {
    var e = p.connect,
        f = p.disconnect,
        t = k("chrome"),
        F = k("safari"),
        G = [d.NUMPAD_PLUS, 61, d.NUMPAD_MINUS, d.UP_ARROW, d.NUMPAD_8,
            d.RIGHT_ARROW, d.NUMPAD_6, d.DOWN_ARROW, d.NUMPAD_2, d.LEFT_ARROW, d.NUMPAD_4, d.PAGE_UP, d.NUMPAD_9, d.PAGE_DOWN, d.NUMPAD_3, d.END, d.NUMPAD_1, d.HOME, d.NUMPAD_7
        ];
    return u(null, {
        declaredClass: "esri.MapNavigationManager",
        eventModel: "",
        constructor: function(a, b) {
            this.map = a;
            g.mixin(this, b);
            var c = a.__container;
            k("esri-pointer") ? (this.pointerEvents = new y(c, {
                map: a
            }), this.eventModel = "pointer") : k("esri-touch") ? (k("ios") || (this.mouseEvents = new r(c, {
                    map: a
                })), this.touchEvents = new x(c, {
                    map: a,
                    mouseEvents: this.mouseEvents
                }),
                this.eventModel = "touch") : (this.mouseEvents = new r(c, {
                map: a
            }), this.eventModel = "mouse");
            this._zoomRect = new B(null, new E(n.defaults.map.zoomSymbol));
            this._keyDx = this._keyDy = 0;
            this._adjustPinch = g.hitch(this, this._adjustPinch);
            this._adjustPinchEnd = g.hitch(this, this._adjustPinchEnd)
        },
        _panInit: function(a) {
            var b = this.mouseEvents;
            q.isLeft(a) && (this.map.isPan && !a.shiftKey) && (this._dragOrigin = new h(0, 0), g.mixin(this._dragOrigin, a.screenPoint), this._panStartHandle = e(b, "onMouseDragStart", this, this._panStart), this._panHandle =
                e(b, "onMouseDrag", this, this._pan), this._panEndHandle = e(b, "onMouseUp", this, this._panEnd), (t || F) && a.preventDefault())
        },
        _panStart: function(a) {
            this.map.setCursor("move");
            this.map.__panStart(a.screenPoint.x, a.screenPoint.y)
        },
        _pan: function(a) {
            this.map.__pan(a.screenPoint.x - this._dragOrigin.x, a.screenPoint.y - this._dragOrigin.y)
        },
        _panEnd: function(a) {
            f(this._panStartHandle);
            f(this._panHandle);
            f(this._panEndHandle);
            this._panStartHandle = this._panHandle = this._panEndHandle = null;
            var b = this.map;
            b.__panning && (b.__panEnd(a.screenPoint.x -
                this._dragOrigin.x, a.screenPoint.y - this._dragOrigin.y), b.resetMapCursor())
        },
        _zoomInit: function(a) {
            var b = this.map,
                c = this.pointerEvents || this.mouseEvents;
            if ((q.isLeft(a) || a.pointerType) && b.isRubberBandZoom && a.shiftKey) b.setCursor("crosshair"), this._dragOrigin = g.mixin({}, a.screenPoint), this._zoomDir = a.ctrlKey || a.metaKey ? -1 : 1, this.pointerEvents ? (this._zoomHandle = e(c, "onSwipeMove", this, this._zoom), this._zoomEndHandle = e(c, "onSwipeEnd", this, this._zoomEnd)) : (this._zoomHandle = e(c, "onMouseDrag", this, this._zoom),
                this._zoomEndHandle = e(c, "onMouseUp", this, this._zoomEnd)), t && a.preventDefault()
        },
        _zoom: function(a) {
            var b = this.map,
                c = this._normalizeRect(a).offset(b.__visibleRect.x, b.__visibleRect.y);
            a = b.graphics;
            var d = this._zoomRect;
            d.geometry || b.setCursor("crosshair");
            d.geometry && a.remove(d, !0);
            var e = b.toMap(new h(c.x, c.y)),
                c = b.toMap(new h(c.x + c.width, c.y + c.height)),
                c = new s(e.x, e.y, c.x - e.x, e.y - c.y, b.spatialReference);
            c._originOnly = !0;
            d.setGeometry(c);
            a.add(d, !0)
        },
        _zoomEnd: function(a) {
            var b = this._zoomRect,
                c = this.map,
                d = c.extent,
                e = c.spatialReference;
            f(this._zoomHandle);
            f(this._zoomEndHandle);
            this._zoomHandle = this._zoomEndHandle = null;
            if (c._canZoom(this._zoomDir) && b.getDojoShape()) {
                c.graphics.remove(b);
                b.geometry = null;
                a = this._normalizeRect(a);
                a.x += c.__visibleRect.x;
                a.y += c.__visibleRect.y;
                if (-1 === this._zoomDir) {
                    var g = d.getWidth();
                    a = (g * c.width / a.width - g) / 2;
                    e = new m(d.xmin - a, d.ymin - a, d.xmax + a, d.ymax + a, e)
                } else d = c.toMap({
                    x: a.x,
                    y: a.y + a.height
                }), a = c.toMap({
                    x: a.x + a.width,
                    y: a.y
                }), e = new m(d.x, d.y, a.x, a.y, e);
                c._extentUtil(null,
                    null, e)
            }
            b.getDojoShape() && c.graphics.remove(b, !0);
            this._zoomDir = 0;
            c.resetMapCursor()
        },
        _wheelZoom: function(a, b) {
            var c = this.map;
            if (!b) {
                if (c.smartNavigation && !a.shiftKey && !c._isPanningOrZooming()) {
                    c.disableScrollWheelZoom();
                    this._setScrollWheelPan(!0);
                    this._wheelPan(a);
                    return
                }
                var d = a.timeStamp;
                if (!z.isDefined(d) || 0 >= d) d = (new Date).getTime();
                if (100 > (this._mwts ? d - this._mwts : d)) return;
                this._mwts = d
            }
            c._canZoom(a.value) && c._extentUtil({
                numLevels: a.value,
                mapAnchor: a.mapPoint,
                screenAnchor: a.screenPoint
            })
        },
        _wheelPan: function(a) {
            var b =
                this.map;
            if (a.shiftKey && !b._isPanningOrZooming()) this._setScrollWheelPan(!1), b.enableScrollWheelZoom(), this._wheelZoom(a);
            else {
                var c = 0,
                    d = 0;
                k("ff") ? a.axis === a.HORIZONTAL_AXIS ? c = -a.detail : d = -a.detail : (c = a.wheelDeltaX, d = a.wheelDeltaY);
                b.translate(c, d)
            }
        },
        _setScrollWheelPan: function(a) {
            this.map.isScrollWheelPan = a;
            this.mouseEvents.enableMouseWheel(a);
            f(this._mwMacHandle);
            this._mwMacHandle = null;
            a && (this._mwMacHandle = e(this.mouseEvents, "onMouseWheel", this, this._wheelPan))
        },
        _recenter: function(a) {
            a.shiftKey &&
                !this.map._isPanningOrZooming() && this.map.centerAt(a.mapPoint)
        },
        _recenterZoom: function(a) {
            a.shiftKey && !this.map._isPanningOrZooming() && (a.value = a.ctrlKey || a.metaKey ? -1 : 1, this._wheelZoom(a, !0))
        },
        _dblClickZoom: function(a) {
            this.map._isPanningOrZooming() || (a.value = 1, this._wheelZoom(a, !0))
        },
        _twoFingerTap: function(a) {
            this.map._isPanningOrZooming() || (a.value = -1, this._wheelZoom(a, !0))
        },
        _keyDown: function(a) {
            var b = a.keyCode,
                c = this.map;
            if (-1 !== v.indexOf(G, b)) {
                if (b === d.NUMPAD_PLUS || 61 === b) c._extentUtil({
                    numLevels: 1
                });
                else if (b === d.NUMPAD_MINUS) c._extentUtil({
                    numLevels: -1
                });
                else {
                    c.__panning || c.__panStart(0, 0);
                    switch (b) {
                        case d.UP_ARROW:
                        case d.NUMPAD_8:
                            this._keyDy += 10;
                            break;
                        case d.RIGHT_ARROW:
                        case d.NUMPAD_6:
                            this._keyDx -= 10;
                            break;
                        case d.DOWN_ARROW:
                        case d.NUMPAD_2:
                            this._keyDy -= 10;
                            break;
                        case d.LEFT_ARROW:
                        case d.NUMPAD_4:
                            this._keyDx += 10;
                            break;
                        case d.PAGE_UP:
                        case d.NUMPAD_9:
                            this._keyDx -= 10;
                            this._keyDy += 10;
                            break;
                        case d.PAGE_DOWN:
                        case d.NUMPAD_3:
                            this._keyDx -= 10;
                            this._keyDy -= 10;
                            break;
                        case d.END:
                        case d.NUMPAD_1:
                            this._keyDx +=
                                10;
                            this._keyDy -= 10;
                            break;
                        case d.HOME:
                        case d.NUMPAD_7:
                            this._keyDx += 10;
                            this._keyDy += 10;
                            break;
                        default:
                            return
                    }
                    c.__pan(this._keyDx, this._keyDy)
                }
                w.stop(a)
            }
        },
        _keyEnd: function(a) {
            var b = this.map;
            b.__panning && a.keyCode !== d.SHIFT && (b.__panEnd(this._keyDx, this._keyDy), this._keyDx = this._keyDy = 0)
        },
        _swipeInit: function(a) {
            var b = this.map,
                b = b._zoomAnim || b._panAnim;
            if (a.shiftKey) return !1;
            b && b._active && (b.stop(), b._fire("onEnd", [b.node]));
            this._dragOrigin = new h(0, 0);
            g.mixin(this._dragOrigin, a.screenPoint);
            f(this._swipeHandle);
            f(this._swipeEndHandle);
            this._swipeHandle = e(this.touchEvents || this.pointerEvents, "onSwipeMove", this, this._swipe);
            this._swipeEndHandle = e(this.touchEvents || this.pointerEvents, "onSwipeEnd", this, this._swipeEnd)
        },
        _swipe: function(a) {
            var b = this.map;
            b.__panning ? (this._panX = a.screenPoint.x, this._panY = a.screenPoint.y, b.__pan(a.screenPoint.x - this._dragOrigin.x, a.screenPoint.y - this._dragOrigin.y)) : (b.setCursor("move"), b.__panStart(a.screenPoint.x, a.screenPoint.y))
        },
        _swipeEnd: function(a) {
            f(this._swipeHandle);
            f(this._swipeEndHandle);
            this._swipeHandle = this._swipeEndHandle = null;
            var b = this.map;
            b.__panning && (b.resetMapCursor(), b.__panEnd(a.screenPoint.x - this._dragOrigin.x, a.screenPoint.y - this._dragOrigin.y))
        },
        _pinchInit: function(a) {
            var b = this.map,
                c = b._zoomAnim || b._panAnim;
            c && c._active ? (c.stop(), c._fire("onEnd", [c.node])) : b.__panning && (a.screenPoint = new h(this._panX, this._panY), a.mapPoint = b.toMap(a.screenPoint), this._swipeEnd(a));
            f(this._pinchHandle);
            f(this._pinchEndHandle);
            this._pinchHandle = e(this.touchEvents ||
                this.pointerEvents, "onPinchMove", this, this._pinch);
            this._pinchEndHandle = e(this.touchEvents || this.pointerEvents, "onPinchEnd", this, this._pinchEnd)
        },
        _pinch: function(a) {
            var b = this.map;
            a.screenPoints && (this.currLength = D.getLength(a.screenPoints[0], a.screenPoints[1]), b.__zooming ? (a = this.currLength / this._length, this._zoomStartExtent = this.__scaleExtent(b.extent, a, this._dragOrigin), b.__zoom(this._zoomStartExtent, a, this._dragOrigin)) : (this._dragOrigin = new h((a.screenPoints[0].x + a.screenPoints[1].x) / 2, (a.screenPoints[0].y +
                a.screenPoints[1].y) / 2), this._length = this.currLength, b.__zoomStart(b.extent, this._dragOrigin)), b._fireOnScale(this.currLength / this._length, this._dragOrigin, !0))
        },
        _pinchEnd: function(a) {
            a = this.map;
            f(this._pinchHandle);
            f(this._pinchEndHandle);
            this._pinchHandle = this._pinchEndHandle = null;
            if (a.__zooming && null === a._zoomAnim) {
                var b = this.currLength / this._length,
                    c = a.extent.getWidth();
                this._zoomAnimAnchor = a.toMap(this._dragOrigin);
                this._zoomStartExtent = this.__scaleExtent(a.extent, 1 / b, this._zoomAnimAnchor);
                if (a.__tileInfo) {
                    var d =
                        C.getCandidateTileInfo(a, a.__tileInfo, this._zoomStartExtent),
                        e = a.__getExtentForLevel(d.lod.level, this._zoomAnimAnchor),
                        g = a.getMinZoom(),
                        k = a.getMaxZoom(),
                        h = e.extent,
                        e = e.lod,
                        m = c / h.getWidth(),
                        l = d.lod.level;
                    1 > b ? m > b && l-- : m < b && l++;
                    l < g ? l = g : l > k && (l = k);
                    l !== d.lod.level && (e = a.__getExtentForLevel(l, this._zoomAnimAnchor), h = e.extent, e = e.lod);
                    this._zoomEndExtent = h;
                    this._zoomEndLod = e;
                    a._zoomAnim = A.animateRange({
                        range: {
                            start: c / this._zoomStartExtent.getWidth(),
                            end: m
                        },
                        duration: n.defaults.map.zoomDuration,
                        rate: n.defaults.map.zoomRate,
                        onAnimate: this._adjustPinch,
                        onEnd: this._adjustPinchEnd
                    });
                    a._zoomAnim.play();
                    a._fireOnScale(a.extent.getWidth() / this._zoomEndExtent.getWidth(), this._dragOrigin)
                } else this._zoomEndExtent = this._zoomStartExtent, a._fireOnScale(a.extent.getWidth() / this._zoomEndExtent.getWidth(), this._dragOrigin), this._adjustPinchEnd()
            }
        },
        _adjustPinch: function(a) {
            var b = this.__scaleExtent(this.map.extent, a, this._zoomAnimAnchor);
            this.map.__zoom(b, a, this._dragOrigin)
        },
        _adjustPinchEnd: function() {
            var a = this.map,
                b = a.extent.getWidth() /
                this._zoomEndExtent.getWidth(),
                c = this.__scaleExtent(a.extent, 1 / b, this._zoomAnimAnchor),
                d = this._dragOrigin,
                e = this._zoomEndLod;
            this._zoomStartExtent = this._zoomEndExtent = this._zoomEndLod = this._dragOrigin = a._zoomAnim = this._zoomAnimAnchor = null;
            a.__zoomEnd(c, b, d, e, !0)
        },
        __scaleExtent: function(a, b, c) {
            c = c || a.getCenter();
            b = a.expand(b);
            var d = a.xmin - (b.getWidth() - a.getWidth()) * (c.x - a.xmin) / a.getWidth();
            c = a.ymax - (b.getHeight() - a.getHeight()) * (c.y - a.ymax) / a.getHeight();
            return new m(d, c - b.getHeight(), d + b.getWidth(),
                c, a.spatialReference)
        },
        _normalizeRect: function(a) {
            a = a.screenPoint;
            var b = this._dragOrigin.x,
                c = this._dragOrigin.y;
            a = new s((a.x < b ? a.x : b) - this.map.__visibleRect.x, (a.y < c ? a.y : c) - this.map.__visibleRect.y, Math.abs(a.x - b), Math.abs(a.y - c));
            delete a.spatialReference;
            0 === a.width && (a.width = 1);
            0 === a.height && (a.height = 1);
            return a
        },
        setImmediateClick: function(a) {
            switch (this.eventModel) {
                case "mouse":
                    this.mouseEvents.setImmediateClick(a);
                    break;
                case "touch":
                    this.touchEvents.setImmediateTap(a);
                    this.mouseEvents && this.mouseEvents.setImmediateClick(a);
                    break;
                case "pointer":
                    this.pointerEvents.setImmediateTap(a)
            }
        },
        enablePan: function() {
            this.disablePan();
            switch (this.eventModel) {
                case "mouse":
                    this._panInitHandle = e(this.mouseEvents, "onMouseDown", this, this._panInit);
                    break;
                case "touch":
                    this._panInitHandle = e(this.mouseEvents, "onMouseDown", this, this._panInit);
                    this._swipeInitHandle = e(this.touchEvents, "onSwipeStart", this, this._swipeInit);
                    break;
                case "pointer":
                    this._swipeInitHandle = e(this.pointerEvents, "onSwipeStart", this, this._swipeInit)
            }
        },
        disablePan: function() {
            f(this._panInitHandle);
            this._panInitHandle = null;
            f(this._swipeInitHandle);
            this._swipeInitHandle = null
        },
        enableRubberBandZoom: function() {
            this.disableRubberBandZoom();
            this._zoomInitHandle = this.pointerEvents ? e(this.pointerEvents, "onSwipeStart", this, this._zoomInit) : e(this.mouseEvents, "onMouseDown", this, this._zoomInit)
        },
        disableRubberBandZoom: function() {
            f(this._zoomInitHandle);
            this._zoomInitHandle = null
        },
        enablePinchZoom: function() {
            this.disablePinchZoom();
            if ("touch" === this.eventModel || "pointer" === this.eventModel) this._pinchInitHandle =
                e(this.touchEvents || this.pointerEvents, "onPinchStart", this, this._pinchInit)
        },
        disablePinchZoom: function() {
            f(this._pinchInitHandle);
            this._pinchInitHandle = null
        },
        enableScrollWheelZoom: function() {
            this.disableScrollWheelZoom();
            this._wheelHandle = e(this.mouseEvents || this.pointerEvents, "onMouseWheel", this, this._wheelZoom)
        },
        disableScrollWheelZoom: function() {
            f(this._wheelHandle);
            this._wheelHandle = null
        },
        enableDoubleClickZoom: function() {
            this.disableDoubleClickZoom();
            switch (this.eventModel) {
                case "mouse":
                    this._dblClickHandle =
                        e(this.mouseEvents, "onDblClick", this, this._dblClickZoom);
                    break;
                case "touch":
                    this._dblClickHandle = e(this.mouseEvents, "onDblClick", this, this._dblClickZoom);
                    this._dblTapHandle = e(this.touchEvents, "onDoubleTap", this, this._dblClickZoom);
                    this._zoomOutHandle = e(this.touchEvents, "onTwoFingerTap", this, this._twoFingerTap);
                    break;
                case "pointer":
                    this._dblTapHandle = e(this.pointerEvents, "onDoubleTap", this, this._dblClickZoom), this._zoomOutHandle = e(this.pointerEvents, "onTwoFingerTap", this, this._twoFingerTap)
            }
        },
        disableDoubleClickZoom: function() {
            f(this._dblClickHandle);
            f(this._zoomOutHandle);
            this._dblTapHandle && f(this._dblTapHandle);
            this._dblClickHandle = this._zoomOutHandle = this._dblTapHandle = null
        },
        enableShiftDoubleClickZoom: function() {
            this.disableShiftDoubleClickZoom();
            this._sDblClickHandle = e(this.pointerEvents || this.mouseEvents, "onDblClick", this, this._recenterZoom)
        },
        disableShiftDoubleClickZoom: function() {
            f(this._sDblClickHandle);
            this._sDblClickHandle = null
        },
        enableClickRecenter: function() {
            this.disableClickRecenter();
            this._recenterHandle = e(this.pointerEvents || this.mouseEvents,
                "onClick", this, this._recenter)
        },
        disableClickRecenter: function() {
            f(this._recenterHandle);
            this._recenterHandle = null
        },
        enableKeyboardNavigation: function() {
            this.disableKeyboardNavigation();
            this._keyHandle = e(this.pointerEvents || this.mouseEvents, "onKeyDown", this, this._keyDown);
            this._keyEndHandle = e(this.pointerEvents || this.mouseEvents, "onKeyUp", this, this._keyEnd)
        },
        disableKeyboardNavigation: function() {
            f(this._keyHandle);
            f(this._keyEndHandle);
            this._keyHandle = this._keyEndHandle = null
        },
        enableNavigation: function() {
            var a =
                this.map;
            a && a.loaded && (a.enableDoubleClickZoom(), a.enableClickRecenter(), a.enablePan(), a.enableRubberBandZoom(), this.enablePinchZoom(), a.enableKeyboardNavigation(), a.smartNavigation ? this._setScrollWheelPan(!0) : a.enableScrollWheelZoom())
        },
        disableNavigation: function() {
            var a = this.map;
            a && a.loaded && (a.disableDoubleClickZoom(), a.disableClickRecenter(), a.disablePan(), a.disableRubberBandZoom(), this.disablePinchZoom(), a.disableKeyboardNavigation(), a.disableScrollWheelZoom(), a.smartNavigation && this._setScrollWheelPan(!1))
        },
        destroy: function() {
            this.touchEvents && this.touchEvents.destroy();
            this.mouseEvents && this.mouseEvents.destroy();
            this.pointerEvents && this.pointerEvents.destroy();
            var a, b = [this._panInitHandle, this._panStartHandle, this._panHandle, this._panEndHandle, this._zoomInitHandle, this._zoomHandle, this._zoomEndHandle, this._wheelHandle, this._mwMacHandle, this._dblClickHandle, this._zoomOutHandle, this._recenterHandle, this._sDblClickHandle, this._dblTapHandle, this._keyHandle, this._keyEndHandle, this._swipeInitHandle, this._swipeHandle,
                this._swipeEndHandle, this._pinchInitHandle, this._pinchHandle, this._pinchEndHandle
            ];
            for (a = 0; a < b.length; a++) f(b[a]);
            this.map = this.touchEvents = this.mouseEvents = this.eventModel = this.pointerEvents = this._zoomRect = this._dragOrigin = this._panInitHandle = this._panStartHandle = this._panHandle = this._panEndHandle = this._zoomInitHandle = this._zoomHandle = this._zoomEndHandle = this._wheelHandle = this._mwMacHandle = this._dblClickHandle = this._zoomOutHandle = this._recenterHandle = this._sDblClickHandle = this._dblTapHandle = this._keyHandle =
                this._keyEndHandle = this._swipeInitHandle = this._swipeHandle = this._swipeEndHandle = this._pinchInitHandle = this._pinchHandle = this._pinchEndHandle = null
        }
    })
});
},
'esri/MouseEvents':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/html", "dojo/_base/lang", "dojo/_base/sniff", "dojo/_base/connect", "dojo/_base/event", "./kernel", "./Evented", "./geometry/Point", "./geometry/ScreenPoint"], function(n, p, h, e, k, g, l, q, r, m) {
    var c = k.connect,
        d = k.disconnect;
    return n([q], {
        declaredClass: "esri.MouseEvents",
        doubleClickDuration: 300,
        minWheelValue: 1,
        maxWheelValue: 1,
        mozWheelDivisor: -1 !== e("mac") ? 1 : 3,
        wheelDivisor: 2 > e("chrome") ? 360 : 120,
        preventPageScroll: !0,
        map: null,
        constructor: function(a, b) {
            this.node = a;
            h.mixin(this, b);
            var f =
                function(a) {
                    g.stop(a);
                    return !1
                };
            e("mozilla") && p.style(a, "MozUserSelect", "none");
            this._handles = [c(a, "onselectstart", f), c(a, "ondragstart", f), c(a, "onmouseenter", this, this._onMouseEnterHandler), c(a, "onmouseleave", this, this._onMouseLeaveHandler), c(a, "onmousedown", this, this._onMouseDownHandler), c(a, "onclick", this, this._onClickHandler), c(a, "ondblclick", this, this._onDblClickHandler)];
            this._onMouseMoveHandler_connect = c(a, "onmousemove", this, this._onMouseMoveHandler);
            this._onMouseUpHandler_connect = c(a, "onmouseup",
                this, this._onMouseUpHandler);
            this._fireClickEvent = h.hitch(this, this._fireClickEvent);
            this._initialDuration = this.doubleClickDuration;
            this.preventPageScroll = (f = this.map) ? f.isScrollWheelZoom || f.isScrollWheelPan : this.preventPageScroll;
            this.enableMouseWheel(!1)
        },
        _fire: function(a, b) {
            if (!this._preventClick || !("onClick" === a || "onDblClick" === a)) {
                if (this[a]) this[a](b);
                if (this.map && this.map[a]) this.map[a](b)
            }
        },
        _processEvent: function(a) {
            a = g.fix(a, a.target);
            var b = this.map,
                c = b && b.position;
            c && ("DOMMouseScroll" ===
                a.type && 3 > e("ff") ? a.screenPoint = new m(window.scrollX + a.screenX - c.x, window.scrollY + a.screenY - c.y) : a.screenPoint = new m(a.pageX - c.x, a.pageY - c.y), a.mapPoint = b.extent ? b.toMap(a.screenPoint) : new r);
            a.numPoints = 0;
            return a
        },
        _onMouseEnterHandler: function(a) {
            d(this._onKeyDown_connect);
            d(this._onKeyUp_connect);
            this._onKeyDown_connect = c(document, "onkeydown", this, this._onKeyDownHandler);
            this._onKeyUp_connect = c(document, "onkeyup", this, this._onKeyUpHandler);
            this._fire("onMouseOver", this._processEvent(a))
        },
        _onMouseLeaveHandler: function(a) {
            d(this._onKeyDown_connect);
            d(this._onKeyUp_connect);
            this._onKeyDown_connect = this._onKeyUp_connect = null;
            this._fire("onMouseOut", this._processEvent(a))
        },
        _onMouseMoveHandler: function(a) {
            this._dragEnd ? this._dragEnd = !1 : this._fire("onMouseMove", this._processEvent(a))
        },
        _onMouseDownHandler: function(a) {
            d(this._onMouseMoveHandler_connect);
            this._onMouseMoveHandler_connect = null;
            this.node.setCapture && this.node.setCapture(!1);
            this._onMouseDragHandler_connect = c(document, "onmousemove", this, this._onMouseDragHandler);
            this._startX = a.pageX;
            this._startY =
                a.pageY;
            this._fire("onMouseDown", this._processEvent(a))
        },
        _onMouseUpHandler: function(a) {
            var b = this.node;
            b.releaseCapture && b.releaseCapture();
            d(this._onMouseDragHandler_connect);
            this._onMouseDragHandler_connect = null;
            d(this._onMouseMoveHandler_connect);
            this._onMouseMoveHandler_connect = c(b, "onmousemove", this, this._onMouseMoveHandler);
            this._fire("onMouseUp", this._processEvent(a))
        },
        _onMouseDragHandler: function(a) {
            d(this._onMouseDragHandler_connect);
            this._onMouseDragHandler_connect = c(document, "onmousemove",
                this, this._onMouseDraggingHandler);
            d(this._onMouseUpHandler_connect);
            this._onMouseUpHandler_connect = c(document, "onmouseup", this, this._onDragMouseUpHandler);
            this._docLeaveConnect = c(document, "onmouseout", this, this._onDocMouseOut);
            this._fire("onMouseDragStart", this._processEvent(a))
        },
        _onMouseDraggingHandler: function(a) {
            g.stop(a);
            this._fire("onMouseDrag", this._processEvent(a))
        },
        _onDragMouseUpHandler: function(a) {
            var b = this.node;
            b.releaseCapture && b.releaseCapture();
            this._dragEnd = !0;
            d(this._docLeaveConnect);
            d(this._onMouseDragHandler_connect);
            d(this._onMouseUpHandler_connect);
            this._docLeaveConnect = this._onMouseDragHandler_connect = null;
            this._onMouseMoveHandler_connect = c(b, "onmousemove", this, this._onMouseMoveHandler);
            this._onMouseUpHandler_connect = c(b, "onmouseup", this, this._onMouseUpHandler);
            a = this._processEvent(a);
            this._fire("onMouseDragEnd", a);
            this._fire("onMouseUp", a)
        },
        _onDocMouseOut: function(a) {
            var b = 9 > e("ie") ? a.toElement : a.relatedTarget,
                c = b && b.nodeName.toLowerCase();
            (!b || e("chrome") && "html" === c) &&
            this._onDragMouseUpHandler(a)
        },
        _onClickHandler: function(a) {
            a = this._processEvent(a);
            a.pageX !== this._startX || a.pageY !== this._startY || (clearTimeout(this._clickTimer), this._clickEvent = h.mixin({}, a), this._clickTimer = setTimeout(this._fireClickEvent, this.doubleClickDuration))
        },
        _fireClickEvent: function() {
            clearTimeout(this._clickTimer);
            9 > e("ie") && (this._clickEvent.graphic = l._ieGraphic, delete l._ieGraphic);
            this._fire("onClick", this._clickEvent)
        },
        _onDblClickHandler: function(a) {
            clearTimeout(this._clickTimer);
            this._fire("onDblClick", this._processEvent(a))
        },
        _onMouseWheelHandler: function(a) {
            var b = this.map;
            (b ? b.isScrollWheelZoom || b.isScrollWheelPan : this.preventPageScroll) && g.stop(a);
            var b = e("ff") || e("mozilla") ? -a.detail / this.mozWheelDivisor : a.wheelDelta / this.wheelDivisor,
                c = Math.abs(b),
                c = c <= this.minWheelValue ? this.minWheelValue : this.maxWheelValue;
            a.value = 0 > b ? -c : c;
            this._fire("onMouseWheel", this._processEvent(a))
        },
        _onKeyDownHandler: function(a) {
            this._fire("onKeyDown", a)
        },
        _onKeyUpHandler: function(a) {
            this._fire("onKeyUp",
                a)
        },
        enableMouseWheel: function(a) {
            d(this._scrollHandle);
            this._scrollHandle = c(this.node, e("ff") || e("mozilla") ? a ? "MozMousePixelScroll" : "DOMMouseScroll" : "onmousewheel", this, this._onMouseWheelHandler)
        },
        setImmediateClick: function(a) {
            this.doubleClickDuration = a ? 0 : this._initialDuration
        },
        preventClickEvents: function(a) {
            this._preventClick = a
        },
        destroy: function() {
            var a = this._handles.concat([this._onMouseMoveHandler_connect, this._onMouseUpHandler_connect, this._onMouseDragHandler_connect, this._scrollHandle, this._onKeyDown_connect,
                    this._onKeyUp_connect, this._docLeaveConnect
                ]),
                b;
            for (b = 0; b < a.length; b++) d(a[b]);
            clearTimeout(this._clickTimer);
            this.node = this.map = this._handles = this._clickEvent = this._onMouseMoveHandler_connect = this._onMouseUpHandler_connect = this._onMouseDragHandler_connect = this._scrollHandle = this._onKeyDown_connect = this._onKeyUp_connect = this._docLeaveConnect = null
        }
    })
});
},
'esri/TouchEvents':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/html", "dojo/_base/lang", "dojo/_base/sniff", "dojo/dom", "./kernel", "./Evented", "./geometry/Point", "./geometry/ScreenPoint"], function(r, q, k, l, s, u, t, m, n) {
    return r([t], {
        declaredClass: "esri.TouchEvents",
        tapRadius: 8,
        doubleTapRadius: 10,
        tapStartTolerance: 50,
        doubleTapDuration: 300,
        map: null,
        constructor: function(a, b) {
            this.node = a;
            k.mixin(this, b);
            q.setSelectable(a, !1);
            this._touchStart = k.hitch(this, this._touchStart);
            this._touchMove = k.hitch(this, this._touchMove);
            this._touchEnd = k.hitch(this,
                this._touchEnd);
            this._touchCancel = k.hitch(this, this._touchCancel);
            a.addEventListener("touchstart", this._touchStart, !1);
            a.addEventListener("touchmove", this._touchMove, !1);
            a.addEventListener("touchend", this._touchEnd, !1);
            a.addEventListener("touchcancel", this._touchCancel, !1);
            this.map && l("ios") && (this._mouseOver = k.hitch(this, this._mouseOver), this._mouseOut = k.hitch(this, this._mouseOut), this._mouseDown = k.hitch(this, this._mouseDown), this._mouseUp = k.hitch(this, this._mouseUp), this._mouseClick = k.hitch(this,
                this._mouseClick), a.addEventListener("mouseover", this._mouseOver, !1), a.addEventListener("mouseout", this._mouseOut, !1), a.addEventListener("mousedown", this._mouseDown, !1), a.addEventListener("mouseup", this._mouseUp, !1), a.addEventListener("click", this._mouseClick, !1));
            this._numTouches = 0;
            this._nodeTouches = [];
            this._touches = {};
            this._touchIds = [];
            this._taps = [];
            this._immediate = !1
        },
        _touchStart: function(a) {
            var b = this._touches,
                c, d = a.changedTouches.length,
                f, e, g, h, k = (new Date).getTime();
            if (!l("android") || !l("safari") ||
                !(1 === a.targetTouches.length && a.touches.length === a.targetTouches.length && a.targetTouches.length === a.changedTouches.length && 0 === a.changedTouches[0].identifier && b[a.changedTouches[0].identifier])) {
                this._addTouch(a);
                for (c = 0; c < d; c++) f = a.changedTouches[c], e = b[f.identifier] = {}, e.startX = f.pageX, e.startY = f.pageY, e.startTS = k, -1 === this._touchIds.indexOf(f.identifier) && this._touchIds.push(f.identifier);
                this._swipeActive && (g = this._nodeTouches[0]);
                this._pinchActive && (h = this._nodeTouches[1]);
                1 === this._numTouches ?
                    this._swipeActive ? (this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, g))) : this._pinchActive && (this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, [g, h]))) : 2 === this._numTouches ? this._swipeActive && (g && (e = b[this._touchIds[0]], e.startX = g.pageX, e.startY = g.pageY, e.moved = !1), this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, g))) : this._swipeActive ? (this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, g))) : this._pinchActive && (this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, [g, h])))
            }
        },
        _touchMove: function(a) {
            a.preventDefault();
            this._updateTouch(a);
            var b = this._touches,
                c, d = a.changedTouches.length,
                f, e, g, h;
            if (!l("android") || !l("safari") || !(1 === a.targetTouches.length && a.touches.length === a.targetTouches.length && a.targetTouches.length === a.changedTouches.length && 0 === a.changedTouches[0].identifier && b[a.changedTouches[0].identifier] && 1 < this._touchIds.length)) {
                for (c = 0; c < d; c++)
                    if (f = a.changedTouches[c], e = b[f.identifier]) {
                        g = Math.abs(f.pageX -
                            e.startX);
                        f = Math.abs(f.pageY - e.startY);
                        if (!e.moved && (g >= this.tapRadius || f >= this.tapRadius)) e.moved = e.absMoved = !0;
                        h = h ? h : e.moved
                    }
                1 === this._numTouches ? (c = a.changedTouches[0], this._swipeActive ? this._fire("onSwipeMove", this._processTouchEvent(a, c)) : h && (this._swipeActive = !0, this._fire("onSwipeStart", this._processTouchEvent(a, c)))) : 2 === this._numTouches && (c = this._nodeTouches[0], d = this._nodeTouches[1], this._pinchActive ? this._fire("onPinchMove", this._processTouchEvent(a, [c, d])) : h && (h = b[c.identifier], e = b[d.identifier],
                    b = Math.abs(h.startX - e.startX), h = Math.abs(h.startY - e.startY), b = Math.sqrt(b * b + h * h), h = Math.abs(c.pageX - d.pageX), e = Math.abs(c.pageY - d.pageY), h = Math.sqrt(h * h + e * e), Math.abs(h - b) >= 2 * this.tapRadius && (this._pinchActive = !0, this._fire("onPinchStart", this._processTouchEvent(a, [c, d])))))
            }
        },
        _touchEnd: function(a) {
            this._removeTouch(a);
            var b = this._touches,
                c = a.changedTouches,
                d, f = c.length,
                e, g, h = (new Date).getTime(),
                k = this._touchIds;
            for (d = 0; d < f; d++)
                if (g = b[c[d].identifier]) g.absMoved && (e = !0), g.pageX = c[d].pageX, g.pageY =
                    c[d].pageY, g.endTS = h;
            if (0 === this._numTouches)
                if (this._touches = {}, this._touchIds = [], this._swipeActive) this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, c[0]));
                else if (this._pinchActive) this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, c));
            else {
                if (!e) {
                    f = Infinity;
                    e = -Infinity;
                    var h = Infinity,
                        l = -Infinity,
                        m = this.tapStartTolerance,
                        p = [],
                        n = !0;
                    for (d = 0; d < k.length; d++) g = b[k[d]], p.push(g), g.startTS < f && (f = g.startTS), g.startTS > e && (e = g.startTS), g.endTS < h && (h = g.endTS), g.endTS >
                        l && (l = g.endTS), delete b[k[d]];
                    if (1 === p.length && c[0] && (b = Math.abs(c[0].pageX - p[0].startX), c = Math.abs(c[0].pageY - p[0].startY), b >= this.tapRadius || c >= this.tapRadius)) n = !1;
                    n && (Math.abs(e - f) <= m && Math.abs(l - h) <= m) && this._basicTap(a, p)
                }
            } else 1 === this._numTouches && this._pinchActive && (d = this._nodeTouches[0], g = b[d.identifier], g.startX = d.pageX, g.startY = d.pageY, this._pinchActive = g.moved = !1, this._fire("onPinchEnd", this._processTouchEvent(a, [c[0], d])))
        },
        _touchCancel: function(a) {
            this._numTouches && this._touchEnd(a)
        },
        _basicTap: function(a, b) {
            var c = (new Date).getTime(),
                d = this;
            a = this._processTouchEvent(a, b);
            this._taps.push({
                touchInfos: b,
                ts: c,
                event: a
            });
            2 < this._taps.length && this._taps.shift();
            this._fire("onBasicTap", a);
            clearTimeout(this._tapTimer);
            this._immediate ? this._analyzeTap(!0) : this._tapTimer = setTimeout(function() {
                var a = d;
                d = null;
                clearTimeout(a._tapTimer);
                a._analyzeTap()
            }, 2 === this._taps.length ? this.doubleTapDuration / 2 : this.doubleTapDuration)
        },
        _analyzeTap: function(a) {
            var b = this._taps,
                c = b[0],
                d = b[1],
                f = c.touchInfos,
                e = d && d.touchInfos;
            b.length && (a || (this._taps = []), c && d ? f.length === e.length ? d.ts - c.ts <= this.doubleTapDuration ? (1 === f.length ? (a = Math.abs(f[0].startX - e[0].startX), f = Math.abs(f[0].startY - e[0].startY), f = a <= this.doubleTapRadius && f <= this.doubleTapRadius) : f = !0, f ? this._processedDoubleTap(b) : this._processedTap(d)) : this._processedTap(d) : this._processedTap(d) : this._processedTap(c || d))
        },
        _processedTap: function(a) {
            var b = a.event;
            this._fire("onProcessedTap", b);
            1 === a.touchInfos.length ? this._fire("onTap", this._fixEvent(b)) :
                2 === a.touchInfos.length && this._fire("onTwoFingerTap", b)
        },
        _processedDoubleTap: function(a) {
            var b = 1 === a[1].touchInfos.length,
                c;
            b && (c = [this._fixEvent(a[0].event), this._fixEvent(a[1].event)], c[1].relatedEvents = c);
            a = [a[0].event, a[1].event];
            a[1].relatedEvents = a;
            this._fire("onProcessedDoubleTap", a[1]);
            b && (this._fire("onDoubleTap", c[1]), this._fire("onDblClick", c[1]))
        },
        _addTouch: function(a) {
            var b = a.changedTouches,
                c = this._nodeTouches,
                d, f, e;
            this._numTouches += b.length;
            for (a = 0; a < b.length; a++) {
                f = c.length;
                e = !1;
                for (d =
                    0; d < f && !(e = c[d].identifier === b[a].identifier); d++);
                e ? this._numTouches-- : c.push(b[a])
            }
            for (a = c.length - 1; 0 <= a; a--) s.isDescendant(c[a].target, document.body) || (c.splice(a, 1), this._numTouches--);
            0 > this._numTouches && (this._numTouches = 0)
        },
        _removeTouch: function(a) {
            var b = [],
                c = [],
                d = a.changedTouches,
                f = this._nodeTouches;
            this._numTouches -= d.length;
            0 > this._numTouches && (this._numTouches = 0);
            for (a = 0; a < d.length; a++) b.push(d[a].identifier);
            for (a = f.length - 1; 0 <= a; a--) - 1 !== b.indexOf(f[a].identifier) && c.push(f.splice(a,
                1)[0]);
            return c
        },
        _updateTouch: function(a) {
            var b = [],
                c, d = a.changedTouches,
                f = this._nodeTouches;
            for (a = 0; a < d.length; a++) b.push(d[a].identifier);
            for (a = 0; a < f.length; a++) c = b.indexOf(f[a].identifier), -1 !== c && f.splice(a, 1, d[c])
        },
        _mouseOver: function(a) {
            this._fire("onMouseOver", this._processMouseEvent(a))
        },
        _mouseOut: function(a) {
            this._fire("onMouseOut", this._processMouseEvent(a))
        },
        _mouseDown: function(a) {
            this._fire("onMouseDown", this._processMouseEvent(a))
        },
        _mouseUp: function(a) {
            this._fire("onMouseUp", this._processMouseEvent(a))
        },
        _mouseClick: function(a) {
            this._fire("onClick", this._processMouseEvent(a))
        },
        _fire: function(a, b) {
            if ("onDblClick" === a && this.mouseEvents) {
                this.mouseEvents.preventClickEvents(!0);
                var c = this;
                setTimeout(function() {
                    c.mouseEvents.preventClickEvents(!1)
                }, 350)
            }
            if (this[a]) this[a](b);
            if (this.map && this.map[a]) this.map[a](b)
        },
        _fixEvent: function(a) {
            var b = {},
                c;
            for (c in a) b[c] = a[c];
            this.map && (b.screenPoint = b.screenPoints[0], b.mapPoint = b.mapPoints[0]);
            return b
        },
        _processTouchEvent: function(a, b) {
            var c = this.map,
                d = c && c.position,
                f = 0;
            if (d && b)
                if (k.isArray(b)) {
                    var e, g;
                    a.screenPoints = [];
                    a.mapPoints = [];
                    for (e = 0; e < b.length; e++) b[e] ? (g = new n(b[e].pageX - d.x, b[e].pageY - d.y), a.screenPoints.push(g), a.mapPoints.push(c.extent ? c.toMap(g) : new m)) : f++
                } else a.screenPoint = new n(b.pageX - d.x, b.pageY - d.y), a.mapPoint = c.extent ? c.toMap(a.screenPoint) : new m;
            a.numPoints = b ? k.isArray(b) ? b.length - f : 1 : 0;
            return a
        },
        _processMouseEvent: function(a) {
            var b = this.map,
                c = b && b.position;
            c && (a.screenPoint = new n(a.pageX - c.x, a.pageY - c.y), a.mapPoint = b.extent ? b.toMap(a.screenPoint) :
                new m);
            return a
        },
        setImmediateTap: function(a) {
            this._immediate = a
        },
        destroy: function() {
            var a = this.node;
            a.removeEventListener("touchstart", this._touchStart, !1);
            a.removeEventListener("touchmove", this._touchMove, !1);
            a.removeEventListener("touchend", this._touchEnd, !1);
            a.removeEventListener("touchcancel", this._touchCancel, !1);
            this.map && (a.removeEventListener("mouseover", this._mouseOver, !1), a.removeEventListener("mouseout", this._mouseOut, !1), a.removeEventListener("mousedown", this._mouseDown, !1), a.removeEventListener("mouseup",
                this._mouseUp, !1), a.removeEventListener("click", this._mouseClick, !1));
            q.setSelectable(a, !0);
            clearTimeout(this._tapTimer);
            this.node = this.map = this._numTouches = this._nodeTouches = this._touches = this._touchIds = this._taps = null
        }
    })
});
},
'esri/PointerEvents':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "./kernel", "./Evented", "./geometry/Point", "./geometry/ScreenPoint"], function(q, g, h, r, t, s, k, l) {
    return q([s], {
        declaredClass: "esri.PointerEvents",
        tapRadius: 8,
        clickRadius: 2,
        doubleTapRadius: 10,
        tapStartTolerance: 50,
        doubleTapDuration: 300,
        minWheelValue: 1,
        maxWheelValue: 1,
        mozWheelDivisor: -1 !== r("mac") ? 1 : 3,
        wheelDivisor: 120,
        preventPageScroll: !0,
        constructor: function(a, c) {
            this.node = a;
            g.mixin(this, c);
            void 0 !== a.style.msTouchAction ? a.style.msTouchAction =
                "none" : void 0 !== a.style.touchAction && (a.style.touchAction = "none");
            var b = navigator.msPointerEnabled,
                d = function(a) {
                    a.preventDefault()
                };
            a.addEventListener("selectstart", d, !1);
            a.addEventListener("dragstart", d, !1);
            this._pointerDown = g.hitch(this, this._pointerDown);
            this._pointerMove = g.hitch(this, this._pointerMove);
            this._pointerUp = g.hitch(this, this._pointerUp);
            this._pointerCancel = g.hitch(this, this._pointerCancel);
            a.addEventListener(b ? "MSPointerDown" : "pointerdown", this._pointerDown, !1);
            a.addEventListener(b ?
                "MSPointerMove" : "pointermove", this._pointerMove, !1);
            a.addEventListener(b ? "MSPointerUp" : "pointerup", this._pointerUp, !1);
            a.addEventListener(b ? "MSPointerCancel" : "pointercancel", this._pointerCancel, !1);
            this.map && (this._mouseOver = g.hitch(this, this._mouseOver), this._mouseOut = g.hitch(this, this._mouseOut), this._mouseLeave = g.hitch(this, this._mouseLeave), this._mouseDown = g.hitch(this, this._mouseDown), this._mouseUp = g.hitch(this, this._mouseUp), this._mouseClick = g.hitch(this, this._mouseClick), this._mouseWheel = g.hitch(this,
                this._mouseWheel), this._mouseMove = g.hitch(this, this._mouseMove), this._mouseEnter = g.hitch(this, this._mouseEnter), this._onKeyDown = g.hitch(this, this._onKeyDown), this._onKeyUp = g.hitch(this, this._onKeyUp), a.addEventListener("mouseover", this._mouseOver, !1), a.addEventListener("mouseout", this._mouseOut, !1), a.addEventListener("mouseleave", this._mouseLeave, !1), a.addEventListener("mousedown", this._mouseDown, !1), a.addEventListener("mouseup", this._mouseUp, !1), a.addEventListener("click", this._mouseClick, !1), a.addEventListener("mousewheel",
                this._mouseWheel, !1), a.addEventListener("mousemove", this._mouseMove, !1), a.addEventListener("mouseenter", this._mouseEnter, !1));
            this._numTouches = 0;
            this._touches = {};
            this._touchIds = [];
            this._taps = [];
            this._immediate = !1
        },
        _pointerDown: function(a) {
            if (-1 < h.indexOf(this._touchIds, a.pointerId)) this._pointerUp(a);
            else {
                var c = this._touches,
                    b = a.target,
                    d = a.pointerId,
                    e = this._touchIds,
                    f, g = (new Date).getTime();
                f = c[d] = {};
                f.pointerId = d;
                f.startX = f.pageX = a.pageX;
                f.startY = f.pageY = a.pageY;
                f.startTS = g;
                e.push(d);
                this._numTouches++;
                b.setPointerCapture ? b.setPointerCapture(d) : b.msSetPointerCapture && b.msSetPointerCapture(d);
                b = c[e[0]];
                c = c[e[1]];
                1 !== this._numTouches && (2 === this._numTouches ? this._swipeActive && (b && (b.startX = b.pageX, b.startY = b.pageY, b.moved = !1), this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, b))) : this._swipeActive ? (this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, b))) : this._pinchActive && (this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, [b, c]))))
            }
        },
        _pointerMove: function(a) {
            var c =
                this._touches,
                b = this._touchIds,
                d, e, f;
            if ((d = c[a.pointerId]) && !(d.pageX === a.pageX && d.pageY === a.pageY)) {
                d.pageX = a.pageX;
                d.pageY = a.pageY;
                e = Math.abs(d.pageX - d.startX);
                f = Math.abs(d.pageY - d.startY);
                if (!d.moved && (e >= this.tapRadius || f >= this.tapRadius)) d.moved = d.absMoved = !0;
                if (1 === this._numTouches) this._swipeActive ? this._fire("onSwipeMove", this._processTouchEvent(a, a)) : d.moved && (this._swipeActive = !0, this._fire("onSwipeStart", this._processTouchEvent(a, a)));
                else if (2 === this._numTouches)
                    if (d = c[b[0]], c = c[b[1]],
                        this._pinchActive) this._fire("onPinchMove", this._processTouchEvent(a, [d, c]));
                    else if (d.moved || c.moved) b = Math.abs(d.startX - c.startX), e = Math.abs(d.startY - c.startY), b = Math.sqrt(b * b + e * e), e = Math.abs(d.pageX - c.pageX), f = Math.abs(d.pageY - c.pageY), e = Math.sqrt(e * e + f * f), Math.abs(e - b) >= 2 * this.tapRadius && (this._pinchActive = !0, this._fire("onPinchStart", this._processTouchEvent(a, [d, c])))
            }
        },
        _pointerUp: function(a) {
            var c = this._touches,
                b, d = this.node,
                e = a.target,
                f = a.pointerId,
                g = this._touchIds,
                n = g.slice(0),
                k = h.map(n, function(a) {
                    return c[a]
                }),
                m = (new Date).getTime();
            if (b = c[f])
                if (b.pageX = a.pageX, b.pageY = a.pageY, b.endTS = m, this._numTouches--, e.releasePointerCapture ? e.releasePointerCapture(f) : e.msReleasePointerCapture && e.msReleasePointerCapture(f), 0 === this._numTouches)
                    if (this._touches = {}, this._touchIds = [], this._swipeActive) this._swipeActive = !1, this._fire("onSwipeEnd", this._processTouchEvent(a, a));
                    else if (this._pinchActive) this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, a));
            else {
                if (!b.absMoved) {
                    var e = Infinity,
                        f = -Infinity,
                        g = Infinity,
                        m = -Infinity,
                        l = this.tapStartTolerance,
                        p;
                    for (p = 0; p < n.length; p++) b = k[p], b.startTS < e && (e = b.startTS), b.startTS > f && (f = b.startTS), b.endTS < g && (g = b.endTS), b.endTS > m && (m = b.endTS);
                    Math.abs(f - e) <= l && Math.abs(m - g) <= l && this._basicTap(a, k)
                }
            } else 1 === this._numTouches && this._pinchActive && (g.splice(h.indexOf(g, a.pointerId), 1), delete c[a.pointerId], b = c[g[0]], b.startX = b.pageX, b.startY = b.pageY, b.moved = !1, document.msElementsFromPoint && (n = document.msElementsFromPoint(b.pageX, b.pageY), h.some(n, function(a) {
                return a ===
                    d
            }) || (this._touches = {}, this._touchIds = [], this._numTouches = 0)), this._pinchActive = !1, this._fire("onPinchEnd", this._processTouchEvent(a, [a, b])))
        },
        _pointerCancel: function(a) {
            this._numTouches && this._pointerUp(a)
        },
        _basicTap: function(a, c) {
            var b = (new Date).getTime(),
                d = this,
                e = this._immediate;
            a = this._processTouchEvent(a, c);
            this._taps.push({
                touchInfos: c,
                ts: b,
                event: a
            });
            2 < this._taps.length && this._taps.shift();
            this._fire("onBasicTap", a);
            clearTimeout(this._tapTimer);
            b = 2 === this._taps.length ? this.doubleTapDuration /
                2 : this.doubleTapDuration;
            this._tapTimer = setTimeout(function() {
                var a = d;
                d = null;
                clearTimeout(a._tapTimer);
                a._analyzeTap(e)
            }, e ? 0 : b)
        },
        _analyzeTap: function(a) {
            var c = this._taps,
                b = c[0],
                d = c[1],
                e = b.touchInfos,
                f = d && d.touchInfos;
            c.length && (a || (this._taps = []), b && d ? e.length === f.length ? d.ts - b.ts <= this.doubleTapDuration ? (1 === e.length ? (a = Math.abs(e[0].startX - f[0].startX), e = Math.abs(e[0].startY - f[0].startY), e = a <= this.doubleTapRadius && e <= this.doubleTapRadius) : e = !0, e ? this._processedDoubleTap(c) : this._processedTap(d)) :
                this._processedTap(d) : this._processedTap(d) : this._processedTap(b || d))
        },
        _processedTap: function(a) {
            var c = a.event;
            this._fire("onProcessedTap", c);
            1 === a.touchInfos.length ? this._fire("onTap", this._fixEvent(c)) : 2 === a.touchInfos.length && this._fire("onTwoFingerTap", c)
        },
        _processedDoubleTap: function(a) {
            var c = 1 === a[1].touchInfos.length,
                b;
            c && (b = [this._fixEvent(a[0].event), this._fixEvent(a[1].event)], b[1].relatedEvents = b);
            a = [a[0].event, a[1].event];
            a[1].relatedEvents = a;
            this._fire("onProcessedDoubleTap", a[1]);
            c &&
                (this._fire("onDoubleTap", b[1]), this._fire("onDblClick", b[1]))
        },
        _mouseOver: function(a) {
            this._fire("onMouseOver", this._processMouseEvent(a))
        },
        _mouseMove: function(a) {
            this._fire("onMouseMove", this._processMouseEvent(a))
        },
        _mouseOut: function(a) {
            this._fire("onMouseOut", this._processMouseEvent(a))
        },
        _mouseLeave: function(a) {
            document.removeEventListener("keydown", this._onKeyDown, !1);
            document.removeEventListener("keyup", this._onKeyUp, !1);
            this._fire("onMouseOut", this._processMouseEvent(event))
        },
        _mouseDown: function(a) {
            this._downX =
                a.pageX;
            this._downY = a.pageY;
            this._fire("onMouseDown", this._processMouseEvent(a))
        },
        _mouseUp: function(a) {
            this._fire("onMouseUp", this._processMouseEvent(a))
        },
        _mouseClick: function(a) {
            Math.abs(a.pageX - this._downX) <= this.clickRadius && Math.abs(a.pageY - this._downY) <= this.clickRadius && this._fire("onClick", this._processMouseEvent(a))
        },
        _mouseWheel: function(a) {
            var c = this.map;
            (c ? c.isScrollWheelZoom || c.isScrollWheelPan : this.preventPageScroll) && a.preventDefault();
            var c = a.wheelDelta ? a.wheelDelta / this.wheelDivisor :
                -a.detail / this.mozWheelDivisor,
                b = Math.abs(c),
                b = b <= this.minWheelValue ? this.minWheelValue : this.maxWheelValue;
            a.value = 0 > c ? -b : b;
            this._fire("onMouseWheel", this._processMouseEvent(a))
        },
        _mouseEnter: function(a) {
            document.removeEventListener("keydown", this._onKeyDown, !1);
            document.removeEventListener("keyup", this._onKeyUp, !1);
            document.addEventListener("keydown", this._onKeyDown, !1);
            document.addEventListener("keyup", this._onKeyUp, !1);
            this._fire("onMouseEnter", this._processMouseEvent(a))
        },
        _onKeyDown: function(a) {
            this._fire("onKeyDown",
                a)
        },
        _onKeyUp: function(a) {
            this._fire("onKeyUp", a)
        },
        _fire: function(a, c) {
            if (this[a]) this[a](c);
            if (this.map && this.map[a]) this.map[a](c)
        },
        _fixEvent: function(a) {
            var c = {},
                b;
            for (b in a) c[b] = a[b];
            this.map && (c.screenPoint = c.screenPoints[0], c.mapPoint = c.mapPoints[0]);
            return c
        },
        _processTouchEvent: function(a, c) {
            var b = this.map,
                d = b && b.position,
                e = 0;
            if (d && c)
                if (g.isArray(c)) {
                    var f, h;
                    a.screenPoints = [];
                    a.mapPoints = [];
                    for (f = 0; f < c.length; f++) c[f] ? (h = new l(c[f].pageX - d.x, c[f].pageY - d.y), a.screenPoints.push(h), a.mapPoints.push(b.extent ?
                        b.toMap(h) : new k)) : e++
                } else a.screenPoint = new l(c.pageX - d.x, c.pageY - d.y), a.mapPoint = b.extent ? b.toMap(a.screenPoint) : new k;
            a.numPoints = c ? g.isArray(c) ? c.length - e : 1 : 0;
            return a
        },
        _processMouseEvent: function(a) {
            var c = this.map,
                b = c && c.position;
            b && (a.screenPoint = new l(a.pageX - b.x, a.pageY - b.y), a.mapPoint = c.extent ? c.toMap(a.screenPoint) : new k);
            return a
        },
        setImmediateTap: function(a) {
            this._immediate = a
        },
        destroy: function() {
            var a = this.node;
            a.removeEventListener("MSPointerDown", this._pointerDown, !1);
            a.removeEventListener("MSPointerMove",
                this._pointerMove, !1);
            a.removeEventListener("MSPointerUp", this._pointerUp, !1);
            a.removeEventListener("MSPointerCancel", this._pointerCancel, !1);
            this.map && (a.removeEventListener("mouseover", this._mouseOver, !1), a.removeEventListener("mousemove", this._mouseMove, !1), a.removeEventListener("mouseout", this._mouseOut, !1), a.removeEventListener("mouseleave", this._mouseLeave, !1), a.removeEventListener("mousedown", this._mouseDown, !1), a.removeEventListener("mouseup", this._mouseUp, !1), a.removeEventListener("click",
                this._mouseClick, !1), a.removeEventListener("mouseenter", this._mouseEnter, !1));
            clearTimeout(this._tapTimer);
            this.node = this.map = this._numTouches = this._touches = this._touchIds = this._taps = null
        }
    })
});
},
'esri/renderers/jsonUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "../Color", "../symbols/jsonUtils", "./SimpleRenderer", "./UniqueValueRenderer", "./ClassBreaksRenderer", "./DotDensityRenderer", "./ScaleDependentRenderer", "./TimeClassBreaksAger", "./TimeRampAger", "./TemporalRenderer", "./HeatmapRenderer"], function(g, k, w, m, x, f, l, n, p, q, r, s, e, t, u, v) {
    return {
        fromJson: function(a) {
            var b;
            switch (a.type || "") {
                case "simple":
                    b = new n(a);
                    break;
                case "uniqueValue":
                    b = new p(a);
                    break;
                case "classBreaks":
                    b = new q(a);
                    break;
                case "scaleDependent":
                    b =
                        this._scaleDependentFromJson(a);
                    break;
                case "dotDensity":
                    b = this._dotDensityFromJson(a);
                    break;
                case "temporal":
                    b = this._temporalFromJson(a);
                    break;
                case "heatmap":
                    b = this._heatmapFromJson(a)
            }
            return b
        },
        _scaleDependentFromJson: function(a) {
            var b = {},
                c = a.minScale;
            b.rendererInfos = g.map(a.rendererInfos, function(a) {
                var b = a.maxScale;
                a = {
                    minScale: c,
                    maxScale: b,
                    renderer: a.renderer && this.fromJson(a.renderer)
                };
                c = b;
                return a
            }, this);
            return new s(b)
        },
        _dotDensityFromJson: function(a) {
            a.backgroundColor && k.isArray(a.backgroundColor) &&
                (a.backgroundColor = f.toDojoColor(a.backgroundColor));
            0 < a.dotSize && (a.dotSize = m.pt2px(a.dotSize));
            a.fields && g.forEach(a.fields, function(a) {
                a && k.isArray(a.color) && (a.color = f.toDojoColor(a.color))
            });
            a.legendOptions && (a.legendOptions.backgroundColor && k.isArray(a.legendOptions.backgroundColor) && (a.legendOptions.backgroundColor = f.toDojoColor(a.legendOptions.backgroundColor)), a.legendOptions.outline && (a.legendOptions.outline = l.fromJson(a.legendOptions.outline)));
            a.outline && (a.outline = l.fromJson(a.outline));
            return new r(a)
        },
        _temporalFromJson: function(a) {
            var b, c, d;
            a = a || {};
            b = this.fromJson(a.observationRenderer);
            c = a.latestObservationRenderer ? this.fromJson(a.latestObservationRenderer) : null;
            d = a.trackRenderer ? this.fromJson(a.trackRenderer) : null;
            a = this._agerFromJson(a.observationAger);
            return new u(b, c, d, a)
        },
        _agerFromJson: function(a) {
            var b;
            a = a || {};
            a.colorRange || a.sizeRange || a.alphaRange ? b = this._timeRampFromJson(a) : a.agerClassBreakInfos && (b = this._timeClassBreaksFromJson(a));
            return b
        },
        _timeRampFromJson: function(a) {
            var b,
                c, d;
            a.colorRange && 1 < a.colorRange.length && (b = [f.toDojoColor(a.colorRange[0]), f.toDojoColor(a.colorRange[1])]);
            a.sizeRange && 1 < a.sizeRange.length && (c = [a.sizeRange[0], a.sizeRange[1]]);
            a.alphaRange && 1 < a.alphaRange.length && (d = [a.alphaRange[0] / 255, a.alphaRange[1] / 255]);
            return new t(b, c, d)
        },
        _timeClassBreaksFromJson: function(a) {
            var b = a.agerClassBreakInfos,
                c, d, g = [],
                h;
            c = e.UNIT_DAYS;
            switch (a.timeUnits) {
                case "esriTimeUnitsSeconds":
                    c = e.UNIT_SECONDS;
                    break;
                case "esriTimeUnitsMilliseconds":
                    c = e.UNIT_MILLISECONDS;
                    break;
                case "esriTimeUnitsHours":
                    c = e.UNIT_HOURS;
                    break;
                case "esriTimeUnitsMinutes":
                    c = e.UNIT_MINUTES;
                    break;
                case "esriTimeUnitsMonths":
                    c = e.UNIT_MONTHS;
                    break;
                case "esriTimeUnitsWeeks":
                    c = e.UNIT_WEEKS;
                    break;
                case "esriTimeUnitsYears":
                    c = e.UNIT_YEARS
            }
            for (h = 0; h < b.length; h += 1) a = b[h], d = {
                minAge: 0,
                maxAge: a.oldestAge || Infinity
            }, a.color && (d.color = f.toDojoColor(a.color)), a.alpha && (d.alpha = a.alpha / 255), d.size = a.size, g[h] = d;
            return new e(g, c)
        },
        _heatmapFromJson: function(a) {
            var b = a.colorStops;
            b && b instanceof Array && g.forEach(b,
                function(a) {
                    a.color = f.toDojoColor(a.color)
                });
            return new v(a)
        }
    }
});
},
'esri/renderers/SimpleRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../symbols/jsonUtils", "./Renderer"], function(c, d, h, k, e, f, g) {
    return c(g, {
        declaredClass: "esri.renderer.SimpleRenderer",
        constructor: function(a) {
            if (a && !a.declaredClass) {
                var b = a;
                this.symbol = (a = b.symbol) && (a.declaredClass ? a : f.fromJson(a));
                this.label = b.label;
                this.description = b.description
            } else this.symbol = a
        },
        getSymbol: function(a) {
            return this.symbol
        },
        toJson: function() {
            var a = d.mixin(this.inherited(arguments), {
                type: "simple",
                label: this.label,
                description: this.description,
                symbol: this.symbol && this.symbol.toJson()
            });
            return e.fixJson(a)
        }
    })
});
},
'esri/renderers/Renderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "dojox/gfx/_base", "../kernel", "../Color"], function(u, l, e, v, q, w, n) {
    return u(null, {
        declaredClass: "esri.renderer.Renderer",
        constructor: function(a) {
            this._ipDataCache = {};
            if (a && !a.declaredClass) {
                this.rotationInfo = a.rotationInfo;
                if (!this.rotationInfo) {
                    var b = a.rotationType,
                        c = a.rotationExpression;
                    if (b || c) this.rotationInfo = {
                        type: b,
                        expression: c
                    }
                }
                this.setRotationInfo(this.rotationInfo);
                this.setSizeInfo(this._readSizeInfo(a.sizeInfo));
                this.setColorInfo(this._readColorInfo(a.colorInfo));
                this.setOpacityInfo(this._readOpacityInfo(a.transparencyInfo));
                this.setVisualVariables(this._readVariables(a.visualVariables))
            }
            this.getSymbol = l.hitch(this, this.getSymbol)
        },
        getSymbol: function(a) {},
        _readSizeInfo: function(a) {
            a && (a.minSize && (a.minSize = q.pt2px(a.minSize)), a.maxSize && (a.maxSize = q.pt2px(a.maxSize)));
            return a
        },
        _readColorInfo: function(a) {
            a && (e.forEach(a.colors, function(b, c) {
                l.isArray(b) && (a.colors[c] = n.toDojoColor(b))
            }), e.forEach(a.stops, function(b, c) {
                b.color && l.isArray(b.color) && (a.stops[c].color =
                    n.toDojoColor(b.color))
            }));
            return a
        },
        _readOpacityInfo: function(a) {
            var b;
            a && (b = l.mixin({}, a), b.transparencyValues && (b.opacityValues = e.map(b.transparencyValues, function(a) {
                return 1 - a / 100
            }), delete b.transparencyValues), b.stops && (b.stops = e.map(b.stops, function(a) {
                a = l.mixin({}, a);
                a.opacity = 1 - a.transparency / 100;
                delete a.transparency;
                return a
            })));
            return b
        },
        _readVariables: function(a) {
            a && (a = e.map(a, function(a) {
                "sizeInfo" === a.type ? a = this._readSizeInfo(a) : "colorInfo" === a.type ? a = this._readColorInfo(a) : "transparencyInfo" ===
                    a.type && (a = this._readOpacityInfo(a), a.type = "opacityInfo");
                return a
            }, this));
            return a
        },
        setRotationInfo: function(a) {
            if ((a = this.rotationInfo = "string" === typeof a ? {
                    field: a
                } : a) && a.expression && !a.field) {
                var b = a.expression.match(this.rotationRE);
                b && b[1] && (a.field = b[1])
            }
            return this
        },
        rotationRE: /^\[([^\]]+)\]$/i,
        getRotationAngle: function(a) {
            var b = this.rotationInfo,
                c = "arithmetic" === b.type,
                b = b.field,
                d = a.attributes,
                f = 0;
            b && (l.isFunction(b) ? f = b.apply(this, arguments) : d && (f = d[b] || 0), f = (f + (c ? -90 : 0)) * (c ? -1 : 1));
            return f
        },
        setVisualVariables: function(a) {
            var b = this._ipDataCache;
            e.forEach(this.visualVariables, function(a, d) {
                b.hasOwnProperty(d) && (b[d] = null)
            }, this);
            this.visualVariables = a;
            e.forEach(a, function(a, d) {
                "colorInfo" === a.type ? b[d] = this._processColorInfo(a) : "opacityInfo" === a.type && (b[d] = this._processOpacityInfo(a))
            }, this);
            return this
        },
        getVisualVariableValues: function(a) {
            var b = this.visualVariables,
                c;
            b && (c = e.map(b, function(b) {
                var c;
                switch (b.type) {
                    case "sizeInfo":
                        c = this.getSize(a, {
                            sizeInfo: b
                        });
                        break;
                    case "colorInfo":
                        c =
                            this.getColor(a, {
                                colorInfo: b
                            });
                        break;
                    case "opacityInfo":
                        c = this.getOpacity(a, {
                            opacityInfo: b
                        })
                }
                return {
                    variable: b,
                    value: c
                }
            }, this));
            return c
        },
        setSizeInfo: function(a) {
            this.sizeInfo = this.proportionalSymbolInfo = a;
            return this
        },
        setProportionalSymbolInfo: function(a) {
            this.setSizeInfo(a);
            return this
        },
        getSize: function(a, b) {
            var c = a.attributes,
                d = b && b.sizeInfo || this.sizeInfo,
                f = d && d.field,
                g = 0,
                e = "number" === typeof a,
                h = e ? a : null;
            if (f) {
                var k = d.minSize,
                    m = d.maxSize,
                    p = d.minDataValue,
                    n = d.maxDataValue,
                    q = d.valueUnit || "unknown",
                    s = d.valueRepresentation,
                    t = d.normalizationField,
                    r = c ? parseFloat(c[t]) : void 0,
                    d = b && b.shape;
                "number" !== typeof h && (l.isFunction(f) ? h = f.apply(this, arguments) : c && (h = c[f]));
                if (null == h || t && !e && (isNaN(r) || 0 === r)) return null;
                !isNaN(r) && !e && (h /= r);
                if (null != k && null != m && null != p && null != n) g = h <= p ? k : h >= n ? m : k + (h - p) / (n - p) * (m - k);
                else if ("unknown" === q) null != k && null != p && (k && p ? (h /= p, g = "circle" === d ? 2 * Math.sqrt(h * Math.pow(k / 2, 2)) : "square" === d || "diamond" === d || "image" === d ? Math.sqrt(h * Math.pow(k, 2)) : h * k) : g = h + (k || p), g = g < k ? k : g,
                    null != m && g > m && (g = m));
                else {
                    c = (b && b.resolution ? b.resolution : 1) * this._meterIn[q];
                    if ("area" === s) g = Math.sqrt(h / Math.PI) / c, g *= 2;
                    else if (g = h / c, "radius" === s || "distance" === s) g *= 2;
                    null != k && g < k && (g = k);
                    null != m && g > m && (g = m)
                }
            } else d && (g = d.minSize);
            return g = isNaN(g) ? 0 : g
        },
        setColorInfo: function(a) {
            this.colorInfo = a;
            this._ipDataCache.colorInfo = this._processColorInfo(a);
            return this
        },
        _processColorInfo: function(a) {
            a && (e.forEach(a.colors, function(b, c) {
                l.isArray(b) && (a.colors[c] = new n(b))
            }), e.forEach(a.stops, function(b, c) {
                b.color &&
                    l.isArray(b.color) && (a.stops[c].color = new n(b.color))
            }));
            return this._interpolateData(a)
        },
        getColor: function(a, b) {
            var c, d = b && b.colorInfo;
            d && "colorInfo" === d.type ? (c = e.indexOf(this.visualVariables, d), d = this.visualVariables[c]) : (c = "colorInfo", d = this.colorInfo);
            return this._getColorComponent(a, d, this._ipDataCache[c])
        },
        setOpacityInfo: function(a) {
            this.opacityInfo = a;
            this._ipDataCache.opacityInfo = this._processOpacityInfo(a);
            return this
        },
        _processOpacityInfo: function(a) {
            return this._interpolateData(a)
        },
        getOpacity: function(a,
            b) {
            var c, d = b && b.opacityInfo;
            d && "opacityInfo" === d.type ? (c = e.indexOf(this.visualVariables, d), d = this.visualVariables[c]) : (c = "opacityInfo", d = this.opacityInfo);
            return this._getColorComponent(a, d, this._ipDataCache[c], !0)
        },
        _getColorComponent: function(a, b, c, d) {
            var f = a.attributes,
                g = b && b.field,
                e = "number" === typeof a ? a : null,
                h;
            if (g) {
                var k = b.normalizationField,
                    m = f ? parseFloat(f[k]) : void 0;
                "number" !== typeof e && (l.isFunction(g) ? e = g.apply(this, arguments) : f && (e = f[g]));
                null != e && (k && (!isNaN(m) && 0 !== m) && (e /= m), h = d ? this._getOpacity(e,
                    b, c) : this._getColor(e, b, c))
            } else b && (f = b.stops, d ? (h = f && f[0] && f[0].opacity, null == h && (h = b.opacityValues && b.opacityValues[0])) : h = f && f[0] && f[0].color || b.colors && b.colors[0]);
            return h
        },
        _interpolateData: function(a) {
            var b;
            if (a && a.field)
                if (a.colors || a.opacityValues) {
                    var c = (a.colors || a.opacityValues).length,
                        d = a.minDataValue,
                        f = (a.maxDataValue - d) / (c - 1);
                    b = [];
                    for (a = 0; a < c; a++) b[a] = d + a * f
                } else a.stops && (b = e.map(a.stops, function(a) {
                    return a.value
                }));
            return b
        },
        _getOpacity: function(a, b, c) {
            a = this._lookupData(a, c);
            var d;
            b = b || this.opacityInfo;
            a && (c = a[0], d = a[1], c === d ? d = this._getOpacValue(b, c) : (c = this._getOpacValue(b, c), b = this._getOpacValue(b, d), d = c + (b - c) * a[2]));
            return d
        },
        _getOpacValue: function(a, b) {
            return a.opacityValues ? a.opacityValues[b] : a.stops[b].opacity
        },
        _getColor: function(a, b, c) {
            a = this._lookupData(a, c);
            var d;
            b = b || this.colorInfo;
            a && (d = a[0], c = a[1], d = d === c ? this._getColorObj(b, d) : n.blendColors(this._getColorObj(b, d), this._getColorObj(b, c), a[2]));
            return d
        },
        _getColorObj: function(a, b) {
            return a.colors ? a.colors[b] : a.stops[b].color
        },
        _lookupData: function(a, b) {
            var c;
            if (b) {
                var d = 0,
                    f = b.length - 1;
                e.some(b, function(b, c) {
                    if (a < b) return f = c, !0;
                    d = c;
                    return !1
                });
                c = [d, f, (a - b[d]) / (b[f] - b[d])]
            }
            return c
        },
        _meterIn: {
            inches: 39.3701,
            feet: 3.28084,
            yards: 1.09361,
            miles: 6.21371E-4,
            "nautical-miles": 5.39957E-4,
            millimeters: 1E3,
            centimeters: 100,
            decimeters: 10,
            meters: 1,
            kilometers: 0.0010,
            "decimal-degrees": 180 / 20015077
        },
        _writeSizeInfo: function(a) {
            if (a) {
                a = l.mixin({}, a);
                a.minSize && (a.minSize = q.px2pt(a.minSize));
                a.maxSize && (a.maxSize = q.px2pt(a.maxSize));
                var b = a.legendOptions;
                if (b && (a.legendOptions = l.mixin({}, b), b = b.customValues)) a.legendOptions.customValues = b.slice(0)
            }
            return a
        },
        _writeColorInfo: function(a) {
            a && (a = l.mixin({}, a), a.colors && (a.colors = e.map(a.colors, function(a) {
                return n.toJsonColor(a)
            })), a.stops && (a.stops = e.map(a.stops, function(a) {
                a = l.mixin({}, a);
                a.color && (a.color = n.toJsonColor(a.color));
                return a
            })));
            return a
        },
        _writeOpacityInfo: function(a) {
            var b;
            a && (b = l.mixin({}, a), b.opacityValues && (b.transparencyValues = e.map(b.opacityValues, function(a) {
                    return 100 * (1 - a)
                }), delete b.opacityValues),
                b.stops && (b.stops = e.map(b.stops, function(a) {
                    a = l.mixin({}, a);
                    a.transparency = 100 * (1 - a.opacity);
                    delete a.opacity;
                    return a
                })));
            return b
        },
        toJson: function() {
            var a = this.visualVariables,
                b = this.rotationInfo,
                c = b && b.field,
                c = b && (b.expression || c && (l.isFunction(c) ? c : "[" + c + "]"));
            a && (a = e.map(a, function(a) {
                "sizeInfo" === a.type ? a = this._writeSizeInfo(a) : "colorInfo" === a.type ? a = this._writeColorInfo(a) : "opacityInfo" === a.type && (a = this._writeOpacityInfo(a), a.type = "transparencyInfo");
                return a
            }, this));
            return {
                rotationType: c &&
                    (b.type || "geographic"),
                rotationExpression: c,
                colorInfo: this._writeColorInfo(this.colorInfo),
                transparencyInfo: this._writeOpacityInfo(this.opacityInfo),
                sizeInfo: this._writeSizeInfo(this.sizeInfo),
                visualVariables: a
            }
        }
    })
});
},
'esri/renderers/UniqueValueRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../symbols/jsonUtils", "./Renderer"], function(k, g, f, n, p, l, h, m) {
    return k(m, {
        declaredClass: "esri.renderer.UniqueValueRenderer",
        constructor: function(b, a, c, e, d) {
            this.values = [];
            this._symbols = {};
            this.infos = [];
            b && !b.declaredClass ? (a = b, this.defaultSymbol = (b = a.defaultSymbol) && (b.declaredClass ? b : h.fromJson(b)), this.attributeField = a.field1, this.attributeField2 = a.field2, this.attributeField3 = a.field3, this.fieldDelimiter =
                a.fieldDelimiter, this.defaultLabel = a.defaultLabel, g.forEach(a.uniqueValueInfos, this._addValueInfo, this)) : (this.defaultSymbol = b, this.attributeField = a, this.attributeField2 = c, this.attributeField3 = e, this.fieldDelimiter = d);
            this._multiple = !!this.attributeField2
        },
        addValue: function(b, a) {
            var c = f.isObject(b) ? b : {
                value: b,
                symbol: a
            };
            this._addValueInfo(c)
        },
        removeValue: function(b) {
            var a = g.indexOf(this.values, b); - 1 !== a && (this.values.splice(a, 1), delete this._symbols[b], this.infos.splice(a, 1))
        },
        getUniqueValueInfo: function(b) {
            var a =
                this.attributeField,
                c = b.attributes,
                e, d;
            this._multiple ? (b = this.attributeField2, e = this.attributeField3, d = [], a && d.push(c[a]), b && d.push(c[b]), e && d.push(c[e]), a = d.join(this.fieldDelimiter || "")) : a = f.isFunction(a) ? a(b) : c[a];
            return this._symbols[a]
        },
        getSymbol: function(b) {
            return (b = this.getUniqueValueInfo(b)) && b.symbol || this.defaultSymbol
        },
        _addValueInfo: function(b) {
            var a = b.value;
            this.values.push(a);
            this.infos.push(b);
            var c = b.symbol;
            c && !c.declaredClass && (b.symbol = h.fromJson(c));
            this._symbols[a] = b
        },
        toJson: function() {
            var b =
                l.fixJson,
                a = f.mixin(this.inherited(arguments), {
                    type: "uniqueValue",
                    field1: this.attributeField,
                    field2: this.attributeField2,
                    field3: this.attributeField3,
                    fieldDelimiter: this.fieldDelimiter,
                    defaultSymbol: this.defaultSymbol && this.defaultSymbol.toJson(),
                    defaultLabel: this.defaultLabel,
                    uniqueValueInfos: g.map(this.infos || [], function(a) {
                        a = f.mixin({}, a);
                        a.symbol = a.symbol && a.symbol.toJson();
                        a.value += "";
                        return b(a)
                    })
                });
            return b(a)
        }
    })
});
},
'esri/renderers/ClassBreaksRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../symbols/jsonUtils", "./Renderer"], function(p, h, k, r, s, n, m, q) {
    return p(q, {
        declaredClass: "esri.renderer.ClassBreaksRenderer",
        constructor: function(a, c) {
            this.breaks = [];
            this._symbols = {};
            this.infos = [];
            this.isMaxInclusive = !0;
            if (a && !a.declaredClass) {
                var b = a;
                this.attributeField = b.field;
                this.defaultSymbol = (a = b.defaultSymbol) && (a.declaredClass ? a : m.fromJson(a));
                this.backgroundFillSymbol = (a = b.backgroundFillSymbol) &&
                    (a.declaredClass ? a : m.fromJson(a));
                this._copy(["defaultLabel", "classificationMethod:rest", "normalizationType:rest", "normalizationField", "normalizationTotal"], b, this);
                var e = b.minValue;
                (b = b.classBreakInfos) && (b[0] && n.isDefined(b[0].classMaxValue)) && h.forEach(b, function(a) {
                    var b = a.classMaxValue;
                    a.minValue = e;
                    e = a.maxValue = b
                }, this);
                h.forEach(b, this._addBreakInfo, this)
            } else this.defaultSymbol = a, this.attributeField = c
        },
        addBreak: function(a, c, b) {
            a = k.isObject(a) ? a : {
                minValue: a,
                maxValue: c,
                symbol: b
            };
            this._addBreakInfo(a)
        },
        removeBreak: function(a, c) {
            var b, e = this.breaks,
                d, g = e.length,
                f = this._symbols;
            for (d = 0; d < g; d++)
                if (b = e[d], b[0] == a && b[1] == c) {
                    e.splice(d, 1);
                    delete f[a + "-" + c];
                    this.infos.splice(d, 1);
                    break
                }
        },
        clearBreaks: function() {
            this.breaks = [];
            this._symbols = {};
            this.infos = []
        },
        getBreakIndex: function(a) {
            var c = this.attributeField,
                b = a.attributes,
                e = this.breaks,
                d = e.length,
                g = this.isMaxInclusive;
            if (k.isFunction(c)) a = c(a);
            else {
                a = parseFloat(b[c]);
                var c = this.normalizationType,
                    f;
                c && (f = parseFloat(this.normalizationTotal), b = parseFloat(b[this.normalizationField]),
                    "log" === c ? a = Math.log(a) * Math.LOG10E : "percent-of-total" === c && !isNaN(f) ? a = 100 * (a / f) : "field" === c && !isNaN(b) && (a /= b))
            }
            for (b = 0; b < d; b++)
                if (c = e[b], c[0] <= a && (g ? a <= c[1] : a < c[1])) return b;
            return -1
        },
        getBreakInfo: function(a) {
            a = this.getBreakIndex(a);
            return -1 !== a ? this.infos[a] : null
        },
        getSymbol: function(a) {
            return (a = this.breaks[this.getBreakIndex(a)]) ? this._symbols[a[0] + "-" + a[1]] : this.defaultSymbol
        },
        setMaxInclusive: function(a) {
            this.isMaxInclusive = a
        },
        _normalizationTypeEnums: [
            ["field", "esriNormalizeByField"],
            ["log",
                "esriNormalizeByLog"
            ],
            ["percent-of-total", "esriNormalizeByPercentOfTotal"]
        ],
        _classificationMethodEnums: [
            ["natural-breaks", "esriClassifyNaturalBreaks"],
            ["equal-interval", "esriClassifyEqualInterval"],
            ["quantile", "esriClassifyQuantile"],
            ["standard-deviation", "esriClassifyStandardDeviation"],
            ["geometrical-interval", "esriClassifyGeometricalInterval"]
        ],
        _copy: function(a, c, b) {
            h.forEach(a, function(a) {
                var d = a.split(":"),
                    g, f, h;
                1 < d.length && (a = d[0], g = this["_" + a + "Enums"], "rest" === d[1] ? (f = "1", h = "0") : "sdk" === d[1] &&
                    (f = "0", h = "1"));
                d = c[a];
                if (void 0 !== d && (b[a] = d, g && f)) {
                    var l, k = g.length;
                    for (l = 0; l < k; l++)
                        if (g[l][f] === d) {
                            b[a] = g[l][h];
                            break
                        }
                }
            }, this)
        },
        _addBreakInfo: function(a) {
            var c = a.minValue,
                b = a.maxValue;
            this.breaks.push([c, b]);
            this.infos.push(a);
            var e = a.symbol;
            e && !e.declaredClass && (a.symbol = m.fromJson(e));
            this._symbols[c + "-" + b] = a.symbol
        },
        toJson: function() {
            var a = this.infos || [],
                c = n.fixJson,
                b = a[0] && a[0].minValue,
                e = this.backgroundFillSymbol,
                a = k.mixin(this.inherited(arguments), {
                    type: "classBreaks",
                    field: this.attributeField,
                    defaultSymbol: this.defaultSymbol && this.defaultSymbol.toJson(),
                    backgroundFillSymbol: e && e.toJson(),
                    minValue: -Infinity === b ? -Number.MAX_VALUE : b,
                    classBreakInfos: h.map(a, function(a) {
                        a = k.mixin({}, a);
                        a.symbol = a.symbol && a.symbol.toJson();
                        a.classMaxValue = Infinity === a.maxValue ? Number.MAX_VALUE : a.maxValue;
                        delete a.minValue;
                        delete a.maxValue;
                        return c(a)
                    })
                });
            this._copy(["defaultLabel", "classificationMethod:sdk", "normalizationType:sdk", "normalizationField", "normalizationTotal"], this, a);
            return c(a)
        }
    })
});
},
'esri/renderers/DotDensityRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/dom-construct", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "../Color", "./Renderer", "../symbols/PictureFillSymbol", "../geometry/ScreenPoint", "../geometry/Point"], function(p, m, q, r, w, s, x, h, k, t, u, v, n) {
    return p(t, {
        declaredClass: "esri.renderer.DotDensityRenderer",
        constructor: function(a) {
            this.dotSize = a.dotSize || 3;
            this.dotValue = a.dotValue;
            this.fields = a.fields;
            this.outline = a.outline;
            this.backgroundColor = a.backgroundColor;
            this.exactCount = a.exactCount ||
                !0;
            this.dotShape = a.dotShape || "square";
            this.legendOptions = a.legendOptions;
            this._exactCountMinArea = 1E4;
            this._currentMapScale = this._map = this._canvas = null;
            this._symbolMap = {};
            this._currentGraphic = this._currentResolution = this._objectIdField = null;
            this._supportsCanvas = window.CanvasRenderingContext2D ? !0 : !1;
            window.CanvasRenderingContext2D || console.log("The DotDensityRenderer requires a Canvas enabled Browser.  IE8 and less does not support Canvas.")
        },
        getSymbol: function(a) {
            var b, c;
            this._currentGraphic = a;
            if (!this._supportsCanvas) return null;
            this._map || (this._map = a.getLayer()._map, this._objectIdField = a.getLayer().objectIdField, this._currentMapScale = this._map.getScale(), this._currentResolution = this._map.extent.getWidth() / this._map.width, this._map.on("zoom-end", m.hitch(this, function(a) {
                this._currentMapScale = this._map.getScale();
                this._currentResolution = a.extent.getWidth() / this._map.width;
                this._symbolMap[this._currentMapScale] = {}
            })));
            if (this._symbolMap[this._currentMapScale] && this._symbolMap[this._currentMapScale][a.attributes[this._objectIdField]]) return b =
                this._symbolMap[this._currentMapScale][a.attributes[this._objectIdField]], c = this._getShapeProperties(a), b.setOffset(c.dx, c.dy), b;
            b = this._generateFieldsCount(this.fields, a.attributes, this.dotValue);
            c = this._getShapeProperties(a);
            b = new u(this._generateImageSrc(c.width, c.height, b, c.minXY, c.maxXY), this.outline, c.width, c.height);
            b.setOffset(c.dx, c.dy);
            this._symbolMap[this._currentMapScale] || (this._symbolMap[this._currentMapScale] = {});
            return this._symbolMap[this._currentMapScale][a.attributes[this._objectIdField]] =
                b
        },
        _generateFieldsCount: function(a, b, c) {
            var e, d;
            for (d = a.length - 1; 0 <= d; d--) e = b[a[d].name] / c, a[d].numPoints = Math.round(e);
            return a
        },
        _getShapeProperties: function(a) {
            var b, c, e, d;
            b = a.geometry.getExtent();
            b.contains(this._map.extent) && (b = this._map.extent);
            e = Math.ceil(b.getWidth() / this._currentResolution);
            d = Math.ceil(b.getHeight() / this._currentResolution);
            c = this._map.toScreen(new n(b.xmin, b.ymin, b.spatialReference));
            b = this._map.toScreen(new n(b.xmax, b.ymax, b.spatialReference));
            a = a.getLayer().getNode().getCTM();
            return {
                minXY: c,
                maxXY: b,
                dx: (c.x - a.e) % e,
                dy: (b.y - a.f) % d,
                width: e,
                height: d
            }
        },
        _generateImageSrc: function(a, b, c, e, d, f) {
            var h = this.dotSize,
                g, k, l;
            this._canvas ? (this._canvas.width = a, this._canvas.height = b) : this._canvas = this._initCanvas(a, b);
            g = this._canvas.getContext("2d");
            if (f = f || this.backgroundColor) g.fillStyle = f.toCss(!0), g.fillRect(0, 0, a, b), g.fill();
            for (f = c.length - 1; 0 <= f; f--) {
                g.fillStyle = c[f].color.toCss(!0);
                for (k = c[f].numPoints - 1; 0 <= k; k--) l = this._getRandomPoint(a, b, e, d), "square" === this.dotShape ? g.fillRect(l.x,
                    l.y, h, h) : "circle" === this.dotShape && (g.beginPath(), g.arc(l.x, l.y, h / 2, 0, 2 * Math.PI, !0)), g.fill()
            }
            return this._canvas.toDataURL()
        },
        _initCanvas: function(a, b) {
            var c = r.create("canvas", {
                id: "canvas",
                width: a + "px",
                height: b + "px",
                style: "position: absolute; left: -10000px; top: 0px;"
            }, null);
            document.body.appendChild(c);
            return c
        },
        _getRandomInt: function(a, b) {
            return Math.floor(Math.random() * (b - a + 1) + a)
        },
        _getRandomPoint: function(a, b, c, e) {
            var d = {},
                f = this.outline && this.outline.width ? this.outline.width : 0;
            if (!0 === this.exactCount &&
                a * b > this._exactCountMinArea) {
                do d.x = this._getRandomInt(c.x, e.x), d.y = this._getRandomInt(e.y, c.y), a = new v(d.x, d.y), a = this._checkPointShapeBounds(a, this.dotSize + f, this._currentGraphic.geometry), !0 === a && (d.x -= c.x, d.y -= e.y); while (!1 === a)
            } else d.x = this._getRandomInt(0, a), d.y = this._getRandomInt(0, b);
            return d
        },
        _checkPointShapeBounds: function(a, b, c) {
            var e = null,
                e = !1,
                d = !0,
                f = 0;
            do {
                switch (f) {
                    case 1:
                        a.x += b;
                        break;
                    case 2:
                        a.y += b;
                        break;
                    case 3:
                        a.x -= b
                }
                e = this._map.toMap(a);
                e = c.contains(e);
                !1 === e && (d = !1);
                f += 1
            } while (3 >=
                f && !0 === d);
            return e
        },
        setDotSize: function(a) {
            0 < a && (this.dotSize = a)
        },
        setDotValue: function(a) {
            0 < a && (this.dotValue = a)
        },
        setOutline: function(a) {
            this.outline = a
        },
        setBackgroundColor: function(a) {
            this.backgroundColor = a
        },
        toJson: function() {
            var a = m.mixin(this.inherited(arguments), {
                type: "dotDensity",
                backgroundColor: k.toJsonColor(this.backgroundColor),
                dotShape: this.dotShape,
                dotSize: 0 < this.dotSize ? s.px2pt(this.dotSize) : 0,
                dotValue: this.dotValue,
                fields: q.map(this.fields, function(a) {
                    return h.fixJson({
                        color: k.toJsonColor(a.color),
                        name: a.name
                    })
                }),
                legendOptions: this.legendOptions && h.fixJson({
                    backgroundColor: k.toJsonColor(this.legendOptions.backgroundColor),
                    dotCoverage: this.legendOptions.dotCoverage,
                    outline: this.legendOptions.outline && this.legendOptions.outline.toJson(),
                    valueUnit: this.legendOptions.valueUnit
                }),
                outline: this.outline && this.outline.toJson()
            });
            return h.fixJson(a)
        }
    })
});
},
'esri/renderers/ScaleDependentRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "./Renderer"], function(m, n, p, r, s, l, q) {
    return m(q, {
        declaredClass: "esri.renderer.ScaleDependentRenderer",
        constructor: function(a) {
            this.setRendererInfos(a && a.rendererInfos || [])
        },
        setRendererInfos: function(a) {
            this.rendererInfos = a;
            this._setRangeType();
            return this
        },
        getSymbol: function(a) {
            var b = this.getRendererInfo(a);
            return b && b.renderer && b.renderer.getSymbol(a)
        },
        getRendererInfo: function(a) {
            a = a.getLayer().getMap();
            return "zoom" === this.rangeType ? this.getRendererInfoByZoom(a.getZoom()) : this.getRendererInfoByScale(a.getScale())
        },
        getRendererInfoByZoom: function(a) {
            var b, c = this.rendererInfos,
                e, d = 0;
            do b = c[d], a >= b.minZoom && a <= b.maxZoom && (e = b), d++; while (!e && d < c.length);
            return e
        },
        getRendererInfoByScale: function(a) {
            var b, c = this.rendererInfos,
                e, d = 0,
                f, g, h, k;
            do b = c[d], f = b.minScale, g = b.maxScale, h = !f, k = !g, !h && a <= f && (h = !0), !k && a >= g && (k = !0), h && k && (e = b), d++; while (!e && d < c.length);
            return e
        },
        addRendererInfo: function(a) {
            var b, c = 0,
                e, d = this.rendererInfos,
                f = a.hasOwnProperty("minZoom") ? "minZoom" : "minScale",
                g = d.length;
            do {
                e = d[c];
                if (g === c || a[f] < e[f]) d.splice(c, 0, a), this._setRangeType(), b = !0;
                c++
            } while (!b && c < g);
            return this
        },
        _setRangeType: function() {
            var a = this.rendererInfos;
            if (a = a && a[0]) this.rangeType = a.hasOwnProperty("minZoom") ? "zoom" : a.hasOwnProperty("minScale") ? "scale" : ""
        },
        toJson: function() {
            if ("zoom" === this.rangeType) return null;
            var a = this.rendererInfos || [],
                b = a[0] && a[0].minScale,
                a = p.mixin(this.inherited(arguments), {
                    type: "scaleDependent",
                    minScale: 0 < b ? b : 0,
                    rendererInfos: n.map(a, function(a) {
                        return l.fixJson({
                            maxScale: 0 < a.maxScale ? a.maxScale : 0,
                            renderer: a.renderer && a.renderer.toJson()
                        })
                    })
                });
            return l.fixJson(a)
        }
    })
});
},
'esri/renderers/TimeClassBreaksAger':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/has", "dojo/date", "../kernel", "../lang", "../symbols/jsonUtils", "../Color", "./SymbolAger"], function(k, l, m, t, n, u, p, q, r, s) {
    var b = k(s, {
        declaredClass: "esri.renderer.TimeClassBreaksAger",
        constructor: function(c, a) {
            this.infos = c;
            this.timeUnits = a || "day";
            c.sort(function(a, c) {
                return a.minAge < c.minAge ? -1 : a.minAge > c.minAge ? 1 : 0
            })
        },
        getAgedSymbol: function(c, a) {
            var e = a.getLayer(),
                b = a.attributes,
                f = p.isDefined;
            c = q.fromJson(c.toJson());
            var g = e._map.timeExtent.endTime;
            if (!g) return c;
            var h = n.difference(new Date(b[e._startTimeField]), g, this.timeUnits);
            l.some(this.infos, function(a) {
                if (h >= a.minAge && h <= a.maxAge) {
                    var e = a.color,
                        b = a.size;
                    a = a.alpha;
                    e && c.setColor(e);
                    f(b) && this._setSymbolSize(c, b);
                    f(a) && c.color && (c.color.a = a);
                    return !0
                }
            }, this);
            return c
        },
        toJson: function() {
            var c = {
                    agerClassBreakInfos: []
                },
                a, b, d;
            c.timeUnits = this._getRestUnits(this.timeUnits);
            for (a = 0; a < this.infos.length; a += 1) b = this.infos[a], d = {}, d.oldestAge = Infinity === b.maxAge ? null : b.maxAge, d.size = b.size, b.color &&
                (d.color = r.toJsonColor(b.color)), b.alpha && (d.alpha = Math.round(255 * b.alpha)), c.agerClassBreakInfos[a] = d;
            return c
        },
        _getRestUnits: function(c) {
            var a = "esriTimeUnitsDays";
            switch (c) {
                case b.UNIT_SECONDS:
                    a = "esriTimeUnitsSeconds";
                    break;
                case b.UNIT_MILLISECONDS:
                    a = "esriTimeUnitsMilliseconds";
                    break;
                case b.UNIT_HOURS:
                    a = "esriTimeUnitsHours";
                    break;
                case b.UNIT_MINUTES:
                    a = "esriTimeUnitsMinutes";
                    break;
                case b.UNIT_MONTHS:
                    a = "esriTimeUnitsMonths";
                    break;
                case b.UNIT_WEEKS:
                    a = "esriTimeUnitsWeeks";
                    break;
                case b.UNIT_YEARS:
                    a =
                        "esriTimeUnitsYears"
            }
            return a
        }
    });
    m.mixin(b, {
        UNIT_DAYS: "day",
        UNIT_HOURS: "hour",
        UNIT_MILLISECONDS: "millisecond",
        UNIT_MINUTES: "minute",
        UNIT_MONTHS: "month",
        UNIT_SECONDS: "second",
        UNIT_WEEKS: "week",
        UNIT_YEARS: "year"
    });
    return b
});
},
'esri/renderers/SymbolAger':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel"], function(c, d, e, f) {
    return c(null, {
        declaredClass: "esri.renderer.SymbolAger",
        getAgedSymbol: function(a, b) {},
        _setSymbolSize: function(a, b) {
            switch (a.type) {
                case "simplemarkersymbol":
                    a.setSize(b);
                    break;
                case "picturemarkersymbol":
                    a.setWidth(b);
                    a.setHeight(b);
                    break;
                case "simplelinesymbol":
                case "cartographiclinesymbol":
                    a.setWidth(b);
                    break;
                case "simplefillsymbol":
                case "picturefillsymbol":
                    a.outline && a.outline.setWidth(b)
            }
        }
    })
});
},
'esri/renderers/TimeRampAger':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Color", "dojo/has", "../kernel", "../symbols/jsonUtils", "../Color", "./SymbolAger"], function(n, s, p, t, u, q, m, r) {
    return n(r, {
        declaredClass: "esri.renderer.TimeRampAger",
        constructor: function(e, k, a) {
            this.colorRange = e;
            this.sizeRange = k;
            this.alphaRange = a
        },
        getAgedSymbol: function(e, k) {
            var a = k.getLayer(),
                c = k.attributes;
            e = q.fromJson(e.toJson());
            var b = a._map.timeExtent,
                d = b.startTime,
                b = b.endTime;
            if (!d || !b) return e;
            d = d.getTime();
            b = b.getTime();
            a = new Date(c[a._startTimeField]);
            a = a.getTime();
            a < d && (a = d);
            d = b === d ? 1 : (a - d) / (b - d);
            if (a = this.sizeRange) c = a[0], b = a[1], a = Math.abs(b - c) * d, this._setSymbolSize(e, c < b ? c + a : c - a);
            if (a = this.colorRange) {
                var b = a[0],
                    g = a[1],
                    l = Math.round,
                    c = new p,
                    f = b.r,
                    h = g.r,
                    a = Math.abs(h - f) * d;
                c.r = l(f < h ? f + a : f - a);
                f = b.g;
                h = g.g;
                a = Math.abs(h - f) * d;
                c.g = l(f < h ? f + a : f - a);
                f = b.b;
                h = g.b;
                a = Math.abs(h - f) * d;
                c.b = l(f < h ? f + a : f - a);
                b = b.a;
                g = g.a;
                a = Math.abs(g - b) * d;
                c.a = b < g ? b + a : b - a;
                e.setColor(c)
            }
            c = e.color;
            if ((a = this.alphaRange) && c) b = a[0], g = a[1], a = Math.abs(g - b) * d, c.a = b < g ? b + a : b - a;
            return e
        },
        toJson: function() {
            var e = {};
            this.sizeRange && (e.sizeRange = this.sizeRange);
            this.colorRange && (e.colorRange = [m.toJsonColor(this.colorRange[0]), m.toJsonColor(this.colorRange[1])]);
            this.alphaRange && (e.alphaRange = [Math.round(255 * this.alphaRange[0]), Math.round(255 * this.alphaRange[1])]);
            return e
        }
    })
});
},
'esri/renderers/TemporalRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./Renderer"], function(f, h, k, l, g) {
    return f(g, {
        declaredClass: "esri.renderer.TemporalRenderer",
        constructor: function(a, d, c, b) {
            this.observationRenderer = a;
            this.latestObservationRenderer = d;
            this.trackRenderer = c;
            this.observationAger = b
        },
        getSymbol: function(a) {
            var d = a.getLayer(),
                c = this.getObservationRenderer(a),
                b = c && c.getSymbol(a),
                e = this.observationAger;
            d.timeInfo && (d._map.timeExtent && c === this.observationRenderer && e && b) && (b = e.getAgedSymbol(b,
                a));
            return b
        },
        getObservationRenderer: function(a) {
            return 0 === a.getLayer()._getKind(a) ? this.observationRenderer : this.latestObservationRenderer || this.observationRenderer
        },
        toJson: function() {
            var a = {
                type: "temporal"
            };
            a.observationRenderer = this.observationRenderer.toJson();
            this.latestObservationRenderer && (a.latestObservationRenderer = this.latestObservationRenderer.toJson());
            this.trackRenderer && (a.trackRenderer = this.trackRenderer.toJson());
            this.observationAger && (a.observationAger = this.observationAger.toJson());
            return a
        }
    })
});
},
'esri/renderers/HeatmapRenderer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/dom-construct", "../sniff", "../kernel", "../lang", "../symbols/PictureMarkerSymbol", "../Color", "./Renderer"], function(m, h, k, n, s, t, p, q, l, r) {
    return m([r], {
        declaredClass: "esri.renderer.HeatmapRenderer",
        colors: null,
        blurRadius: 10,
        maxPixelIntensity: 100,
        minPixelIntensity: 0,
        field: null,
        colorStops: null,
        constructor: function(a) {
            (this._supportsCanvas = window.CanvasRenderingContext2D ? !0 : !1) ? ("string" == typeof a && (a = JSON.parse(a)), h.mixin(this, a), this._canvas =
                null, !this.colors && !this.colorStops && (this.colorStops = [{
                    ratio: 0,
                    color: "rgba(255, 140, 0, 0)"
                }, {
                    ratio: 0.75,
                    color: "rgba(255, 140, 0, 1)"
                }, {
                    ratio: 0.9,
                    color: "rgba(255, 0,   0, 1)"
                }]), this.gradient = this._generateGradient(this.colorStops || this.colors)) : console.log("The HeatmapRenderer requires a Canvas enabled Browser.  IE8 and less does not support Canvas.")
        },
        getSymbol: function(a) {
            if (!this._supportsCanvas) return !1;
            var b = a.attributes.imageData;
            a = a.attributes.size;
            if (!a) return null;
            var c = this._getContext(a[0],
                    a[1]),
                d = c.getImageData(0, 0, a[0], a[1]);
            window.ArrayBuffer && b instanceof ArrayBuffer ? b = window.Uint8ClampedArray ? new Uint8ClampedArray(b) : new Uint8Array(b) : b.BYTES_PER_ELEMENT && 1 !== b.BYTES_PER_ELEMENT && (b = window.Uint8ClampedArray ? new Uint8ClampedArray(b.buffer) : new Uint8Array(b.buffer));
            if (window.CanvasPixelArray && d.data instanceof window.CanvasPixelArray)
                for (var f = d.data, e = f.length; e--;) f[e] = b[e];
            else d.data.set(b);
            c.putImageData(d, 0, 0);
            return new q(c.canvas.toDataURL(), a[0], a[1])
        },
        setColors: function(a) {
            if (a &&
                (a instanceof Array || a.colors)) this.gradient = this._generateGradient(a.colors || a), this.colors = a;
            return this
        },
        setColorStops: function(a) {
            if (a && (a instanceof Array || a.colorStops)) this.gradient = this._generateGradient(a.colorStops || a), this.colorStops = a;
            return this
        },
        setMaxPixelIntensity: function(a) {
            this.maxPixelIntensity = a;
            return this
        },
        setMinPixelIntensity: function(a) {
            this.minPixelIntensity = a;
            return this
        },
        setField: function(a) {
            this.field = a;
            return this
        },
        setBlurRadius: function(a) {
            this.blurRadius = a;
            return this
        },
        getStats: function() {},
        getHistogramData: function() {},
        toJson: function() {
            var a = h.mixin(this.inherited(arguments), {
                type: "heatmap",
                blurRadius: this.blurRadius,
                colorStops: this._colorsToStops(this.colorStops || this.colors),
                maxPixelIntensity: this.maxPixelIntensity,
                minPixelIntensity: this.minPixelIntensity,
                field: this.field
            });
            k.forEach(a.colorStops, function(a) {
                a.color = l.toJsonColor(a.color)
            });
            return p.fixJson(a)
        },
        _getContext: function(a, b) {
            this._canvas ? (this._canvas.width = a, this._canvas.height = b) : this._canvas =
                this._initCanvas(a, b);
            return this._canvas.getContext("2d")
        },
        _initCanvas: function(a, b) {
            var c = n.create("canvas", {
                id: "hm_canvas-" + Math.floor(1E3 * Math.random()),
                style: "position: absolute; left: -10000px; top: 0px;"
            }, null);
            c.width = a;
            c.height = b;
            document.body.appendChild(c);
            return c
        },
        _generateGradient: function(a, b) {
            b || (b = 512);
            for (var c = this._colorsToStops(a), d = this._getContext(1, b || 512), f = d.createLinearGradient(0, 0, 0, b), e = 0, g; e < c.length; e++) g = c[e], f.addColorStop(g.ratio, g.color.toCss(!0));
            d.fillStyle = f;
            d.fillRect(0, 0, 1, b);
            return d.getImageData(0, 0, 1, b).data
        },
        _colorsToStops: function(a) {
            function b(a) {
                !a.toRgba && !a.declaredClass && (a = new l(a));
                return a
            }
            var c = [];
            if (!a[0]) return c;
            if (null != a[0].ratio) c = k.map(a, function(a) {
                a.color = b(a.color);
                return a
            });
            else if (null != a[0].value) {
                var d = Infinity,
                    c = -Infinity,
                    f = 0,
                    e;
                for (e = 0; e < a.length; e++) {
                    var g = a[e].value;
                    g < d && (d = g);
                    g > c && (c = g)
                }
                f = c - d;
                this.maxPixelIntensity = c;
                this.minPixelIntensity = d;
                c = k.map(a, function(a) {
                    var c = a.value;
                    a = b(a.color);
                    return {
                        value: c,
                        ratio: (c - d) /
                            f,
                        color: a
                    }
                })
            } else var h = a.length - 1,
                c = k.map(a, function(a, c) {
                    return {
                        color: b(a),
                        ratio: c / h
                    }
                });
            return c
        }
    })
});
},
'esri/dijit/PopupTemplate':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojo/dom-construct", "../kernel", "../InfoTemplate", "../PopupInfo", "./PopupRenderer"], function(c, d, k, e, l, f, g, h) {
    return c([f, g], {
        declaredClass: "esri.dijit.PopupTemplate",
        "-chains-": {
            constructor: "manual"
        },
        chartTheme: null,
        constructor: function(a, b) {
            d.mixin(this, b);
            this.initialize(a, b)
        },
        getTitle: function(a) {
            var b;
            this.info && (b = this.titleHasRelatedFields ? "" : this._getPopupValues(a, !0).title);
            return b || ""
        },
        getContent: function(a) {
            return this.info ? (new h({
                template: this,
                graphic: a,
                chartTheme: this.chartTheme
            }, e.create("div"))).domNode : ""
        }
    })
});
},
'esri/PopupInfo':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/i18n", "dojo/has", "dojo/Deferred", "dojo/sniff", "dojo/promise/all", "./lang", "./kernel", "./request", "./tasks/query", "./tasks/QueryTask", "./tasks/StatisticDefinition", "dojo/i18n!dojo/cldr/nls/number"], function(F, m, p, z, K, L, C, G, t, g, M, H, D, I, J, E) {
    return F(null, {
        declaredClass: "esri.PopupInfo",
        initialize: function(a, b) {
            if (a) {
                m.mixin(this, b);
                this.info = a;
                this.title = this.getTitle;
                this.content = this.getContent;
                var d = this._fieldLabels = {},
                    c = this._fieldsMap = {};
                a.fieldInfos && p.forEach(a.fieldInfos, function(a) {
                    d[a.fieldName] = a.label;
                    c[a.fieldName] = a
                });
                this._relatedFieldPrefix = "relationships/";
                this.titleHasRelatedFields = !!(a.title && -1 !== a.title.indexOf("{" + this._relatedFieldPrefix))
            }
        },
        toJson: function() {
            return z.fromJson(z.toJson(this.info))
        },
        getTitle: function() {},
        getContent: function() {},
        getComponents: function(a) {
            var b = this.info,
                d = new C,
                c, e;
            b.fieldInfos && (e = p.filter(b.fieldInfos, function(a) {
                return -1 !== a.fieldName.indexOf(this._relatedFieldPrefix)
            }, this));
            e && 0 < e.length && (c = this._getRelatedRecords({
                graphic: a,
                fieldsInfo: e
            }));
            c ? c.always(m.hitch(this, function() {
                d.resolve(this._getPopupValues(a))
            })) : d.resolve(this._getPopupValues(a));
            return d.promise
        },
        _getPopupValues: function(a, b) {
            var d = this.info,
                c = a.getLayer(),
                e = m.clone(a.attributes) || {},
                f = m.clone(e),
                q = d.fieldInfos,
                h = "",
                k = "",
                w, n, l, u, r, A = c && c._getDateOpts && c._getDateOpts().properties,
                s = {
                    dateFormat: {
                        properties: A,
                        formatter: "DateFormat" + this._insertOffset(this._dateFormats.shortDateShortTime)
                    }
                };
            if (this._relatedInfo)
                for (u in this._relatedInfo)
                    if (this._relatedInfo.hasOwnProperty(u)) {
                        var v =
                            this._relatedInfo[u],
                            t = this._relatedLayersInfo[u];
                        v && (p.forEach(v.relatedFeatures, function(a) {
                            for (r in a.attributes)
                                if (a.attributes.hasOwnProperty(r) && "esriRelCardinalityOneToOne" === t.relation.cardinality) {
                                    var b = this._toRelatedFieldName([t.relation.id, r]);
                                    e[b] = f[b] = a.attributes[r]
                                }
                        }, this), p.forEach(v.relatedStatsFeatures, function(a) {
                            for (r in a.attributes)
                                if (a.attributes.hasOwnProperty(r)) {
                                    var b = this._toRelatedFieldName([t.relation.id, r]);
                                    e[b] = f[b] = a.attributes[r]
                                }
                        }, this))
                    }
            q && p.forEach(q, function(a) {
                n =
                    a.fieldName;
                f[n] = this._formatValue(f[n], n, s);
                A && (a.format && a.format.dateFormat) && (a = p.indexOf(A, n), -1 < a && A.splice(a, 1))
            }, this);
            if (c) {
                u = c.types;
                var z = (v = c.typeIdField) && e[v];
                for (n in e)
                    if (e.hasOwnProperty(n) && -1 === n.indexOf(this._relatedFieldPrefix) && (l = e[n], g.isDefined(l))) {
                        var x = this._getDomainName(c, a, u, z, n, l);
                        g.isDefined(x) ? f[n] = x : n === v && (x = this._getTypeName(c, a, l), g.isDefined(x) && (f[n] = x))
                    }
            }
            d.title && (h = this._processFieldsInLinks(this._fixTokens(d.title), e), h = m.trim(g.substitute(f, h, s) || ""));
            if (b) return {
                title: h
            };
            d.description && (k = this._processFieldsInLinks(this._fixTokens(d.description), e), k = m.trim(g.substitute(f, k, s) || ""));
            q && (w = [], p.forEach(q, function(a) {
                (n = a.fieldName) && a.visible && w.push([a.label || n, g.substitute(f, "${" + n + "}", s) || ""])
            }));
            var y, B;
            d.mediaInfos && (y = [], p.forEach(d.mediaInfos, function(a) {
                B = 0;
                l = a.value;
                switch (a.type) {
                    case "image":
                        var b = l.sourceURL,
                            b = b && m.trim(g.substitute(e, this._fixTokens(b)));
                        B = !!b;
                        break;
                    case "piechart":
                    case "linechart":
                    case "columnchart":
                    case "barchart":
                        B = p.some(l.fields,
                            function(a) {
                                return g.isDefined(e[a]) || -1 !== a.indexOf(this._relatedFieldPrefix) && this._relatedInfo
                            }, this);
                        break;
                    default:
                        return
                }
                if (B) {
                    a = m.clone(a);
                    l = a.value;
                    var b = a.title ? this._processFieldsInLinks(this._fixTokens(a.title), e) : "",
                        d = a.caption ? this._processFieldsInLinks(this._fixTokens(a.caption), e) : "";
                    a.title = b ? m.trim(g.substitute(f, b, s) || "") : "";
                    a.caption = d ? m.trim(g.substitute(f, d, s) || "") : "";
                    if ("image" === a.type) l.sourceURL = g.substitute(e, this._fixTokens(l.sourceURL)), l.linkURL && (l.linkURL = m.trim(g.substitute(e,
                        this._fixTokens(l.linkURL)) || ""));
                    else {
                        var c, h;
                        p.forEach(l.fields, function(a, b) {
                            if (-1 !== a.indexOf(this._relatedFieldPrefix)) h = this._getRelatedChartInfos(a, l, e, s), h instanceof Array ? l.fields = h : l.fields[b] = h;
                            else {
                                var d = e[a],
                                    d = void 0 === d ? null : d;
                                c = e[l.normalizeField] || 0;
                                d && c && (d /= c);
                                l.fields[b] = {
                                    y: d,
                                    tooltip: (this._fieldLabels[a] || a) + ":\x3cbr/\x3e" + this._formatValue(d, a, s, !!c)
                                }
                            }
                        }, this)
                    }
                    y.push(a)
                }
            }, this));
            return {
                title: h,
                description: k,
                fields: w && w.length ? w : null,
                mediaInfos: y && y.length ? y : null,
                formatted: f,
                editSummary: c &&
                    c.getEditSummary ? c.getEditSummary(a) : ""
            }
        },
        _getRelatedChartInfos: function(a, b, d, c) {
            var e, f, q, h, k, g;
            e = [];
            g = this._fromRelatedFieldName(a);
            k = g[0];
            f = this._relatedInfo[k];
            k = this._relatedLayersInfo[k];
            f && p.forEach(f.relatedFeatures, function(f) {
                f = f.attributes;
                var l, k;
                for (k in f)
                    if (f.hasOwnProperty(k) && k === g[1]) {
                        l = {};
                        h = f[k];
                        b.normalizeField && (q = -1 !== b.normalizeField.indexOf(this._relatedFieldPrefix) ? f[this._fromRelatedFieldName(b.normalizeField)[1]] : d[b.normalizeField]);
                        h && q && (h /= q);
                        if (b.tooltipField)
                            if (-1 !==
                                b.tooltipField.indexOf(this._relatedFieldPrefix)) {
                                var m = this._fromRelatedFieldName(b.tooltipField)[1];
                                l.tooltip = f[m] + ":\x3cbr/\x3e" + this._formatValue(h, f[m], c, !!q)
                            } else l.tooltip = (this._fieldLabels[a] || a) + ":\x3cbr/\x3e" + this._formatValue(h, b.tooltipField, c, !!q);
                        else l.tooltip = h;
                        l.y = h;
                        e.push(l)
                    }
            }, this);
            return "esriRelCardinalityOneToMany" === k.relation.cardinality || "esriRelCardinalityManyToMany" === k.relation.cardinality ? e : e[0]
        },
        getAttachments: function(a) {
            var b = a.getLayer();
            a = a.attributes;
            if (this.info.showAttachments &&
                (b && b.hasAttachments && b.objectIdField) && (a = a && a[b.objectIdField])) return b.queryAttachmentInfos(a)
        },
        _dateFormats: {
            shortDate: "(datePattern: 'M/d/y', selector: 'date')",
            shortDateLE: "(datePattern: 'd/M/y', selector: 'date')",
            longMonthDayYear: "(datePattern: 'MMMM d, y', selector: 'date')",
            dayShortMonthYear: "(datePattern: 'd MMM y', selector: 'date')",
            longDate: "(datePattern: 'EEEE, MMMM d, y', selector: 'date')",
            shortDateShortTime: "(datePattern: 'M/d/y', timePattern: 'h:mm a', selector: 'date and time')",
            shortDateLEShortTime: "(datePattern: 'd/M/y', timePattern: 'h:mm a', selector: 'date and time')",
            shortDateShortTime24: "(datePattern: 'M/d/y', timePattern: 'H:mm', selector: 'date and time')",
            shortDateLEShortTime24: "(datePattern: 'd/M/y', timePattern: 'H:mm', selector: 'date and time')",
            shortDateLongTime: "(datePattern: 'M/d/y', timePattern: 'h:mm:ss a', selector: 'date and time')",
            shortDateLELongTime: "(datePattern: 'd/M/y', timePattern: 'h:mm:ss a', selector: 'date and time')",
            shortDateLongTime24: "(datePattern: 'M/d/y', timePattern: 'H:mm:ss', selector: 'date and time')",
            shortDateLELongTime24: "(datePattern: 'd/M/y', timePattern: 'H:mm:ss', selector: 'date and time')",
            longMonthYear: "(datePattern: 'MMMM y', selector: 'date')",
            shortMonthYear: "(datePattern: 'MMM y', selector: 'date')",
            year: "(datePattern: 'y', selector: 'date')"
        },
        _reHref: /href\s*=\s*\"[^\"]+\"/ig,
        _fixTokens: function(a) {
            return a.replace(/(\{[^\{\r\n]+\})/g, "$$$1")
        },
        _processFieldsInLinks: function(a, b) {
            return a && a.replace(this._reHref, function(a) {
                return a = g.substitute(b, a)
            })
        },
        _formatValue: function(a, b, d,
            c) {
            var e = this._fieldsMap[b],
                f = e && e.format;
            b = "number" === typeof a && -1 === p.indexOf(d.dateFormat.properties, b) && (!f || !f.dateFormat);
            if (!g.isDefined(a) || !e || !g.isDefined(f)) return b ? this._forceLTR(a) : a;
            var q = "",
                h = [],
                e = f.hasOwnProperty("places") || f.hasOwnProperty("digitSeparator"),
                k = f.hasOwnProperty("digitSeparator") ? f.digitSeparator : !0;
            if (e) q = "NumberFormat", h.push("places: " + (g.isDefined(f.places) && (!c || 0 < f.places) ? Number(f.places) : "Infinity")), h.length && (q += "(" + h.join(",") + ")");
            else if (f.dateFormat) q =
                "DateFormat" + this._insertOffset(this._dateFormats[f.dateFormat] || this._dateFormats.shortDateShortTime);
            else return b ? this._forceLTR(a) : a;
            a = g.substitute({
                myKey: a
            }, "${myKey:" + q + "}", d) || "";
            e && !k && E.group && (a = a.replace(RegExp("\\" + E.group, "g"), ""));
            return b ? this._forceLTR(a) : a
        },
        _forceLTR: function(a) {
            var b = G("ie");
            return b && 10 >= b ? a : "\x3cspan class\x3d'esriNumericValue'\x3e" + a + "\x3c/span\x3e"
        },
        _insertOffset: function(a) {
            a && (a = g.isDefined(this.utcOffset) ? a.replace(/\)\s*$/, ", utcOffset:" + this.utcOffset + ")") :
                a);
            return a
        },
        _getDomainName: function(a, b, d, c, e, f) {
            return (a = a.getDomain && a.getDomain(e, {
                feature: b
            })) && a.codedValues ? a.getName(f) : null
        },
        _getTypeName: function(a, b, d) {
            return (a = a.getType && a.getType(b)) && a.name
        },
        _getRelatedRecords: function(a) {
            var b = a.graphic,
                d = new C,
                c;
            this._relatedLayersInfo ? this._queryRelatedLayers(b).then(m.hitch(this, function(a) {
                this._setRelatedRecords(b, a);
                d.resolve(a)
            }), m.hitch(this, this._handlerErrorResponse, d)) : this._getRelatedLayersInfo(a).then(m.hitch(this, function(a) {
                for (c in a) a.hasOwnProperty(c) &&
                    a[c] && (this._relatedLayersInfo[c].relatedLayerInfo = a[c]);
                this._queryRelatedLayers(b).then(m.hitch(this, function(a) {
                    this._setRelatedRecords(b, a);
                    d.resolve(a)
                }), m.hitch(this, this._handlerErrorResponse, d))
            }), m.hitch(this, this._handlerErrorResponse, d));
            return d.promise
        },
        _getRelatedLayersInfo: function(a) {
            var b = a.fieldsInfo,
                d, c, e = {};
            d = a.graphic.getLayer();
            this._relatedLayersInfo || (this._relatedLayersInfo = {});
            p.forEach(b, function(a) {
                var b, c, e, g;
                b = this._fromRelatedFieldName(a.fieldName);
                c = b[0];
                b = b[1];
                c &&
                    (this._relatedLayersInfo[c] || (p.some(d.relationships, function(a) {
                        if (a.id == c) return g = a, !0
                    }), g && (this._relatedLayersInfo[c] = {
                        relation: g,
                        relatedFields: [],
                        outStatistics: []
                    })), this._relatedLayersInfo[c] && (this._relatedLayersInfo[c].relatedFields.push(b), a.statisticType && (e = new J, e.statisticType = a.statisticType, e.onStatisticField = b, e.outStatisticFieldName = b, this._relatedLayersInfo[c].outStatistics.push(e))))
            }, this);
            for (c in this._relatedLayersInfo) this._relatedLayersInfo.hasOwnProperty(c) && this._relatedLayersInfo[c] &&
                (a = this._relatedLayersInfo[c].relation, a = d.url.replace(/[0-9]+$/, a.relatedTableId), this._relatedLayersInfo[c].relatedLayerUrl = a, e[c] = H({
                    url: a,
                    content: {
                        f: "json"
                    },
                    callbackParamName: "callback"
                }));
            return t(e)
        },
        _queryRelatedLayers: function(a) {
            var b = {},
                d;
            for (d in this._relatedLayersInfo) this._relatedLayersInfo.hasOwnProperty(d) && (b[d] = this._queryRelatedLayer({
                graphic: a,
                relatedInfo: this._relatedLayersInfo[d]
            }));
            return t(b)
        },
        _queryRelatedLayer: function(a) {
            var b, d, c, e, f, g, h, k, m, n;
            b = a.graphic;
            d = b.getLayer().url.match(/[0-9]+$/g)[0];
            k = a.relatedInfo;
            h = k.relatedLayerInfo;
            m = k.relatedLayerUrl;
            n = k.relation;
            p.some(h.relationships, function(a) {
                if (a.relatedTableId === parseInt(d, 10)) return c = a, !0
            }, this);
            c && (a = new D, p.some(h.fields, function(a) {
                    if (a.name === c.keyField) return f = -1 !== p.indexOf(["esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"], a.type) ? "number" : "string", !0
                }), e = "string" === f ? c.keyField + "\x3d'" + b.attributes[n.keyField] + "'" : c.keyField + "\x3d" + b.attributes[n.keyField], a.where = e, a.outFields =
                k.relatedFields, k.outStatistics && (0 < k.outStatistics.length && h.supportsStatistics) && (g = new D, g.where = a.where, g.outFields = a.outFields, g.outStatistics = k.outStatistics), b = new I(m), e = [], e.push(b.execute(a)), g && e.push(b.execute(g)));
            return t(e)
        },
        _setRelatedRecords: function(a, b) {
            this._relatedInfo = [];
            for (var d in b)
                if (b.hasOwnProperty(d) && b[d]) {
                    var c = b[d];
                    this._relatedInfo[d] = {};
                    this._relatedInfo[d].relatedFeatures = c[0].features;
                    g.isDefined(c[1]) && (this._relatedInfo[d].relatedStatsFeatures = c[1].features)
                }
        },
        _handlerErrorResponse: function(a, b) {
            a.reject(b)
        },
        _fromRelatedFieldName: function(a) {
            var b = []; - 1 !== a.indexOf(this._relatedFieldPrefix) && (a = a.split("/"), b = a.slice(1));
            return b
        },
        _toRelatedFieldName: function(a) {
            var b = "";
            a && 0 < a.length && (b = this._relatedFieldPrefix + a[0] + "/" + a[1]);
            return b
        }
    })
});
},
'esri/tasks/QueryTask':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/Deferred", "dojo/_base/json", "dojo/has", "../kernel", "../request", "../deferredUtils", "../geometry/Extent", "../geometry/normalizeUtils", "./Task", "./FeatureSet"], function(l, g, p, q, m, w, x, k, r, s, t, u, n) {
    l = l(u, {
        declaredClass: "esri.tasks.QueryTask",
        _eventMap: {
            complete: ["featureSet"],
            "execute-for-count-complete": ["count"],
            "execute-for-ids-complete": ["objectIds"],
            "execute-relationship-query-complete": ["featureSets"]
        },
        constructor: function(a, f) {
            this._handler =
                g.hitch(this, this._handler);
            this._relationshipQueryHandler = g.hitch(this, this._relationshipQueryHandler);
            this._executeForIdsHandler = g.hitch(this, this._executeForIdsHandler);
            this._countHandler = g.hitch(this, this._countHandler);
            this._extentHandler = g.hitch(this, this._extentHandler);
            this.source = f && f.source;
            this.gdbVersion = f && f.gdbVersion;
            this.registerConnectEvents()
        },
        __msigns: [{
            n: "execute",
            c: 4,
            a: [{
                i: 0,
                p: ["geometry"]
            }],
            e: 2
        }, {
            n: "executeForIds",
            c: 3,
            a: [{
                i: 0,
                p: ["geometry"]
            }],
            e: 2
        }, {
            n: "executeForCount",
            c: 3,
            a: [{
                i: 0,
                p: ["geometry"]
            }],
            e: 2
        }, {
            n: "executeForExtent",
            c: 3,
            a: [{
                i: 0,
                p: ["geometry"]
            }],
            e: 2
        }],
        onComplete: function() {},
        onExecuteRelationshipQueryComplete: function() {},
        onExecuteForIdsComplete: function() {},
        onExecuteForCountComplete: function() {},
        onExecuteForExtentComplete: function() {},
        execute: function(a, f, e, c, b) {
            var d = b.assembly;
            a = this._encode(g.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson(d && d[0])));
            var h = this._handler,
                v = this._errorHandler;
            this.source && (d = {
                source: this.source.toJson()
            }, a.layer = m.toJson(d));
            this.gdbVersion &&
                (a.gdbVersion = this.gdbVersion);
            return k({
                url: this._url.path + "/query",
                content: a,
                callbackParamName: "callback",
                load: function(a, d) {
                    h(a, d, f, e, b.dfd)
                },
                error: function(a) {
                    v(a, e, b.dfd)
                },
                callbackSuffix: c
            }, this.requestOptions)
        },
        executeRelationshipQuery: function(a, f, e) {
            a = this._encode(g.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson()));
            var c = this._relationshipQueryHandler,
                b = this._errorHandler;
            this.gdbVersion && (a.gdbVersion = this.gdbVersion);
            var d = new q(r._dfdCanceller);
            d._pendingDfd = k({
                url: this._url.path + "/queryRelatedRecords",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, e, d)
                },
                error: function(a) {
                    b(a, e, d)
                }
            }, this.requestOptions);
            return d
        },
        executeForIds: function(a, f, e, c) {
            var b = c.assembly;
            a = this._encode(g.mixin({}, this._url.query, {
                f: "json",
                returnIdsOnly: !0
            }, a.toJson(b && b[0])));
            var d = this._executeForIdsHandler,
                h = this._errorHandler;
            this.source && (b = {
                source: this.source.toJson()
            }, a.layer = m.toJson(b));
            this.gdbVersion && (a.gdbVersion = this.gdbVersion);
            return k({
                url: this._url.path + "/query",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    d(a, b, f, e, c.dfd)
                },
                error: function(a) {
                    h(a, e, c.dfd)
                }
            }, this.requestOptions)
        },
        executeForCount: function(a, f, e, c) {
            var b = c.assembly;
            a = this._encode(g.mixin({}, this._url.query, {
                f: "json",
                returnIdsOnly: !0,
                returnCountOnly: !0
            }, a.toJson(b && b[0])));
            var d = this._countHandler,
                h = this._errorHandler;
            this.source && (b = {
                source: this.source.toJson()
            }, a.layer = m.toJson(b));
            this.gdbVersion && (a.gdbVersion = this.gdbVersion);
            return k({
                url: this._url.path + "/query",
                content: a,
                callbackParamName: "callback",
                load: function(a,
                    b) {
                    d(a, b, f, e, c.dfd)
                },
                error: function(a) {
                    h(a, e, c.dfd)
                }
            }, this.requestOptions)
        },
        executeForExtent: function(a, f, e, c) {
            var b = c.assembly;
            a = this._encode(g.mixin({}, this._url.query, {
                f: "json",
                returnExtentOnly: !0,
                returnCountOnly: !0
            }, a.toJson(b && b[0])));
            var d = this._extentHandler,
                h = this._errorHandler;
            this.source && (b = {
                source: this.source.toJson()
            }, a.layer = m.toJson(b));
            this.gdbVersion && (a.gdbVersion = this.gdbVersion);
            return k({
                url: this._url.path + "/query",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    d(a,
                        b, f, e, c.dfd)
                },
                error: function(a) {
                    h(a, e, c.dfd)
                }
            }, this.requestOptions)
        },
        _handler: function(a, f, e, c, b) {
            try {
                var d = new n(a);
                this._successHandler([d], "onComplete", e, b)
            } catch (h) {
                this._errorHandler(h, c, b)
            }
        },
        _relationshipQueryHandler: function(a, f, e, c, b) {
            try {
                var d = a.geometryType,
                    h = a.spatialReference,
                    g = {};
                p.forEach(a.relatedRecordGroups, function(a) {
                    var b = {};
                    b.geometryType = d;
                    b.spatialReference = h;
                    b.features = a.relatedRecords;
                    b = new n(b);
                    if (null != a.objectId) g[a.objectId] = b;
                    else
                        for (var c in a) a.hasOwnProperty(c) &&
                            "relatedRecords" !== c && (g[a[c]] = b)
                });
                this._successHandler([g], "onExecuteRelationshipQueryComplete", e, b)
            } catch (k) {
                this._errorHandler(k, c, b)
            }
        },
        _executeForIdsHandler: function(a, f, e, c, b) {
            try {
                this._successHandler([a.objectIds], "onExecuteForIdsComplete", e, b)
            } catch (d) {
                this._errorHandler(d, c, b)
            }
        },
        _countHandler: function(a, f, e, c, b) {
            try {
                var d, g = a.features,
                    k = a.objectIds;
                if (k) d = k.length;
                else {
                    if (g) throw Error("Unable to perform query. Please check your parameters.");
                    d = a.count
                }
                this._successHandler([d], "onExecuteForCountComplete",
                    e, b)
            } catch (l) {
                this._errorHandler(l, c, b)
            }
        },
        _extentHandler: function(a, f, e, c, b) {
            try {
                a.extent && (a.extent = new s(a.extent)), this._successHandler([a], "onExecuteForExtentComplete", e, b)
            } catch (d) {
                this._errorHandler(d, c, b)
            }
        }
    });
    t._createWrappers(l);
    return l
});
},
'esri/geometry/normalizeUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/has", "../kernel", "../config", "../deferredUtils", "./Polyline", "./Polygon", "./webMercatorUtils", "./jsonUtils"], function(h, m, E, M, N, K, y, v, A, z, L) {
    function w(a, f) {
        return Math.ceil((a - f) / (2 * f))
    }

    function B(a, f) {
        var c = a.paths || a.rings,
            b, e, d = c.length,
            n;
        for (b = 0; b < d; b++) {
            n = c[b].length;
            for (e = 0; e < n; e++) {
                var p = a.getPoint(b, e);
                a.setPoint(b, e, p.offset(f, 0))
            }
        }
        return a
    }

    function F(a, f) {
        if (!(a instanceof v || a instanceof A)) throw console.error("_straightLineDensify: the input geometry is neither polyline nor polygon"),
            Error("_straightLineDensify: the input geometry is neither polyline nor polygon");
        var c = a instanceof v,
            b = [],
            e;
        h.forEach(c ? a.paths : a.rings, function(a) {
            b.push(e = []);
            e.push([a[0][0], a[0][1]]);
            var n, c, q, l, k, g, h, x, m, r, s, t;
            for (k = 0; k < a.length - 1; k++) {
                n = a[k][0];
                c = a[k][1];
                q = a[k + 1][0];
                l = a[k + 1][1];
                h = Math.sqrt((q - n) * (q - n) + (l - c) * (l - c));
                x = (l - c) / h;
                m = (q - n) / h;
                r = h / f;
                if (1 < r) {
                    for (g = 1; g <= r - 1; g++) t = g * f, s = m * t + n, t = x * t + c, e.push([s, t]);
                    g = (h + Math.floor(r - 1) * f) / 2;
                    s = m * g + n;
                    t = x * g + c;
                    e.push([s, t])
                }
                e.push([q, l])
            }
        });
        return c ? new v({
            paths: b,
            spatialReference: a.spatialReference
        }) : new A({
            rings: b,
            spatialReference: a.spatialReference
        })
    }

    function C(a, f, c) {
        f && (a = F(a, 1E6), a = z.webMercatorToGeographic(a, !0));
        c && (a = B(a, c));
        return a
    }

    function D(a, f, c) {
        var b = a.x || a[0],
            e;
        b > f ? (e = w(b, f), a.x ? a = a.offset(e * -2 * f, 0) : a[0] = b + e * -2 * f) : b < c && (e = w(b, c), a.x ? a = a.offset(e * -2 * c, 0) : a[0] = b + e * -2 * c);
        return a
    }

    function G(a, f) {
        var c = -1;
        h.forEach(f.cutIndexes, function(b, e) {
            var d = f.geometries[e];
            h.forEach(d.rings || d.paths, function(a, e) {
                h.some(a, function(b) {
                    if (!(180 > b[0])) {
                        b = 0;
                        var c, f = a.length,
                            g;
                        for (c = 0; c < f; c++) g = a[c][0], b = g > b ? g : b;
                        b = Number(b.toFixed(9));
                        b = -360 * w(b, 180);
                        f = a.length;
                        for (c = 0; c < f; c++) g = d.getPoint(e, c), d.setPoint(e, c, g.offset(b, 0))
                    }
                    return !0
                })
            });
            b === c ? d.rings ? h.forEach(d.rings, function(d, c) {
                a[b] = a[b].addRing(d)
            }) : h.forEach(d.paths, function(d, c) {
                a[b] = a[b].addPath(d)
            }) : (c = b, a[b] = d)
        });
        return a
    }

    function H(a, f, c, b) {
        var e = new E;
        e.addCallbacks(c, b);
        var d = [],
            n = [],
            p, q, l, k, g, m, x, u, r = 0;
        h.forEach(a, function(a) {
            if (a)
                if (p || (p = a.spatialReference, q = p._getInfo(), k = (l = p._isWebMercator()) ?
                        2.0037508342788905E7 : 180, g = l ? -2.0037508342788905E7 : -180, m = l ? 102100 : 4326, x = new v({
                            paths: [
                                [
                                    [k, g],
                                    [k, k]
                                ]
                            ],
                            spatialReference: {
                                wkid: m
                            }
                        }), u = new v({
                            paths: [
                                [
                                    [g, g],
                                    [g, k]
                                ]
                            ],
                            spatialReference: {
                                wkid: m
                            }
                        })), q) {
                    var b = L.fromJson(a.toJson()),
                        c = a.getExtent();
                    "point" === a.type ? d.push(D(b, k, g)) : "multipoint" === a.type ? (b.points = h.map(b.points, function(a) {
                        return D(a, k, g)
                    }), d.push(b)) : "extent" === a.type ? (b = c._normalize(null, null, q), d.push(b.rings ? new A(b) : b)) : c ? (a = w(c.xmin, g) * 2 * k, b = 0 === a ? b : B(b, a), c = c.offset(a, 0), c.intersects(x) &&
                        c.xmax !== k ? (r = c.xmax > r ? c.xmax : r, b = C(b, l), n.push(b), d.push("cut")) : c.intersects(u) && c.xmin !== g ? (r = c.xmax * 2 * k > r ? c.xmax * 2 * k : r, b = C(b, l, 360), n.push(b), d.push("cut")) : d.push(b)) : d.push(b)
                } else d.push(a);
            else d.push(a)
        });
        c = new v;
        b = w(r, k);
        for (var s = -90, t = b; 0 < b;) {
            var y = -180 + 360 * b;
            c.addPath([
                [y, s],
                [y, -1 * s]
            ]);
            s *= -1;
            b--
        }
        0 < n.length && 0 < t ? f ? f.cut(n, c, function(b) {
            n = G(n, b);
            var c = [];
            h.forEach(d, function(b, e) {
                if ("cut" === b) {
                    var f = n.shift();
                    a[e].rings && 1 < a[e].rings.length && f.rings.length >= a[e].rings.length ? (d[e] = "simplify",
                        c.push(f)) : d[e] = !0 === l ? z.geographicToWebMercator(f) : f
                }
            });
            0 < c.length ? f.simplify(c, function(a) {
                h.forEach(d, function(b, c) {
                    "simplify" === b && (d[c] = !0 === l ? z.geographicToWebMercator(a.shift()) : a.shift())
                });
                e.callback(d)
            }, function(a) {
                e.errback(a)
            }) : e.callback(d)
        }, function(a) {
            e.errback(a)
        }) : e.errback(Error("esri.geometry.normalizeCentralMeridian: 'geometryService' argument is missing.")) : (h.forEach(d, function(a, b) {
            if ("cut" === a) {
                var c = n.shift();
                d[b] = !0 === l ? z.geographicToWebMercator(c) : c
            }
        }), e.callback(d));
        return e
    }

    function u(a, f, c, b) {
        var e = !1,
            d;
        m.isObject(a) && a && (m.isArray(a) ? a.length && ((d = a[0] && a[0].declaredClass) && -1 !== d.indexOf("Graphic") ? (a = h.map(a, function(a) {
            return a.geometry
        }), e = a.length ? !0 : !1) : d && -1 !== d.indexOf("esri.geometry.") && (e = !0)) : (d = a.declaredClass) && -1 !== d.indexOf("FeatureSet") ? (a = h.map(a.features || [], function(a) {
            return a.geometry
        }), e = a.length ? !0 : !1) : d && -1 !== d.indexOf("esri.geometry.") && (e = !0));
        e && f.push({
            index: c,
            property: b,
            value: a
        })
    }

    function I(a, f) {
        var c = [];
        h.forEach(f, function(b) {
            var e = b.i,
                d = a[e];
            b = b.p;
            var f;
            if (m.isObject(d) && d)
                if (b)
                    if ("*" === b[0])
                        for (f in d) d.hasOwnProperty(f) && u(d[f], c, e, f);
                    else h.forEach(b, function(a) {
                        u(m.getObject(a, !1, d), c, e, a)
                    });
            else u(d, c, e)
        });
        return c
    }

    function J(a, f) {
        var c = 0,
            b = {};
        h.forEach(f, function(e) {
            var d = e.index,
                f = e.property,
                h = e.value,
                q = h.length || 1,
                l = a.slice(c, c + q);
            m.isArray(h) || (l = l[0]);
            c += q;
            delete e.value;
            f ? (b[d] = b[d] || {}, b[d][f] = l) : b[d] = l
        });
        return b
    }
    return {
        normalizeCentralMeridian: H,
        _foldCutResults: G,
        _prepareGeometryForCut: C,
        _offsetMagnitude: w,
        _pointNormalization: D,
        _updatePolyGeometry: B,
        _straightLineDensify: F,
        _createWrappers: function(a) {
            var f = m.isObject(a) ? a.prototype : m.getObject(a + ".prototype");
            h.forEach(f.__msigns, function(a) {
                var b = f[a.n];
                f[a.n] = function() {
                    var e = this,
                        d = [],
                        f, p = new E(y._dfdCanceller);
                    a.f && y._fixDfd(p);
                    for (f = 0; f < a.c; f++) d[f] = arguments[f];
                    var m = {
                        dfd: p
                    };
                    d.push(m);
                    var l, k = [],
                        g;
                    e.normalization && !e._isTable && (l = I(d, a.a), h.forEach(l, function(a) {
                        k = k.concat(a.value)
                    }), k.length && (g = H(k, K.defaults.geometryService)));
                    g ? (p._pendingDfd = g, g.addCallbacks(function(a) {
                        p.canceled ||
                            (m.assembly = J(a, l), p._pendingDfd = b.apply(e, d))
                    }, function(b) {
                        var f = e.declaredClass;
                        f && -1 !== f.indexOf("FeatureLayer") ? e._resolve([b], null, d[a.e], p, !0) : e._errorHandler(b, d[a.e], p)
                    })) : p._pendingDfd = b.apply(e, d);
                    return p
                }
            })
        },
        _disassemble: I,
        _addToBucket: u,
        _reassemble: J
    }
});
},
'esri/tasks/Task':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/json", "dojo/has", "../kernel", "../deferredUtils", "../urlUtils", "../Evented"], function(l, h, m, r, s, n, p, q) {
    return l(q, {
        declaredClass: "esri.tasks._Task",
        _eventMap: {
            error: ["error"],
            complete: ["result"]
        },
        constructor: function(a, c) {
            a && h.isString(a) && (this._url = p.urlToObject(this.url = a));
            c && c.requestOptions && (this.requestOptions = c.requestOptions);
            this.normalization = !0;
            this._errorHandler = h.hitch(this, this._errorHandler);
            this.registerConnectEvents()
        },
        _useSSL: function() {
            var a =
                this._url,
                c = /^http:/i;
            this.url && (this.url = this.url.replace(c, "https:"));
            a && a.path && (a.path = a.path.replace(c, "https:"))
        },
        _encode: function(a, c, e) {
            var d, b, g = {},
                f, k;
            for (f in a)
                if ("declaredClass" !== f && (d = a[f], b = typeof d, null !== d && void 0 !== d && "function" !== b))
                    if (h.isArray(d)) {
                        g[f] = [];
                        k = d.length;
                        for (b = 0; b < k; b++) g[f][b] = this._encode(d[b])
                    } else "object" === b ? d.toJson && (b = d.toJson(e && e[f]), "esri.tasks.FeatureSet" === d.declaredClass && b.spatialReference && (b.sr = b.spatialReference, delete b.spatialReference), g[f] = c ?
                        b : m.toJson(b)) : g[f] = d;
            return g
        },
        _successHandler: function(a, c, e, d) {
            c && this[c].apply(this, a);
            e && e.apply(null, a);
            d && n._resDfd(d, a)
        },
        _errorHandler: function(a, c, e) {
            this.onError(a);
            c && c(a);
            e && e.errback(a)
        },
        setNormalization: function(a) {
            this.normalization = a
        },
        onError: function() {}
    })
});
},
'esri/tasks/FeatureSet':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../lang", "../graphic", "../SpatialReference", "../graphicsUtils", "../geometry/jsonUtils", "../symbols/jsonUtils"], function(n, q, r, x, y, s, t, u, v, h, w) {
    return n(null, {
        declaredClass: "esri.tasks.FeatureSet",
        constructor: function(a) {
            if (a) {
                q.mixin(this, a);
                var b = this.features,
                    c = a.spatialReference,
                    d = h.getGeometryType(a.geometryType),
                    c = this.spatialReference = new u(c);
                this.geometryType = a.geometryType;
                a.fields && (this.fields = a.fields);
                r.forEach(b,
                    function(a, g) {
                        var p = a.geometry && a.geometry.spatialReference;
                        b[g] = new t(d && a.geometry ? new d(a.geometry) : null, a.symbol && w.fromJson(a.symbol), a.attributes);
                        b[g].geometry && !p && b[g].geometry.setSpatialReference(c)
                    });
                this._hydrate()
            } else this.features = []
        },
        displayFieldName: null,
        geometryType: null,
        spatialReference: null,
        fieldAliases: null,
        toJson: function(a) {
            var b = {};
            this.displayFieldName && (b.displayFieldName = this.displayFieldName);
            this.fields && (b.fields = this.fields);
            this.spatialReference ? b.spatialReference =
                this.spatialReference.toJson() : this.features[0] && this.features[0].geometry && (b.spatialReference = this.features[0].geometry.spatialReference.toJson());
            this.features[0] && (this.features[0].geometry && (b.geometryType = h.getJsonType(this.features[0].geometry)), b.features = v._encodeGraphics(this.features, a));
            b.exceededTransferLimit = this.exceededTransferLimit;
            return s.fixJson(b)
        },
        _hydrate: function() {
            var a = this.transform;
            if (a) {
                var b = this.features,
                    c, d = a.translate[0],
                    h = a.translate[1],
                    g = a.scale[0],
                    p = a.scale[1],
                    n = function(a, b, c) {
                        if ("esriGeometryPoint" === a) return function(a) {
                            a.x = b(a.x);
                            a.y = c(a.y)
                        };
                        if ("esriGeometryPolyline" === a || "esriGeometryPolygon" === a) return function(a) {
                            a = a.rings || a.paths;
                            var e, g, f, h, d, k, l, m;
                            e = 0;
                            for (g = a.length; e < g; e++) {
                                d = a[e];
                                f = 0;
                                for (h = d.length; f < h; f++) k = d[f], 0 < f ? (l += k[0], m += k[1]) : (l = k[0], m = k[1]), k[0] = b(l), k[1] = c(m)
                            }
                        };
                        if ("esriGeometryEnvelope" === a) return function(a) {
                            a.xmin = b(a.xmin);
                            a.ymin = c(a.ymin);
                            a.xmax = b(a.xmax);
                            a.ymax = c(a.ymax)
                        };
                        if ("esriGeometryMultipoint" === a) return function(a) {
                            a =
                                a.points;
                            var e, d, f;
                            e = 0;
                            for (d = a.length; e < d; e++) f = a[e], f[0] = b(void 0), f[1] = c(void 0)
                        }
                    }(this.geometryType, function(a) {
                        return a * g + d
                    }, function(a) {
                        return h - a * p
                    }),
                    a = 0;
                for (c = b.length; a < c; a++) b[a].geometry && n(b[a].geometry);
                this.transform = null
            }
        }
    })
});
},
'esri/graphicsUtils':function(){
//>>built
define(["dojo/_base/lang", "dojo/_base/array", "dojo/has", "./kernel", "./geometry/Extent"], function(k, f, l, m, h) {
    return {
        graphicsExtent: function(d) {
            var a = d[0].geometry,
                b = a.getExtent(),
                c, e, g = d.length;
            null === b && (b = new h(a.x, a.y, a.x, a.y, a.spatialReference));
            for (e = 1; e < g; e++) c = (a = d[e].geometry).getExtent(), null === c && (c = new h(a.x, a.y, a.x, a.y, a.spatialReference)), b = b.union(c);
            return 0 > b.getWidth() && 0 > b.getHeight() ? null : b
        },
        getGeometries: function(d) {
            return f.map(d, function(a) {
                return a.geometry
            })
        },
        _encodeGraphics: function(d,
            a) {
            var b = [],
                c, e, g;
            f.forEach(d, function(d, f) {
                c = d.toJson();
                e = {};
                c.geometry && (g = a && a[f], e.geometry = g && g.toJson() || c.geometry);
                c.attributes && (e.attributes = c.attributes);
                b[f] = e
            });
            return b
        }
    }
});
},
'esri/tasks/StatisticDefinition':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel"], function(a, b, c, d) {
    return a(null, {
        declaredClass: "esri.tasks.StatisticDefinition",
        toJson: function() {
            return {
                statisticType: this.statisticType,
                onStatisticField: this.onStatisticField,
                outStatisticFieldName: this.outStatisticFieldName,
                maxPointCount: this.maxPointCount,
                maxRecordCount: this.maxRecordCount,
                maxVertexCount: this.maxVertexCount
            }
        }
    })
});
},
'esri/dijit/PopupRenderer':function(){
//>>built
define(["require", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/kernel", "dojo/sniff", "dojo/query", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-style", "dijit/_Widget", "dijit/_Templated", "../kernel", "./_EventedWidget", "dojo/i18n!../nls/jsapi", "dojo/NodeList-dom"], function(r, s, n, m, p, k, A, B, t, h, e, u, q, v, w, C, x, y) {
    var z = 0;
    return s([x, v, w], {
        declaredClass: "esri.dijit._PopupRenderer",
        constructor: function() {
            this._nls = m.mixin({}, y.widgets.popup)
        },
        templateString: "\x3cdiv class\x3d'esriViewPopup'\x3e\x3cdiv class\x3d'mainSection'\x3e\x3cdiv class\x3d'header' dojoAttachPoint\x3d'_title'\x3e\x3c/div\x3e\x3cdiv class\x3d'hzLine'\x3e\x3c/div\x3e\x3cdiv dojoAttachPoint\x3d'_description'\x3e\x3c/div\x3e\x3cdiv class\x3d'break'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'attachmentsSection hidden'\x3e\x3cdiv\x3e${_nls.NLS_attach}:\x3c/div\x3e\x3cul dojoAttachPoint\x3d'_attachmentsList'\x3e\x3c/ul\x3e\x3cdiv class\x3d'break'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'mediaSection hidden'\x3e\x3cdiv class\x3d'header' dojoAttachPoint\x3d'_mediaTitle'\x3e\x3c/div\x3e\x3cdiv class\x3d'hzLine'\x3e\x3c/div\x3e\x3cdiv class\x3d'caption' dojoAttachPoint\x3d'_mediaCaption'\x3e\x3c/div\x3e\x3cdiv class\x3d'gallery' dojoAttachPoint\x3d'_gallery'\x3e\x3cdiv class\x3d'mediaHandle prev' dojoAttachPoint\x3d'_prevMedia' dojoAttachEvent\x3d'onclick: _goToPrevMedia'\x3e\x3c/div\x3e\x3cdiv class\x3d'mediaHandle next' dojoAttachPoint\x3d'_nextMedia' dojoAttachEvent\x3d'onclick: _goToNextMedia'\x3e\x3c/div\x3e\x3cul class\x3d'summary'\x3e\x3cli class\x3d'image mediaCount hidden' dojoAttachPoint\x3d'_imageCount'\x3e0\x3c/li\x3e\x3cli class\x3d'image mediaIcon hidden'\x3e\x3c/li\x3e\x3cli class\x3d'chart mediaCount hidden' dojoAttachPoint\x3d'_chartCount'\x3e0\x3c/li\x3e\x3cli class\x3d'chart mediaIcon hidden'\x3e\x3c/li\x3e\x3c/ul\x3e\x3cdiv class\x3d'frame' dojoAttachPoint\x3d'_mediaFrame'\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'editSummarySection hidden' dojoAttachPoint\x3d'_editSummarySection'\x3e\x3cdiv class\x3d'break'\x3e\x3c/div\x3e\x3cdiv class\x3d'break hidden' dojoAttachPoint\x3d'_mediaBreak'\x3e\x3c/div\x3e\x3cdiv class\x3d'editSummary' dojoAttachPoint\x3d'_editSummary'\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e",
        showTitle: !0,
        startup: function() {
            this.inherited(arguments);
            this.template.getComponents(this.graphic).then(m.hitch(this, this._handleComponentsSuccess), m.hitch(this, this._handleComponentsError))
        },
        destroy: function() {
            this._dfd && this._dfd.cancel();
            this._destroyFrame();
            this.template = this.graphic = this._nls = this._mediaInfos = this._mediaPtr = this._dfd = null;
            this.inherited(arguments)
        },
        _goToPrevMedia: function() {
            0 > this._mediaPtr - 1 || (this._mediaPtr--, this._updateUI(), this._displayMedia())
        },
        _goToNextMedia: function() {
            this._mediaPtr +
                1 !== this._mediaInfos.length && (this._mediaPtr++, this._updateUI(), this._displayMedia())
        },
        _updateUI: function() {
            var b = this._mediaInfos,
                c = b.length,
                a = this.domNode,
                f = this._prevMedia,
                d = this._nextMedia;
            if (1 < c) {
                var g = 0,
                    l = 0;
                p.forEach(b, function(a) {
                    "image" === a.type ? g++ : -1 !== a.type.indexOf("chart") && l++
                });
                g && (h.set(this._imageCount, "innerHTML", g), k.query(".summary .image", a).removeClass("hidden"));
                l && (h.set(this._chartCount, "innerHTML", l), k.query(".summary .chart", a).removeClass("hidden"))
            } else k.query(".summary",
                a).addClass("hidden"), e.add(f, "hidden"), e.add(d, "hidden");
            b = this._mediaPtr;
            0 === b ? e.add(f, "hidden") : e.remove(f, "hidden");
            b === c - 1 ? e.add(d, "hidden") : e.remove(d, "hidden");
            this._destroyFrame()
        },
        _displayMedia: function() {
            var b = this._mediaInfos[this._mediaPtr],
                c = b.title,
                a = b.caption,
                f = k.query(".mediaSection .hzLine", this.domNode)[0];
            h.set(this._mediaTitle, "innerHTML", c);
            e[c ? "remove" : "add"](this._mediaTitle, "hidden");
            h.set(this._mediaCaption, "innerHTML", a);
            e[a ? "remove" : "add"](this._mediaCaption, "hidden");
            e[c &&
                a ? "remove" : "add"](f, "hidden");
            this._rid = null;
            if ("image" === b.type) this._showImage(b.value);
            else {
                var d = this,
                    c = ["dojox/charting/Chart2D", "dojox/charting/action2d/Tooltip"],
                    a = b.value.theme || this.chartTheme;
                m.isString(a) && (a = a.replace(/\./gi, "/"), -1 === a.indexOf("/") && (a = "dojox/charting/themes/" + a));
                a || (a = "./Rainbow");
                c.push(a);
                try {
                    var g = this._rid = z++;
                    r(c, function(a, c, f) {
                        g === d._rid && (d._rid = null, d._showChart(b.type, b.value, a, c, f))
                    })
                } catch (l) {
                    console.log("PopupRenderer: error loading modules")
                }
            }
        },
        _preventNewTab: function(b) {
            return (b =
                b && m.trim(b).toLowerCase()) && (0 === b.indexOf("mailto:") || 0 === b.indexOf("tel:"))
        },
        _showImage: function(b) {
            e.add(this._mediaFrame, "image");
            var c = q.get(this._gallery, "height"),
                a = "\x3cimg class\x3d'esriPopupMediaImage' src\x3d'" + b.sourceURL + "' /\x3e";
            b.linkURL && (a = "\x3ca " + (this._preventNewTab(b.linkURL) ? "" : "target\x3d'_blank' ") + "href\x3d'" + b.linkURL + "'\x3e" + a + "\x3c/a\x3e");
            h.set(this._mediaFrame, "innerHTML", a);
            var f = k.query(".esriPopupMediaImage", this._mediaFrame)[0],
                d = this,
                g;
            g = n.connect(f, "onload", function() {
                n.disconnect(g);
                g = null;
                d._imageLoaded(f, c)
            })
        },
        _showChart: function(b, c, a, f, d) {
            e.remove(this._mediaFrame, "image");
            a = this._chart = new a(u.create("div", {
                "class": "chart"
            }, this._mediaFrame), {
                margins: {
                    l: 4,
                    t: 4,
                    r: 4,
                    b: 4
                }
            });
            d && a.setTheme(d);
            switch (b) {
                case "piechart":
                    a.addPlot("default", {
                        type: "Pie",
                        labels: !1
                    });
                    a.addSeries("Series A", c.fields);
                    break;
                case "linechart":
                    a.addPlot("default", {
                        type: "Markers"
                    });
                    a.addAxis("x", {
                        min: 0,
                        majorTicks: !1,
                        minorTicks: !1,
                        majorLabels: !1,
                        minorLabels: !1
                    });
                    a.addAxis("y", {
                        includeZero: !0,
                        vertical: !0,
                        fixUpper: "minor"
                    });
                    p.forEach(c.fields, function(a, b) {
                        a.x = b + 1
                    });
                    a.addSeries("Series A", c.fields);
                    break;
                case "columnchart":
                    a.addPlot("default", {
                        type: "Columns",
                        gap: 3
                    });
                    a.addAxis("y", {
                        includeZero: !0,
                        vertical: !0,
                        fixUpper: "minor"
                    });
                    a.addSeries("Series A", c.fields);
                    break;
                case "barchart":
                    a.addPlot("default", {
                        type: "Bars",
                        gap: 3
                    }), a.addAxis("x", {
                        includeZero: !0,
                        fixUpper: "minor",
                        minorLabels: !1
                    }), a.addAxis("y", {
                        vertical: !0,
                        majorTicks: !1,
                        minorTicks: !1,
                        majorLabels: !1,
                        minorLabels: !1
                    }), a.addSeries("Series A", c.fields)
            }
            this._action = new f(a);
            a.render()
        },
        _destroyFrame: function() {
            this._rid = null;
            this._chart && (this._chart.destroy(), this._chart = null);
            this._action && (this._action.destroy(), this._action = null);
            h.set(this._mediaFrame, "innerHTML", "")
        },
        _imageLoaded: function(b, c) {
            var a = b.height;
            a < c && (a = Math.round((c - a) / 2), q.set(b, "marginTop", a + "px"))
        },
        _attListHandler: function(b, c) {
            if (b === this._dfd) {
                this._dfd = null;
                var a = "";
                !(c instanceof Error) && (c && c.length) && p.forEach(c, function(b) {
                    a += "\x3cli\x3e";
                    a += "\x3ca href\x3d'" + b.url + "' target\x3d'_blank'\x3e" +
                        (b.name || "[No name]") + "\x3c/a\x3e";
                    a += "\x3c/li\x3e"
                });
                h.set(this._attachmentsList, "innerHTML", a || "\x3cli\x3e" + this._nls.NLS_noAttach + "\x3c/li\x3e")
            }
        },
        _handleComponentsSuccess: function(b) {
            if (b) {
                var c = this.showTitle ? b.title : "",
                    a = b.description,
                    f = b.fields,
                    d = b.mediaInfos,
                    g = this.domNode,
                    l = this._nls,
                    n = this,
                    q = this.template,
                    r = this.graphic;
                this._prevMedia.title = l.NLS_prevMedia;
                this._nextMedia.title = l.NLS_nextMedia;
                h.set(this._title, "innerHTML", c);
                c || e.add(this._title, "hidden");
                !a && f && (a = "", p.forEach(f, function(b) {
                    a +=
                        "\x3ctr valign\x3d'top'\x3e";
                    a += "\x3ctd class\x3d'attrName'\x3e" + b[0] + "\x3c/td\x3e";
                    a += "\x3ctd class\x3d'attrValue'\x3e" + b[1].replace(/^\s*(https?:\/\/[^\s]+)\s*$/i, "\x3ca target\x3d'_blank' href\x3d'$1' title\x3d'$1'\x3e" + l.NLS_moreInfo + "\x3c/a\x3e") + "\x3c/td\x3e";
                    a += "\x3c/tr\x3e"
                }), a && (a = "\x3ctable class\x3d'attrTable' cellpadding\x3d'0px' cellspacing\x3d'0px'\x3e" + a + "\x3c/table\x3e"));
                h.set(this._description, "innerHTML", a);
                a || e.add(this._description, "hidden");
                k.query("a", this._description).forEach(function(a) {
                    n._preventNewTab(a.href) ?
                        "_blank" === a.target && h.remove(a, "target") : h.set(a, "target", "_blank")
                });
                c && a ? k.query(".mainSection .hzLine", g).removeClass("hidden") : c || a ? k.query(".mainSection .hzLine", g).addClass("hidden") : k.query(".mainSection", g).addClass("hidden");
                if (c = this._dfd = q.getAttachments(r)) c.addBoth(m.hitch(this, this._attListHandler, c)), h.set(this._attachmentsList, "innerHTML", "\x3cli\x3e" + l.NLS_searching + "...\x3c/li\x3e"), k.query(".attachmentsSection", g).removeClass("hidden");
                d && d.length && (k.query(".mediaSection", g).removeClass("hidden"),
                    t.setSelectable(this._mediaFrame, !1), this._mediaInfos = d, this._mediaPtr = 0, this._updateUI(), this._displayMedia());
                b.editSummary && (h.set(this._editSummary, "innerHTML", b.editSummary), d && d.length && e.remove(this._mediaBreak, "hidden"), e.remove(this._editSummarySection, "hidden"))
            }
        },
        _handleComponentsError: function(b) {
            console.log("PopupRenderer: error loading template", b)
        }
    })
});
},
'esri/dijit/_EventedWidget':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/aspect", "dojo/on", "../Evented", "dijit/_WidgetBase"], function(k, l, q, m, n, p) {
    return k([p, n], {
        _onMap: function(b) {
            var a = this.constructor._onMap,
                c;
            if (!a || !a.FINAL) delete this.constructor._onMap, a = this.registerConnectEvents(), a.FINAL = !0;
            b = b.toLowerCase();
            a[b] ? c = this[a[b].method] : (b = this._onCamelCase(b), this[b] && (c = b));
            return c
        },
        on: function(b, a) {
            var c = this._onMap(b),
                d = b.replace(/\-/g, ""),
                e = "on" + d in this.domNode;
            return c || !e ? this.inherited(arguments) : this.own(m(this.domNode,
                d, a))[0]
        },
        emit: function(b, a, c) {
            var d, e, f, g = b.toLowerCase(),
                h = this.constructor._onMap || this.registerConnectEvents();
            e = this[this._onMap(g)];
            a = a || {};
            a.target || (a.target = this);
            e && (h && h[g]) && (this._onObj2Arr(function() {
                d = Array.prototype.slice.call(arguments)
            }, h[g].argKeys)(a), f = l.mixin({}, arguments), f[2] = d, f[0] = h[g].name.replace(/^on/, ""));
            return this.inherited(f || arguments)
        }
    })
});
},
'esri/tasks/GeometryService':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/_base/Deferred", "dojo/has", "../kernel", "../request", "../deferredUtils", "./Task", "../geometry/Extent", "../geometry/Polyline", "../geometry/Polygon", "../geometry/Multipoint", "../geometry/jsonUtils"], function(u, l, s, k, n, A, B, p, q, y, w, x, v, z, r) {
    u = u(y, {
        declaredClass: "esri.tasks.GeometryService",
        _eventMap: {
            "areas-and-lengths-complete": ["result"],
            "auto-complete-complete": ["geometries"],
            "buffer-complete": ["geometries"],
            "convex-hull-complete": ["geometry"],
            "cut-complete": ["result"],
            "densify-complete": ["geometries"],
            "difference-complete": ["geometries"],
            "distance-complete": ["distance"],
            "generalize-complete": ["geometries"],
            "intersect-complete": ["geometries"],
            "label-points-complete": ["geometries"],
            "lengths-complete": ["result"],
            "offset-complete": ["geometries"],
            "project-complete": ["geometries"],
            "relation-complete": ["relations"],
            "reshape-complete": ["geometry"],
            "simplify-complete": ["geometries"],
            "trim-extend-complete": ["geometries"],
            "union-complete": ["geometry"]
        },
        constructor: function(a) {
            a = l.hitch;
            this._projectHandler = a(this, this._projectHandler);
            this._simplifyHandler = a(this, this._simplifyHandler);
            this._bufferHandler = a(this, this._bufferHandler);
            this._areasAndLengthsHandler = a(this, this._areasAndLengthsHandler);
            this._lengthsHandler = a(this, this._lengthsHandler);
            this._labelPointsHandler = a(this, this._labelPointsHandler);
            this._relationHandler = a(this, this._relationHandler);
            this._convexHullHandler = a(this, this._convexHullHandler);
            this._unionHandler = a(this, this._unionHandler);
            this._autoCompleteHandler = a(this, this._autoCompleteHandler);
            this._reshapeHandler = a(this, this._reshapeHandler);
            this._cutHandler = a(this, this._cutHandler);
            this._intersectHandler = a(this, this._intersectHandler);
            this._differenceHandler = a(this, this._differenceHandler);
            this._trimExtendHandler = a(this, this._trimExtendHandler);
            this._densifyHandler = a(this, this._densifyHandler);
            this._generalizeHandler = a(this, this._densifyHandler);
            this._offsetHandler = a(this, this._offsetHandler);
            this._distanceHandler = a(this, this._distanceHandler);
            this._toGeoCoordinateHandler = a(this, this._toGeoCoordinateHandler);
            this._fromGeoCoordinateHandler = a(this, this._fromGeoCoordinateHandler);
            this.registerConnectEvents()
        },
        _encodeGeometries: function(a) {
            var h = [],
                e, b = a.length;
            for (e = 0; e < b; e++) h.push(a[e].toJson());
            return {
                geometryType: r.getJsonType(a[0]),
                geometries: h
            }
        },
        _decodeGeometries: function(a, h, e) {
            var b = r.getGeometryType(h);
            a = a.geometries;
            var f = [],
                c = {
                    spatialReference: e.toJson()
                },
                g = l.mixin;
            s.forEach(a, function(a, e) {
                f[e] = new b(g(a, c))
            });
            return f
        },
        _toProjectGeometry: function(a) {
            var h =
                a.spatialReference.toJson();
            return a instanceof w ? new v({
                rings: [
                    [
                        [a.xmin, a.ymin],
                        [a.xmin, a.ymax],
                        [a.xmax, a.ymax],
                        [a.xmax, a.ymin],
                        [a.xmin, a.ymin]
                    ]
                ],
                spatialReference: h
            }) : new x({
                paths: [
                    [].concat(a.points)
                ],
                spatialReference: h
            })
        },
        _fromProjectedGeometry: function(a, h, e) {
            return "esriGeometryEnvelope" === h ? (a = a.rings[0], new w(a[0][0], a[0][1], a[2][0], a[2][1], e)) : new z({
                points: a.paths[0],
                spatialReference: e.toJson()
            })
        },
        project: function(a, h, e, b) {
            var f = l.mixin({}, this._url.query, {
                    f: "json"
                }),
                c;
            a.geometries ? (b = e, e =
                h, h = a.outSR, c = a.geometries[0], f = l.mixin(f, a.toJson())) : (c = a[0], f = l.mixin(f, {
                outSR: h.wkid || k.toJson(h.toJson()),
                inSR: c.spatialReference.wkid || k.toJson(c.spatialReference.toJson()),
                geometries: k.toJson(this._encodeGeometries(a))
            }));
            var g = r.getJsonType(c),
                d = this._projectHandler,
                m = this._errorHandler,
                t = new n(q._dfdCanceller);
            t._pendingDfd = p({
                url: this._url.path + "/project",
                content: f,
                callbackParamName: "callback",
                load: function(a, c) {
                    d(a, c, g, h, e, b, t)
                },
                error: function(a) {
                    m(a, b, t)
                }
            });
            return t
        },
        _projectHandler: function(a,
            h, e, b, f, c, g) {
            try {
                var d = this._decodeGeometries(a, e, b);
                this._successHandler([d], "onProjectComplete", f, g)
            } catch (m) {
                this._errorHandler(m, c, g)
            }
        },
        onProjectComplete: function() {},
        simplify: function(a, h, e) {
            var b = a[0].spatialReference,
                f = l.mixin({}, this._url.query, {
                    f: "json",
                    sr: b.wkid ? b.wkid : k.toJson(b.toJson()),
                    geometries: k.toJson(this._encodeGeometries(a))
                }),
                c = r.getJsonType(a[0]),
                g = this._simplifyHandler,
                d = this._errorHandler,
                m = new n(q._dfdCanceller);
            m._pendingDfd = p({
                url: this._url.path + "/simplify",
                content: f,
                callbackParamName: "callback",
                load: function(a, d) {
                    g(a, d, c, b, h, e, m)
                },
                error: function(a) {
                    d(a, e, m)
                }
            });
            return m
        },
        _simplifyHandler: function(a, h, e, b, f, c, g) {
            try {
                var d = this._decodeGeometries(a, e, b);
                this._successHandler([d], "onSimplifyComplete", f, g)
            } catch (m) {
                this._errorHandler(m, c, g)
            }
        },
        onSimplifyComplete: function() {},
        convexHull: function(a, h, e) {
            var b = a[0].spatialReference;
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(b.toJson()),
                geometries: k.toJson(this._encodeGeometries(a))
            });
            var f = this._convexHullHandler,
                c = this._errorHandler,
                g = new n(q._dfdCanceller);
            g._pendingDfd = p({
                url: this._url.path + "/convexHull",
                content: a,
                callbackParamName: "callback",
                load: function(a, c) {
                    f(a, c, b, h, e, g)
                },
                error: function(a) {
                    c(a, e, g)
                }
            });
            return g
        },
        _convexHullHandler: function(a, h, e, b, f, c) {
            try {
                var g = r.fromJson(a.geometry).setSpatialReference(e);
                this._successHandler([g], "onConvexHullComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onConvexHullComplete: function() {},
        union: function(a, h, e) {
            var b = a[0].spatialReference;
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(b.toJson()),
                geometries: k.toJson(this._encodeGeometries(a))
            });
            var f = this._unionHandler,
                c = this._errorHandler,
                g = new n(q._dfdCanceller);
            g._pendingDfd = p({
                url: this._url.path + "/union",
                content: a,
                callbackParamName: "callback",
                load: function(a, c) {
                    f(a, c, b, h, e, g)
                },
                error: function(a) {
                    c(a, e, g)
                }
            });
            return g
        },
        _unionHandler: function(a, h, e, b, f, c) {
            try {
                var g = r.fromJson(a.geometry).setSpatialReference(e);
                this._successHandler([g], "onUnionComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onUnionComplete: function() {},
        autoComplete: function(a, h, e, b) {
            var f = a[0].spatialReference;
            a = l.mixin({},
                this._url.query, {
                    f: "json",
                    sr: k.toJson(f.toJson()),
                    polygons: k.toJson(this._encodeGeometries(a).geometries),
                    polylines: k.toJson(this._encodeGeometries(h).geometries)
                });
            var c = this._autoCompleteHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/autoComplete",
                content: a,
                callbackParamName: "callback",
                load: function(a, g) {
                    c(a, g, f, e, b, d)
                },
                error: function(a) {
                    g(a, b, d)
                }
            });
            return d
        },
        _autoCompleteHandler: function(a, h, e, b, f, c) {
            try {
                var g = a.geometries;
                a = [];
                var d, m = g.length;
                for (d =
                    0; d < m; d++) a[d] = new v({
                    spatialReference: e,
                    rings: g[d].rings
                });
                this._successHandler([a], "onAutoCompleteComplete", b, c)
            } catch (t) {
                this._errorHandler(t, f, c)
            }
        },
        onAutoCompleteComplete: function() {},
        reshape: function(a, h, e, b) {
            var f = a.spatialReference;
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(f.toJson()),
                target: k.toJson({
                    geometryType: r.getJsonType(a),
                    geometry: a.toJson()
                }),
                reshaper: k.toJson(h.toJson())
            });
            var c = this._reshapeHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path +
                    "/reshape",
                content: a,
                callbackParamName: "callback",
                load: function(a, g) {
                    c(a, g, f, e, b, d)
                },
                error: function(a) {
                    g(a, b, d)
                }
            });
            return d
        },
        _reshapeHandler: function(a, h, e, b, f, c) {
            try {
                var g = r.fromJson(a.geometry).setSpatialReference(e);
                this._successHandler([g], "onReshapeComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onReshapeComplete: function() {},
        cut: function(a, h, e, b) {
            var f = a[0].spatialReference,
                c = s.map(a, function(a) {
                    return a.toJson()
                });
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(f.toJson()),
                target: k.toJson({
                    geometryType: r.getJsonType(a[0]),
                    geometries: c
                }),
                cutter: k.toJson(h.toJson())
            });
            var g = this._cutHandler,
                d = this._errorHandler,
                m = new n(q._dfdCanceller);
            m._pendingDfd = p({
                url: this._url.path + "/cut",
                content: a,
                callbackParamName: "callback",
                load: function(a, d) {
                    g(a, d, f, e, b, m)
                },
                error: function(a) {
                    d(a, b, m)
                }
            });
            return m
        },
        _cutHandler: function(a, h, e, b, f, c) {
            try {
                var g = a.geometries,
                    d = {};
                d.cutIndexes = a.cutIndexes;
                d.geometries = [];
                s.forEach(g, function(a) {
                    d.geometries.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([d], "onCutComplete", b, c)
            } catch (m) {
                this._errorHandler(m,
                    f, c)
            }
        },
        onCutComplete: function() {},
        intersect: function(a, h, e, b) {
            var f = a[0].spatialReference;
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(f.toJson()),
                geometries: k.toJson(this._encodeGeometries(a)),
                geometry: k.toJson({
                    geometryType: r.getJsonType(h),
                    geometry: h.toJson()
                })
            });
            var c = this._intersectHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/intersect",
                content: a,
                callbackParamName: "callback",
                load: function(a, g) {
                    c(a, g, f, e, b, d)
                },
                error: function(a) {
                    g(a, b, d)
                }
            });
            return d
        },
        _intersectHandler: function(a, h, e, b, f, c) {
            try {
                var g = [];
                s.forEach(a.geometries, function(a) {
                    g.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([g], "onIntersectComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onIntersectComplete: function() {},
        difference: function(a, h, e, b) {
            var f = a[0].spatialReference;
            a = l.mixin({}, this._url.query, {
                f: "json",
                sr: k.toJson(f.toJson()),
                geometries: k.toJson(this._encodeGeometries(a)),
                geometry: k.toJson({
                    geometryType: r.getJsonType(h),
                    geometry: h.toJson()
                })
            });
            var c = this._differenceHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/difference",
                content: a,
                callbackParamName: "callback",
                load: function(a, g) {
                    c(a, g, f, e, b, d)
                },
                error: function(a) {
                    g(a, b, d)
                }
            });
            return d
        },
        _differenceHandler: function(a, h, e, b, f, c) {
            try {
                var g = [];
                s.forEach(a.geometries, function(a) {
                    g.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([g], "onDifferenceComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onDifferenceComplete: function() {},
        buffer: function(a,
            h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.outSpatialReference || a.geometries[0].spatialReference,
                c = this._bufferHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/buffer",
                content: b,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _bufferHandler: function(a, h, e, b, f, c) {
            try {
                var g = a.geometries;
                a = [];
                var d, m = g.length;
                for (d = 0; d < m; d++) a[d] = new v({
                    spatialReference: e,
                    rings: g[d].rings
                });
                this._successHandler([a],
                    "onBufferComplete", b, c)
            } catch (k) {
                this._errorHandler(k, f, c)
            }
        },
        onBufferComplete: function() {},
        areasAndLengths: function(a, h, e) {
            a = l.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson());
            var b = this._areasAndLengthsHandler,
                f = this._errorHandler,
                c = new n(q._dfdCanceller);
            c._pendingDfd = p({
                url: this._url.path + "/areasAndLengths",
                content: a,
                callbackParamName: "callback",
                load: function(a, d) {
                    b(a, d, h, e, c)
                },
                error: function(a) {
                    f(a, e, c)
                }
            });
            return c
        },
        _areasAndLengthsHandler: function(a, h, e, b, f) {
            try {
                this._successHandler([a], "onAreasAndLengthsComplete",
                    e, f)
            } catch (c) {
                this._errorHandler(c, b, f)
            }
        },
        onAreasAndLengthsComplete: function() {},
        lengths: function(a, h, e) {
            a = l.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson());
            var b = this._lengthsHandler,
                f = this._errorHandler,
                c = new n(q._dfdCanceller);
            c._pendingDfd = p({
                url: this._url.path + "/lengths",
                content: a,
                callbackParamName: "callback",
                load: function(a, d) {
                    b(a, d, h, e, c)
                },
                error: function(a) {
                    f(a, e, c)
                }
            });
            return c
        },
        _lengthsHandler: function(a, h, e, b, f) {
            try {
                this._successHandler([a], "onLengthsComplete", e, f)
            } catch (c) {
                this._errorHandler(c,
                    b, f)
            }
        },
        onLengthsComplete: function() {},
        labelPoints: function(a, h, e) {
            var b = s.map(a, function(a) {
                    return a.toJson()
                }),
                f = a[0].spatialReference,
                b = l.mixin({}, this._url.query, {
                    f: "json",
                    sr: f.wkid ? f.wkid : k.toJson(f.toJson()),
                    polygons: k.toJson(b)
                }),
                c = this._labelPointsHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/labelPoints",
                content: b,
                callbackParamName: "callback",
                load: function(b, g) {
                    c(b, g, a, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _labelPointsHandler: function(a,
            h, e, b, f, c, g) {
            try {
                var d = [];
                s.forEach(a.labelPoints, function(a) {
                    d.push(r.fromJson(a).setSpatialReference(b))
                });
                this._successHandler([d], "onLabelPointsComplete", f, g)
            } catch (m) {
                this._errorHandler(m, c, g)
            }
        },
        onLabelPointsComplete: function() {},
        relation: function(a, h, e) {
            a = l.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson());
            var b = this._relationHandler,
                f = this._errorHandler,
                c = new n(q._dfdCanceller);
            c._pendingDfd = p({
                url: this._url.path + "/relation",
                content: a,
                callbackParamName: "callback",
                load: function(a, d) {
                    b(a, d, h, e,
                        c)
                },
                error: function(a) {
                    f(a, e, c)
                }
            });
            return c
        },
        _relationHandler: function(a, h, e, b, f) {
            try {
                this._successHandler([a.relations], "onRelationComplete", e, f)
            } catch (c) {
                this._errorHandler(c, b, f)
            }
        },
        onRelationComplete: function() {},
        trimExtend: function(a, h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.sr,
                c = this._trimExtendHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/trimExtend",
                content: b,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _trimExtendHandler: function(a, h, e, b, f, c) {
            try {
                var g = a.geometries;
                a = [];
                var d, m = g.length;
                for (d = 0; d < m; d++) a[d] = new x({
                    spatialReference: e,
                    paths: g[d].paths
                });
                this._successHandler([a], "onTrimExtendComplete", b, c)
            } catch (k) {
                this._errorHandler(k, f, c)
            }
        },
        onTrimExtendComplete: function() {},
        densify: function(a, h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.geometries[0].spatialReference,
                c = this._densifyHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd =
                p({
                    url: this._url.path + "/densify",
                    content: b,
                    callbackParamName: "callback",
                    load: function(a, b) {
                        c(a, b, f, h, e, d)
                    },
                    error: function(a) {
                        g(a, e, d)
                    }
                });
            return d
        },
        _densifyHandler: function(a, h, e, b, f, c) {
            try {
                var g = [];
                s.forEach(a.geometries, function(a) {
                    g.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([g], "onDensifyComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onDensifyComplete: function() {},
        generalize: function(a, h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.geometries[0].spatialReference,
                c = this._generalizeHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/generalize",
                content: b,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _generalizeHandler: function(a, h, e, b, f, c) {
            try {
                var g = [];
                s.forEach(a.geometries, function(a) {
                    g.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([g], "onGeneralizeComplete", b, c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onGeneralizeComplete: function() {},
        offset: function(a,
            h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.geometries[0].spatialReference,
                c = this._offsetHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/offset",
                content: b,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _offsetHandler: function(a, h, e, b, f, c) {
            try {
                var g = [];
                s.forEach(a.geometries, function(a) {
                    g.push(r.fromJson(a).setSpatialReference(e))
                });
                this._successHandler([g], "onOffsetComplete", b,
                    c)
            } catch (d) {
                this._errorHandler(d, f, c)
            }
        },
        onOffsetComplete: function() {},
        distance: function(a, h, e) {
            var b = l.mixin({}, this._url.query, {
                    f: "json"
                }, a.toJson()),
                f = a.geometry1.spatialReference,
                c = this._distanceHandler,
                g = this._errorHandler,
                d = new n(q._dfdCanceller);
            d._pendingDfd = p({
                url: this._url.path + "/distance",
                content: b,
                callbackParamName: "callback",
                load: function(a, b) {
                    c(a, b, f, h, e, d)
                },
                error: function(a) {
                    g(a, e, d)
                }
            });
            return d
        },
        _distanceHandler: function(a, h, e, b, f, c) {
            try {
                a = a && a.distance, this._successHandler([a], "onDistanceComplete",
                    b, c)
            } catch (g) {
                this._errorHandler(g, f, c)
            }
        },
        onDistanceComplete: function() {},
        toGeoCoordinateString: function(a, h, e) {
            var b = {};
            l.isObject(a.sr) ? b.sr = a.sr.wkid || k.toJson(a.sr.toJson()) : b.sr = a.sr;
            b.coordinates = k.toJson(a.coordinates);
            b.conversionType = a.conversionType || "MGRS";
            b.conversionMode = a.conversionMode;
            b.numOfDigits = a.numOfDigits;
            b.rounding = a.rounding;
            b.addSpaces = a.addSpaces;
            a = l.mixin({}, this._url.query, {
                f: "json"
            }, b);
            var f = this._toGeoCoordinateHandler,
                c = this._errorHandler,
                g = new n(q._dfdCanceller);
            g._pendingDfd =
                p({
                    url: this._url.path + "/toGeoCoordinateString",
                    content: a,
                    callbackParamName: "callback",
                    load: function(a, b) {
                        f(a, b, h, e, g)
                    },
                    error: function(a) {
                        c(a, e, g)
                    }
                });
            return g
        },
        _toGeoCoordinateHandler: function(a, h, e, b, f) {
            try {
                this._successHandler([a.strings], "onToGeoCoordinateStringComplete", e, f)
            } catch (c) {
                this._errorHandler(c, b, f)
            }
        },
        onToGeoCoordinateStringComplete: function() {},
        fromGeoCoordinateString: function(a, h, e) {
            var b = {};
            l.isObject(a.sr) ? b.sr = a.sr.wkid || k.toJson(a.sr.toJson()) : b.sr = a.sr;
            b.strings = k.toJson(a.strings);
            b.conversionType = a.conversionType || "MGRS";
            b.conversionMode = a.conversionMode;
            a = l.mixin({}, this._url.query, {
                f: "json"
            }, b);
            var f = this._fromGeoCoordinateHandler,
                c = this._errorHandler,
                g = new n(q._dfdCanceller);
            g._pendingDfd = p({
                url: this._url.path + "/fromGeoCoordinateString",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    f(a, b, h, e, g)
                },
                error: function(a) {
                    c(a, e, g)
                }
            });
            return g
        },
        _fromGeoCoordinateHandler: function(a, h, e, b, f) {
            try {
                this._successHandler([a.coordinates], "onToGeoCoordinateStringComplete", e, f)
            } catch (c) {
                this._errorHandler(c,
                    b, f)
            }
        },
        onFromGeoCoordinateStringComplete: function() {}
    });
    l.mixin(u, {
        UNIT_METER: 9001,
        UNIT_GERMAN_METER: 9031,
        UNIT_FOOT: 9002,
        UNIT_SURVEY_FOOT: 9003,
        UNIT_CLARKE_FOOT: 9005,
        UNIT_FATHOM: 9014,
        UNIT_NAUTICAL_MILE: 9030,
        UNIT_SURVEY_CHAIN: 9033,
        UNIT_SURVEY_LINK: 9034,
        UNIT_SURVEY_MILE: 9035,
        UNIT_KILOMETER: 9036,
        UNIT_CLARKE_YARD: 9037,
        UNIT_CLARKE_CHAIN: 9038,
        UNIT_CLARKE_LINK: 9039,
        UNIT_SEARS_YARD: 9040,
        UNIT_SEARS_FOOT: 9041,
        UNIT_SEARS_CHAIN: 9042,
        UNIT_SEARS_LINK: 9043,
        UNIT_BENOIT_1895A_YARD: 9050,
        UNIT_BENOIT_1895A_FOOT: 9051,
        UNIT_BENOIT_1895A_CHAIN: 9052,
        UNIT_BENOIT_1895A_LINK: 9053,
        UNIT_BENOIT_1895B_YARD: 9060,
        UNIT_BENOIT_1895B_FOOT: 9061,
        UNIT_BENOIT_1895B_CHAIN: 9062,
        UNIT_BENOIT_1895B_LINK: 9063,
        UNIT_INDIAN_FOOT: 9080,
        UNIT_INDIAN_1937_FOOT: 9081,
        UNIT_INDIAN_1962_FOOT: 9082,
        UNIT_INDIAN_1975_FOOT: 9083,
        UNIT_INDIAN_YARD: 9084,
        UNIT_INDIAN_1937_YARD: 9085,
        UNIT_INDIAN_1962_YARD: 9086,
        UNIT_INDIAN_1975_YARD: 9087,
        UNIT_FOOT_1865: 9070,
        UNIT_RADIAN: 9101,
        UNIT_DEGREE: 9102,
        UNIT_ARCMINUTE: 9103,
        UNIT_ARCSECOND: 9104,
        UNIT_GRAD: 9105,
        UNIT_GON: 9106,
        UNIT_MICRORADIAN: 9109,
        UNIT_ARCMINUTE_CENTESIMAL: 9112,
        UNIT_ARCSECOND_CENTESIMAL: 9113,
        UNIT_MIL6400: 9114,
        UNIT_BRITISH_1936_FOOT: 9095,
        UNIT_GOLDCOAST_FOOT: 9094,
        UNIT_INTERNATIONAL_CHAIN: 109003,
        UNIT_INTERNATIONAL_LINK: 109004,
        UNIT_INTERNATIONAL_YARD: 109001,
        UNIT_STATUTE_MILE: 9093,
        UNIT_SURVEY_YARD: 109002,
        UNIT_50KILOMETER_LENGTH: 109030,
        UNIT_150KILOMETER_LENGTH: 109031,
        UNIT_DECIMETER: 109005,
        UNIT_CENTIMETER: 109006,
        UNIT_MILLIMETER: 109007,
        UNIT_INTERNATIONAL_INCH: 109008,
        UNIT_US_SURVEY_INCH: 109009,
        UNIT_INTERNATIONAL_ROD: 109010,
        UNIT_US_SURVEY_ROD: 109011,
        UNIT_US_NAUTICAL_MILE: 109012,
        UNIT_UK_NAUTICAL_MILE: 109013,
        UNIT_SQUARE_INCHES: "esriSquareInches",
        UNIT_SQUARE_FEET: "esriSquareFeet",
        UNIT_SQUARE_YARDS: "esriSquareYards",
        UNIT_ACRES: "esriAcres",
        UNIT_SQUARE_MILES: "esriSquareMiles",
        UNIT_SQUARE_MILLIMETERS: "esriSquareMillimeters",
        UNIT_SQUARE_CENTIMETERS: "esriSquareCentimeters",
        UNIT_SQUARE_DECIMETERS: "esriSquareDecimeters",
        UNIT_SQUARE_METERS: "esriSquareMeters",
        UNIT_ARES: "esriAres",
        UNIT_HECTARES: "esriHectares",
        UNIT_SQUARE_KILOMETERS: "esriSquareKilometers"
    });
    return u
});
},
'esri/layers/FeatureLayer':function(){
//>>built
define(["require", "module", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/_base/Deferred", "dojo/date/locale", "dojo/sniff", "dojo/io-query", "dojo/dom-construct", "dojo/i18n", "dojo/when", "dojo/promise/all", "../kernel", "../lang", "../request", "../config", "../deferredUtils", "../SpatialReference", "../symbols/SimpleMarkerSymbol", "../symbols/SimpleLineSymbol", "../symbols/SimpleFillSymbol", "../symbols/jsonUtils", "../renderers/SimpleRenderer", "../renderers/UniqueValueRenderer", "../renderers/jsonUtils", "../tasks/QueryTask", "../tasks/query", "../tasks/FeatureSet", "../tasks/StatisticDefinition", "../geometry/Extent", "../geometry/jsonUtils", "../geometry/normalizeUtils", "../geometry/scaleUtils", "./GraphicsLayer", "./Field", "./TimeInfo", "./FeatureType", "./FeatureTemplate", "./FeatureEditResult", "./LabelClass", "./SnapshotMode", "./OnDemandMode", "./SelectionMode", "./StreamMode", "./TrackManager", "./HeatmapManager", "dojo/i18n!../nls/jsapi", "require"], function(M, S, T, C, q, k, F, u, U, H, V, W, ua, N, X, G, r, D, Y, A, I, Z, $, O, aa, P, ba, ca, da, J, K, ea, Q, fa, ga, ha, ia, ja, ka, la, ma, E, na, L, oa, pa, qa, ra, R, sa) {
    var ta = Y.defaults,
        t = T(ia, {
            declaredClass: "esri.layers.FeatureLayer",
            invalidParams: "query contains one or more unsupported parameters",
            reHostedFS: /https?:\/\/services.*\.arcgis\.com/i,
            maxPointCountForAuto: 4E3,
            maxRecordCountForAuto: 2E3,
            maxVertexCountForAuto: 25E4,
            generalizeForScale: 4E3,
            _eventMap: {
                "add-attachment-complete": ["result"],
                "before-apply-edits": ["adds", "updates", "deletes"],
                "delete-attachments-complete": ["results"],
                "edits-complete": ["adds", "updates", "deletes"],
                "query-attachment-infos-complete": ["results"],
                "query-count-complete": ["count"],
                "query-features-complete": ["featureSet"],
                "query-ids-complete": ["objectIds"],
                "query-related-features-complete": ["featureSets"],
                "selection-complete": ["features", "method"],
                "update-end": ["error", "info"]
            },
            constructor: function(a, b) {
                this._preventInit || this._initFeatureLayer(a, b)
            },
            _initFeatureLayer: function(a, b) {
                this.i18n = sa;
                b = b || {};
                this.showLabels =
                    null != b.showLabels ? b.showLabels : !0;
                this._outFields = b.outFields;
                this._defnExpr = b.definitionExpression;
                this._loadCallback = b.loadCallback;
                var c = b._usePatch;
                this._usePatch = null === c || void 0 === c ? !0 : c;
                this._trackIdField = b.trackIdField;
                this.objectIdField = b.objectIdField;
                this._maxOffset = null != b.maxAllowableOffset ? b.maxAllowableOffset : this.maxAllowableOffset;
                this.quantize = null != b.quantize ? b.quantize : !0;
                this._optEditable = b.editable;
                this._optAutoGen = b.autoGeneralize;
                this.editSummaryCallback = b.editSummaryCallback;
                this.userId = b.userId;
                this.userIsAdmin = b.userIsAdmin;
                this.useMapTime = b.hasOwnProperty("useMapTime") ? !!b.useMapTime : !0;
                this.source = b.source;
                this.gdbVersion = b.gdbVersion;
                this.orderByFields = b.orderByFields;
                this.maxPointCountForAuto = null != b.maxPointCountForAuto ? b.maxPointCountForAuto : this.maxPointCountForAuto;
                this.maxRecordCountForAuto = null != b.maxRecordCountForAuto ? b.maxRecordCountForAuto : this.maxRecordCountForAuto;
                this.maxVertexCountForAuto = null != b.maxVertexCountForAuto ? b.maxVertexCountForAuto : this.maxVertexCountForAuto;
                this.generalizeForScale = null != b.generalizeForScale ? b.generalizeForScale : this.generalizeForScale;
                this.queryPagination = null != b.queryPagination ? b.queryPagination : this.url ? this.reHostedFS.test(this.url) : !1;
                this.multipatchOption = b.multipatchOption;
                this._selectedFeatures = {};
                this._selectedFeaturesArr = [];
                this._newFeatures = [];
                this._deletedFeatures = {};
                this._ulid = this._getUniqueId();
                var d = t,
                    c = this.mode = r.isDefined(b.mode) ? b.mode : d.MODE_ONDEMAND;
                this._isStream && (this.mode = c = d.MODE_STREAM);
                switch (c) {
                    case d.MODE_SNAPSHOT:
                        this.currentMode =
                            d.MODE_SNAPSHOT;
                        this._mode = new L(this);
                        this._isSnapshot = !0;
                        break;
                    case d.MODE_ONDEMAND:
                    case d.MODE_AUTO:
                        this.currentMode = d.MODE_ONDEMAND;
                        this._tileWidth = b.tileWidth || 512;
                        this._tileHeight = b.tileHeight || 512;
                        this._mode = new oa(this);
                        this.latticeTiling = b.latticeTiling;
                        break;
                    case d.MODE_SELECTION:
                        this.currentMode = d.MODE_SELECTION;
                        this._mode = new pa(this);
                        this._isSelOnly = !0;
                        break;
                    case d.MODE_STREAM:
                        this.currentMode = d.MODE_STREAM, this._mode = new qa(this), this._isStream = !0
                }
                this._initLayer = q.hitch(this, this._initLayer);
                this._selectHandler = q.hitch(this, this._selectHandler);
                this._editable = !1;
                if (q.isObject(a) && a.layerDefinition) return this._collection = !0, this.mode = this._isStream ? d.MODE_STREAM : d.MODE_SNAPSHOT, this._initLayer(a), this;
                this._task = new da(this.url, {
                    source: this.source,
                    gdbVersion: this.gdbVersion
                });
                c = this._url.path;
                this._fserver = !1; - 1 !== c.search(/\/FeatureServer\//i) && (this._fserver = !0);
                this.mode === d.MODE_AUTO && this.reHostedFS.test(this.url) && this._queryLimit();
                (d = b.resourceInfo) ? this._initLayer(d): (this.source &&
                    (d = {
                        source: this.source.toJson()
                    }, this._url.query = q.mixin(this._url.query, {
                        layer: F.toJson(d)
                    })), this.gdbVersion && (this._url.query = q.mixin(this._url.query, {
                        gdbVersion: this.gdbVersion
                    })), D({
                        url: c,
                        content: q.mixin({
                            f: "json"
                        }, this._url.query),
                        callbackParamName: "callback",
                        load: this._initLayer,
                        error: this._errorHandler
                    }));
                this.registerConnectEvents()
            },
            _initLayer: function(a, b) {
                if (a || b) {
                    this._json = a;
                    this._findCredential();
                    if (this.credential && this.credential.ssl || a && a._ssl) this._useSSL(), this._task._useSSL();
                    this._collection && (this._isStream || (this.currentMode = t.MODE_SNAPSHOT, this._mode = new L(this)), this._isSnapshot = !0, this._featureSet = a.featureSet, this._nextId = a.nextObjectId, a = a.layerDefinition);
                    this.geometryType = a.geometryType;
                    "string" !== typeof this.multipatchOption && "esriGeometryMultiPatch" === this.geometryType && (this.multipatchOption = "xyFootprint");
                    if (a.hasOwnProperty("capabilities")) {
                        var c = this.capabilities = a.capabilities;
                        c && -1 !== c.toLowerCase().indexOf("editing") ? this._editable = !0 : this._editable = !1
                    } else this._collection || (this._editable = this._fserver);
                    r.isDefined(this._optEditable) ? (this._editable = this._optEditable, delete this._optEditable) : "esriGeometryMultiPatch" === this.geometryType && (this._editable = !1);
                    this._json = F.toJson(this._json);
                    if (this.isEditable()) this._setMaxOffset(null);
                    else if (this.currentMode !== t.MODE_SNAPSHOT && ("esriGeometryPolyline" === this.geometryType || "esriGeometryPolygon" === this.geometryType || this.hasXYFootprint())) this._autoGeneralize = r.isDefined(this._optAutoGen) ? this._optAutoGen :
                        this.currentMode === t.MODE_ONDEMAND, delete this._optAutoGen;
                    var c = a.effectiveMinScale || a.minScale,
                        d = a.effectiveMaxScale || a.maxScale;
                    !this._hasMin && c && this.setMinScale(c);
                    !this._hasMax && d && this.setMaxScale(d);
                    this.layerId = a.id;
                    this.name = a.name;
                    this.description = a.description;
                    this.copyright = a.copyrightText;
                    this.type = a.type;
                    this.displayField = a.displayField;
                    this.defaultDefinitionExpression = a.definitionExpression;
                    this.fullExtent = new Q(a.extent);
                    this.initialExtent = new Q(this.fullExtent.toJson());
                    this.fullExtent.spatialReference &&
                        (this.spatialReference = new I(this.fullExtent.spatialReference.toJson()));
                    this.defaultVisibility = a.defaultVisibility;
                    if ("esriGeometryPoint" === this.geometryType || "esriGeometryMultipoint" === this.geometryType) this.latticeTiling = !1;
                    this.indexedFields = a.indexedFields;
                    this.maxRecordCount = a.maxRecordCount;
                    this.canModifyLayer = a.canModifyLayer;
                    this.supportsStatistics = a.supportsStatistics;
                    this.supportsAdvancedQueries = this._collection ? !1 : a.supportsAdvancedQueries;
                    this.supportsCalculate = a.supportsCalculate;
                    this.supportsAttachmentsByUploadId =
                        a.supportsAttachmentsByUploadId;
                    this.supportsCoordinatesQuantization = a.supportsCoordinatesQuantization;
                    this.quantize = this.quantize && this.supportsCoordinatesQuantization;
                    this.hasLabels = a.hasLabels;
                    this.canScaleSymbols = a.canScaleSymbols;
                    this.supportsRollbackOnFailureParameter = this.supportsRollbackOnFailure = a.supportsRollbackOnFailure;
                    this.syncCanReturnChanges = a.syncCanReturnChanges;
                    this.isDataVersioned = a.isDataVersioned;
                    this.editFieldsInfo = a.editFieldsInfo;
                    this.ownershipBasedAccessControlForFeatures =
                        a.ownershipBasedAccessControlForFeatures;
                    this.editFieldsInfo && this.ownershipBasedAccessControlForFeatures && (this.creatorField = this.editFieldsInfo.creatorField);
                    this.relationships = a.relationships;
                    this.allowGeometryUpdates = r.isDefined(a.allowGeometryUpdates) ? a.allowGeometryUpdates : !0;
                    this.advancedQueryCapabilities = a.advancedQueryCapabilities || {
                        supportsStatistics: this.supportsStatistics,
                        supportsOrderBy: this.supportsAdvancedQueries,
                        supportsDistinct: this.supportsAdvancedQueries
                    };
                    this._setMaxOffset(this._maxOffset, !0);
                    this._isTable = "Table" === this.type;
                    for (var e = this.fields = [], d = a.fields, c = 0; c < d.length; c++) e.push(new ja(d[c]));
                    if (!this.objectIdField) {
                        this.objectIdField = a.objectIdField;
                        if (!this.objectIdField) {
                            d = a.fields;
                            for (c = 0; c < d.length; c++)
                                if (e = d[c], "esriFieldTypeOID" === e.type) {
                                    this.objectIdField = e.name;
                                    break
                                }
                        }!this.objectIdField && !this._isStream && console.debug("esri.layers.FeatureLayer: " + r.substitute({
                            url: this.url
                        }, "objectIdField is not set [url: ${url}]"))
                    }
                    if (!r.isDefined(this._nextId)) {
                        d = this.objectIdField;
                        e = -1;
                        if (this._collection && d)
                            for (var f = (c = this._featureSet) && c.features, l = f ? f.length : 0, g, c = 0; c < l; c++) g = (g = f[c].attributes) && g[d], g > e && (e = g);
                        this._nextId = e + 1
                    }
                    this.globalIdField = a.globalIdField;
                    if (c = this.typeIdField = a.typeIdField)
                        if (c = !this._getField(c) && this._getField(c, !0)) this.typeIdField = c.name;
                    this.visibilityField = a.visibilityField;
                    if (d = a.defaultSymbol) this.defaultSymbol = aa.fromJson(d);
                    var h = this.types = [],
                        n = a.types,
                        m, w, e = (c = this.editFieldsInfo) && c.creatorField,
                        f = c && c.editorField;
                    g = e || f;
                    l = [];
                    if (n)
                        for (c =
                            0; c < n.length; c++) m = new la(n[c]), w = m.templates, g && (w && w.length) && (l = l.concat(w)), h.push(m);
                    n = a.templates;
                    m = this.templates = [];
                    if (n)
                        for (c = 0; c < n.length; c++) h = new ma(n[c]), g && l.push(h), m.push(h);
                    for (c = 0; c < l.length; c++)
                        if (g = q.getObject("prototype.attributes", !1, l[c])) e && delete g[e], f && delete g[f];
                    if (c = a.timeInfo) this.timeInfo = new ka(c), this._startTimeField = c.startTimeField, this._endTimeField = c.endTimeField, this._startTimeField && this._endTimeField && (this._twoTimeFields = !0), this._trackIdField ? c.trackIdField =
                        this._trackIdField : this._trackIdField = c.trackIdField;
                    this.hasAttachments = !this._collection && a.hasAttachments ? !0 : !1;
                    this.htmlPopupType = a.htmlPopupType;
                    var c = a.drawingInfo,
                        p;
                    if ((e = c && c.labelingInfo) && !this.labelingInfo) this.labelingInfo = k.map(e, function(a) {
                        return new na(a)
                    }), this._fixLabelExpr();
                    if (!this.renderer)
                        if (c && c.renderer) {
                            if (p = c.renderer, this.setRenderer(ca.fromJson(p)), "classBreaks" === p.type && this.renderer.setMaxInclusive(!0), !this._collection) {
                                var s = p.type,
                                    d = [];
                                p = this.renderer;
                                switch (s) {
                                    case "simple":
                                        d.push(p.symbol);
                                        break;
                                    case "uniqueValue":
                                    case "classBreaks":
                                        d.push(p.defaultSymbol), d = d.concat(k.map(p.infos, function(a) {
                                            return a.symbol
                                        }))
                                }
                                var d = k.filter(d, r.isDefined),
                                    B = this._url.path + "/images/",
                                    x = this._getToken();
                                k.forEach(d, function(a) {
                                    var b = a.url;
                                    b && (-1 === b.search(/https?\:/) && -1 === b.indexOf("data:") && (a.url = B + b), x && -1 !== a.url.search(/https?\:/) && (a.url += "?token\x3d" + x))
                                })
                            }
                        } else if (d) n = this.types, 0 < n.length ? (p = new ba(this.defaultSymbol, this.typeIdField), k.forEach(n, function(a) {
                            p.addValue(a.id, a.symbol)
                        })) :
                        p = new P(this.defaultSymbol), this.setRenderer(p);
                    else if (!this._isTable) {
                        switch (this.geometryType) {
                            case "esriGeometryPoint":
                            case "esriGeometryMultipoint":
                                s = new Z;
                                break;
                            case "esriGeometryPolyline":
                                s = new $;
                                break;
                            case "esriGeometryPolygon":
                                s = new O;
                                break;
                            default:
                                this.hasXYFootprint() && (s = new O)
                        }
                        this.setRenderer(s ? new P(s) : null)
                    }
                    s = c && c.transparency || 0;
                    !this.hasOwnProperty("opacity") && 0 < s && (this.opacity = 1 - s / 100);
                    this.version = a.currentVersion;
                    this.version || (this.version = "capabilities" in a || "drawingInfo" in
                        a || "hasAttachments" in a || "htmlPopupType" in a || "relationships" in a || "timeInfo" in a || "typeIdField" in a || "types" in a ? 10 : 9.3);
                    if ((H("ie") || 7 <= H("trident") || H("safari")) && this.isEditable() && 10.02 > this.version) this._ts = !0;
                    this.statistics = a.statistics;
                    this._fixRendererFields();
                    this._checkFields();
                    this._updateCaps();
                    var v = function() {
                        this.currentMode !== t.MODE_SNAPSHOT && (this.queryPagination = !1);
                        this.loaded = !0;
                        this.onLoad(this);
                        var a = this._loadCallback;
                        a && (delete this._loadCallback, a(this))
                    };
                    this._collection ?
                        (s = this._featureSet, this._featureSet = null, this._mode._drawFeatures(new K(s)), this._fcAdded = !0, v.call(this)) : this._forceIdentity(this._limitPromise ? function() {
                            var a = this;
                            this._limitPromise.then(function(b) {
                                a._checkMode(b)
                            });
                            this._limitPromise.always(function() {
                                a._limitPromise = null;
                                v.call(a)
                            })
                        } : v)
                }
            },
            setShowLabels: function(a) {
                this.showLabels = a;
                this.onShowLabelsChange()
            },
            onShowLabelsChange: function() {},
            onRendererChange: function(a) {
                this.inherited(arguments);
                var b = this._map;
                this._ager = !(!a || !a.observationAger ||
                    !a.observationRenderer);
                a && "colors" in a && "blurRadius" in a && "maxPixelIntensity" in a ? "esriGeometryPoint" == this.geometryType && (!this._heatmapManager && b) && (this._heatmapManager = new R(this), this._heatmapManager.initialize(b)) : this.renderer && this.renderer.getRendererInfo ? k.some(this.renderer.rendererInfos, function(a) {
                    return a.renderer && "colors" in a.renderer && "blurRadius" in a.renderer
                }) || (this._heatmapManager = null) : this._heatmapManager = null;
                if (a) {
                    var c = [],
                        b = k.filter([a, a.observationRenderer, a.latestObservationRenderer,
                            a.trackRenderer
                        ], r.isDefined),
                        d = function(a) {
                            return null != a && "function" != typeof a && a
                        };
                    k.forEach(b, function(a) {
                        var b = d(a.attributeField),
                            l = d(a.attributeField2);
                        a = d(a.attributeField3);
                        !1 !== b && c.push(b);
                        !1 !== l && c.push(l);
                        !1 !== a && c.push(a)
                    });
                    this._rendererFields = c
                } else this._rendererFields = [];
                this.loaded && (this._fixRendererFields(), this._checkFields(this._rendererFields), this._collection && (this._typesDirty = !0))
            },
            redraw: function() {
                this.inherited(arguments);
                this._trackManager && this._trackManager.container &&
                    this._trackManager.container.redraw()
            },
            _evalSDRenderer: function() {
                this.inherited(arguments);
                var a = this._getRenderer();
                this._ager = !(!a || !a.observationAger || !a.observationRenderer);
                this._trackManager && this._trackManager.container && this._trackManager.container.setRenderer(a && a.trackRenderer)
            },
            _setMap: function(a) {
                var b = this.inherited(arguments),
                    c = this._mode,
                    d = this;
                c && c.initialize(a);
                this.geometryType && this.attr("data-geometry-type", this.geometryType.replace(/esriGeometry/i, "").toLowerCase());
                this._addHandle =
                    this.on("graphic-node-add", function(a) {
                        a = a.graphic.attributes;
                        (a = d._selectedFeatures[a && a[d.objectIdField]]) && a.attr("data-selected", "")
                    });
                return b
            },
            _unsetMap: function(a) {
                var b = this._mode;
                b && b.suspend();
                this._trackManager && (this._trackManager.destroy(), this._trackManager = null);
                C.disconnect(this._zoomConnect);
                C.disconnect(this._addHandle);
                this._zoomConnect = this._addHandle = null;
                this._toggleTime(!1);
                this.inherited("_unsetMap", arguments)
            },
            refresh: function() {
                var a = this._mode;
                a && a.refresh()
            },
            hasXYFootprint: function() {
                return "esriGeometryMultiPatch" ===
                    this.geometryType && "xyFootprint" === this.multipatchOption
            },
            getOutFields: function() {
                return k.filter(this._getOutFields(), function(a) {
                    return "*" === a || !!this._getField(a)
                }, this)
            },
            getField: function(a) {
                return this._getField(a, !0)
            },
            getDomain: function(a, b) {
                var c, d, e = b && b.feature,
                    f = e && this.typeIdField && e.attributes && e.attributes[this.typeIdField];
                null != f && k.some(this.types, function(b) {
                    if (b.id == f) {
                        if ((c = b.domains && b.domains[a]) && "inherited" === c.type) c = this._getLayerDomain(a), d = !0;
                        return !0
                    }
                    return !1
                }, this);
                !d &&
                    !c && (c = this._getLayerDomain(a));
                return c
            },
            _getLayerDomain: function(a) {
                var b;
                k.some(this.fields, function(c) {
                    c.name === a && (b = c.domain);
                    return !!b
                });
                return b
            },
            getType: function(a) {
                var b, c = a && this.typeIdField && a.attributes && a.attributes[this.typeIdField];
                k.some(this.types, function(a) {
                    a.id == c && (b = a);
                    return !!b
                });
                return b
            },
            setEditable: function(a) {
                if (!this._collection) return console.log("FeatureLayer:setEditable - this functionality is not yet supported for layer in a feature service"), this;
                if (!this.loaded) return this._optEditable =
                    a, this;
                var b = this._editable;
                this._editable = a;
                this._updateCaps();
                if (b !== a) this.onCapabilitiesChange();
                return this
            },
            getEditCapabilities: function(a) {
                var b = {
                    canCreate: !1,
                    canUpdate: !1,
                    canDelete: !1
                };
                if (!this.loaded || !this.isEditable()) return b;
                var c = a && a.feature;
                a = a && a.userId;
                var d = k.map(this.capabilities ? this.capabilities.toLowerCase().split(",") : [], q.trim),
                    e = -1 < k.indexOf(d, "editing"),
                    f = e && -1 < k.indexOf(d, "create"),
                    b = e && -1 < k.indexOf(d, "update"),
                    d = e && -1 < k.indexOf(d, "delete"),
                    l = this.ownershipBasedAccessControlForFeatures,
                    g = this.editFieldsInfo,
                    h = g && g.creatorField,
                    g = g && g.realm,
                    c = (c = c && c.attributes) && h ? c[h] : void 0,
                    n = !!this.userIsAdmin,
                    h = !l || n || !(!l.allowOthersToUpdate && !l.allowUpdateToOthers),
                    l = !l || n || !(!l.allowOthersToDelete && !l.allowDeleteToOthers);
                if (n || e && !f && !b && !d) f = b = d = !0;
                e = {
                    canCreate: f,
                    canUpdate: b,
                    canDelete: d
                };
                null === c ? (e.canUpdate = b && h, e.canDelete = d && l) : "" !== c && c && ((a = a || this.getUserId()) && g && (a = a + "@" + g), a.toLowerCase() !== c.toLowerCase() && (e.canUpdate = b && h, e.canDelete = d && l));
                return e
            },
            getUserId: function() {
                var a;
                this.loaded && (a = this.credential && this.credential.userId || this.userId || "");
                return a
            },
            setUserIsAdmin: function(a) {
                this.userIsAdmin = a
            },
            setEditSummaryCallback: function(a) {
                this.editSummaryCallback = a
            },
            getEditSummary: function(a, b, c) {
                c = r.isDefined(c) ? c : (new Date).getTime();
                var d = "";
                c = this.getEditInfo(a, b, c);
                (b = b && b.callback || this.editSummaryCallback) && (c = b(a, c) || "");
                if (q.isString(c)) d = c;
                else {
                    if (c) {
                        a = c.action;
                        b = c.userId;
                        var e = c.timeValue,
                            f = 0;
                        a && f++;
                        b && f++;
                        r.isDefined(e) && f++;
                        1 < f && (d = ("edit" === a ? "edit" : "create") +
                            (b ? "User" : "") + (r.isDefined(e) ? c.displayPattern : ""))
                    }
                    d = d && r.substitute(c, this.i18n.layers.FeatureLayer[d])
                }
                return d
            },
            getEditInfo: function(a, b, c) {
                if (this.loaded) {
                    c = r.isDefined(c) ? c : (new Date).getTime();
                    b = b && b.action || "last";
                    var d = this.editFieldsInfo,
                        e = d && d.creatorField,
                        f = d && d.creationDateField,
                        l = d && d.editorField,
                        d = d && d.editDateField,
                        l = (a = a && a.attributes) && l ? a[l] : void 0,
                        d = a && d ? a[d] : null,
                        e = this._getEditData(a && e ? a[e] : void 0, a && f ? a[f] : null, c);
                    c = this._getEditData(l, d, c);
                    var g;
                    switch (b) {
                        case "creation":
                            g =
                                e;
                            break;
                        case "edit":
                            g = c;
                            break;
                        case "last":
                            g = c || e
                    }
                    g && (g.action = g === c ? "edit" : "creation");
                    return g
                }
            },
            _getEditData: function(a, b, c) {
                var d, e, f;
                r.isDefined(b) && (e = c - b, f = 0 > e ? "Full" : 6E4 > e ? "Seconds" : 12E4 > e ? "Minute" : 36E5 > e ? "Minutes" : 72E5 > e ? "Hour" : 864E5 > e ? "Hours" : 6048E5 > e ? "WeekDay" : "Full");
                if (void 0 !== a || f) d = d || {}, d.userId = a, f && (a = U.format, c = new Date(b), d.minutes = Math.floor(e / 6E4), d.hours = Math.floor(e / 36E5), d.weekDay = a(c, {
                        datePattern: "EEEE",
                        selector: "date"
                    }), d.formattedDate = a(c, {
                        selector: "date"
                    }), d.formattedTime =
                    a(c, {
                        selector: "time"
                    }), d.displayPattern = f, d.timeValue = b);
                return d
            },
            isEditable: function() {
                return !(!this._editable && !this.userIsAdmin)
            },
            setMaxAllowableOffset: function(a) {
                this.isEditable() || this._setMaxOffset(a, !0);
                return this
            },
            getMaxAllowableOffset: function() {
                var a = this._quantizationParameters ? this._quantizationParameters.tolerance : void 0;
                return null != this._maxOffset ? this._maxOffset : a
            },
            _setMaxOffset: function(a, b) {
                if (null == a) return delete this._maxOffset, delete this._quantizationParameters, this;
                this.quantize &&
                    this.supportsCoordinatesQuantization ? ("esriGeometryPolyline" === this.geometryType ? this._maxOffset = a : delete this._maxOffset, this._quantizationParameters = {
                        mode: "view",
                        originPosition: "upperLeft",
                        tolerance: a,
                        extent: this.fullExtent
                    }) : (b || (a = Math.floor(a)), this._maxOffset = a, delete this._quantizationParameters);
                return this
            },
            setAutoGeneralize: function(a) {
                if (this.loaded) {
                    if (!this.isEditable() && this.currentMode !== t.MODE_SNAPSHOT && ("esriGeometryPolyline" === this.geometryType || "esriGeometryPolygon" === this.geometryType ||
                            this.hasXYFootprint()))(this._autoGeneralize = a) ? (a = this._map) && a.loaded && this._setMaxOffset(a.extent.getWidth() / a.width) : this._setMaxOffset(null)
                } else this._optAutoGen = a;
                return this
            },
            setGDBVersion: function(a) {
                if (!this._collection && a !== this.gdbVersion && (a || this.gdbVersion)) this.gdbVersion = a, this._task.gdbVersion = a, this._url.query = q.mixin(this._url.query, {
                    gdbVersion: a
                }), this.loaded && (this.clearSelection(), this._map && this.refresh()), this.onGDBVersionChange();
                return this
            },
            setDefinitionExpression: function(a) {
                this._defnExpr =
                    a;
                (a = this._mode) && a.propertyChangeHandler(1);
                return this
            },
            getDefinitionExpression: function() {
                return this._defnExpr
            },
            setTimeDefinition: function(a) {
                this._isSnapshot ? (this._timeDefn = a, (a = this._mode) && a.propertyChangeHandler(2)) : console.log("FeatureLayer.setTimeDefinition: layer in on-demand or selection mode does not support time definitions. Layer id \x3d " + this.id + ", Layer URL \x3d " + this.url);
                return this
            },
            getTimeDefinition: function() {
                return this._timeDefn
            },
            setTimeOffset: function(a, b) {
                this._timeOffset =
                    a;
                this._timeOffsetUnits = b;
                var c = this._mode;
                c && c.propertyChangeHandler(0);
                return this
            },
            setUseMapTime: function(a) {
                this.useMapTime = a;
                this._toggleTime(!this.suspended);
                (a = this._mode) && a.propertyChangeHandler(0)
            },
            selectFeatures: function(a, b, c, d) {
                b = b || t.SELECTION_NEW;
                a = this._getShallowClone(a);
                var e = this._map,
                    f, l = this,
                    g = A._fixDfd(new u(A._dfdCanceller));
                a.outFields = this.getOutFields();
                a.returnGeometry = !0;
                a.multipatchOption = this.multipatchOption;
                e && (a.outSpatialReference = new I(e.spatialReference.toJson()));
                if (!this._applyQueryFilters(a, !0)) return f = {
                    features: []
                }, this._selectHandler(f, b, c, d, g), g;
                if (e = this._canDoClientSideQuery(a)) g._pendingDfd = N(this._doQuery(a, e)), g._pendingDfd.then(function(a) {
                    f = {
                        features: a
                    };
                    l._selectHandler(f, b, c, d, g)
                });
                else {
                    if (this._collection) return this._resolve([Error("FeatureLayer::selectFeatures - " + this.invalidParams)], null, d, g, !0), g;
                    var h = this;
                    this._ts && (a._ts = (new Date).getTime());
                    (g._pendingDfd = this._task.execute(a)).addCallbacks(function(a) {
                            h._selectHandler(a, b, c, d, g)
                        },
                        function(a) {
                            h._resolve([a], null, d, g, !0)
                        })
                }
                return g
            },
            getSelectedFeatures: function() {
                var a = this._selectedFeatures,
                    b = [],
                    c;
                for (c in a) a.hasOwnProperty(c) && b.push(a[c]);
                return b
            },
            clearSelection: function(a) {
                var b = this._selectedFeatures,
                    c = this._mode,
                    d;
                for (d in b) b.hasOwnProperty(d) && (this._unSelectFeatureIIf(d, c), c._removeFeatureIIf(d));
                this._selectedFeatures = {};
                this._isSelOnly && c._applyTimeFilter(!0);
                if (!a) this.onSelectionClear();
                return this
            },
            setSelectionSymbol: function(a) {
                if (this._selectionSymbol = a) {
                    var b =
                        this._selectedFeatures,
                        c;
                    for (c in b) b.hasOwnProperty(c) && b[c].setSymbol(a)
                }
                return this
            },
            getSelectionSymbol: function() {
                return this._selectionSymbol
            },
            setLabelingInfo: function(a) {
                a ? (this.labelingInfo = a, this._fixLabelExpr()) : delete this.labelingInfo;
                this._collection && (this._typesDirty = !0);
                this.onLabelingInfoChange()
            },
            _fixLabelExpr: function() {
                var a = /\[([^\[\]]+)\]/ig,
                    b, c = this,
                    d = function(a, b) {
                        var d = c._getField(b, !0);
                        return "[" + (d && d.name || b) + "]"
                    };
                k.forEach(this.labelingInfo, function(c) {
                    if (b = c.labelExpression) c.labelExpression =
                        b.replace(a, d)
                })
            },
            __msigns: [{
                n: "applyEdits",
                c: 5,
                a: [{
                    i: 0
                }, {
                    i: 1
                }],
                e: 4,
                f: 1
            }],
            applyEdits: function(a, b, c, d, e, f) {
                var l = f.assembly,
                    g = f.dfd;
                this._applyNormalized(a, l && l[0]);
                this._applyNormalized(b, l && l[1]);
                this.onBeforeApplyEdits(a, b, c);
                var h = {},
                    n = this.objectIdField,
                    l = {
                        f: "json"
                    },
                    m = !1;
                if (this._collection) f = {}, f.addResults = a ? k.map(a, function() {
                        m = !0;
                        return {
                            objectId: this._nextId++,
                            success: !0
                        }
                    }, this) : null, f.updateResults = b ? k.map(b, function(a) {
                        m = !0;
                        var b = a.attributes[n];
                        h[b] = a;
                        return {
                            objectId: b,
                            success: !0
                        }
                    }, this) :
                    null, f.deleteResults = c ? k.map(c, function(a) {
                        m = !0;
                        return {
                            objectId: a.attributes[n],
                            success: !0
                        }
                    }, this) : null, m ? this._editHandler(f, a, h, d, e, g) : this._resolve([f.addResults, f.updateResults, f.deleteResults], null, d, g);
                else {
                    a && 0 < a.length && (l.adds = this._convertFeaturesToJson(a, 0, 1), m = !0);
                    if (b && 0 < b.length) {
                        for (f = 0; f < b.length; f++) {
                            var w = b[f];
                            h[w.attributes[n]] = w
                        }
                        l.updates = this._convertFeaturesToJson(b, 0, 0, 1);
                        m = !0
                    }
                    if (c && 0 < c.length) {
                        b = [];
                        for (f = 0; f < c.length; f++) b.push(c[f].attributes[n]);
                        l.deletes = b.join(",");
                        m = !0
                    }
                    if (m) {
                        var p =
                            this;
                        return D({
                            url: this._url.path + "/applyEdits",
                            content: q.mixin(l, this._url.query),
                            callbackParamName: "callback",
                            load: function(b) {
                                p._editHandler(b, a, h, d, e, g)
                            },
                            error: function(a) {
                                p._resolve([a], null, e, g, !0)
                            }
                        }, {
                            usePost: !0
                        })
                    }
                    this._resolve([], null, d, g)
                }
            },
            queryFeatures: function(a, b, c) {
                return this._query("execute", "onQueryFeaturesComplete", a, b, c)
            },
            queryRelatedFeatures: function(a, b, c) {
                return this._query("executeRelationshipQuery", "onQueryRelatedFeaturesComplete", a, b, c)
            },
            queryIds: function(a, b, c) {
                return this._query("executeForIds",
                    "onQueryIdsComplete", a, b, c)
            },
            queryCount: function(a, b, c) {
                return this._query("executeForCount", "onQueryCountComplete", a, b, c)
            },
            queryExtent: function(a, b, c) {
                return this._query("executeForExtent", "onQueryExtentComplete", a, b, c)
            },
            queryAttachmentInfos: function(a, b, c) {
                var d = this._url.path + "/" + a + "/attachments",
                    e = new u(A._dfdCanceller),
                    f = this;
                e._pendingDfd = D({
                    url: d,
                    content: q.mixin({
                        f: "json"
                    }, this._url.query),
                    callbackParamName: "callback",
                    load: function(c) {
                        c = c.attachmentInfos;
                        var g;
                        k.forEach(c, function(b) {
                            g = V.objectToQuery({
                                gdbVersion: f._url.query &&
                                    f._url.query.gdbVersion,
                                layer: f._url.query && f._url.query.layer,
                                token: f._getToken()
                            });
                            b.url = d + "/" + b.id + (g ? "?" + g : "");
                            b.objectId = a
                        });
                        f._resolve([c], "onQueryAttachmentInfosComplete", b, e)
                    },
                    error: function(a) {
                        f._resolve([a], null, c, e, !0)
                    }
                });
                return e
            },
            addAttachment: function(a, b, c, d) {
                return this._sendAttachment("add", a, b, c, d)
            },
            updateAttachment: function(a, b, c, d, e) {
                c.appendChild(W.create("input", {
                    type: "hidden",
                    name: "attachmentId",
                    value: b
                }));
                return this._sendAttachment("update", a, c, d, e)
            },
            deleteAttachments: function(a,
                b, c, d) {
                var e = this._url.path + "/" + a + "/deleteAttachments",
                    f = new u(A._dfdCanceller),
                    l = this;
                b = {
                    f: "json",
                    attachmentIds: b.join(",")
                };
                f._pendingDfd = D({
                    url: e,
                    content: q.mixin(b, this._url.query),
                    callbackParamName: "callback",
                    load: q.hitch(this, function(b) {
                        b = b.deleteAttachmentResults;
                        b = k.map(b, function(b) {
                            b = new E(b);
                            b.attachmentId = b.objectId;
                            b.objectId = a;
                            return b
                        });
                        l._resolve([b], "onDeleteAttachmentsComplete", c, f)
                    }),
                    error: function(a) {
                        l._resolve([a], null, d, f, !0)
                    }
                }, {
                    usePost: !0
                });
                return f
            },
            addType: function(a) {
                var b =
                    this.types;
                if (b) {
                    if (k.some(b, function(b) {
                            return b.id == a.id ? !0 : !1
                        })) return !1;
                    b.push(a)
                } else this.types = [a];
                return this._typesDirty = !0
            },
            deleteType: function(a) {
                if (this._collection) {
                    var b = this.types;
                    if (b) {
                        var c = -1;
                        k.some(b, function(b, e) {
                            return b.id == a ? (c = e, !0) : !1
                        });
                        if (-1 < c) return this._typesDirty = !0, b.splice(c, 1)[0]
                    }
                }
            },
            toJson: function() {
                var a = this._json;
                if (a = q.isString(a) ? F.fromJson(a) : q.clone(a)) {
                    var a = a.layerDefinition ? a : {
                            layerDefinition: a
                        },
                        b = a.layerDefinition,
                        c = this._collection;
                    if (c && this._typesDirty) {
                        b.types =
                            k.map(this.types || [], function(a) {
                                return a.toJson()
                            });
                        var d = this.renderer,
                            e = this.labelingInfo,
                            f = b.drawingInfo;
                        if ((d || e) && !f) f = b.drawingInfo = {};
                        f && (d && -1 === d.declaredClass.indexOf("TemporalRenderer")) && (f.renderer = d.toJson());
                        e && (f.labelingInfo = k.map(e, function(a) {
                            return a.toJson()
                        }))
                    }
                    d = null;
                    if (!c || this._fcAdded) d = {
                        geometryType: b.geometryType,
                        features: this._convertFeaturesToJson(this.graphics, !0)
                    };
                    a.featureSet = q.mixin({}, a.featureSet || {}, d);
                    c && (a.nextObjectId = this._nextId, b.capabilities = this.capabilities);
                    return a
                }
            },
            onSelectionComplete: function() {},
            onSelectionClear: function() {},
            onBeforeApplyEdits: function() {},
            onEditsComplete: function() {},
            onQueryFeaturesComplete: function() {},
            onQueryRelatedFeaturesComplete: function() {},
            onQueryIdsComplete: function() {},
            onQueryCountComplete: function() {},
            onQueryExtentComplete: function() {},
            onQueryAttachmentInfosComplete: function() {},
            onAddAttachmentComplete: function() {},
            onUpdateAttachmentComplete: function() {},
            onDeleteAttachmentsComplete: function() {},
            onCapabilitiesChange: function() {},
            onGDBVersionChange: function() {},
            onQueryLimitExceeded: function() {},
            onLabelingInfoChange: function() {},
            _forceIdentity: function(a) {
                var b = this,
                    c = this._url && this._url.path;
                (this.ownershipBasedAccessControlForFeatures || this.userIsAdmin) && !this._getToken() && c && G.id && G.id._hasPortalSession() && G.id._doPortalSignIn(c) ? G.id.getCredential(c).then(function() {
                    b._findCredential();
                    a.call(b)
                }, function() {
                    a.call(b)
                }) : a.call(this)
            },
            _checkMode: function(a) {
                var b = this.geometryType,
                    c = this.maxRecordCount;
                a = (a = a && a.features &&
                    a.features[0]) && a.attributes && a.attributes.exceedslimit;
                if (this.mode === t.MODE_AUTO && !this.isEditable() && 0 === a && (this.queryPagination || ("esriGeometryPolyline" === b || "esriGeometryPolygon" === b || "esriGeometryMultipoint" === b || this.hasXYFootprint()) && c >= this.maxRecordCountForAuto || "esriGeometryPoint" === b && c >= this.maxPointCountForAuto)) this.currentMode = t.MODE_SNAPSHOT, this._mode = new L(this), this._isSnapshot = !0, this._autoGeneralize = !1
            },
            _queryLimit: function() {
                var a = this,
                    b = new u;
                this._limitPromise = b.promise;
                setTimeout(function() {
                    var c = new J,
                        d = new ea;
                    d.statisticType = "exceedslimit";
                    d.maxPointCount = a.maxPointCountForAuto;
                    d.maxRecordCount = a.maxRecordCountForAuto;
                    d.maxVertexCount = a.maxVertexCountForAuto;
                    d.outStatisticFieldName = "exceedslimit";
                    c.outStatistics = [d];
                    a.queryFeatures(c).promise.then(function(a) {
                        b.resolve(a)
                    }, function(a) {
                        b.reject(a)
                    })
                }, 0)
            },
            _updateCaps: function() {
                var a = this._editable,
                    b = q.trim(this.capabilities || ""),
                    c = k.map(b ? b.split(",") : [], q.trim),
                    d = k.map(b ? b.toLowerCase().split(",") : [], q.trim),
                    b = k.indexOf(d, "editing"),
                    e, d = {
                        Create: k.indexOf(d, "create"),
                        Update: k.indexOf(d, "update"),
                        Delete: k.indexOf(d, "delete")
                    };
                if (a && -1 === b) c.push("Editing");
                else if (!a && -1 < b) {
                    a = [b];
                    for (e in d) - 1 < d[e] && a.push(d[e]);
                    a.sort();
                    for (e = a.length - 1; 0 <= e; e--) c.splice(a[e], 1)
                }
                this.capabilities = c.join(",")
            },
            _counter: {
                value: 0
            },
            _getUniqueId: function() {
                return this._counter.value++
            },
            onSuspend: function() {
                this.inherited(arguments);
                this._toggleTime(!1);
                var a = this._mode;
                a && a.suspend()
            },
            onResume: function(a) {
                this.inherited(arguments);
                this._toggleTime(!0);
                this._updateMaxOffset();
                var b = this._mode,
                    c = this._map,
                    d = this._getRenderer();
                if (a.firstOccurrence) {
                    this._fixRendererFields();
                    this._checkFields();
                    this.clearSelection();
                    if (this.timeInfo && !this._trackManager && (this._trackIdField || d && (d.latestObservationRenderer || d.trackRenderer))) this._trackManager = new ra(this), this._trackManager.initialize(c);
                    d && ("colors" in d && "blurRadius" in d && "maxPixelIntensity" in d) && ("esriGeometryPoint" == this.geometryType && !this._heatmapManager) && (this._heatmapManager =
                        new R(this), this._heatmapManager.initialize(c));
                    if (this.mode === t.MODE_AUTO && this.currentMode === t.MODE_SNAPSHOT && ("esriGeometryPolyline" === this.geometryType || "esriGeometryPolygon" === this.geometryType || this.hasXYFootprint()) && !this.getMaxAllowableOffset()) d = this.generalizeForScale, d = this.maxScale ? this.maxScale : this.minScale ? Math.min(d, this.minScale) : Math.min(d, ha.getScale(c, this.initialExtent)), this.isEditable() || this._setMaxOffset(c.extent.getWidth() / c.width / c.getScale() * d, !0);
                    this._zoomConnect = C.connect(c,
                        "onZoomEnd", this, this._updateMaxOffset)
                }
                b && (a.firstOccurrence ? b.startup() : b.resume())
            },
            _updateMaxOffset: function() {
                var a = this._map;
                a && a.loaded && this._autoGeneralize && this._setMaxOffset(a.extent.getWidth() / a.width)
            },
            _toggleTime: function(a) {
                var b = this._map;
                a && this.timeInfo && this.useMapTime && b ? (this._mapTimeExtent = b.timeExtent, this._timeConnect || (this._timeConnect = C.connect(b, "onTimeExtentChange", this, this._timeChangeHandler))) : (this._mapTimeExtent = null, C.disconnect(this._timeConnect), this._timeConnect =
                    null)
            },
            _timeChangeHandler: function(a) {
                this._mapTimeExtent = a;
                (a = this._mode) && a.propertyChangeHandler(0)
            },
            _getOffsettedTE: function(a) {
                var b = this._timeOffset,
                    c = this._timeOffsetUnits;
                return a && b && c ? a.offset(-1 * b, c) : a
            },
            _getTimeOverlap: function(a, b) {
                return a && b ? a.intersection(b) : a || b
            },
            _getTimeFilter: function(a) {
                var b = this.getTimeDefinition(),
                    c;
                if (b && (c = this._getTimeOverlap(b, null), !c)) return [!1];
                if (a) {
                    if (a = c ? this._getTimeOverlap(a, c) : a, !a) return [!1]
                } else a = c;
                return [!0, a]
            },
            _getAttributeFilter: function(a) {
                var b =
                    this.getDefinitionExpression();
                return a ? b ? "(" + b + ") AND (" + a + ")" : a : b
            },
            _applyQueryFilters: function(a, b) {
                a.where = this._getAttributeFilter(a.where);
                a.maxAllowableOffset = this._maxOffset;
                a.quantizationParameters = this._quantizationParameters;
                b && this.supportsAdvancedQueries && (a.orderByFields = a.orderByFields || this.getOrderByFields());
                if (this.timeInfo) {
                    var c = this._getTimeFilter(a.timeExtent);
                    if (c[0]) a.timeExtent = c[1];
                    else return !1
                }
                return !0
            },
            _add: function(a) {
                var b = this._selectionSymbol,
                    c = a.attributes,
                    d = this.visibilityField;
                b && this._isSelOnly && a.setSymbol(b);
                if (d && c && c.hasOwnProperty(d)) a[c[d] ? "show" : "hide"]();
                return this.add.apply(this, arguments)
            },
            _remove: function() {
                return this.remove.apply(this, arguments)
            },
            _canDoClientSideQuery: function(a) {
                var b = [],
                    c = this._map;
                if (!(this._isTable || !c && !this._collection))
                    if (!a.text && !(a.where && a.where !== this.getDefinitionExpression() || a.orderByFields && a.orderByFields.length || a.outStatistics || a.returnDistinctValues)) {
                        var d = this._isSnapshot,
                            e = this._isSelOnly,
                            f = a.geometry;
                        if (f)
                            if (!e && a.spatialRelationship ===
                                J.SPATIAL_REL_INTERSECTS && "extent" === f.type && (d || c.extent.contains(f))) b.push(1);
                            else return;
                        if (c = a.objectIds)
                            if (d) b.push(2);
                            else {
                                var f = c.length,
                                    l = this._mode,
                                    g = 0,
                                    h;
                                for (h = 0; h < f; h++) l._getFeature(c[h]) && g++;
                                if (g === f) b.push(2);
                                else return
                            }
                        if (this.timeInfo)
                            if (a = a.timeExtent, c = this._mapTimeExtent, d) a && b.push(3);
                            else if (e) {
                            if (a) return
                        } else if (c)
                            if (-1 !== k.indexOf(b, 2)) a && b.push(3);
                            else if (-1 !== k.indexOf(b, 1)) a == c && b.push(3);
                        else return;
                        else if (0 < b.length) a && b.push(3);
                        else if (a) return;
                        return 0 < b.length ? b :
                            null
                    }
            },
            _getAbsMid: function(a) {
                return M.toAbsMid ? M.toAbsMid(a) : S.id.replace(/\/[^\/]*$/ig, "/") + a
            },
            _doQuery: function(a, b, c) {
                var d = [],
                    e = this._mode,
                    f = this.objectIdField,
                    l = this,
                    g, h, n = new u,
                    m = new u,
                    w = function(a, b) {
                        if (!a.length || !b.length) return a.length ? a : b;
                        var c, d, e = {};
                        a.length > b.length ? (d = a, c = b) : (d = b, c = a);
                        for (var g = d.length, l = c.length, h; g--;) h = d[g], e[h.attributes[f]] = !0;
                        for (; l--;) h = c[l], e[h.attributes[f]] || d.push(h);
                        return d
                    };
                if (-1 !== k.indexOf(b, 1)) {
                    h = this.graphics;
                    g = h.length;
                    var p = this.spatialIndex ||
                        this._map && this._map.spatialIndex,
                        s, B = a.geometry._normalize(null, !0);
                    null == p && ta.autoSpatialIndexing ? s = (this._map || this).addPlugin(this._getAbsMid("../plugins/spatialIndex")).then(q.hitch(this, q.partial(this._getFromIndex, B, p)), function(a) {
                        m.resolve(q.hitch(this, q.partial(this._filterByExtent, h, B)))
                    }) : p && (s = this._getFromIndex(B, p));
                    s ? s.then(function(a) {
                        for (var b = 0; b < a.length; b++) a[b].results && (d = d.concat(a[b].results));
                        m.resolve(d)
                    }).otherwise(function(a) {
                        m.reject(a)
                    }) : m.resolve(this._filterByExtent(h,
                        B))
                } else m.resolve([]);
                m.then(function(d) {
                    var h = [];
                    if (-1 !== k.indexOf(b, 2)) {
                        var m = a.objectIds;
                        for (g = m.length; g--;) {
                            var p = e._getFeature(m[g]);
                            p && h.push(p)
                        }
                        h = w(d, h)
                    } else h = d; - 1 !== k.indexOf(b, 3) && l.timeInfo && (d = a.timeExtent, h = l._filterByTime(0 < h.length ? h : l.graphics, d.startTime, d.endTime).match);
                    c && (h = k.map(h, function(a) {
                        return a.attributes[f]
                    }, this));
                    n.resolve(h)
                });
                return n
            },
            _getFromIndex: function(a, b) {
                b = b || this.spatialIndex || this._map.spatialIndex;
                a instanceof Array || (a = [a]);
                var c = this.id;
                return X(k.map(a,
                    function(a) {
                        return b.intersects(a, c)
                    }))
            },
            _filterByExtent: function(a, b) {
                for (var c = [], d = 0, e = a.length; d < e; d++) {
                    var f = a[d],
                        l = f.geometry;
                    l && (this.normalization && b.length ? (b[0].intersects(l) || b[1].intersects(l)) && c.push(f) : b.intersects(l) && c.push(f))
                }
                return c
            },
            _filterByTime: function(a, b, c) {
                var d = this._startTimeField,
                    e = this._endTimeField,
                    f;
                this._twoTimeFields || (f = d || e);
                var l = r.isDefined,
                    g = [],
                    h = [],
                    n, m = a.length,
                    k, p;
                b = b ? b.getTime() : -Infinity;
                c = c ? c.getTime() : Infinity;
                if (f)
                    for (n = 0; n < m; n++) k = a[n], p = k.attributes,
                        d = p[f], d >= b && d <= c ? g.push(k) : h.push(k);
                else
                    for (n = 0; n < m; n++) k = a[n], p = k.attributes, f = p[d], p = p[e], f = l(f) ? f : -Infinity, p = l(p) ? p : Infinity, f >= b && f <= c || p >= b && p <= c || b >= f && c <= p ? g.push(k) : h.push(k);
                return {
                    match: g,
                    noMatch: h
                }
            },
            _resolve: function(a, b, c, d, e) {
                b && this[b].apply(this, a);
                c && c.apply(null, a);
                d && A._resDfd(d, a, e)
            },
            _getShallowClone: function(a) {
                var b = new J,
                    c;
                for (c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
                return b
            },
            _query: function(a, b, c, d, e) {
                var f = this,
                    l = this._map,
                    g = new u(A._dfdCanceller),
                    h = c,
                    k = function(c, e) {
                        if (!e &&
                            ("execute" === a || "executeRelationshipQuery" === a)) {
                            var h, l;
                            if ("execute" === a) {
                                h = c.features;
                                l = h.length;
                                for (l -= 1; 0 <= l; l--)
                                    if (h[l]._layer = f, !f._isTable) {
                                        var k = f._mode._getFeature(h[l].attributes[f.objectIdField]);
                                        k && h.splice(l, 1, k)
                                    }
                            } else
                                for (k in c)
                                    if (c.hasOwnProperty(k)) {
                                        h = c[k].features;
                                        l = h.length;
                                        for (l -= 1; 0 <= l; l--) h[l]._layer = f
                                    }
                        }
                        f._resolve([c], b, d, g)
                    };
                if ("executeRelationshipQuery" !== a) {
                    h = this._getShallowClone(c);
                    h.outFields = this.getOutFields();
                    h.returnGeometry = c.hasOwnProperty("returnGeometry") ? c.returnGeometry :
                        !c.outStatistics;
                    h.returnGeometry && (h.multipatchOption = this.multipatchOption);
                    var m;
                    l && (h.outSpatialReference = new I(l.spatialReference.toJson()));
                    if (!this._applyQueryFilters(h, "execute" === a && !h.outStatistics)) {
                        switch (a) {
                            case "execute":
                                m = new K({
                                    features: []
                                });
                                break;
                            case "executeForIds":
                                m = [];
                                break;
                            case "executeForCount":
                                m = 0;
                                break;
                            case "executeForExtent":
                                m = {}
                        }
                        k(m, !0);
                        return g
                    }
                    if (c = "executeForExtent" !== a && this._canDoClientSideQuery(h)) return g._pendingDfd = N(this._doQuery(h, c, "executeForIds" === a || "executeForCount" ===
                        a)), g._pendingDfd.then(function(b) {
                        switch (a) {
                            case "execute":
                                m = new K;
                                m.features = b;
                                break;
                            case "executeForIds":
                                m = b;
                                break;
                            case "executeForCount":
                                m = b.length
                        }
                        k(m, !0)
                    }), g
                }
                if (this._collection) return this._resolve([Error("FeatureLayer::_query - " + this.invalidParams)], null, e, g, !0), g;
                this._ts && (h._ts = (new Date).getTime());
                (g._pendingDfd = this._task[a](h)).addCallbacks(function(a) {
                    k(a, !!h.outStatistics)
                }, function(a) {
                    f._resolve([a], null, e, g, !0)
                });
                return g
            },
            _convertFeaturesToJson: function(a, b, c, d) {
                var e = [],
                    f = this._selectionSymbol,
                    l = this.visibilityField,
                    g, h = this.objectIdField;
                if (this.loaded && (c || d)) g = k.filter(this.fields, function(a) {
                    return !1 === a.editable && (!d || a.name !== h)
                });
                for (c = 0; c < a.length; c++) {
                    var n = a[c],
                        m = {},
                        r = n.geometry,
                        p = n.attributes,
                        s = n.symbol;
                    if (r && (!d || !this.loaded || this.allowGeometryUpdates)) m.geometry = r.toJson();
                    l ? (m.attributes = p = q.mixin({}, p), p[l] = n.visible ? 1 : 0) : p && (m.attributes = q.mixin({}, p));
                    m.attributes && (g && g.length) && k.forEach(g, function(a) {
                        delete m.attributes[a.name]
                    });
                    s && s !== f && (m.symbol = s.toJson());
                    e.push(m)
                }
                return b ?
                    e : F.toJson(e)
            },
            _selectHandler: function(a, b, c, d, e) {
                var f;
                d = t;
                switch (b) {
                    case d.SELECTION_NEW:
                        this.clearSelection(!0);
                        f = !0;
                        break;
                    case d.SELECTION_ADD:
                        f = !0;
                        break;
                    case d.SELECTION_SUBTRACT:
                        f = !1
                }
                d = a.features;
                var l = this._mode,
                    g = [],
                    h = this.objectIdField,
                    k, m;
                if (f)
                    for (f = 0; f < d.length; f++) k = d[f], m = k.attributes[h], k = l._addFeatureIIf(m, k), g.push(k), this._selectFeatureIIf(m, k, l);
                else
                    for (f = 0; f < d.length; f++) k = d[f], m = k.attributes[h], this._unSelectFeatureIIf(m, l), m = l._removeFeatureIIf(m), g.push(m || k);
                this._isSelOnly &&
                    l._applyTimeFilter(!0);
                this._resolve([g, b, a.exceededTransferLimit ? {
                    queryLimitExceeded: !0
                } : null], "onSelectionComplete", c, e);
                if (a.exceededTransferLimit) this.onQueryLimitExceeded()
            },
            _selectFeatureIIf: function(a, b, c) {
                var d = this._selectedFeatures,
                    e = d[a];
                e || (c._incRefCount(a), d[a] = b, this._isTable || (this._setSelectSymbol(b), b.attr("data-selected", "")));
                return e || b
            },
            _unSelectFeatureIIf: function(a, b) {
                var c = this._selectedFeatures[a];
                c && (b._decRefCount(a), delete this._selectedFeatures[a], this._isTable || (this._setUnSelectSymbol(c),
                    c.attr("data-selected")));
                return c
            },
            _isSelected: function(a) {},
            _setSelectSymbol: function(a) {
                var b = this._selectionSymbol;
                b && !this._isSelOnly && a.setSymbol(b)
            },
            _setUnSelectSymbol: function(a) {
                var b = this._selectionSymbol;
                b && !this._isSelOnly && b === a.symbol && a.setSymbol(null, !0)
            },
            _getOutFields: function() {
                var a = [this.objectIdField, this.typeIdField, this.creatorField, this._startTimeField, this._endTimeField, this._trackIdField].concat(this._rendererFields).concat(this.dataAttributes),
                    a = k.filter(a, function(a, b,
                        e) {
                        return !!a && k.indexOf(e, a) === b
                    }),
                    b = q.clone(this._outFields);
                if (b) {
                    if (-1 !== k.indexOf(b, "*")) return b;
                    k.forEach(a, function(a) {
                        -1 === k.indexOf(b, a) && b.push(a)
                    });
                    return b
                }
                return a
            },
            _checkFields: function(a) {
                var b = a || this._getOutFields();
                k.forEach(b, function(a) {
                    "*" !== a && (this._getField(a) || console.debug("esri.layers.FeatureLayer: " + r.substitute({
                        url: this.url,
                        field: a
                    }, "unable to find '${field}' field in the layer 'fields' information [url: ${url}]")))
                }, this);
                !a && (!this._isTable && !this._fserver && !this._collection &&
                    !this._isStream) && (k.some(this.fields, function(a) {
                    return a && "esriFieldTypeGeometry" === a.type ? !0 : !1
                }) || console.debug("esri.layers.FeatureLayer: " + r.substitute({
                    url: this.url
                }, "unable to find a field of type 'esriFieldTypeGeometry' in the layer 'fields' information. If you are using a map service layer, features will not have geometry [url: ${url}]")))
            },
            _fixFieldCase: function(a, b, c) {
                var d = a && a[b],
                    e;
                if (d && !q.isFunction(d)) {
                    if (e = !this._getField(d) && this._getField(d, !0)) d = a[b] = e.name;
                    c && c.push(d)
                }
                return d
            },
            _fixRendererFields: function() {
                var a = this.renderer;
                this._orderBy = null;
                if (a && 0 < this.fields.length) {
                    var b = [],
                        c, a = k.filter([a, a.observationRenderer, a.latestObservationRenderer, a.trackRenderer], r.isDefined),
                        d = [].concat(a);
                    k.forEach(a, function(a) {
                        k.forEach(a.rendererInfos, function(a) {
                            a.renderer && d.push(a.renderer)
                        })
                    });
                    k.forEach(d, function(a) {
                        this._fixFieldCase(a, "attributeField", b);
                        this._fixFieldCase(a, "attributeField2", b);
                        this._fixFieldCase(a, "attributeField3", b);
                        this._fixFieldCase(a.rotationInfo, "field",
                            b);
                        if ((c = this._fixFieldCase(a.sizeInfo, "field", b)) && !this._orderBy) this._orderBy = [c + " DESC"];
                        this._fixFieldCase(a.sizeInfo, "normalizationField", b);
                        this._fixFieldCase(a.colorInfo, "field", b);
                        this._fixFieldCase(a.colorInfo, "normalizationField", b);
                        this._fixFieldCase(a.field, "field", b);
                        this._fixFieldCase(a.opacityInfo, "field", b);
                        this._fixFieldCase(a.opacityInfo, "normalizationField", b);
                        k.forEach(a.visualVariables, function(a) {
                            c = this._fixFieldCase(a, "field", b);
                            "sizeInfo" === a.type && (c && !this._orderBy) && (this._orderBy = [c + " DESC"]);
                            this._fixFieldCase(a, "normalizationField", b)
                        }, this);
                        if (!this._orderBy && a.addBreak && !q.isFunction(a.attributeField) && (a.backgroundFillSymbol || this._hasSizeDiff(a))) this._orderBy = [a.attributeField + " DESC"]
                    }, this);
                    this._rendererFields = k.filter(b, r.isDefined)
                }
            },
            _hasSizeDiff: function(a) {
                var b = Number.MAX_VALUE,
                    c = -Number.MAX_VALUE,
                    d, e;
                k.forEach(a.infos, function(a) {
                    if (e = a.symbol) {
                        d = 0;
                        switch (e.type) {
                            case "simplemarkersymbol":
                                d = e.size;
                                break;
                            case "picturemarkersymbol":
                                d = (e.width + e.height) / 2;
                                break;
                            case "simplelinesymbol":
                            case "cartographiclinesymbol":
                                d = e.width;
                                break;
                            case "simplefillsymbol":
                            case "picturefillsymbol":
                                d = e.outline && e.outline.width
                        }
                        d && (b = Math.min(b, d), c = Math.max(c, d))
                    }
                });
                return b !== Number.MAX_VALUE && c !== -Number.MAX_VALUE && 1 < Math.abs(c - b)
            },
            getOrderByFields: function() {
                var a = this.orderByFields || this._orderBy;
                return this.supportsAdvancedQueries && a ? k.filter(a, function(a) {
                    a = a.split(" ")[0];
                    return !!this._getField(a, !0)
                }, this) : null
            },
            _getField: function(a, b) {
                var c = this.fields;
                if (!c || 0 === c.length) return null;
                var d;
                b && (a = a.toLowerCase());
                k.some(c, function(c) {
                    var f = !1;
                    (f = b ? c && c.name.toLowerCase() === a ? !0 : !1 : c && c.name === a ? !0 : !1) && (d = c);
                    return f
                });
                return d
            },
            _getDateOpts: function() {
                this._dtOpts || (this._dtOpts = {
                    properties: k.map(k.filter(this.fields, function(a) {
                        return !!(a && "esriFieldTypeDate" === a.type)
                    }), function(a) {
                        return a.name
                    })
                });
                return this._dtOpts
            },
            _applyNormalized: function(a, b) {
                a && b && k.forEach(a, function(a, d) {
                    a && b[d] && a.setGeometry(b[d])
                })
            },
            _editHandler: function(a, b, c, d, e, f) {
                e = a.addResults;
                var l = a.updateResults;
                a = a.deleteResults;
                var g, h, n, m, q = this.objectIdField,
                    p = this._mode,
                    s = this._isTable;
                g = this.editFieldsInfo;
                var r = this.getOutFields() || [],
                    x = g && g.creatorField,
                    v = g && g.creationDateField,
                    y = g && g.editorField,
                    z = g && g.editDateField;
                g = g && g.realm; - 1 === k.indexOf(r, "*") && (x && -1 === k.indexOf(r, x) && (x = null), v && -1 === k.indexOf(r, v) && (v = null), y && -1 === k.indexOf(r, y) && (y = null), z && -1 === k.indexOf(r, z) && (z = null));
                var r = v || z ? (new Date).getTime() : null,
                    u = x || y ? this.getUserId() : void 0;
                u && g && (u = u + "@" + g);
                if (e)
                    for (g = 0; g < e.length; g++) e[g] =
                        new E(e[g]), s || (h = e[g], h.success && (h = h.objectId, n = b[g], (m = n._graphicsLayer) && m !== this && m.remove(n), m = n.attributes || {}, m[q] = h, x && (m[x] = u), y && (m[y] = u), v && (m[v] = r), z && (m[z] = r), n.setAttributes(m), p._init && p.drawFeature(n)));
                if (l)
                    for (g = 0; g < l.length; g++)
                        if (l[g] = new E(l[g]), !s && (h = l[g], h.success)) {
                            h = h.objectId;
                            n = c[h];
                            if (b = p._getFeature(h)) b.geometry !== n.geometry && b.setGeometry(fa.fromJson(n.geometry.toJson())), this._repaint(b, h);
                            n = b || n;
                            m = n.attributes || {};
                            y && (m[y] = u);
                            z && (m[z] = r);
                            n.setAttributes(m)
                        }
                if (a) {
                    c = [];
                    for (g = 0; g < a.length; g++)
                        if (a[g] = new E(a[g]), !s && (h = a[g], h.success && (h = h.objectId, n = p._getFeature(h)))) this._unSelectFeatureIIf(h, p) && c.push(n), n._count = 0, p._removeFeatureIIf(h);
                    if (0 < c.length) this.onSelectionComplete(c, t.SELECTION_SUBTRACT)
                }
                this._resolve([e, l, a], "onEditsComplete", d, f)
            },
            _sendAttachment: function(a, b, c, d, e) {
                var f = this;
                return D({
                    url: this._url.path + "/" + b + "/" + ("add" === a ? "addAttachment" : "updateAttachment"),
                    form: c,
                    content: q.mixin(this._url.query, {
                        f: "json",
                        token: this._getToken() || void 0
                    }),
                    callbackParamName: "callback.html",
                    handleAs: "json"
                }).addCallback(function(c) {
                    var e = "add" === a ? "onAddAttachmentComplete" : "onUpdateAttachmentComplete";
                    c = new E(c["add" === a ? "addAttachmentResult" : "updateAttachmentResult"]);
                    c.attachmentId = c.objectId;
                    c.objectId = b;
                    f._resolve([c], e, d);
                    return c
                }).addErrback(function(a) {
                    f._resolve([a], null, e, null, !0)
                })
            },
            _repaint: function(a, b, c) {
                b = r.isDefined(b) ? b : a.attributes[this.objectIdField];
                (!(b in this._selectedFeatures) || !this._selectionSymbol) && a.setSymbol(a.symbol, c)
            },
            _getKind: function(a) {
                var b = this._trackManager;
                return b ? b.isLatestObservation(a) ? 1 : 0 : 0
            }
        });
    q.mixin(t, {
        MODE_SNAPSHOT: 0,
        MODE_ONDEMAND: 1,
        MODE_SELECTION: 2,
        SELECTION_NEW: 3,
        SELECTION_ADD: 4,
        SELECTION_SUBTRACT: 5,
        MODE_AUTO: 6,
        MODE_STREAM: 7,
        POPUP_NONE: "esriServerHTMLPopupTypeNone",
        POPUP_HTML_TEXT: "esriServerHTMLPopupTypeAsHTMLText",
        POPUP_URL: "esriServerHTMLPopupTypeAsURL"
    });
    ga._createWrappers(t);
    return t
});
},
'esri/layers/Field':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./RangeDomain", "./CodedValueDomain"], function(c, b, f, g, d, e) {
    return c(null, {
        declaredClass: "esri.layers.Field",
        constructor: function(a) {
            if (a && b.isObject(a) && (this.name = a.name, this.type = a.type, this.alias = a.alias, this.length = a.length, this.editable = a.editable, this.nullable = a.nullable, (a = a.domain) && b.isObject(a))) switch (a.type) {
                case "range":
                    this.domain = new d(a);
                    break;
                case "codedValue":
                    this.domain = new e(a)
            }
        }
    })
});
},
'esri/layers/RangeDomain':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "./Domain"], function(b, c, f, g, d, e) {
    return b([e], {
        declaredClass: "esri.layers.RangeDomain",
        constructor: function(a) {
            a && c.isObject(a) && (this.minValue = a.range[0], this.maxValue = a.range[1])
        },
        toJson: function() {
            var a = this.inherited(arguments);
            a.range = [this.minValue, this.maxValue];
            return d.fixJson(a)
        }
    })
});
},
'esri/layers/Domain':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang"], function(b, c, e, f, d) {
    return b(null, {
        declaredClass: "esri.layers.Domain",
        constructor: function(a) {
            a && c.isObject(a) && (this.name = a.name, this.type = a.type)
        },
        toJson: function() {
            return d.fixJson({
                name: this.name,
                type: this.type
            })
        }
    })
});
},
'esri/layers/CodedValueDomain':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../lang", "./Domain"], function(d, b, e, h, k, f, g) {
    return d([g], {
        declaredClass: "esri.layers.CodedValueDomain",
        constructor: function(a) {
            a && b.isObject(a) && (this.codedValues = a.codedValues)
        },
        getName: function(a) {
            var c;
            e.some(this.codedValues, function(b) {
                b.code == a && (c = b.name);
                return !!c
            });
            return c
        },
        toJson: function() {
            var a = this.inherited(arguments);
            a.codedValues = b.clone(this.codedValues);
            return f.fixJson(a)
        }
    })
});
},
'esri/layers/FeatureType':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../lang", "../symbols/jsonUtils", "./RangeDomain", "./CodedValueDomain", "./InheritedDomain", "./FeatureTemplate"], function(g, h, k, s, t, l, m, n, p, q, r) {
    return g(null, {
        declaredClass: "esri.layers.FeatureType",
        constructor: function(a) {
            if (a && h.isObject(a)) {
                this.id = a.id;
                this.name = a.name;
                var c = a.symbol;
                c && (this.symbol = m.fromJson(c));
                var c = a.domains,
                    b, e = this.domains = {};
                for (b in c)
                    if (c.hasOwnProperty(b)) {
                        var d = c[b];
                        switch (d.type) {
                            case "range":
                                e[b] =
                                    new n(d);
                                break;
                            case "codedValue":
                                e[b] = new p(d);
                                break;
                            case "inherited":
                                e[b] = new q(d)
                        }
                    }
                if (b = a.templates) {
                    c = this.templates = [];
                    for (a = 0; a < b.length; a++) c.push(new r(b[a]))
                }
            }
        },
        toJson: function() {
            var a = {
                    id: this.id,
                    name: this.name,
                    symbol: this.symbol && this.symbol.toJson()
                },
                c, b = this.domains,
                e = this.templates,
                d = l.fixJson;
            if (b) {
                var f = a.domains = {};
                for (c in b) b.hasOwnProperty(c) && (f[c] = b[c] && b[c].toJson());
                d(f)
            }
            e && (a.templates = k.map(e, function(a) {
                return a.toJson()
            }));
            return d(a)
        }
    })
});
},
'esri/layers/InheritedDomain':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./Domain"], function(a, c, d, e, b) {
    return a([b], {
        declaredClass: "esri.layers.InheritedDomain"
    })
});
},
'esri/layers/FeatureTemplate':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../lang", "../graphic"], function(b, c, f, g, d, e) {
    b = b(null, {
        declaredClass: "esri.layers.FeatureTemplate",
        constructor: function(a) {
            a && c.isObject(a) && (this.name = a.name, this.description = a.description, this.drawingTool = a.drawingTool, a = a.prototype, this.prototype = new e(a.geometry, null, a.attributes))
        },
        toJson: function() {
            return d.fixJson({
                name: this.name,
                description: this.description,
                drawingTool: this.drawingTool,
                prototype: this.prototype && this.prototype.toJson()
            })
        }
    });
    c.mixin(b, {
        TOOL_AUTO_COMPLETE_POLYGON: "esriFeatureEditToolAutoCompletePolygon",
        TOOL_CIRCLE: "esriFeatureEditToolCircle",
        TOOL_ELLIPSE: "esriFeatureEditToolEllipse",
        TOOL_FREEHAND: "esriFeatureEditToolFreehand",
        TOOL_LINE: "esriFeatureEditToolLine",
        TOOL_NONE: "esriFeatureEditToolNone",
        TOOL_POINT: "esriFeatureEditToolPoint",
        TOOL_POLYGON: "esriFeatureEditToolPolygon",
        TOOL_RECTANGLE: "esriFeatureEditToolRectangle",
        TOOL_ARROW: "esriFeatureEditToolArrow",
        TOOL_TRIANGLE: "esriFeatureEditToolTriangle",
        TOOL_LEFT_ARROW: "esriFeatureEditToolLeftArrow",
        TOOL_RIGHT_ARROW: "esriFeatureEditToolRightArrow",
        TOOL_UP_ARROW: "esriFeatureEditToolUpArrow",
        TOOL_DOWN_ARROW: "esriFeatureEditToolDownArrow"
    });
    return b
});
},
'esri/layers/FeatureEditResult':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel"], function(b, c, d, e) {
    return b(null, {
        declaredClass: "esri.layers.FeatureEditResult",
        constructor: function(a) {
            a && c.isObject(a) && (this.objectId = a.objectId, this.success = a.success, a.success || (a = a.error, this.error = Error(), this.error.code = a.code, this.error.message = a.description))
        }
    })
});
},
'esri/layers/LabelClass':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "dojox/gfx/_base", "../kernel", "../lang", "../symbols/TextSymbol", "../symbols/ShieldLabelSymbol"], function(e, c, h, b, k, d, f, g) {
    return e(null, {
        declaredClass: "esri.layers.LabelClass",
        labelPlacement: null,
        labelExpression: null,
        useCodedValues: null,
        symbol: null,
        maxScale: 0,
        minScale: 0,
        where: null,
        sizeInfo: null,
        _labelPlacementLookup: {
            "above-center": "esriServerPointLabelPlacementAboveCenter",
            "above-left": "esriServerPointLabelPlacementAboveLeft",
            "above-right": "esriServerPointLabelPlacementAboveRight",
            "below-center": "esriServerPointLabelPlacementBelowCenter",
            "below-left": "esriServerPointLabelPlacementBelowLeft",
            "below-right": "esriServerPointLabelPlacementBelowRight",
            "center-center": "esriServerPointLabelPlacementCenterCenter",
            "center-left": "esriServerPointLabelPlacementCenterLeft",
            "center-right": "esriServerPointLabelPlacementCenterRight",
            "above-after": "esriServerLinePlacementAboveAfter",
            "above-along": "esriServerLinePlacementAboveAlong",
            "above-before": "esriServerLinePlacementAboveBefore",
            "above-start": "esriServerLinePlacementAboveStart",
            "above-end": "esriServerLinePlacementAboveEnd",
            "below-after": "esriServerLinePlacementBelowAfter",
            "below-along": "esriServerLinePlacementBelowAlong",
            "below-before": "esriServerLinePlacementBelowBefore",
            "below-start": "esriServerLinePlacementBelowStart",
            "below-end": "esriServerLinePlacementBelowEnd",
            "center-after": "esriServerLinePlacementCenterAfter",
            "center-along": "esriServerLinePlacementCenterAlong",
            "center-before": "esriServerLinePlacementCenterBefore",
            "center-start": "esriServerLinePlacementCenterStart",
            "center-end": "esriServerLinePlacementCenterEnd",
            "always-horizontal": "esriServerPolygonPlacementAlwaysHorizontal"
        },
        constructor: function(a) {
            if (a && (c.mixin(this, a), this._labelPlacementLookup.hasOwnProperty(this.labelPlacement) || (this.labelPlacement = d.valueOf(this._labelPlacementLookup, a.labelPlacement)), a.symbol && (this.symbol = "esriSHD" === a.symbol.type ? new g(a.symbol) : new f(a.symbol)), a = this.sizeInfo)) a.minSize && (a.minSize = b.pt2px(a.minSize)), a.maxSize && (a.maxSize = b.pt2px(a.maxSize))
        },
        getSymbol: function() {
            return this.symbol
        },
        toJson: function() {
            var a = this.sizeInfo;
            a && (a = c.mixin({}, a), a.minSize && (a.minSize = b.px2pt(a.minSize)), a.maxSize && (a.maxSize = b.px2pt(a.maxSize)));
            a = {
                labelExpression: this.labelExpression,
                labelExpressionInfo: this.labelExpressionInfo && c.clone(this.labelExpressionInfo),
                useCodedValues: this.useCodedValues,
                maxScale: this.maxScale,
                minScale: this.minScale,
                where: this.where,
                sizeInfo: a,
                labelPlacement: this._labelPlacementLookup.hasOwnProperty(this.labelPlacement) ? this._labelPlacementLookup[this.labelPlacement] : this.labelPlacement,
                symbol: this.symbol && this.symbol.toJson()
            };
            return d.fixJson(a)
        }
    })
});
},
'esri/symbols/ShieldLabelSymbol':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/sniff", "dojox/gfx/_base", "../kernel", "../lang", "../urlUtils", "./MarkerSymbol", "./Font"], function(c, f, k, e, q, l, m, n, p) {
    var g = {
        url: "",
        width: 12,
        height: 12,
        angle: 0,
        xoffset: 0,
        yoffset: 0
    };
    c = c(n, {
        declaredClass: "esri.symbol.ShieldLabelSymbol",
        type: "shieldlabelsymbol",
        color: [255, 255, 255, 1],
        width: 32,
        height: 32,
        font: e.defaultFont,
        constructor: function(a, b, d, h, c) {
            a ? f.isString(a) ? (this.url = a, b && (this.color = b), d && (this.width = d), h && (this.height = h), void 0 !== c && (this.font = c)) :
                (this.width = e.pt2px(a.width), this.height = e.pt2px(a.height), b = a.imageData, !(9 > k("ie")) && b && (d = this.url, this.url = "data:" + (a.contentType || "image") + ";base64," + b, this.imageData = d)) : f.mixin(this, g)
        },
        getStroke: function() {
            return null
        },
        getFill: function() {
            return this.color
        },
        setWidth: function(a) {
            this.width = a;
            return this
        },
        setHeight: function(a) {
            this.height = a;
            return this
        },
        setUrl: function(a) {
            a !== this.url && (delete this.imageData, delete this.contentType);
            this.url = a;
            return this
        },
        setFont: function(a) {
            this.font = a;
            return this
        },
        setText: function(a) {
            this.text = a;
            return this
        },
        getWidth: function() {
            return this.width
        },
        getHeight: function() {
            return this.height
        },
        getShapeDescriptors: function() {
            return {
                defaultShape: {
                    type: "image",
                    x: -Math.round(this.width / 2),
                    y: -Math.round(this.height / 2),
                    width: this.width,
                    height: this.height,
                    src: this.url || ""
                },
                fill: null,
                stroke: null
            }
        },
        toJson: function() {
            var a = this.url,
                b = this.imageData;
            if (0 === a.indexOf("data:")) var d = a,
                a = b,
                b = d.indexOf(";base64,") + 8,
                b = d.substr(b);
            var a = m.getAbsoluteUrl(a),
                d = e.px2pt(this.width),
                d = isNaN(d) ? void 0 : d,
                c = e.px2pt(this.height),
                c = isNaN(c) ? void 0 : c,
                a = l.fixJson(f.mixin(this.inherited("toJson", arguments), {
                    type: "esriSHD",
                    url: a,
                    imageData: b,
                    contentType: this.contentType,
                    width: d,
                    height: c
                }));
            this.font ? (b = new p(this.font), a.font = b.toJson()) : a.font = null;
            delete a.size;
            a.imageData || delete a.imageData;
            return a
        }
    });
    c.defaultProps = g;
    return c
});
},
'esri/layers/SnapshotMode':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../SpatialReference", "../tasks/query", "./RenderMode"], function(l, e, q, r, m, n, p) {
    return l([p], {
        declaredClass: "esri.layers._SnapshotMode",
        constructor: function(a) {
            this.featureLayer = a;
            this.pagination = a.queryPagination;
            this._featureMap = {};
            this._drawFeatures = e.hitch(this, this._drawFeatures);
            this._queryErrorHandler = e.hitch(this, this._queryErrorHandler)
        },
        startup: function() {
            this.pagination = this.pagination && null != this.featureLayer.maxRecordCount;
            this.featureLayer._collection ? this._applyTimeFilter() : this._fetchAll()
        },
        propertyChangeHandler: function(a) {
            this._init && (a ? this.featureLayer._collection ? console.log("FeatureLayer: layer created by value (from a feature collection) does not support definition expressions and time definitions. Layer id \x3d " + this.featureLayer.id) : this._fetchAll() : this._applyTimeFilter())
        },
        drawFeature: function(a) {
            var d = a.attributes[this.featureLayer.objectIdField];
            this._addFeatureIIf(d, a);
            this._incRefCount(d)
        },
        resume: function() {
            this.propertyChangeHandler(0)
        },
        refresh: function() {
            var a = this.featureLayer;
            a._collection ? (a._fireUpdateStart(), a._refresh(!0), a._fireUpdateEnd()) : this._fetchAll()
        },
        _getRequestId: function(a) {
            return ("_" + a.name + a.layerId + a._ulid).replace(/[^a-zA-Z0-9\_]+/g, "_")
        },
        _fetchAll: function() {
            var a = this.featureLayer;
            !a._collection && !a.suspended && (a._fireUpdateStart(), this._clearIIf(), this._sendRequest())
        },
        _sendRequest: function(a) {
            var d = this.map,
                b = this.featureLayer,
                g = b.getDefinitionExpression(),
                c = new n;
            c.outFields = b.getOutFields();
            c.where = g ||
                "1\x3d1";
            c.returnGeometry = !0;
            c.outSpatialReference = new m(d.spatialReference.toJson());
            c.timeExtent = b.getTimeDefinition();
            c.maxAllowableOffset = b._maxOffset;
            c.quantizationParameters = b._quantizationParameters;
            b._ts && (c._ts = (new Date).getTime());
            c.orderByFields = b.supportsAdvancedQueries ? b.getOrderByFields() : null;
            c.multipatchOption = b.multipatchOption;
            this.pagination && (this._start = c.start = null == a ? 0 : a, c.num = b.maxRecordCount);
            var f;
            b._usePatch && (f = this._getRequestId(b), this._cancelPendingRequest(null, f));
            b._task.execute(c, this._drawFeatures, this._queryErrorHandler, f)
        },
        _drawFeatures: function(a) {
            this._purgeRequests();
            var d = a.features,
                b = this.featureLayer,
                g = b.objectIdField,
                c, f = d.length,
                e = a.exceededTransferLimit && !b._collection,
                h, k;
            for (c = 0; c < f; c++) h = d[c], k = h.attributes[g], this._addFeatureIIf(k, h), this._incRefCount(k);
            this._applyTimeFilter(!0);
            if (!this.pagination || !e) b._fireUpdateEnd(null, a.exceededTransferLimit ? {
                queryLimitExceeded: !0
            } : null);
            e && (this.pagination && this._sendRequest(this._start + b.maxRecordCount),
                b.onQueryLimitExceeded())
        },
        _queryErrorHandler: function(a) {
            this._purgeRequests();
            var d = this.featureLayer;
            d._errorHandler(a);
            d._fireUpdateEnd(a)
        }
    })
});
},
'esri/layers/RenderMode':function(){
//>>built
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "dojo/io/script", "../kernel"], function(l, m, n, h, p, f, q) {
    return m(null, {
        declaredClass: "esri.layers._RenderMode",
        constructor: function() {
            this._prefix = "jsonp_" + (l._scopeName || "dojo") + "IoScript"
        },
        initialize: function(a) {
            this.map = a;
            this._init = !0
        },
        startup: function() {},
        propertyChangeHandler: function(a) {},
        destroy: function() {
            this._init = !1
        },
        drawFeature: function(a) {},
        suspend: function() {},
        resume: function() {},
        refresh: function() {},
        _incRefCount: function(a) {
            (a = this._featureMap[a]) && a._count++
        },
        _decRefCount: function(a) {
            (a = this._featureMap[a]) && a._count--
        },
        _getFeature: function(a) {
            return this._featureMap[a]
        },
        _addFeatureIIf: function(a, b) {
            var c = this._featureMap,
                e = c[a],
                d = this.featureLayer;
            e || (c[a] = b, d._add(b), b._count = 0);
            return e || b
        },
        _removeFeatureIIf: function(a) {
            var b = this._featureMap[a],
                c = this.featureLayer;
            if (b) {
                if (b._count) return;
                delete this._featureMap[a];
                c._remove(b)
            }
            return b
        },
        _clearIIf: function() {
            var a;
            a = this.featureLayer;
            var b =
                a.graphics,
                c = a._selectedFeatures,
                e = a.objectIdField;
            for (a = b.length - 1; 0 <= a; a--) {
                var d = b[a],
                    g = d.attributes[e];
                g in c ? d._count = 1 : (d._count = 0, this._removeFeatureIIf(g))
            }
        },
        _isPending: function(a) {
            return f[this._prefix + a] ? !0 : !1
        },
        _cancelPendingRequest: function(a, b) {
            if (a = a || f[this._prefix + b]) try {
                a.cancel(), f._validCheck(a)
            } catch (c) {}
        },
        _purgeRequests: function() {
            f._validCheck(null)
        },
        _toggleVisibility: function(a) {
            var b = this.featureLayer,
                c = b.graphics,
                e = a ? "show" : "hide",
                d, g = c.length;
            a = a && b._ager;
            for (d = 0; d < g; d++) {
                var k =
                    c[d];
                k[e]();
                a && b._repaint(k)
            }
        },
        _applyTimeFilter: function(a) {
            var b = this.featureLayer;
            if (b.timeInfo && !b.suspended) {
                a || b._fireUpdateStart();
                var c = b._trackManager;
                c && c.clearTracks();
                var e = b.getTimeDefinition(),
                    d = b._getOffsettedTE(b._mapTimeExtent);
                d ? (d = b._getTimeOverlap(e, d)) ? (e = b._filterByTime(b.graphics, d.startTime, d.endTime), c && c.addFeatures(e.match), h.forEach(e.match, function(a) {
                    var c = a._shape;
                    a.visible || (a.show(), (c = a._shape) && c._moveToFront());
                    b._ager && c && b._repaint(a)
                }), h.forEach(e.noMatch, function(a) {
                    a.visible &&
                        a.hide()
                })) : this._toggleVisibility(!1) : (c && c.addFeatures(b.graphics), this._toggleVisibility(!0));
                c && (c.moveLatestToFront(), c.drawTracks());
                a || b._fireUpdateEnd()
            }
        }
    })
});
},
'esri/layers/OnDemandMode':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../geometry/Point", "../tasks/query", "./RenderMode", "./GridLayout"], function(t, m, v, r, z, A, w, u, x, y) {
    return t([x], {
        declaredClass: "esri.layers._OnDemandMode",
        constructor: function(b) {
            this.featureLayer = b;
            this._featureMap = {};
            this._queryErrorHandler = v.hitch(this, this._queryErrorHandler)
        },
        initialize: function(b) {
            this.inherited(arguments);
            var a = this.featureLayer,
                c = a._srInfo;
            this._gridLayer = new y(new w(c ? c.valid[0] :
                b.extent.xmin, b.extent.ymax, b.spatialReference), {
                width: a._tileWidth,
                height: a._tileHeight
            }, {
                width: b.width,
                height: b.height
            }, c);
            this._cellMap = {};
            this._gridLayer.setResolution(b.extent)
        },
        startup: function() {
            this._ioQueue = [];
            this.featureLayer.suspended || (this._zoomHandler(), this._enableConnectors())
        },
        propertyChangeHandler: function(b) {
            this._init && (2 > b ? this._zoomHandler() : console.log("FeatureLayer: layer in on-demand mode does not support time definitions. Layer id \x3d " + this.featureLayer.id + ", Layer URL \x3d " +
                this.featureLayer.url))
        },
        destroy: function() {
            this._disableConnectors();
            this.inherited(arguments)
        },
        drawFeature: function(b) {
            var a = this._gridLayer,
                c = b.geometry,
                e = [];
            if (c)
                for (var e = a.getCellsInExtent("point" === c.type ? {
                        xmin: c.x,
                        ymin: c.y,
                        xmax: c.x,
                        ymax: c.y
                    } : c.getExtent(), !1).cells, a = this._cellMap, d, g = b.attributes[this.featureLayer.objectIdField], f, h, k, c = 0; c < e.length; c++) d = e[c], f = d.latticeID, h = d.row, k = d.col, f ? d = a[f] = a[f] || d : (a[h] = a[h] || {}, d = a[h][k] = a[h][k] || d), d.features = d.features || [], d.features.push(b),
                    this._addFeatureIIf(g, b), this._incRefCount(g)
        },
        suspend: function() {
            this._init && this._disableConnectors()
        },
        resume: function() {
            this._init && (this._enableConnectors(), this._zoomHandler())
        },
        refresh: function() {
            this._zoomHandler()
        },
        _enableConnectors: function() {
            var b = this.map;
            this._zoomConnect = m.connect(b, "onZoomEnd", this, this._zoomHandler);
            this._panConnect = m.connect(b, "onPanEnd", this, this._panHandler);
            this._resizeConnect = m.connect(b, "onResize", this, this._panHandler)
        },
        _disableConnectors: function() {
            m.disconnect(this._zoomConnect);
            m.disconnect(this._panConnect);
            m.disconnect(this._resizeConnect)
        },
        _zoomHandler: function() {
            this._processIOQueue(!0);
            var b = this.featureLayer,
                a = this.map;
            b.suspended || (b._fireUpdateStart(), this._clearIIf(), (b = b._trackManager) && b.clearTracks(), this._cellMap = {}, this._gridLayer.setResolution(a.extent), this._sendRequest())
        },
        _panHandler: function(b) {
            this.featureLayer._fireUpdateStart();
            this._sendRequest(this.featureLayer._resized && b)
        },
        _getRequestId: function(b, a) {
            return ("_" + b.name + b.layerId + b._ulid + "_" + a.resolution +
                "_" + (a.latticeID || a.row + "_" + a.col)).replace(/[^a-zA-Z0-9\_]+/g, "_")
        },
        _sendRequest: function(b) {
            this._exceeds = !1;
            var a = this.featureLayer,
                c = this.map;
            b = b || c.extent;
            c = this._gridLayer.getCellsInExtent(b, a.latticeTiling).cells;
            if (!a.isEditable()) var e = this._cellMap,
                c = r.filter(c, function(a) {
                    if (a.lattice) {
                        if (e[a.latticeID]) return !1
                    } else if (e[a.row] && e[a.row][a.col]) return !1;
                    return !0
                });
            var d = a.getOutFields(),
                g = a.getDefinitionExpression(),
                f = a._getOffsettedTE(a._mapTimeExtent),
                h = a.supportsAdvancedQueries ? a.getOrderByFields() :
                null,
                k = a._usePatch,
                p = this._ioQueue,
                n, m = this,
                t = this._drawFeatures,
                q, l, s;
            this._pending = this._pending || 0;
            for (n = 0; n < c.length; n++) {
                q = c[n];
                l = new u;
                l.geometry = q.extent || q.lattice;
                l.outFields = d;
                l.where = g;
                a.latticeTiling && q.extent && (l.spatialRelationship = u.SPATIAL_REL_CONTAINS);
                l.returnGeometry = !0;
                l.timeExtent = f;
                a._ts && (l._ts = (new Date).getTime());
                l.orderByFields = h;
                l.multipatchOption = a.multipatchOption;
                l.maxAllowableOffset = a._maxOffset;
                l.quantizationParameters = a._quantizationParameters;
                s = null;
                if (k && (s = this._getRequestId(a,
                        q), this._isPending(s))) continue;
                this._pending++;
                p.push(a._task.execute(l, function() {
                    var a = q;
                    return function(b) {
                        t.apply(m, [b, a])
                    }
                }.call(this), this._queryErrorHandler, s))
            }
            this._removeOldCells(b);
            this._endCheck()
        },
        _drawFeatures: function(b, a) {
            this._exceeds = this._exceeds || b.exceededTransferLimit;
            this._finalizeIO();
            var c = this.map.extent,
                e = a.extent,
                d = a.row,
                g = a.col,
                f = this.featureLayer.objectIdField,
                h = b.features,
                k = this._gridLayer,
                p = this._cellMap,
                n = a.latticeID,
                m = n ? p[n] : p[d] && p[d][g];
            if (a.resolution != k._resolution ||
                (n ? n !== k.getLatticeID(c) : !k.intersects(e, c))) m && this._removeCell(d, g, n);
            else if (m) this._updateCell(m, h);
            else {
                a.features = h;
                n ? p[n] = a : (p[d] = p[d] || {}, p[d][g] = a);
                e = h.length;
                for (c = 0; c < e; c++) d = h[c], g = d.attributes[f], this._addFeatureIIf(g, d), this._incRefCount(g)
            }
            this._endCheck()
        },
        _queryErrorHandler: function(b) {
            this._finalizeIO();
            this.featureLayer._errorHandler(b);
            this._endCheck(!0)
        },
        _finalizeIO: function() {
            this._purgeRequests();
            this._pending--
        },
        _endCheck: function(b) {
            if (0 === this._pending) {
                this._processIOQueue();
                var a = this.featureLayer,
                    c = a._trackManager;
                c && (c.clearTracks(), c.addFeatures(a.graphics), a._ager && r.forEach(a.graphics, function(b) {
                    b._shape && a._repaint(b)
                }), c.moveLatestToFront(), c.drawTracks());
                this.featureLayer._fireUpdateEnd(b && Error("FeatureLayer: an error occurred while updating the layer"), this._exceeds ? {
                    queryLimitExceeded: !0
                } : null);
                if (this._exceeds) a.onQueryLimitExceeded()
            }
        },
        _processIOQueue: function(b) {
            this._ioQueue = r.filter(this._ioQueue, function(a) {
                return -1 < a.fired ? !1 : !0
            });
            b && r.forEach(this._ioQueue,
                this._cancelPendingRequest)
        },
        _removeOldCells: function(b) {
            var a = this._cellMap,
                c = this._gridLayer,
                e, d;
            for (e in a)
                if (a[e]) {
                    var g = a[e],
                        f = g.latticeID,
                        h = 0,
                        k = 0;
                    if (f) h++, f !== c.getLatticeID(b) && (this._removeCell(null, null, f), k++);
                    else
                        for (d in g) g[d] && (h++, c.intersects(g[d].extent, b) || (this._removeCell(e, d), k++));
                    k === h && delete a[e]
                }
        },
        _updateCell: function(b, a) {
            var c = this.featureLayer,
                e = c.objectIdField,
                c = c._selectedFeatures,
                d, g = a.length;
            b.features = b.features || [];
            for (d = 0; d < g; d++) {
                var f = a[d],
                    h = f.attributes[e],
                    k = this._addFeatureIIf(h, f);
                k === f ? (this._incRefCount(h), b.features.push(k)) : h in c || (k.setGeometry(f.geometry), k.setAttributes(f.attributes))
            }
        },
        _removeCell: function(b, a, c) {
            var e = this._cellMap,
                d = this.featureLayer,
                g = d.objectIdField,
                f = c ? e[c] : e[b] && e[b][a];
            if (f) {
                c ? delete e[c] : delete e[b][a];
                b = f.features;
                for (a = 0; a < b.length; a++) c = b[a].attributes[g], this._decRefCount(c), c in d._selectedFeatures || this._removeFeatureIIf(c)
            }
        }
    })
});
},
'esri/layers/GridLayout':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../SpatialReference", "../geometry/Extent", "../geometry/Polyline"], function(t, y, u, z, A, v, w, x) {
    return t(null, {
        declaredClass: "esri.layers._GridLayout",
        constructor: function(a, d, b, e) {
            this.origin = a;
            this.cellWidth = d.width;
            this.cellHeight = d.height;
            this.mapWidth = b.width;
            this.mapHeight = b.height;
            this.srInfo = e
        },
        setResolution: function(a) {
            this._resolution = (a.xmax - a.xmin) / this.mapWidth;
            this.srInfo && (a = Math.round(2 * this.srInfo.valid[1] /
                this._resolution), a = Math.round(a / this.cellWidth), this._frameStats = [a, 0, a - 1])
        },
        getCellCoordinates: function(a) {
            var d = this._resolution,
                b = this.origin;
            return {
                row: Math.floor((b.y - a.y) / (this.cellHeight * d)),
                col: Math.floor((a.x - b.x) / (this.cellWidth * d))
            }
        },
        normalize: function(a) {
            var d = this._frameStats;
            if (d) {
                var b = d[0],
                    e = d[1],
                    d = d[2];
                a < e ? (a %= b, a = a < e ? a + b : a) : a > d && (a %= b)
            }
            return a
        },
        intersects: function(a, d) {
            var b = this.srInfo;
            return b ? u.some(d._getParts(b), function(b) {
                return a.intersects(b.extent)
            }) : a.intersects(d)
        },
        getCellExtent: function(a, d) {
            var b = this._resolution,
                e = this.origin,
                k = this.cellWidth,
                l = this.cellHeight;
            return new w(d * k * b + e.x, e.y - (a + 1) * l * b, (d + 1) * k * b + e.x, e.y - a * l * b, new v(e.spatialReference.toJson()))
        },
        getLatticeID: function(a) {
            var d = this.getCellCoordinates({
                    x: a.xmin,
                    y: a.ymax
                }),
                b = this.getCellCoordinates({
                    x: a.xmax,
                    y: a.ymin
                });
            a = d.row;
            var e = b.row,
                d = this.normalize(d.col),
                b = this.normalize(b.col);
            return a + "_" + e + "_" + d + "_" + b
        },
        sorter: function(a, d) {
            return a < d ? -1 : 1
        },
        getCellsInExtent: function(a, d) {
            var b = this.getCellCoordinates({
                    x: a.xmin,
                    y: a.ymax
                }),
                e = this.getCellCoordinates({
                    x: a.xmax,
                    y: a.ymin
                }),
                k = b.row,
                l = e.row,
                b = b.col,
                e = e.col,
                n = [],
                c, f, m, g = [],
                h = [],
                q, r, s, p = [];
            for (c = k; c <= l; c++)
                for (f = b; f <= e; f++) m = this.normalize(f), a = this.getCellExtent(c, m), n.push({
                    row: c,
                    col: m,
                    extent: a,
                    resolution: this._resolution
                }), d && (g.push(a.xmin, a.xmax), h.push(a.ymin, a.ymax));
            b = this.normalize(b);
            e = this.normalize(e);
            g.sort(this.sorter);
            h.sort(this.sorter);
            f = g.length;
            for (c = f - 1; 0 <= c; c--) c < f - 1 && g[c] === g[c + 1] && g.splice(c, 1);
            f = h.length;
            for (c = f - 1; 0 <= c; c--) c < f - 1 && h[c] === h[c +
                1] && h.splice(c, 1);
            if (g.length && h.length) {
                m = g[0];
                q = g[g.length - 1];
                r = h[0];
                s = h[h.length - 1];
                f = g.length;
                for (c = 0; c < f; c++) p.push([
                    [g[c], s],
                    [g[c], r]
                ]);
                f = h.length;
                for (c = 0; c < f; c++) p.push([
                    [m, h[c]],
                    [q, h[c]]
                ]);
                c = new x({
                    paths: p,
                    spatialReference: this.origin.spatialReference.toJson()
                });
                n.push({
                    latticeID: k + "_" + l + "_" + b + "_" + e,
                    lattice: c,
                    resolution: this._resolution
                })
            }
            return {
                minRow: k,
                maxRow: l,
                minCol: b,
                maxCol: e,
                cells: n
            }
        }
    })
});
},
'esri/layers/SelectionMode':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "./RenderMode"], function(b, d, e, f, c) {
    return b([c], {
        declaredClass: "esri.layers._SelectionMode",
        constructor: function(a) {
            this.featureLayer = a;
            this._featureMap = {}
        },
        propertyChangeHandler: function(a) {
            this._init && 0 === a && this._applyTimeFilter()
        },
        resume: function() {
            this.propertyChangeHandler(0)
        }
    })
});
},
'esri/layers/StreamMode':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../SpatialReference", "../tasks/query", "../tasks/QueryTask", "../geometry/jsonUtils", "./RenderMode"], function(n, m, k, u, v, p, q, r, s, t) {
    return n([t], {
        declaredClass: "esri.layers._StreamMode",
        constructor: function(a, b) {
            this.featureLayer = a;
            this._featureMap = {};
            this._setRefreshRate();
            this._drawBuffer = {
                adds: [],
                updates: []
            };
            this._timeoutId = null;
            this._flushDrawBuffer = m.hitch(this, this._flushDrawBuffer);
            this._featuresByTime = {};
            this._lastEndTimeCheck =
                null;
            this._drawFeatures = m.hitch(this, this._drawFeatures);
            this._queryErrorHandler = m.hitch(this, this._queryErrorHandler)
        },
        startup: function() {},
        propertyChangeHandler: function(a) {
            this._init && (0 === a ? this._applyTimeFilter() : 3 === a ? this._redrawAllTracks() : console.debug("StreamLayer: Stream Layer only supports changing map time or maximumTrackPoints. Layer id \x3d " + this.featureLayer.id))
        },
        drawFeature: function(a) {
            var b = this.featureLayer,
                c = b.objectIdField;
            this._timeoutId || (this._timeoutId = setTimeout(this._flushDrawBuffer,
                this._refreshRate));
            b._joinField && this._getFeature(a.attributes[c]) ? this._drawBuffer.updates.push({
                oid: a.attributes[c],
                updates: a
            }) : this._drawBuffer.adds.push(a)
        },
        resume: function() {
            this.propertyChangeHandler(0)
        },
        refresh: function() {
            var a = this.featureLayer;
            a && (a._fireUpdateStart(), this._flushDrawBuffer())
        },
        _drawFeatures: function(a) {
            this._purgeRequests();
            var b = this.featureLayer;
            b._create(a.features || []);
            b._fireUpdateEnd(null, null)
        },
        _applyTimeFilter: function(a) {
            this.inherited(arguments);
            this._redrawAllTracks()
        },
        _removeFeatures: function(a) {
            var b = this.featureLayer,
                c = b.objectIdField;
            a && k.forEach(a, function(a) {
                a = a.attributes[c];
                b._unSelectFeatureIIf(a, this);
                this._decRefCount(a);
                this._removeFeatureIIf(a)
            }, this)
        },
        _addFeatures: function(a) {
            var b = this.featureLayer,
                c = b._endTimeField,
                f, d, e, g = [],
                h = [],
                l = [];
            f = b._trackManager;
            d = b.objectIdField;
            if (f)
                for (e in a = f.addFeatures(a), a) a.hasOwnProperty(e) && (g.push(e), a[e].adds && (h = h.concat(a[e].adds)), a[e].deletes && (l = l.concat(a[e].deletes)));
            else h = a;
            k.forEach(h, function(a) {
                var b =
                    a.attributes[d],
                    e;
                if (e = c && a.attributes[c]) e = 1E3 * Math.ceil(e / 1E3), this._featuresByTime[e] ? this._featuresByTime[e].push(b) : this._featuresByTime[e] = [b];
                this._addFeatureIIf(b, a);
                this._incRefCount(b)
            }, this);
            l.length && this._removeFeatures(l);
            f && f.refreshTracks(g)
        },
        _updateFeatures: function(a) {
            var b = this.featureLayer,
                c, f, d = [];
            c = b._trackManager;
            f = b._trackIdField;
            k.forEach(a, function(a) {
                var g = a.updates;
                a = this._getFeature(a.oid);
                var h;
                if (a) {
                    g.geometry && a.setGeometry(g.geometry);
                    g = g.attributes || {};
                    for (h in g) g.hasOwnProperty(h) &&
                        (a.attributes[h] = g[h]);
                    a.visible = this._checkFeatureTimeIntersects(a);
                    c && a.attributes[f] ? d.push(a.attributes[f]) : b._repaint(a, null, !0)
                }
            }, this);
            d.length && c.refreshTracks(d)
        },
        _redrawAllTracks: function() {
            var a = this.featureLayer._trackManager,
                b;
            if (a && (b = a.trimTracks()) && 0 < b.length) this._removeFeatures(b), a.refreshTracks()
        },
        _flushDrawBuffer: function() {
            clearTimeout(this._timeoutId);
            var a = this._drawBuffer,
                b = a.adds.splice(0, a.adds.length),
                c = a.updates.splice(0, a.updates.length),
                a = this.featureLayer;
            if (!a) return !1;
            a.updating || a._fireUpdateStart();
            this._addFeatures(b);
            this._updateFeatures(c);
            if ((b = this._getExpiredFeatures()) && b.length) this._removeFeatures(b), a._trackManager && a._trackManager.removeFeatures(b);
            a._purge();
            a._fireUpdateEnd();
            this._timeoutId = null
        },
        _clearDrawBuffer: function() {
            var a = this._timeoutId,
                b = this._drawBuffer,
                c = b.adds,
                b = b.updates;
            a && clearTimeout(a);
            c.splice(0, c.length);
            b.splice(0, b.length);
            this._timeoutId = null
        },
        _setRefreshRate: function(a) {
            a = a || 0 === a ? a : 200;
            0 > a && (a = 200);
            this._refreshRate = a
        },
        _checkFeatureTimeIntersects: function(a) {
            var b = this.featureLayer,
                c = b.getMap().timeExtent;
            return !c || !b.timeInfo || !b.timeInfo.startTimeField && !b.timeInfo.endTimeField ? !0 : 0 < b._filterByTime([a], c.startTime, c.endTime).match.length
        },
        _getRequestId: function(a) {
            return ("_" + a.name + a.layerId + a._ulid).replace(/[^a-zA-Z0-9\_]+/g, "_")
        },
        _fetchArchive: function(a) {
            var b = this.featureLayer,
                c, f, d, e, g, h;
            b._fireUpdateStart();
            if (a) a = new r(a), c = new q, f = this.map, d = b.getFilter() || {}, e = d.where || "1\x3d1", g = d.geometry ? s.fromJson(d.geometry) :
                null, d = d.outFields ? d.outFields.split(",") : ["*"], c.geometry = g, c.where = e, c.outFields = d, c.returnGeometry = !0, c.outSpatialReference = new p(f.spatialReference.toJson()), b._usePatch && (h = this._getRequestId(b), this._cancelPendingRequest(null, h)), a.execute(c, this._drawFeatures, this._queryErrorHandler, h);
            else return this._fireUpdateEnd({
                error: "No url provided"
            }), !1
        },
        _queryErrorHandler: function(a) {
            this._purgeRequests();
            var b = this.featureLayer;
            b._errorHandler(a);
            b._fireUpdateEnd(a)
        },
        _getExpiredFeatures: function() {
            var a,
                b, c, f = [],
                d = [];
            if (!this.featureLayer._endTimeField) return d;
            a = 1E3 * Math.floor(this._lastEndTimeCheck / 1E3);
            this._lastEndTimeCheck = b = 1E3 * Math.ceil(Date.now() / 1E3);
            if (a && a !== b)
                for (c = this._featuresByTime; a <= b; a += 1E3) c[a] && (f = f.concat(c[a]), delete c[a]);
            k.forEach(f, function(a) {
                (a = this._getFeature(a)) && d.push(a)
            }, this);
            return d
        }
    })
});
},
'esri/layers/TrackManager':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../graphic", "../geometry/Polyline", "./GraphicsLayer"], function(m, r, d, s, t, n, p, q) {
    return m(null, {
        declaredClass: "esri.layers._TrackManager",
        constructor: function(a) {
            this.layer = a;
            this.trackMap = {};
            this.trackLineMap = {}
        },
        initialize: function(a) {
            this.map = a;
            var c = this.layer,
                b = c._getRenderer(),
                b = b && b.trackRenderer;
            if ("esriGeometryPoint" === c.geometryType) {
                var e = this.container = new q._GraphicsLayer({
                    id: c.id + "_tracks",
                    _child: !0
                });
                e.loaded = !0;
                e.onLoad(e);
                e._setMap(a, c._div);
                e.setRenderer(b)
            }
        },
        addFeatures: function(a) {
            var c = this.trackMap,
                b = this.layer,
                e = b._trackIdField,
                f = [];
            d.forEach(a, function(a) {
                var b = a.attributes[e];
                (c[b] = c[b] || []).push(a); - 1 === d.indexOf(f, b) && f.push(b)
            });
            var g = b._startTimeField,
                k = b.objectIdField,
                h = function(b, a) {
                    var c = b.attributes[g],
                        f = a.attributes[g];
                    return c === f ? b.attributes[k] < a.attributes[k] ? -1 : 1 : c < f ? -1 : 1
                };
            d.forEach(f, function(b) {
                c[b].sort(h)
            })
        },
        trimTracks: function(a) {
            function c(a) {
                for (a = b[a] || []; a.length >
                    e;) f.push(a.shift())
            }
            var b = this.trackMap,
                e = this.layer.maximumTrackPoints || 0,
                f = [],
                g;
            if (!e) return f;
            if (a) d.forEach(a, function(a) {
                c(a)
            });
            else
                for (g in b) b.hasOwnProperty(g) && c(g);
            return f
        },
        drawTracks: function(a) {
            function c(a) {
                var c = f[a],
                    h, d, l;
                d = b.trackLineMap[a];
                e.remove(d);
                delete b.trackLineMap[a];
                if (!c || 2 > c.length) return !1;
                d = [];
                for (h = c.length - 1; 0 <= h; h--)(l = c[h].geometry) && d.push([l.x, l.y]);
                c = {};
                c[k] = a;
                1 < d.length && (d = new n(new p({
                    paths: [d],
                    spatialReference: g
                }), null, c), e.add(d), b.trackLineMap[a] = d)
            }
            var b = this,
                e = this.container,
                f, g, k, h;
            if (e)
                if (f = this.trackMap, g = this.map.spatialReference, k = this.layer._trackIdField, a) d.forEach(a, function(a) {
                    c(a)
                });
                else
                    for (h in f) f.hasOwnProperty(h) && c(h)
        },
        refreshTracks: function(a) {
            function c(a) {
                var c, d;
                b.drawTracks([a]);
                if (g && g.latestObservationRenderer) {
                    a = e[a] || [];
                    c = a.length;
                    for (d = 0; d < c; d++) f._repaint(a[d], null, !0)
                }
            }
            var b = this,
                e = this.trackMap,
                f = this.layer,
                g = f._getRenderer(),
                k;
            if (a) d.forEach(a, function(a) {
                c(a)
            });
            else
                for (k in e) e.hasOwnProperty(k) && c(k);
            this.moveLatestToFront()
        },
        moveLatestToFront: function(a) {
            d.forEach(this.getLatestObservations(a), function(a) {
                var b = a._shape;
                b && b._moveToFront();
                this._repaint(a, null, !0)
            }, this.layer)
        },
        getLatestObservations: function(a) {
            function c(a) {
                a = f[a];
                return a[a.length - 1]
            }
            var b = [],
                e = this.layer._getRenderer(),
                f = this.trackMap,
                g;
            if (!e.latestObservationRenderer) return b;
            if (a) d.forEach(a, function(a) {
                b.push(c(a))
            });
            else
                for (g in f) f.hasOwnProperty(g) && b.push(c(g));
            return b
        },
        clearTracks: function(a) {
            var c = this.getLatestObservations(a),
                b = this.container,
                e;
            a ? d.forEach(a, function(a) {
                delete this.trackMap[a];
                b && (e = this.trackLineMap[a], b.remove(e), delete this.trackLineMap[a])
            }, this) : (this.trackMap = {}, this.trackLineMap = {}, b && b.clear());
            d.forEach(c, function(a) {
                this._repaint(a, null, !0)
            }, this.layer)
        },
        isLatestObservation: function(a) {
            var c = this.trackMap[a.attributes[this.layer._trackIdField]];
            return c ? c[c.length - 1] === a : !1
        },
        destroy: function() {
            var a = this.container;
            a && (a.clear(), a._unsetMap(this.map, this.layer._div));
            this.map = this.layer = this.trackMap = this.container =
                null
        }
    })
});
},
'esri/layers/HeatmapManager':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/on", "dojo/aspect", "dojo/_base/array", "require", "../kernel", "../sniff", "../geometry/Point", "./MapImageLayer", "./MapImage", "./FeatureLayer", "../renderers/HeatmapRenderer", "../tasks/query"], function(s, r, D, t, u, v, E, F, w, x, y, z, q, A) {
    function B() {}

    function C(b) {
        var a = b.layer;
        return {
            geometry: b.geometry,
            attributes: b.attributes,
            getLayer: function() {
                return a
            }
        }
    }
    return s(null, {
        declaredClass: "esri.layers.HeatmapManager",
        heatmapRenderer: null,
        sourceLayer: null,
        imageLayer: null,
        useTiles: !0,
        useWorker: !1,
        map: null,
        constructor: function(b) {
            this.sourceLayer = b;
            this._hndls = []
        },
        initialize: function(b) {
            this.map = b;
            var a = this.sourceLayer,
                c = a.renderer;
            a.setDrawMode(!1);
            var a = this.imageLayer = new x({
                    className: "heatmapImgLyr"
                }),
                d = this;
            this.heatmapRenderer = c instanceof q ? c : (c.getRendererInfoByZoom(b.getZoom()) || c.getRendererInfoByScale(b.getScale())).renderer;
            this.recalculateHeatmap = this.recalculateHeatmap.bind(this);
            this._removeRenderer = this._removeRenderer.bind(this);
            this._handleRendererChange = this._handleRendererChange.bind(this);
            this._rendererChangeHandle = this.sourceLayer.on("renderer-change", this._handleRendererChange);
            b.addLayer(a);
            v(["../workers/heatmapCalculator"], function(a) {
                d._calculator = new a(r.mixin({
                    width: d.map.width,
                    height: d.map.height
                }, d._getOptions()));
                d._setupRenderer();
                d.heatmapRenderer.getStats = function(a) {
                    return d._calculator.calculateStats(a || 1)
                };
                d.heatmapRenderer.getHistogramData = function(a, b) {
                    return d._calculator.getHistogramData(a, b)
                }
            })
        },
        destroy: function() {
            this._removeHandlers();
            this.map.removeLayer(this.imageLayer);
            this._rendererChangeHandle.remove();
            this._rendererChangeHandle = this.sourceLayer = this.imageLayer = this.map = this.heatmapRenderer = this._hndls = null
        },
        _handleRendererChange: function(b) {
            var a = b.renderer,
                c = a instanceof q;
            this.heatmapRenderer ? c ? this.heatmapRenderer = a : this._removeRenderer(b) : c && (this.heatmapRenderer = a, this.sourceLayer && this.map && this._setupRenderer())
        },
        _setupRenderer: function() {
            var b = this._hndls,
                a = this.sourceLayer,
                c = this.map,
                d = this;
            a._originalDraw = a._draw;
            a._draw = B;
            a._div.clear();
            setTimeout(this._resetGraphics.bind(this),
                250);
            b.push(a.on("update-end", function(a) {
                d.recalculateHeatmap()
            }));
            b.push(a.on("suspend", function(a) {
                d.imageLayer.suspend()
            }));
            b.push(a.on("resume", function(a) {
                d.imageLayer.resume()
            }));
            b.push(t.after(a, "redraw", this.recalculateHeatmap));
            b.push(c.on("layer-remove", function(b) {
                b.layer == a && (c.removeLayer(d.imageLayer), d._removeRenderer({
                    target: a
                }))
            }));
            a.mode !== z.MODE_ONDEMAND && (b.push(c.on("resize, pan-end", function(a) {
                setTimeout(d.recalculateHeatmap, 16)
            })), b.push(c.on("zoom-end", function(b) {
                setTimeout(function() {
                    a._getRenderer().isInstanceOf(q) &&
                        d.recalculateHeatmap()
                }, 16)
            })));
            this.imageLayer.suspended && this.imageLayer.resume();
            a.graphics && a.graphics.length && this.recalculateHeatmap()
        },
        _removeRenderer: function(b) {
            var a = b.target;
            a._draw = a._originalDraw;
            delete a._originalDraw;
            a.setDrawMode(!0);
            this._removeHandlers();
            this._hndls = [];
            a.renderer != b.renderer && a.renderer.getRendererInfo ? (this.heatmapRenderer = null, this.imageLayer.suspend()) : (a.redraw(), this.destroy())
        },
        recalculateHeatmap: function() {
            this._calculator ? this._doMainCalculation() : this._calculatorClient &&
                this._doWorkerCalculation()
        },
        _doWorkerCalculation: function() {},
        _doMainCalculation: function() {
            var b = this.sourceLayer,
                a = this.imageLayer,
                c = this.map,
                d = this.heatmapRenderer,
                g = this.map.extent,
                n = this.map.width,
                f = this.map.height,
                h = this._calculator,
                l = this,
                k = function(e) {
                    e = l._getScreenPoints(e.features, c, b);
                    e = h.calculateImageData(r.mixin({
                        screenPoints: e,
                        mapinfo: {
                            extent: [g.xmin, g.ymin, g.xmax, g.ymax],
                            resolution: c.getResolution()
                        },
                        width: n,
                        height: f
                    }, l._getOptions()));
                    e = d.getSymbol(C({
                        geometry: c.extent,
                        attributes: {
                            size: [n,
                                f
                            ],
                            imageData: e
                        },
                        layer: b
                    }));
                    e = new y({
                        extent: c.extent,
                        href: e.url
                    });
                    a.addImage(e);
                    setTimeout(function() {
                        var b = a._mapImages.slice(0, -1),
                            c = b.length;
                        if (1E3 < c) b = a._mapImages[c], a.removeAllImages(), a.addImage(b);
                        else
                            for (; c-- && b[c];) a.removeImage(b[c])
                    }, 250)
                },
                p = {
                    geometry: c.extent,
                    timeExtent: c.timeExtent,
                    spatialRelationship: A.SPATIAL_REL_INTERSECTS
                };
            null != b._canDoClientSideQuery(p) ? b.queryFeatures(p, k) : k({
                features: b.graphics
            })
        },
        _getScreenPoints: function(b, a, c) {
            var d = [],
                g = b.length,
                n = 0,
                f = 0,
                h, l = new w(a.extent.xmin,
                    a.extent.ymax, a.spatialReference),
                k = a.toScreen(l),
                p = k.x,
                k = k.y,
                e = a.getResolution(),
                m;
            for (a.extent._parts && (m = u.map(a.extent._parts, function(b) {
                    return c._intersects(a, b.extent)[0]
                })); g--;) f = b[g], f.geometry && (h = {
                x: Math.ceil((f.geometry.x - l.x) / e + p),
                y: Math.floor((l.y - f.geometry.y) / e - k),
                attributes: f.attributes
            }, m && (f = 1 < m.length && h.x < -m[0] ? m[1] : m[0], h.x += f), d[n++] = h);
            return d
        },
        _removeHandlers: function() {
            for (var b = this._hndls.length; b--;) this._hndls[b].remove()
        },
        _getOptions: function() {
            var b = this.heatmapRenderer;
            return {
                blurRadius: b.blurRadius,
                gradient: b.gradient,
                maxPixelIntensity: b.maxPixelIntensity,
                minPixelIntensity: b.minPixelIntensity,
                field: b.field
            }
        },
        _resetGraphics: function() {
            for (var b = this.sourceLayer.graphics, a = b.length, c; a--;) c = b[a], c._shape = c._offsets = void 0
        }
    })
});
},
'esri/layers/MapImageLayer':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array", "dojo/dom-construct", "dojo/dom-style", "../kernel", "../config", "../sniff", "../domUtils", "../geometry/Point", "../geometry/webMercatorUtils", "./layer"], function(u, l, v, w, n, f, k, x, m, s, t, p, y) {
    var r = u([y], {
        declaredClass: "esri.layers.MapImageLayer",
        "-chains-": {
            constructor: "manual"
        },
        constructor: function(b) {
            this.inherited(arguments, [null, b]);
            this._mapImages = [];
            var a = v.hitch;
            this._panStart = a(this, this._panStart);
            this._pan = a(this, this._pan);
            this._extentChange = a(this, this._extentChange);
            this._zoom = a(this, this._zoom);
            this._zoomStart = a(this, this._zoomStart);
            this._scale = a(this, this._scale);
            this._resize = a(this, this._resize);
            l.connect(this, "onSuspend", this, this._onSuspend);
            l.connect(this, "onResume", this, this._onResume);
            this.loaded = !0;
            this.onLoad(this)
        },
        opacity: 1,
        addImage: function(b) {
            var a = this._mapImages.push(b),
                a = a - 1;
            b._idx = a;
            b._layer = this;
            this._div && this._createImage(b, a)
        },
        removeImage: function(b) {
            if (b) {
                var a = b._idx,
                    c = this._mapImages;
                if (c[a] ===
                    b) {
                    delete c[a];
                    if (a = b._node) this._clearEvents(a), a.e_idx = a.e_bl = a.e_tr = a.e_l = a.e_t = a.e_w = a.e_h = null, a.parentNode && (a.parentNode.removeChild(a), n.destroy(a));
                    b._node = b._idx = b._layer = null
                }
            }
        },
        removeAllImages: function() {
            var b = this._mapImages,
                a, c = b.length;
            for (a = 0; a < c; a++) {
                var d = b[a];
                d && this.removeImage(d)
            }
            this._mapImages = []
        },
        getImages: function() {
            var b = this._mapImages,
                a = [],
                c, d = b.length;
            for (c = 0; c < d; c++) b[c] && a.push(b[c]);
            return a
        },
        setOpacity: function(b) {
            this.opacity != b && (this._opacityChanged(this.opacity =
                b), this.onOpacityChange())
        },
        onOpacityChange: function() {},
        _opacityChanged: function(b) {
            var a = this._div,
                c, d;
            if (a)
                if (!m("ie") || 8 < m("ie")) f.set(a, "opacity", b);
                else {
                    d = a.childNodes;
                    c = d.length;
                    for (a = 0; a < c; a++) f.set(d[a], "opacity", b)
                }
        },
        _createImage: function(b, a) {
            var c = n.create("img");
            f.set(c, {
                position: "absolute"
            });
            8 >= m("ie") && f.set(c, "opacity", this.opacity);
            b.rotation && !(9 > m("ie")) && f.set(c, k._css.names.transform, k._css.rotate(360 - b.rotation));
            b._node = c;
            c.e_idx = a;
            c.e_layer = this;
            c.e_load = l.connect(c, "onload",
                r.prototype._imageLoaded);
            c.e_error = l.connect(c, "onerror", r.prototype._imageError);
            c.e_abort = l.connect(c, "onabort", r.prototype._imageError);
            c.src = b.href
        },
        _imageLoaded: function(b, a) {
            var c = a || b.target || b.currentTarget,
                d = c.e_layer,
                e = d._mapImages[c.e_idx],
                g = d._map;
            g && (g.__zooming || g.__panning || !d._sr) ? d._standby.push(c) : (d._clearEvents(c), e && e._node === c && g && d._attach(e))
        },
        _imageError: function(b) {
            b = b.target || b.currentTarget;
            var a = b.e_layer,
                c = a._mapImages[b.e_idx];
            a._clearEvents(b);
            c && (c._node = null)
        },
        _clearEvents: function(b) {
            var a =
                l.disconnect;
            a(b.e_load);
            a(b.e_error);
            a(b.e_abort);
            b.e_load = b.e_error = b.e_abort = b.e_layer = null
        },
        _attach: function(b) {
            var a = b.extent,
                c = a.spatialReference,
                d = this._sr,
                e = this._div,
                g = b._node,
                f = new t({
                    x: a.xmin,
                    y: a.ymin,
                    spatialReference: c
                }),
                a = new t({
                    x: a.xmax,
                    y: a.ymax,
                    spatialReference: c
                });
            d.equals(c) || (d.isWebMercator() && 4326 === c.wkid ? (f = p.geographicToWebMercator(f), a = p.geographicToWebMercator(a)) : c.isWebMercator() && 4326 === d.wkid && (f = p.webMercatorToGeographic(f), a = p.webMercatorToGeographic(a)));
            g.e_bl = f;
            g.e_tr =
                a;
            b.visible && (this._setPos(g, e._left, e._top), (this._active || e).appendChild(g))
        },
        _setPos: function(b, a, c) {
            var d = b.e_bl,
                e = b.e_tr,
                g = this._map,
                d = g.toScreen(d),
                e = g.toScreen(e);
            a = d.x - a;
            c = e.y - c;
            var q = Math.abs(e.x - d.x),
                d = Math.abs(d.y - e.y),
                e = {
                    width: q + "px",
                    height: d + "px"
                },
                h = this._mapImages[b.e_idx];
            "css-transforms" === g.navigationMode ? e[k._css.names.transform] = k._css.translate(a, c) + (h.rotation ? " " + k._css.rotate(360 - h.rotation) : "") : (e.left = a + "px", e.top = c + "px");
            f.set(b, e);
            b.e_l = a;
            b.e_t = c;
            b.e_w = q;
            b.e_h = d
        },
        managedSuspension: !0,
        _setMap: function(b, a) {
            this.inherited(arguments);
            var c = this._div = n.create("div", null, a),
                d = k._css.names,
                e = {
                    position: "absolute"
                },
                g = b.__visibleDelta;
            if (!m("ie") || 8 < m("ie")) e.opacity = this.opacity;
            "css-transforms" === b.navigationMode ? (e[d.transform] = k._css.translate(g.x, g.y), f.set(c, e), c._left = g.x, c._top = g.y, e = {
                position: "absolute",
                width: b.width + "px",
                height: b.height + "px",
                overflow: "visible"
            }, this._active = n.create("div", null, c), f.set(this._active, e), this._passive = n.create("div", null, c), f.set(this._passive,
                e)) : (c._left = 0, c._top = 0, f.set(c, e));
            this._standby = [];
            d = this._mapImages;
            g = d.length;
            for (e = 0; e < g; e++) {
                var q = d[e];
                q._node || this._createImage(q, q._idx)
            }
            s.hide(c);
            return c
        },
        _unsetMap: function(b, a) {
            this._disconnect();
            var c = this._div;
            if (c) {
                var d = this._mapImages,
                    e, g = d.length;
                for (e = 0; e < g; e++) {
                    var f = d[e];
                    if (f) {
                        var h = f._node;
                        h && (this._clearEvents(h), h.e_idx = h.e_bl = h.e_tr = h.e_l = h.e_t = h.e_w = h.e_h = null);
                        f._node = null
                    }
                }
                a.removeChild(c);
                n.destroy(c)
            }
            this._map = this._div = this._sr = this._active = this._passive = this._standby =
                null;
            this.inherited(arguments)
        },
        _onSuspend: function() {
            this._disconnect();
            s.hide(this._div)
        },
        _onResume: function(b) {
            b.firstOccurrence && (this._sr = this._map.spatialReference, this._processStandbyList());
            b = this._map;
            var a = this._div,
                c = b.__visibleDelta;
            "css-transforms" === b.navigationMode && (a._left = c.x, a._top = c.y, f.set(a, k._css.names.transform, k._css.translate(a._left, a._top)));
            this._redraw("css-transforms" === b.navigationMode);
            this._connect(b);
            s.show(a)
        },
        _connect: function(b) {
            if (!this._connections) {
                var a = l.connect,
                    c = "css-transforms" === b.navigationMode;
                this._connections = [a(b, "onPanStart", this._panStart), a(b, "onPan", this._pan), a(b, "onExtentChange", this._extentChange), c && a(b, "onZoomStart", this._zoomStart), c ? a(b, "onScale", this._scale) : a(b, "onZoom", this._zoom), c && a(b, "onResize", this._resize)]
            }
        },
        _disconnect: function() {
            this._connections && (w.forEach(this._connections, l.disconnect), this._connections = null)
        },
        _panStart: function() {
            this._panL = this._div._left;
            this._panT = this._div._top
        },
        _pan: function(b, a) {
            var c = this._div;
            c._left = this._panL + a.x;
            c._top = this._panT + a.y;
            "css-transforms" === this._map.navigationMode ? f.set(c, k._css.names.transform, k._css.translate(c._left, c._top)) : f.set(c, {
                left: c._left + "px",
                top: c._top + "px"
            })
        },
        _extentChange: function(b, a, c) {
            c ? this._redraw("css-transforms" === this._map.navigationMode) : a && this._pan(b, a);
            this._processStandbyList()
        },
        _processStandbyList: function() {
            var b, a = this._standby;
            if (a && a.length)
                for (b = a.length - 1; 0 <= b; b--) this._imageLoaded(null, a[b]), a.splice(b, 1)
        },
        _redraw: function(b) {
            if (b) {
                b =
                    this._passive;
                var a = k._css.names;
                f.set(b, a.transition, "none");
                this._moveImages(b, this._active);
                f.set(b, a.transform, "none")
            }
            b = this._active || this._div;
            var a = this._div._left,
                c = this._div._top,
                d, e = b.childNodes.length,
                g;
            for (d = 0; d < e; d++) g = b.childNodes[d], this._setPos(g, a, c)
        },
        _zoom: function(b, a, c) {
            b = this._div;
            var d = b._left,
                e = b._top,
                g, k = b.childNodes.length,
                h;
            for (g = 0; g < k; g++) {
                h = b.childNodes[g];
                var l = h.e_w * a,
                    n = h.e_h * a,
                    m = (c.x - d - h.e_l) * (l - h.e_w) / h.e_w,
                    p = (c.y - e - h.e_t) * (n - h.e_h) / h.e_h,
                    m = isNaN(m) ? 0 : m,
                    p = isNaN(p) ?
                    0 : p;
                f.set(h, {
                    left: h.e_l - m + "px",
                    top: h.e_t - p + "px",
                    width: l + "px",
                    height: n + "px"
                })
            }
        },
        _zoomStart: function() {
            this._moveImages(this._active, this._passive)
        },
        _moveImages: function(b, a) {
            var c = b.childNodes,
                d;
            d = c.length;
            if (0 < d)
                for (d -= 1; 0 <= d; d--) a.appendChild(c[d])
        },
        _scale: function(b, a) {
            var c = k._css.names,
                d = this._passive;
            f.set(d, c.transition, a ? "none" : c.transformName + " " + x.defaults.map.zoomDuration + "ms ease");
            k._css.matrix(b);
            f.set(d, c.transform, k._css.matrix(b))
        },
        _resize: function(b, a, c) {
            f.set(this._active, {
                width: a +
                    "px",
                height: c + "px"
            });
            f.set(this._passive, {
                width: a + "px",
                height: c + "px"
            })
        }
    });
    return r
});
},
'esri/layers/MapImage':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../domUtils", "../geometry/Extent"], function(e, f, h, k, d, g) {
    return e(null, {
        declaredClass: "esri.layers.MapImage",
        constructor: function(a) {
            f.mixin(this, a);
            this.extent = new g(this.extent)
        },
        visible: !0,
        getLayer: function() {
            return this._layer
        },
        getNode: function() {
            return this._node
        },
        show: function() {
            if (!this.visible) {
                this.visible = !0;
                var a = this._node,
                    b = this._layer,
                    c;
                if (a) {
                    if (c = b && b._div) b.suspended || b._setPos(a, c._left, c._top), (b._active || c).appendChild(a);
                    d.show(a)
                }
            }
        },
        hide: function() {
            if (this.visible) {
                this.visible = !1;
                var a = this._node;
                a && (d.hide(a), a.parentNode && a.parentNode.removeChild(a))
            }
        }
    })
});
},
'esri/dijit/Attribution':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/kernel", "dojo/has", "dojo/query", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dojo/dom-style", "dojo/dom-class", "dojo/dom-geometry", "../kernel", "../lang", "../SpatialReference", "../geometry/webMercatorUtils", "../geometry/Extent"], function(w, l, h, q, x, C, D, y, s, t, r, k, u, E, v, z, A, B) {
    return w(null, {
        declaredClass: "esri.dijit.Attribution",
        itemDelimiter: " | ",
        listClass: "esriAttributionList",
        itemClass: "esriAttributionItem",
        lastItemClass: "esriAttributionLastItem",
        delimiterClass: "esriAttributionDelim",
        constructor: function(d, b) {
            try {
                l.mixin(this, d);
                this._attributions = {};
                this._pendingDfds = {};
                this._activeLayers = [];
                this._sharedLayers = [];
                var a = this.domNode = y.byId(b),
                    c = this.map,
                    e = "\x3cspan class\x3d'" + this.listClass + "'\x3e\x3c/span\x3e";
                a && (s.set(a, "innerHTML", e), this.listNode = x.query(".esriAttributionList", a)[0], this.itemNodes = {});
                this._eventConnections = [q.connect(c, "onLayerAdd", this, this._onLayerAdd), q.connect(c, "onLayerRemove", this, this._onLayerRemove), q.connect(c,
                    "onLayerSuspend", this, this._onLayerSuspend), q.connect(c, "onLayerResume", this, this._onLayerResume), q.connect(c, "onExtentChange", this, this._onExtentChange)];
                if (c.loaded) {
                    var f = c.layerIds.concat(c.graphicsLayerIds),
                        g, n, p = f.length;
                    for (n = 0; n < p; n++) g = c.getLayer(f[n]), g.loaded && this._onLayerAdd(g)
                }
            } catch (h) {}
        },
        startup: function() {},
        destroy: function() {
            h.forEach(this._eventConnections, q.disconnect);
            t.destroy(this.listNode);
            this.map = this.domNode = this._eventConnections = this.listNode = this._attributions = this._pendingDfds =
                this.itemNodes = this._activeLayers = this._lastItem = this._sharedLayers = null
        },
        _onLayerAdd: function(d) {
            try {
                var b = this._attributions,
                    a = d.id;
                if (!v.isDefined(b[a]) && d.showAttribution)
                    if (d.hasAttributionData) {
                        var c = d.getAttributionData();
                        this._pendingDfds[a] = 1;
                        b[a] = c;
                        c.addBoth(l.partial(this._onAttributionLoad, this, d))
                    } else b[a] = d.copyright || d.copyrightText || "", b[a] ? (d.suspended || this._activeLayers.push(a), this._createNode(a)) : this._onLayerRemove(d)
            } catch (e) {}
        },
        _onAttributionLoad: function(d, b, a) {
            var c = d._attributions,
                e = d._pendingDfds,
                f = b.id;
            if (e && e[f]) {
                delete e[f];
                if (!a || a instanceof Error) a = "";
                c[f] = a ? d._createIndexByLevel(a, -1 !== b.declaredClass.toLowerCase().indexOf("vetiledlayer")) : b.copyright || b.copyrightText || "";
                c[f] ? (b.suspended || d._activeLayers.push(f), d._createNode(f)) : d._onLayerRemove(b)
            }
        },
        _onLayerRemove: function(d) {
            try {
                var b = d.id,
                    a = this.itemNodes,
                    c, e = -1;
                this._onLayerSuspend(d);
                delete this._attributions[b];
                delete this._pendingDfds[b];
                c = this._getGroupIndex(b); - 1 !== c && (e = h.indexOf(this._sharedLayers[c],
                    b), -1 !== e && (this._sharedLayers[c].splice(e, 1), 1 >= this._sharedLayers[c].length && this._sharedLayers.splice(c, 1)));
                a[b] && -1 === e && t.destroy(a[b]);
                delete a[b];
                this._updateLastItem()
            } catch (f) {}
        },
        _onLayerSuspend: function(d) {
            try {
                var b = d.id;
                if (this._attributions[b]) {
                    var a = h.indexOf(this._activeLayers, b),
                        c = this.itemNodes[b]; - 1 !== a && this._activeLayers.splice(a, 1);
                    c && this._toggleItem(c, !1, this._getGroupIndex(b))
                }
            } catch (e) {}
        },
        _onLayerResume: function(d) {
            try {
                var b = d.id,
                    a = this._attributions[b],
                    c = this.itemNodes[b];
                if (a && (-1 === h.indexOf(this._activeLayers, b) && this._activeLayers.push(b), c)) {
                    var e = l.isString(a) ? a : this._getContributorsList(a, this.map.extent, this.map.getLevel());
                    l.isString(a) || s.set(c, "innerHTML", e ? e + this._getDelimiter() : "");
                    e && this._toggleItem(c, !0, this._getGroupIndex(b))
                }
            } catch (f) {}
        },
        _onExtentChange: function(d, b, a, c) {
            try {
                var e = this._activeLayers,
                    f = this._attributions,
                    g = this.itemNodes,
                    n, p, h, k, q = e.length || 0;
                for (k = 0; k < q; k++)
                    if (p = e[k], h = f[p], (n = g[p]) && !l.isString(h)) {
                        var m = this._getContributorsList(h,
                            d, c ? c.level : -1);
                        s.set(n, "innerHTML", m ? m + this._getDelimiter() : "");
                        this._toggleItem(n, !!m, -1)
                    }
            } catch (r) {}
            this._adjustCursorStyle()
        },
        _createNode: function(d) {
            if (this.domNode) {
                var b = this._checkShareInfo(d),
                    a = b && b.sharedWith,
                    a = a && this.itemNodes[a],
                    c = this.map,
                    e = this._attributions[d],
                    e = l.isString(e) ? e : this._getContributorsList(e, c.extent, c.getLevel()),
                    c = !!e && !c.getLayer(d).suspended;
                a ? (this.itemNodes[d] = a, this._toggleItem(a, c, b.index)) : (d = this.itemNodes[d] = t.create("span", {
                    "class": this.itemClass,
                    innerHTML: e ?
                        e + this._getDelimiter() : "",
                    style: {
                        display: c ? "inline" : "none"
                    }
                }, this.listNode), c && this._setLastItem(d));
                this._adjustCursorStyle()
            }
        },
        _checkShareInfo: function(d) {
            var b = this._attributions,
                a, c, e = -1,
                f = b[d],
                g;
            if (f && l.isString(f)) {
                for (c in b)
                    if (a = b[c], c !== d && a && l.isString(a) && a.length === f.length && a.toLowerCase() === f.toLowerCase()) {
                        g = c;
                        break
                    }
                b = this._sharedLayers;
                a = b.length;
                if (g) {
                    for (c = 0; c < a; c++)
                        if (f = b[c], -1 !== h.indexOf(f, g)) {
                            e = c;
                            f.push(d);
                            break
                        } - 1 === e && (e = b.push([g, d]) - 1)
                }
            }
            return -1 < e ? {
                    index: e,
                    sharedWith: g
                } :
                null
        },
        _getGroupIndex: function(d) {
            var b = this._sharedLayers,
                a, c = b.length,
                e = -1;
            for (a = 0; a < c; a++)
                if (-1 !== h.indexOf(b[a], d)) {
                    e = a;
                    break
                }
            return e
        },
        _getDelimiter: function() {
            var d = this.itemDelimiter;
            return d ? "\x3cspan class\x3d'" + this.delimiterClass + "'\x3e" + d + "\x3c/span\x3e" : ""
        },
        _toggleItem: function(d, b, a) {
            if (-1 < a && !b) {
                a = this._sharedLayers[a];
                var c, e = a.length,
                    f = this._activeLayers;
                for (c = 0; c < e; c++)
                    if (-1 !== h.indexOf(f, a[c])) return
            }
            r.set(d, "display", b ? "inline" : "none");
            this._updateLastItem()
        },
        _updateLastItem: function() {
            var d =
                this.listNode.childNodes,
                b;
            b = d.length;
            var a;
            if (b)
                for (b -= 1; 0 <= b; b--)
                    if (a = d[b], "none" !== r.get(a, "display")) {
                        this._setLastItem(a);
                        break
                    }
            this._adjustCursorStyle()
        },
        _setLastItem: function(d) {
            var b = this.itemClass,
                a = this.lastItemClass;
            this._lastItem && k.replace(this._lastItem, b, a);
            d && (k.replace(d, a, b), this._lastItem = d)
        },
        _createIndexByLevel: function(d, b) {
            var a = d.contributors,
                c, e, f, g, n = a ? a.length : 0,
                p, h, k = new z(4326),
                l = {},
                m;
            for (g = 0; g < n; g++) {
                c = a[g];
                h = (e = c.coverageAreas) ? e.length : 0;
                for (p = 0; p < h; p++) {
                    f = e[p];
                    m = f.bbox;
                    m = {
                        extent: A.geographicToWebMercator(new B(m[1], m[0], m[3], m[2], k)),
                        attribution: c.attribution || "",
                        zoomMin: f.zoomMin - (b && f.zoomMin ? 1 : 0),
                        zoomMax: f.zoomMax - (b && f.zoomMax ? 1 : 0),
                        score: v.isDefined(f.score) ? f.score : 100,
                        objectId: g
                    };
                    for (f = m.zoomMin; f <= m.zoomMax; f++) l[f] = l[f] || [], l[f].push(m)
                }
            }
            return l
        },
        _getContributorsList: function(d, b, a) {
            var c = "";
            if (b && v.isDefined(a) && -1 < a) {
                d = d[a];
                a = b.getCenter().normalize();
                for (var e = d ? d.length : 0, f = [], g = {}, c = 0; c < e; c++) b = d[c], !g[b.objectId] && b.extent.contains(a) && (g[b.objectId] =
                    1, f.push(b));
                f.sort(function(a, b) {
                    return b.score - a.score || a.objectId - b.objectId
                });
                e = f.length;
                for (c = 0; c < e; c++) f[c] = f[c].attribution;
                c = f.join(", ")
            }
            return c
        },
        _adjustCursorStyle: function() {
            var d = u.position(this.listNode.parentNode, !0).h;
            k.contains(this.listNode.parentNode, "esriAttributionOpen") ? (k.remove(this.listNode.parentNode, "esriAttributionOpen"), d > u.position(this.listNode.parentNode, !0).h ? (r.set(this.listNode.parentNode, "cursor", "pointer"), k.add(this.listNode.parentNode, "esriAttributionOpen")) :
                r.set(this.listNode.parentNode, "cursor", "default")) : (k.add(this.listNode.parentNode, "esriAttributionOpen"), d < u.position(this.listNode.parentNode, !0).h ? r.set(this.listNode.parentNode, "cursor", "pointer") : r.set(this.listNode.parentNode, "cursor", "default"), k.remove(this.listNode.parentNode, "esriAttributionOpen"))
        }
    })
});
},
'esri/dijit/Geocoder':function(){
//>>built
define(["require", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/_base/event", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-style", "dojo/dom-construct", "dojo/keys", "dojo/on", "dojo/query", "dojo/i18n!../nls/jsapi", "dojo/text!./templates/Geocoder.html", "dojo/uacss", "dijit/a11yclick", "dijit/_TemplatedMixin", "dijit/focus", "../kernel", "../SpatialReference", "../graphic", "../symbols/PictureMarkerSymbol", "./_EventedWidget", "../geometry/Point", "../geometry/Extent", "../tasks/locator", "../tasks/query", "../tasks/QueryTask", "../geometry/scaleUtils"], function(y, z, e, q, n, f, g, m, A, d, l, r, s, B, J, p, C, t, K, u, v, D, E, w, x, F, G, H, I) {
    return z("esri.dijit.Geocoder", [E, C], {
        templateString: B,
        reHostedFS: /https?:\/\/services.*\.arcgis\.com/i,
        _eventMap: {
            select: ["result"],
            "find-results": ["results"],
            "auto-complete": ["results"],
            "geocoder-select": ["geocoder"],
            clear: !0,
            "enter-key-select": !0,
            load: !0
        },
        constructor: function(a, b) {
            this._css = {
                GeocoderContainerClass: "esriGeocoderContainer",
                GeocoderClass: "esriGeocoder",
                GeocoderMultipleClass: "esriGeocoderMultiple",
                GeocoderIconClass: "esriGeocoderIcon",
                GeocoderActiveClass: "esriGeocoderActive",
                GeocoderResultsOpenClass: "esriGeocoderResultsOpen",
                GeocoderMenuOpenClass: "esriGeocoderMenuOpen",
                loadingClass: "esriGeocoderLoading",
                resultsContainerClass: "esriGeocoderResults",
                resultsItemClass: "esriGeocoderResult",
                resultsItemEvenClass: "esriGeocoderResultEven",
                resultsItemOddClass: "esriGeocoderResultOdd",
                resultsItemFirstClass: "esriGeocoderResultFirst",
                resultsItemLastClass: "esriGeocoderResultLast",
                resultsPartialMatchClass: "esriGeocoderResultPartial",
                searchButtonClass: "esriGeocoderSearch",
                clearButtonClass: "esriGeocoderReset",
                hasValueClass: "esriGeocoderHasValue",
                geocoderMenuClass: "esriGeocoderMenu",
                geocoderMenuHeaderClass: "esriGeocoderMenuHeader",
                geocoderMenuCloseClass: "esriGeocoderMenuClose",
                activeMenuClass: "esriGeocoderMenuActive",
                geocoderMenuArrowClass: "esriGeocoderMenuArrow",
                geocoderSelectedClass: "esriGeocoderSelected",
                geocoderSelectedCheckClass: "esriGeocoderSelectedCheck",
                GeocoderClearClass: "esriGeocoderClearFloat"
            };
            this.options = {
                autoComplete: !1,
                arcgisGeocoder: !0,
                value: "",
                theme: "simpleGeocoder",
                activeGeocoderIndex: 0,
                maxLocations: 6,
                minCharacters: 3,
                searchDelay: 300,
                geocoderMenu: !0,
                autoNavigate: !0,
                showResults: !0,
                map: null,
                activeGeocoder: null,
                geocoders: null,
                zoomScale: 1E4,
                highlightLocation: !1,
                symbol: new D(y.toUrl(".") + "/images/sdk_gps_location.png", 28, 28),
                graphicsLayer: null
            };
            var c = e.mixin({}, this.options, a);
            this.set("autoComplete", c.autoComplete);
            this.set("arcgisGeocoder", c.arcgisGeocoder);
            this.set("value", c.value);
            this.set("theme", c.theme);
            this.set("activeGeocoderIndex", c.activeGeocoderIndex);
            this.set("maxLocations", c.maxLocations);
            this.set("minCharacters", c.minCharacters);
            this.set("searchDelay", c.searchDelay);
            this.set("geocoderMenu", c.geocoderMenu);
            this.set("autoNavigate", c.autoNavigate);
            this.set("showResults", c.showResults);
            this.set("map", c.map);
            this.set("activeGeocoder", c.activeGeocoder);
            this.set("geocoders", c.geocoders);
            this.set("zoomScale", c.zoomScale);
            this.set("highlightLocation", c.highlightLocation);
            this.set("symbol", c.symbol);
            this.set("graphicsLayer", c.graphicsLayer);
            this.set("results", []);
            this._i18n = s;
            this._deferreds = [];
            this._defaultSR = new u(4326);
            this.watch("value", this._updateValue);
            this.watch("theme", this._updateTheme);
            this.watch("activeGeocoder", this._setActiveGeocoder);
            this.watch("activeGeocoderIndex", this._setActiveGeocoderIndex);
            this.watch("geocoders", this._updateGeocoder);
            this.watch("arcgisGeocoder", this._updateGeocoder);
            this.watch("geocoderMenu", this._updateGeocoder);
            this.watch("map", this._setupEvents);
            this.domNode = b
        },
        startup: function() {
            if (this._geocoders.length)
                if (this.domNode)
                    if (this.get("map"))
                        if (this.get("map").loaded) this._init();
                        else l.once(this.get("map"), "load", e.hitch(this, function() {
                            this._init()
                        }));
            else this._init();
            else console.log("Geocoder:: domNode is undefined."), this.destroy();
            else console.log("Geocoder:: No geocoders defined."), this.destroy()
        },
        postCreate: function() {
            this.inherited(arguments);
            this.own(l(this.submitNode, p, e.hitch(this, this._findThenSelect)));
            this.own(l(this.geocoderMenuArrowNode, p, e.hitch(this, this._toggleGeolocatorMenu)));
            this.own(l(this.inputNode, p, e.hitch(this, this._inputClick)));
            this.own(l(this.clearNode,
                p, e.hitch(this, this.clear)));
            this.own(l(this.geocoderMenuCloseNode, p, e.hitch(this, this._hideGeolocatorMenu)));
            this._updateGeocoder();
            this._setupEvents();
            this.get("value") && this._checkStatus();
            this._hideMenus()
        },
        destroy: function() {
            this._removeEvents();
            A.empty(this.domNode);
            this.inherited(arguments)
        },
        clear: function() {
            this.onClear();
            var a = this.get("highlightGraphic"),
                b = this.get("graphicsLayer");
            a && (b ? b.remove(a) : this.get("map").graphics.remove(a), this.set("highlightGraphic", null));
            f.set(this.inputNode,
                "value", "");
            this.set("value", "");
            this.set("results", []);
            g.remove(this.containerNode, this._css.hasValueClass);
            f.set(this.clearNode, "title", "");
            this._hideMenus();
            this._hideLoading()
        },
        show: function() {
            m.set(this.domNode, "display", "block")
        },
        hide: function() {
            m.set(this.domNode, "display", "none")
        },
        find: function(a) {
            var b = new q;
            if (a)
                if ("string" === typeof a) this._findQuery(a).then(function(a) {
                    b.resolve(a)
                });
                else if ("object" === typeof a && a.hasOwnProperty("geometry")) {
                var c;
                switch (a.geometry.type) {
                    case "extent":
                        c =
                            a.geometry.getCenter();
                        break;
                    case "multipoint":
                        c = a.geometry.getExtent().getCenter();
                        break;
                    case "point":
                        c = a.geometry;
                        break;
                    case "polygon":
                        c = a.geometry.getExtent().getCenter();
                        break;
                    case "polyline":
                        c = a.geometry.getExtent().getCenter()
                }
                c && this._reverseGeocodePoint(c, a.geometry).then(function(c) {
                    c.results[0] && (a.hasOwnProperty("attributes") && c.results[0].feature.setAttributes(e.mixin(c.results[0].feature.attributes, a.attributes)), a.hasOwnProperty("infoTemplate") && c.results[0].feature.setInfoTemplate(a.infoTemplate),
                        a.hasOwnProperty("symbol") && c.results[0].feature.setSymbol(a.symbol));
                    b.resolve(c)
                }, function(a) {
                    b.reject(a)
                })
            } else "object" === typeof a && "point" === a.type ? this._reverseGeocodePoint(a).then(function(a) {
                b.resolve(a)
            }, function(a) {
                b.reject(a)
            }) : a instanceof Array && 2 === a.length ? (c = new w(a, new u({
                wkid: 4326
            })), this._reverseGeocodePoint(c).then(function(a) {
                b.resolve(a)
            }, function(a) {
                b.reject(a)
            })) : b.reject("Geocoder:: Invalid find type");
            else this._findQuery(this.get("value")).then(function(a) {
                b.resolve(a)
            });
            return b.promise
        },
        focus: function() {
            t.focus(this.inputNode)
        },
        blur: function() {
            t.curNode && t.curNode.blur();
            this.inputNode.blur();
            this._hideMenus();
            var a = this.get("map");
            a && a.enableKeyboardNavigation()
        },
        select: function(a) {
            this.onSelect(a);
            this._hideMenus();
            this._hideLoading();
            this.get("autoNavigate") && (a && a.hasOwnProperty("extent") && this.get("map")) && this.get("map").setExtent(a.extent);
            if (a.feature) {
                var b = this.get("highlightGraphic"),
                    c = this.get("graphicsLayer"),
                    k = this.get("symbol") || a.feature.symbol;
                b ? (b.setGeometry(a.feature.geometry), b.setAttributes(a.feature.attributes), b.setInfoTemplate(a.feature.infoTemplate), b.setSymbol(k)) : (b = a.feature, this.get("highlightLocation") && (b.setSymbol(k), c ? c.add(b) : this.get("map").graphics.add(b)));
                this.set("highlightGraphic", b)
            }
        },
        onSelect: function() {},
        onFindResults: function() {},
        onAutoComplete: function() {},
        onGeocoderSelect: function() {},
        onClear: function() {},
        onEnterKeySelect: function() {},
        onLoad: function() {},
        _autoComplete: function() {
            var a = this.get("activeGeocoder"),
                b = this.reHostedFS.test(a.url);
            ("query" !== a.type || b) && this._query({
                delay: this.get("searchDelay"),
                autoComplete: !0,
                search: this.get("value")
            }).then(e.hitch(this, function(a) {
                this.onAutoComplete(a);
                this.get("showResults") && this._showResults(a)
            }))
        },
        _init: function() {
            this.set("loaded", !0);
            this.onLoad()
        },
        _containsNonLatinCharacter: function(a) {
            for (var b = 0; b < a.length; b++)
                if (255 < a.charCodeAt(b)) return !0;
            return !1
        },
        _findQuery: function(a) {
            var b = new q;
            this._query({
                delay: 0,
                search: a
            }).then(e.hitch(this, function(a) {
                this.onFindResults(a);
                b.resolve(a)
            }), e.hitch(this, function(a) {
                this.onFindResults(a);
                b.reject(a)
            }));
            return b.promise
        },
        _reverseGeocodePoint: function(a, b) {
            var c = new q;
            if (a && this.get("activeGeocoder")) {
                var k = b || a,
                    d = this.get("activeGeocoder").distance || 1500;
                this._task.outSpatialReference = this._defaultSR;
                this.get("map") && (this._task.outSpatialReference = this.get("map").spatialReference);
                this._task.locationToAddress(a, d, e.hitch(this, function(a) {
                        a = {
                            results: [this._hydrateResult(a)],
                            geometry: k
                        };
                        this.onFindResults(a);
                        c.resolve(a)
                    }),
                    e.hitch(this, function(a) {
                        c.reject(a)
                    }))
            } else c.reject("Geocoder:: no point or active geocoder defined");
            return c.promise
        },
        _setEsriGeocoder: function() {
            this.get("arcgisGeocoder") ? ("object" === typeof this.get("arcgisGeocoder") ? this._arcgisGeocoder = this.get("arcgisGeocoder") : this._arcgisGeocoder = {}, this._arcgisGeocoder.hasOwnProperty("suggest") || (this._arcgisGeocoder.suggest = !0), this._arcgisGeocoder.hasOwnProperty("singleLineFieldName") || (this._arcgisGeocoder.singleLineFieldName = "SingleLine"), this._arcgisGeocoder.url ||
                (this._arcgisGeocoder.url = ("file:" === location.protocol ? "http:" : location.protocol) + "//geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer"), this._arcgisGeocoder.name || (this._arcgisGeocoder.name = s.widgets.Geocoder.esriGeocoderName), this._arcgisGeocoder.hasOwnProperty("localSearchOptions") || (this._arcgisGeocoder.localSearchOptions = {
                    minScale: 3E5,
                    distance: 5E4
                }), this.set("arcgisGeocoder", this._arcgisGeocoder)) : this.set("arcgisGeocoder", !1)
        },
        _setActiveGeocoder: function() {
            this.set("activeGeocoder",
                this._geocoders[this.get("activeGeocoderIndex")]);
            this._task = "query" === this.activeGeocoder.type ? new H(this.get("activeGeocoder").url) : new F(this.get("activeGeocoder").url);
            this._updatePlaceholder()
        },
        _setGeocoderList: function() {
            var a = [];
            this.get("arcgisGeocoder") && (a = a.concat([this._arcgisGeocoder]));
            this.get("geocoders") && this.get("geocoders").length && (a = a.concat(this.get("geocoders")));
            this._geocoders = a
        },
        _updateGeocoder: function() {
            this.set("activeGeocoderIndex", 0);
            this._setEsriGeocoder();
            this._setGeocoderList();
            this._setActiveGeocoder();
            this._insertGeocoderMenuItems()
        },
        _updatePlaceholder: function() {
            this._placeholder = "";
            this.get("activeGeocoder") && this.get("activeGeocoder").placeholder && (this._placeholder = this.get("activeGeocoder").placeholder);
            f.set(this.inputNode, "placeholder", this._placeholder);
            f.set(this.submitNode, "title", this._placeholder)
        },
        _updateValue: function(a, b, c) {
            this._ignoreUpdateValue || (f.set(this.inputNode, "value", c), this._checkStatus())
        },
        _updateTheme: function(a, b, c) {
            g.remove(this.domNode,
                b);
            g.add(this.domNode, c)
        },
        _setActiveGeocoderIndex: function(a, b, c) {
            this.set("activeGeocoderIndex", c);
            this._setActiveGeocoder();
            this._hideMenus();
            this._insertGeocoderMenuItems();
            a = {
                attr: this.get("activeGeocoder"),
                oldVal: b,
                newVal: c
            };
            this.onGeocoderSelect(a)
        },
        _clearQueryTimeout: function() {
            this._queryTimer && clearTimeout(this._queryTimer)
        },
        _query: function(a) {
            a || (a = {
                delay: 0
            });
            a.search || (a.search = this.get("value"));
            var b = new q;
            this._deferreds.push(b);
            a.delay ? (this._clearQueryTimeout(), this._queryTimer = setTimeout(e.hitch(this,
                function() {
                    this._performTask(b, a)
                }), a.delay)) : this._performTask(b, a);
            return b.promise
        },
        _performTask: function(a, b) {
            if (b.search) {
                this._hideGeolocatorMenu();
                this._showLoading();
                var c = "";
                this.get("activeGeocoder").prefix && (c += this.get("activeGeocoder").prefix);
                c += b.search;
                this.get("activeGeocoder").suffix && (c += this.get("activeGeocoder").suffix);
                var k = this.get("activeGeocoder").outFields;
                k && (k instanceof Array || (k = [k]));
                var d = this.get("maxLocations") || 6,
                    f = this.get("activeGeocoder").searchExtent,
                    g = this._defaultSR;
                this.get("map") && (g = this.get("map").spatialReference);
                if ("query" === this.get("activeGeocoder").type) {
                    var h = new G;
                    h.outSpatialReference = g;
                    h.returnGeometry = !0;
                    h.num = d;
                    f && (h.geometry = f);
                    d = this.get("activeGeocoder").exactMatch;
                    f = this.get("activeGeocoder").field;
                    g = "";
                    this.reHostedFS.test(this.get("activeGeocoder").url) && this._containsNonLatinCharacter(c) && (g = "N");
                    h.where = d ? f + " \x3d " + g + "'" + c + "'" : "UPPER(" + f + ") LIKE " + g + "'%" + c.toUpperCase() + "%'";
                    k && (h.outFields = k);
                    this._task.execute(h, e.hitch(this, function(c) {
                        this._receivedResults(c.features,
                            a, b)
                    }), e.hitch(this, function(c) {
                        this._receivedResults([], a, b)
                    }))
                } else {
                    h = {};
                    this.get("activeGeocoder").categories && (h.categories = this.get("activeGeocoder").categories);
                    this._task.outSpatialReference = g;
                    if (this.get("map") && (this.get("activeGeocoder").localSearchOptions && this.get("activeGeocoder").localSearchOptions.hasOwnProperty("distance") && this.get("activeGeocoder").localSearchOptions.hasOwnProperty("minScale")) && (g = this.get("map").getScale(), !this.get("activeGeocoder").localSearchOptions.minScale ||
                            g && g <= parseFloat(this.get("activeGeocoder").localSearchOptions.minScale))) h.location = this.get("map").extent.getCenter(), h.distance = this.get("activeGeocoder").localSearchOptions.distance;
                    this.get("activeGeocoder").suggest && b.autoComplete ? (h.text = c, f && (h.searchExtent = f), this._task.suggestLocations(h).then(e.hitch(this, function(c) {
                        this._receivedResults(c, a, b)
                    }), e.hitch(this, function(c) {
                        this._receivedResults(c, a, b)
                    }))) : (h.address = {}, h.maxLocations = d, f && (h.searchExtent = f), this.get("activeGeocoder").sourceCountry &&
                        (h.countryCode = this.get("activeGeocoder").sourceCountry), b.magicKey && (h.magicKey = b.magicKey), this.get("activeGeocoder").singleLineFieldName ? h.address[this.get("activeGeocoder").singleLineFieldName] = c : h.address["Single Line Input"] = c, k && (h.outFields = k), this._task.addressToLocations(h, e.hitch(this, function(c) {
                            this._receivedResults(c, a, b)
                        }), e.hitch(this, function(c) {
                            this._receivedResults(c, a, b)
                        })))
                }
            } else this._hideLoading(), a.reject("Geocoder:: no search to perform");
            (c = this.get("map")) && c.enableKeyboardNavigation()
        },
        _showResults: function() {
            this._hideGeolocatorMenu();
            var a = "";
            if (this.get("results") && this.get("results").length && this.resultsNode) {
                for (var b = this.get("value"), c = RegExp("(" + b + ")", "gi"), a = a + '\x3cul role\x3d"presentation"\x3e', b = 0; b < this.get("results").length && 5 > b; ++b) {
                    var k = this.get("results")[b].text || this.get("results")[b].name,
                        d = this._css.resultsItemClass + " ",
                        d = 0 === b % 2 ? d + this._css.resultsItemOddClass : d + this._css.resultsItemEvenClass;
                    0 === b ? d += " " + this._css.resultsItemFirstClass : b === this.get("results").length -
                        1 && (d += " " + this._css.resultsItemLastClass);
                    a += '\x3cli title\x3d"' + k + '" data-text\x3d"' + k + '" data-item\x3d"true" data-index\x3d"' + b + '" role\x3d"menuitem" tabindex\x3d"0" class\x3d"' + d + '"\x3e' + k.replace(c, '\x3cstrong class\x3d"' + this._css.resultsPartialMatchClass + '"\x3e$1\x3c/strong\x3e') + "\x3c/li\x3e"
                }
                a += "\x3c/ul\x3e";
                this.resultsNode && (this.resultsNode.innerHTML = a);
                this._autoCompleteEvent();
                this._showResultsMenu()
            } else this.resultsNode && (this.resultsNode.innerHTML = a), this._hideResultsMenu()
        },
        _receivedResults: function(a,
            b) {
            this._hideLoading();
            var c = this._hydrateResults(a);
            this.set("results", c);
            c = {
                results: c,
                value: this.get("value")
            };
            b.resolve(c)
        },
        _showLoading: function() {
            g.add(this.containerNode, this._css.loadingClass)
        },
        _hideLoading: function() {
            g.remove(this.containerNode, this._css.loadingClass)
        },
        _showGeolocatorMenu: function() {
            g.add(this.containerNode, this._css.activeMenuClass);
            g.add(this.domNode, this._css.GeocoderMenuOpenClass);
            m.set(this.geocoderMenuNode, "display", "block");
            f.set(this.geocoderMenuInsertNode, "aria-hidden",
                "false");
            f.set(this.geocoderMenuArrowNode, "aria-expanded", "true")
        },
        _hideGeolocatorMenu: function() {
            g.remove(this.containerNode, this._css.activeMenuClass);
            g.remove(this.domNode, this._css.GeocoderMenuOpenClass);
            m.set(this.geocoderMenuNode, "display", "none");
            f.set(this.geocoderMenuInsertNode, "aria-hidden", "true");
            f.set(this.geocoderMenuArrowNode, "aria-expanded", "false")
        },
        _toggleGeolocatorMenu: function() {
            this._hideResultsMenu();
            "block" === m.get(this.geocoderMenuNode, "display") ? this._hideGeolocatorMenu() :
                this._showGeolocatorMenu()
        },
        _showResultsMenu: function() {
            g.add(this.containerNode, this._css.GeocoderActiveClass);
            g.add(this.domNode, this._css.GeocoderResultsOpenClass);
            m.set(this.resultsNode, "display", "block");
            f.set(this.resultsNode, "aria-hidden", "false")
        },
        _hideResultsMenu: function() {
            m.set(this.resultsNode, "display", "none");
            g.remove(this.containerNode, this._css.GeocoderActiveClass);
            g.remove(this.domNode, this._css.GeocoderResultsOpenClass);
            f.set(this.resultsNode, "aria-hidden", "true")
        },
        _hideMenus: function() {
            this._hideGeolocatorMenu();
            this._hideResultsMenu()
        },
        _insertGeocoderMenuItems: function() {
            if (this.get("geocoderMenu") && this._geocoders && 1 < this._geocoders.length) {
                var a, b = "",
                    c;
                a = '\x3cul role\x3d"presentation"\x3e';
                for (c = 0; c < this._geocoders.length; c++) {
                    b = this._css.resultsItemClass + " ";
                    b = 0 === c % 2 ? b + this._css.resultsItemOddClass : b + this._css.resultsItemEvenClass;
                    c === this.get("activeGeocoderIndex") && (b += " " + this._css.geocoderSelectedClass);
                    0 === c ? b += " " + this._css.resultsItemFirstClass : c === this._geocoders.length - 1 && (b += " " + this._css.resultsItemLastClass);
                    var d = this._geocoders[c].name || s.widgets.Geocoder.main.untitledGeocoder;
                    a += '\x3cli data-index\x3d"' + c + '" data-item\x3d"true" role\x3d"menuitem" tabindex\x3d"0" class\x3d"' + b + '"\x3e';
                    a += '\x3cdiv class\x3d"' + this._css.geocoderSelectedCheckClass + '"\x3e\x3c/div\x3e';
                    a += d;
                    a += '\x3cdiv class\x3d"' + this._css.GeocoderClearClass + '"\x3e\x3c/div\x3e';
                    a += "\x3c/li\x3e"
                }
                this.geocoderMenuInsertNode.innerHTML = a + "\x3c/ul\x3e";
                this._geocoderMenuEvent();
                m.set(this.geocoderMenuNode, "display", "none");
                m.set(this.geocoderMenuArrowNode,
                    "display", "block");
                g.add(this.containerNode, this._css.GeocoderMultipleClass)
            } else this.geocoderMenuInsertNode.innerHTML = "", m.set(this.geocoderMenuNode, "display", "none"), m.set(this.geocoderMenuArrowNode, "display", "none"), g.remove(this.containerNode, this._css.GeocoderMultipleClass)
        },
        _checkStatus: function() {
            this.get("value") ? (g.add(this.containerNode, this._css.hasValueClass), f.set(this.clearNode, "title", s.widgets.Geocoder.main.clearButtonTitle)) : this.clear()
        },
        _autoCompleteEvent: function() {
            var a = r('[data-item\x3d"true"]',
                this.resultsNode);
            this._acEvent && this._acEvent.remove();
            this._acEvent = l(a, "click, keydown", e.hitch(this, function(b) {
                this._clearQueryTimeout();
                var c = parseInt(f.get(b.currentTarget, "data-index"), 10),
                    k = f.get(b.currentTarget, "data-text");
                "click" === b.type || "keydown" === b.type && b.keyCode === d.ENTER ? (f.set(this.inputNode, "value", k), this.set("value", k), this.get("results") && this.get("results")[c] && (b = this.get("results")[c], b.name ? this.select(b) : this._query({
                    delay: 0,
                    search: b.text,
                    magicKey: b.magicKey || null
                }).then(e.hitch(this,
                    function(a) {
                        this.select(a.results[0])
                    })))) : "keydown" === b.type && (b.keyCode === d.BACKSPACE || b.keyCode === d.DELETE) ? (n.stop(b), this.inputNode.focus(), b = this.inputNode.value.slice(0, -1), f.set(this.inputNode, "value", b), this.set("value", b)) : "keydown" === b.type && b.keyCode === d.UP_ARROW ? (n.stop(b), b = c - 1, 0 > b ? this.inputNode.focus() : a[b].focus()) : "keydown" === b.type && b.keyCode === d.DOWN_ARROW ? (n.stop(b), b = c + 1, b >= a.length ? this.inputNode.focus() : a[b].focus()) : b.keyCode === d.ESCAPE && this._hideMenus()
            }))
        },
        _geocoderMenuEvent: function() {
            var a =
                r('[data-item\x3d"true"]', this.geocoderMenuInsertNode);
            this._gmEvent && this._gmEvent.remove();
            this._gmEvent = l(a, "click, keydown", e.hitch(this, function(b) {
                var c = parseInt(f.get(b.currentTarget, "data-index"), 10);
                "click" === b.type || "keydown" === b.type && b.keyCode === d.ENTER ? (this._setActiveGeocoderIndex(null, null, c), this._hideGeolocatorMenu()) : "keydown" === b.type && b.keyCode === d.UP_ARROW ? (n.stop(b), b = c - 1, 0 > b ? this.geocoderMenuArrowNode.focus() : a[b].focus()) : "keydown" === b.type && b.keyCode === d.DOWN_ARROW ? (n.stop(b),
                    b = c + 1, b >= a.length ? this.geocoderMenuArrowNode.focus() : a[b].focus()) : b.keyCode === d.ESCAPE && this._hideGeolocatorMenu()
            }))
        },
        _removeEvents: function() {
            var a;
            if (this._events && this._events.length)
                for (a = 0; a < this._events.length; a++) this._events[a].remove();
            this._acEvent && this._acEvent.remove();
            this._gmEvent && this._gmEvent.remove();
            this._events = []
        },
        _setupEvents: function() {
            this._removeEvents();
            var a = l(document, "click", e.hitch(this, function(a) {
                this._hideResultsMenu(a)
            }));
            this._events.push(a);
            a = l(this.inputNode,
                "keyup", e.hitch(this, function(a) {
                    this._inputKeyUp(a)
                }));
            this._events.push(a);
            a = l(this.inputNode, "keydown", e.hitch(this, function(a) {
                this._inputKeyDown(a)
            }));
            this._events.push(a);
            a = l(this.geocoderMenuArrowNode, "keydown", this._geocoderMenuButtonKeyDown());
            this._events.push(a);
            this.get("map") && (a = l(this.get("map"), "click", e.hitch(this, function() {
                this.blur()
            })), this._events.push(a));
            this._geocoderMenuEvent();
            this._autoCompleteEvent()
        },
        _findThenSelect: function() {
            this.find().then(e.hitch(this, function(a) {
                a.results &&
                    a.results.length && (this.select(a.results[0]), this.onEnterKeySelect())
            }))
        },
        _inputKeyUp: function(a) {
            if (a) {
                this._clearQueryTimeout();
                var b = this.inputNode.value;
                this._ignoreUpdateValue = !0;
                this.set("value", b);
                this._ignoreUpdateValue = !1;
                var c = 0;
                b && (c = b.length);
                if (a.ctrlKey || a.shiftKey || a.metaKey || a.altKey || a.keyCode === d.copyKey || a.keyCode === d.ALT || a.keyCode === d.CTRL || a.keyCode === d.META || a.keyCode === d.SHIFT || a.keyCode === d.UP_ARROW || a.keyCode === d.DOWN_ARROW || a.keyCode === d.LEFT_ARROW || a.keyCode === d.RIGHT_ARROW) return a;
                a && a.keyCode === d.ENTER ? (this._cancelDeferreds(), this._findThenSelect()) : a && a.keyCode === d.ESCAPE ? (this._cancelDeferreds(), this._hideMenus()) : a && a.keyCode === d.TAB ? (this._cancelDeferreds(), this._hideMenus()) : this.get("autoComplete") && c >= this.get("minCharacters") ? this._autoComplete() : this._hideMenus();
                this._checkStatus()
            }
        },
        _cancelDeferreds: function() {
            if (this._deferreds.length) {
                for (var a = 0; a < this._deferreds.length; a++) this._deferreds[a].cancel("Geocoder:: stop query");
                this._deferreds = []
            }
        },
        _inputKeyDown: function(a) {
            var b =
                r('[data-item\x3d"true"]', this.resultsNode);
            a && a.keyCode === d.TAB ? (this._cancelDeferreds(), this._hideMenus()) : a && a.keyCode === d.UP_ARROW ? (n.stop(a), (a = b.length) && b[a - 1].focus()) : a && a.keyCode === d.DOWN_ARROW && (n.stop(a), b[0] && b[0].focus())
        },
        _geocoderMenuButtonKeyDown: function(a) {
            var b = r('[data-item\x3d"true"]', this.geocoderMenuInsertNode);
            a && a.keyCode === d.UP_ARROW ? (n.stop(a), this._showGeolocatorMenu(), (a = b.length) && b[a - 1].focus()) : a && a.keyCode === d.DOWN_ARROW && (n.stop(a), this._showGeolocatorMenu(), b[0] &&
                b[0].focus())
        },
        _inputClick: function() {
            this._hideGeolocatorMenu();
            this.get("value") || (this.clear(), this._hideMenus());
            this._checkStatus();
            var a = this.get("map");
            a && a.disableKeyboardNavigation()
        },
        _hydrateResult: function(a) {
            var b = {},
                c = this._defaultSR,
                d;
            this.get("map") && (c = this.get("map").spatialReference);
            if (a.hasOwnProperty("text") && a.hasOwnProperty("magicKey")) return a;
            if (a.hasOwnProperty("feature")) b.feature = new v(a.feature), (d = b.feature.geometry) && d.setSpatialReference(c);
            else if (a.hasOwnProperty("geometry")) {
                var e =
                    a.symbol || null;
                d = a.attributes || {};
                b.feature = new v(a.geometry, e, d, a.infoTemplate || null);
                (d = b.feature.geometry) && d.setSpatialReference(c)
            } else a.hasOwnProperty("location") ? (e = new w(a.location.x, a.location.y, c), d = {}, a.hasOwnProperty("attributes") && (d = a.attributes), a.hasOwnProperty("score") && (d.score = a.score), b.feature = new v(e, null, d, null)) : b.feature = null;
            if (a.hasOwnProperty("extent")) b.extent = new x(a.extent), b.extent.setSpatialReference(new u(c));
            else if (b.feature && b.feature.geometry) switch (b.feature.geometry.type) {
                case "extent":
                    b.extent =
                        b.feature.geometry;
                    break;
                case "multipoint":
                    b.extent = b.feature.geometry.getExtent();
                    break;
                case "polygon":
                    b.extent = b.feature.geometry.getExtent();
                    break;
                case "polyline":
                    b.extent = b.feature.geometry.getExtent();
                    break;
                case "point":
                    this.get("map") ? this.get("map").getScale() > this.get("zoomScale") ? b.extent = I.getExtentForScale(this.get("map"), this.get("zoomScale")).centerAt(b.feature.geometry) : b.extent = this.get("map").extent.centerAt(b.feature.geometry) : b.extent = new x({
                        xmin: b.feature.geometry.x - 0.25,
                        ymin: b.feature.geometry.y -
                            0.25,
                        xmax: b.feature.geometry.x + 0.25,
                        ymax: b.feature.geometry.y + 0.25,
                        spatialReference: {
                            wkid: 4326
                        }
                    })
            } else b.extent = null;
            a.hasOwnProperty("name") ? b.name = a.name : "query" === this.activeGeocoder.type && this.activeGeocoder.field && a.hasOwnProperty("attributes") && a.attributes.hasOwnProperty(this.activeGeocoder.field) ? b.name = a.attributes[this.activeGeocoder.field] : a.hasOwnProperty("Match_addr") && "string" === typeof a.Match_addr ? b.name = a.Match_addr : a.hasOwnProperty("address") && "object" === typeof a.address && a.address.hasOwnProperty("Match_addr") ?
                b.name = a.address.Match_addr : a.hasOwnProperty("address") && "string" === typeof a.address ? b.name = a.address : a.hasOwnProperty("address") && "object" === typeof a.address && a.address.hasOwnProperty("Address") ? b.name = a.address.Address : b.name = b.feature && b.feature.geometry ? b.feature.geometry.x + "," + b.feature.geometry.y : "";
            return b
        },
        _hydrateResults: function(a) {
            var b = [],
                c = 0;
            if (a && a.length)
                for (c; c < a.length; c++) {
                    var d = this._hydrateResult(a[c]);
                    b.push(d)
                }
            return b
        }
    })
});
},
'esri/tasks/locator':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/Deferred", "dojo/_base/json", "dojo/has", "../kernel", "../request", "../deferredUtils", "./Task", "./AddressCandidate"], function(t, f, u, p, l, z, A, q, v, y, m) {
    return t(y, {
        declaredClass: "esri.tasks.Locator",
        _eventMap: {
            "address-to-locations-complete": ["addresses"],
            "addresses-to-locations-complete": ["addresses"],
            "location-to-address-complete": ["address"],
            "suggest-locations-complete": ["suggestions"]
        },
        constructor: function(a) {
            this._geocodeHandler = f.hitch(this,
                this._geocodeHandler);
            this._geocodeAddressesHandler = f.hitch(this, this._geocodeAddressesHandler);
            this._reverseGeocodeHandler = f.hitch(this, this._reverseGeocodeHandler);
            this.registerConnectEvents()
        },
        outSpatialReference: null,
        setOutSpatialReference: function(a) {
            this.outSpatialReference = a
        },
        _geocodeHandler: function(a, b, k, g, c) {
            try {
                var h = a.candidates,
                    e;
                b = [];
                var d, n = h.length,
                    r = a.spatialReference,
                    f;
                for (d = 0; d < n; d++) {
                    e = h[d];
                    if (f = e.location) f.spatialReference = r;
                    b[d] = new m(e)
                }
                this._successHandler([b], "onAddressToLocationsComplete",
                    k, c)
            } catch (l) {
                this._errorHandler(l, g, c)
            }
        },
        _geocodeAddressesHandler: function(a, b, k, g, c) {
            try {
                var h = a.locations;
                b = [];
                var e, d = h.length,
                    n = a.spatialReference,
                    f;
                for (e = 0; e < d; e++) {
                    if (f = h[e].location) f.spatialReference = n;
                    b[e] = new m(h[e])
                }
                this._successHandler([b], "onAddressesToLocationsComplete", k, c)
            } catch (l) {
                this._errorHandler(l, g, c)
            }
        },
        addressToLocations: function(a, b, k, g, c) {
            var h, e, d, n, r, m, w;
            a.address && (g = k, k = b, b = a.outFields, c = a.searchExtent, w = a.countryCode, h = a.magicKey, e = a.distance, m = a.categories, a.location &&
                this.normalization && (d = a.location.normalize()), n = a.maxLocations, r = a.forStorage, a = a.address);
            c && (c = c.shiftCentralMeridian());
            var x = this.outSpatialReference;
            a = this._encode(f.mixin({}, this._url.query, a, {
                f: "json",
                outSR: x && l.toJson(x.toJson()),
                outFields: b && b.join(",") || null,
                searchExtent: c && l.toJson(c.toJson()),
                category: m && m.join(",") || null,
                countryCode: w || null,
                magicKey: h || null,
                distance: e || null,
                location: d || null,
                maxLocations: n || null,
                forStorage: r || null
            }));
            var t = this._geocodeHandler,
                u = this._errorHandler,
                s =
                new p(v._dfdCanceller);
            s._pendingDfd = q({
                url: this._url.path + "/findAddressCandidates",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    t(a, b, k, g, s)
                },
                error: function(a) {
                    u(a, g, s)
                }
            });
            return s
        },
        suggestLocations: function(a) {
            var b;
            b = new p;
            a.hasOwnProperty("location") && this.normalization && (a.location = a.location.normalize());
            a.searchExtent && (a.searchExtent = a.searchExtent.shiftCentralMeridian());
            a = this._encode(f.mixin({}, this._url.query, {
                f: "json",
                text: a.text,
                searchExtent: a.searchExtent && l.toJson(a.searchExtent.toJson()),
                category: a.categories && a.categories.join(",") || null,
                location: a.location || null,
                distance: a.distance || null
            }, {
                f: "json"
            }));
            q({
                url: this._url.path + "/suggest",
                content: a,
                callbackParamName: "callback"
            }).then(f.hitch(this, function(a) {
                a = a.suggestions || [];
                this.onSuggestLocationsComplete(a);
                b.resolve(a)
            }), f.hitch(this, function(a) {
                this._errorHandler(a);
                b.reject(a)
            }));
            return b
        },
        addressesToLocations: function(a, b, k) {
            var g = this.outSpatialReference,
                c = [];
            u.forEach(a.addresses, function(a, b) {
                c.push({
                    attributes: a
                })
            });
            a = this._encode(f.mixin({},
                this._url.query, {
                    addresses: l.toJson({
                        records: c
                    })
                }, {
                    f: "json",
                    outSR: g && l.toJson(g.toJson())
                }));
            var h = this._geocodeAddressesHandler,
                e = this._errorHandler,
                d = new p(v._dfdCanceller);
            d._pendingDfd = q({
                url: this._url.path + "/geocodeAddresses",
                content: a,
                callbackParamName: "callback",
                load: function(a, c) {
                    h(a, c, b, k, d)
                },
                error: function(a) {
                    e(a, k, d)
                }
            });
            return d
        },
        _reverseGeocodeHandler: function(a, b, f, g, c) {
            try {
                var h = new m({
                    address: a.address,
                    location: a.location,
                    score: 100
                });
                this._successHandler([h], "onLocationToAddressComplete",
                    f, c)
            } catch (e) {
                this._errorHandler(e, g, c)
            }
        },
        locationToAddress: function(a, b, k, g) {
            a && this.normalization && (a = a.normalize());
            var c = this.outSpatialReference;
            a = this._encode(f.mixin({}, this._url.query, {
                outSR: c && l.toJson(c.toJson()),
                location: a && l.toJson(a.toJson()),
                distance: b,
                f: "json"
            }));
            var h = this._reverseGeocodeHandler,
                e = this._errorHandler,
                d = new p(v._dfdCanceller);
            d._pendingDfd = q({
                url: this._url.path + "/reverseGeocode",
                content: a,
                callbackParamName: "callback",
                load: function(a, b) {
                    h(a, b, k, g, d)
                },
                error: function(a) {
                    e(a,
                        g, d)
                }
            });
            return d
        },
        onSuggestLocationsComplete: function() {},
        onAddressToLocationsComplete: function() {},
        onAddressesToLocationsComplete: function() {},
        onLocationToAddressComplete: function() {}
    })
});
},
'esri/tasks/AddressCandidate':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../geometry/Point"], function(a, b, d, e, c) {
    return a(null, {
        declaredClass: "esri.tasks.AddressCandidate",
        constructor: function(a) {
            b.mixin(this, a);
            this.location = new c(this.location)
        }
    })
});
},
'esri/dijit/HomeButton':function(){
//>>built
define(["dojo/Evented", "dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "dijit/_WidgetBase", "dijit/a11yclick", "dijit/_TemplatedMixin", "dojo/on", "dojo/Deferred", "dojo/text!./templates/HomeButton.html", "dojo/i18n!../nls/jsapi", "dojo/dom-class", "dojo/dom-style"], function(h, k, d, s, t, l, m, n, f, p, q, r, e, g) {
    return k("esri.dijit.HomeButton", [l, n, h], {
        templateString: q,
        options: {
            theme: "HomeButton",
            map: null,
            extent: null,
            fit: !1,
            visible: !0
        },
        constructor: function(c, a) {
            var b = d.mixin({}, this.options, c);
            this.domNode = a;
            this._i18n =
                r;
            this.set("map", b.map);
            this.set("theme", b.theme);
            this.set("visible", b.visible);
            this.set("extent", b.extent);
            this.set("fit", b.fit);
            this.watch("theme", this._updateThemeWatch);
            this.watch("visible", this._visible);
            this._css = {
                container: "homeContainer",
                home: "home",
                loading: "loading"
            }
        },
        postCreate: function() {
            this.inherited(arguments);
            this.own(f(this._homeNode, m, d.hitch(this, this.home)))
        },
        startup: function() {
            this.map || (this.destroy(), console.log("HomeButton::map required"));
            if (this.map.loaded) this._init();
            else f.once(this.map,
                "load", d.hitch(this, function() {
                    this._init()
                }))
        },
        destroy: function() {
            this.inherited(arguments)
        },
        home: function() {
            var c = new p,
                a = this.get("extent");
            this._showLoading();
            var b = {
                extent: a
            };
            a ? this.map.extent !== a ? this.map.setExtent(a, this.get("fit")).then(d.hitch(this, function() {
                    this._hideLoading();
                    this.emit("home", b);
                    c.resolve(b)
                }), d.hitch(this, function(a) {
                    a || (a = Error("HomeButton::Error setting map extent"));
                    b.error = a;
                    this.emit("home", b);
                    c.reject(a)
                })) : (this._hideLoading(), this.emit("home", b), c.resolve(b)) :
                (this._hideLoading(), a = Error("HomeButton::home extent is undefined"), b.error = a, this.emit("home", b), c.reject(a));
            return c.promise
        },
        show: function() {
            this.set("visible", !0)
        },
        hide: function() {
            this.set("visible", !1)
        },
        _init: function() {
            this._visible();
            this.get("extent") || this.set("extent", this.map.extent);
            this.set("loaded", !0);
            this.emit("load", {})
        },
        _showLoading: function() {
            e.add(this._homeNode, this._css.loading)
        },
        _hideLoading: function() {
            e.remove(this._homeNode, this._css.loading)
        },
        _updateThemeWatch: function(c,
            a, b) {
            e.remove(this.domNode, a);
            e.add(this.domNode, b)
        },
        _visible: function() {
            this.get("visible") ? g.set(this.domNode, "display", "block") : g.set(this.domNode, "display", "none")
        }
    })
});
},
'esri/dijit/Legend':function(){
//>>built
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/json", "dojo/_base/Color", "dojo/has", "dojo/sniff", "dojo/DeferredList", "dojo/json", "dojo/number", "dojo/dom", "dojo/dom-construct", "dojo/dom-style", "dijit/_Widget", "dojox/gfx", "dojox/gfx/matrix", "dojox/html/entities", "../kernel", "../config", "../request", "../lang", "../renderers/SimpleRenderer", "../renderers/UniqueValueRenderer", "../renderers/ClassBreaksRenderer", "../renderers/ScaleDependentRenderer", "../renderers/DotDensityRenderer", "../renderers/TemporalRenderer", "../renderers/HeatmapRenderer", "../symbols/SimpleMarkerSymbol", "../symbols/PictureFillSymbol", "../symbols/jsonUtils", "./_EventedWidget", "dojo/i18n!../nls/jsapi", "dojo/i18n!dojo/cldr/nls/number"], function(A, K, s, m, n, L, y, v, $, M, N, F, q, e, t, O, G, P, Q, aa, H, I, D, B, J, E, R, S, T, U, V, W, C, X, Y, Z) {
    var x = K([X, O], {
        declaredClass: "esri.dijit.Legend",
        widgetsInTemplate: !1,
        layers: null,
        alignRight: !1,
        hoverLabelShowing: !1,
        dotDensitySwatchSize: 26,
        dotCoverage: 75,
        reZeros: RegExp("\\" + Z.decimal + "0+$", "g"),
        reZerosFractional: RegExp("(\\d)0*$", "g"),
        _ieTimer: 100,
        _isRightToLeft: !1,
        _align: null,
        _legendAlign: null,
        constructor: function(a, b) {
            s.mixin(this, Y.widgets.legend);
            a = a || {};
            a.map ? b ? (this.map = a.map, this.layerInfos = a.layerInfos, this._respectCurrentMapScale = !1 === a.respectCurrentMapScale ? !1 : !0, this.arrangement = a.arrangement === x.ALIGN_RIGHT ? x.ALIGN_RIGHT : x.ALIGN_LEFT, this.arrangement === x.ALIGN_RIGHT && (this.alignRight = !0), this.autoUpdate = !1 === a.autoUpdate ? !1 : !0, this._surfaceItems = []) : console.error("esri.dijit.Legend: must specify a container for the legend") : console.error("esri.dijit.Legend: unable to find the 'map' property in parameters")
        },
        postMixInProperties: function() {
            this.inherited(arguments);
            var a = ["ar", "he"],
                b, c;
            for (b = 0; b < a.length; b += 1) c = a[b], A.locale &&
                -1 !== A.locale.indexOf(c) && (-1 !== A.locale.indexOf("-") ? -1 !== A.locale.indexOf(c + "-") && (this._isRightToLeft = !0) : this._isRightToLeft = !0);
            this._isRightToLeft ? (this._align = this.alignRight ? "left" : "right", this._legendAlign = this.alignRight ? "esriLegendLeft" : "esriLegendRight") : (this._align = this.alignRight ? "right" : "left", this._legendAlign = this.alignRight ? "esriLegendRight" : "esriLegendLeft")
        },
        startup: function() {
            this.inherited(arguments);
            this._initialize();
            9 > v("ie") && (this._repaintItems = s.hitch(this, this._repaintItems),
                setTimeout(this._repaintItems, this._ieTimer))
        },
        destroy: function() {
            this._deactivate();
            this._removeHoverHandlers();
            this.inherited(arguments)
        },
        refresh: function(a) {
            if (this.domNode) {
                a ? (this.layerInfos = a, this.layers = [], m.forEach(this.layerInfos, function(a) {
                    this._isSupportedLayerType(a.layer) && (a.title && (a.layer._titleForLegend = a.title), a.layer._hideDefaultSymbol = !1 === a.defaultSymbol ? !0 : !1, a.hideLayers ? (a.layer._hideLayersInLegend = a.hideLayers, this._addSubLayersToHide(a)) : a.layer._hideLayersInLegend = [],
                        a.hoverLabel && (a.layer._hoverLabel = a.hoverLabel), a.hoverLabels && (a.layer._hoverLabels = a.hoverLabels), this.layers.push(a.layer))
                }, this)) : this.useAllMapLayers && (this.layers = this.layerInfos = null);
                for (a = this.domNode.children.length - 1; 0 <= a; a--) e.destroy(this.domNode.children[a]);
                this._removeHoverHandlers();
                this.startup()
            }
        },
        _legendUrl: "http://utility.arcgis.com/sharing/tools/legend",
        _initialize: function() {
            this.layerInfos && (this.layers = [], m.forEach(this.layerInfos, function(a) {
                this._isSupportedLayerType(a.layer) &&
                    (a.title && (a.layer._titleForLegend = a.title), a.layer._hideDefaultSymbol = !1 === a.defaultSymbol ? !0 : !1, a.hideLayers ? (a.layer._hideLayersInLegend = a.hideLayers, this._addSubLayersToHide(a)) : a.layer._hideLayersInLegend = [], a.hoverLabel && (a.layer._hoverLabel = a.hoverLabel), a.hoverLabels && (a.layer._hoverLabels = a.hoverLabels), this.layers.push(a.layer))
            }, this));
            this.useAllMapLayers = !1;
            if (!this.layers) {
                this.useAllMapLayers = !0;
                this.layers = [];
                var a = [],
                    b = [];
                m.forEach(this.map.layerIds, function(c) {
                    c = this.map.getLayer(c);
                    var d;
                    this._isSupportedLayerType(c) && (c.arcgisProps && c.arcgisProps.title && (c._titleForLegend = c.arcgisProps.title), this.layers.push(c));
                    "esri.layers.KMLLayer" == c.declaredClass && (d = c.getLayers(), m.forEach(d, function(b) {
                        a.push(b.id)
                    }, this));
                    "esri.layers.GeoRSSLayer" == c.declaredClass && (d = c.getFeatureLayers(), m.forEach(d, function(a) {
                        b.push(a.id)
                    }, this))
                }, this);
                m.forEach(this.map.graphicsLayerIds, function(c) {
                    var d = this.map.getLayer(c); - 1 == m.indexOf(a, c) && -1 == m.indexOf(b, c) && (this._isSupportedLayerType(d) &&
                        d._params && d._params.drawMode) && (d.arcgisProps && d.arcgisProps.title && (d._titleForLegend = d.arcgisProps.title), this.layers.push(d))
                }, this)
            }
            this._createLegend()
        },
        _activate: function() {
            this._deactivate();
            this.autoUpdate && (this._respectCurrentMapScale && (this._ozeConnect = n.connect(this.map, "onZoomEnd", this, "_refreshLayers")), this.useAllMapLayers && (this._olaConnect = n.connect(this.map, "onLayerAdd", this, "_updateAllMapLayers"), this._olrConnect = n.connect(this.map, "onLayerRemove", this, "_updateAllMapLayers"), this._olroConnect =
                n.connect(this.map, "onLayersReordered", this, "_updateAllMapLayers")), m.forEach(this.layers, function(a) {
                a.ovcConnect = n.connect(a, "onVisibilityChange", this, "_refreshLayers");
                a.oscConnect = n.connect(a, "onScaleRangeChange", this, "_refreshLayers");
                "esri.layers.ArcGISDynamicMapServiceLayer" === a.declaredClass && a.supportsDynamicLayers && (a.odcConnect = n.connect(a, "_onDynamicLayersChange", s.hitch(this, "_updateDynamicLayers", a)));
                "esri.layers.ArcGISImageServiceLayer" === a.declaredClass && (a.oirConnect = n.connect(a,
                    "onRenderingChange", s.partial(this._updateImageServiceLayers, this, a)))
            }, this))
        },
        _deactivate: function() {
            this._ozeConnect && n.disconnect(this._ozeConnect);
            this._olaConnect && n.disconnect(this._olaConnect);
            this._olroConnect && n.disconnect(this._olroConnect);
            this._olrConnect && n.disconnect(this._olrConnect);
            m.forEach(this.layers, function(a) {
                a.ovcConnect && n.disconnect(a.ovcConnect);
                a.oscConnect && n.disconnect(a.oscConnect);
                a.odcConnect && n.disconnect(a.odcConnect);
                a.oirConnect && n.disconnect(a.oirConnect)
            }, this)
        },
        _updateDynamicLayers: function(a) {
            delete a.legendResponse;
            this._refreshLayers()
        },
        _updateImageServiceLayers: function(a, b) {
            delete b.legendResponse;
            a._refreshLayers()
        },
        _refreshLayers: function() {
            this.refresh()
        },
        _updateAllMapLayers: function() {
            this.layers = [];
            m.forEach(this.map.layerIds, function(a) {
                a = this.map.getLayer(a);
                this._isSupportedLayerType(a) && this.layers.push(a)
            }, this);
            m.forEach(this.map.graphicsLayerIds, function(a) {
                a = this.map.getLayer(a);
                this._isSupportedLayerType(a) && (a._params && a._params.drawMode) &&
                    this.layers.push(a)
            }, this);
            this.refresh()
        },
        _createLegend: function() {
            var a = !1;
            t.set(this.domNode, "position", "relative");
            e.create("div", {
                id: this.id + "_msg",
                className: "esriLegendMsg",
                innerHTML: this.NLS_creatingLegend + "..."
            }, this.domNode);
            var b = [];
            m.forEach(this.layers, function(c) {
                if ("esri.layers.KMLLayer" == c.declaredClass || "esri.layers.GeoRSSLayer" == c.declaredClass) {
                    var f;
                    c.loaded ? ("esri.layers.KMLLayer" == c.declaredClass ? f = c.getLayers() : "esri.layers.GeoRSSLayer" == c.declaredClass && (f = c.getFeatureLayers(),
                        c._hideLayersInLegend && (f = m.filter(f, function(a) {
                            return -1 == m.indexOf(c._hideLayersInLegend, a.id)
                        }))), m.forEach(f, function(a) {
                        "esri.layers.FeatureLayer" == a.declaredClass && c._titleForLegend && (a._titleForLegend = c._titleForLegend + " - ", "esriGeometryPoint" == a.geometryType ? a._titleForLegend += this.NLS_points : "esriGeometryPolyline" == a.geometryType ? a._titleForLegend += this.NLS_lines : "esriGeometryPolygon" == a.geometryType && (a._titleForLegend += this.NLS_polygons), b.push(a))
                    }, this)) : n.connect(c, "onLoad", s.hitch(this,
                        function() {
                            this.refresh(this.layerInfos)
                        }))
                } else if ("esri.layers.WMSLayer" === c.declaredClass)
                    if (c.loaded) {
                        if (c.visible && 0 < c.layerInfos.length && m.some(c.layerInfos, function(a) {
                                return a.legendURL
                            })) {
                            var g = !1;
                            m.forEach(c.layerInfos, function(b) {
                                b.legendURL && -1 < m.indexOf(c.visibleLayers, b.name) && (g || (e.create("div", {
                                    innerHTML: "\x3cspan class\x3d'esriLegendServiceLabel'\x3e" + (c._titleForLegend || c.name || c.id) + "\x3c/span\x3e"
                                }, this.domNode), g = !0), e.create("div", {
                                        innerHTML: "\x3cimg src\x3d'" + b.legendURL + "'/\x3e"
                                    },
                                    this.domNode), a = !0)
                            }, this)
                        }
                    } else n.connect(c, "onLoad", s.hitch(this, function() {
                        this.refresh(this.layerInfos)
                    }));
                else b.push(c)
            }, this);
            var c = [];
            m.forEach(b, function(a) {
                if (a.loaded) {
                    if (!0 === a.visible && (a.layerInfos || a.renderer || "esri.layers.ArcGISImageServiceLayer" == a.declaredClass)) {
                        var b = e.create("div", {
                            id: this.id + "_" + a.id,
                            style: {
                                display: "none"
                            },
                            "class": "esriLegendService"
                        });
                        e.create("span", {
                            innerHTML: this._getServiceTitle(a),
                            "class": "esriLegendServiceLabel"
                        }, e.create("td", {
                            align: this._align
                        }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                            width: "95%"
                        }, b)))));
                        e.place(b, this.id, "first");
                        a.legendResponse || a.renderer ? this._createLegendForLayer(a) : c.push(this._legendRequest(a))
                    }
                } else var g = n.connect(a, "onLoad", this, function(a) {
                    n.disconnect(g);
                    g = null;
                    this.refresh()
                })
            }, this);
            0 === c.length && !a ? (q.byId(this.id + "_msg").innerHTML = this.NLS_noLegend, this._activate()) : (new M(c)).addCallback(s.hitch(this, function(b) {
                a ? q.byId(this.id + "_msg").innerHTML = "" : q.byId(this.id + "_msg").innerHTML = this.NLS_noLegend;
                this._activate()
            }))
        },
        _createLegendForLayer: function(a) {
            if (a.legendResponse || a.renderer) {
                var b = !1;
                if (a.legendResponse) {
                    var c = a.dynamicLayerInfos || a.layerInfos;
                    c && c.length ? m.forEach(c, function(c, f) {
                        if (!a._hideLayersInLegend || -1 == m.indexOf(a._hideLayersInLegend, c.id)) {
                            var g = this._buildLegendItems(a, c, f);
                            b = b || g
                        }
                    }, this) : "esri.layers.ArcGISImageServiceLayer" == a.declaredClass && (b = this._buildLegendItems(a, {
                        id: 0,
                        name: null,
                        title: a.name,
                        subLayerIds: null,
                        parentLayerId: -1
                    }, 0))
                } else a.renderer && (c = a.url ? a.url.substring(a.url.lastIndexOf("/") +
                    1, a.url.length) : "fc_" + a.id, b = this._buildLegendItems(a, {
                    id: c,
                    name: null,
                    subLayerIds: null,
                    parentLayerId: -1
                }, 0));
                b && (t.set(q.byId(this.id + "_" + a.id), "display", "block"), t.set(q.byId(this.id + "_msg"), "display", "none"))
            }
        },
        _legendRequest: function(a) {
            if (a.loaded) return 10.01 <= a.version ? this._legendRequestServer(a) : this._legendRequestTools(a);
            n.connect(a, "onLoad", s.hitch(this, "_legendRequest"))
        },
        _legendRequestServer: function(a) {
            var b = a.url,
                c = b.indexOf("?"),
                b = -1 < c ? b.substring(0, c) + "/legend" + b.substring(c) : b + "/legend";
            (c = a._getToken()) && (b += "?token\x3d" + c);
            var d = s.hitch(this, "_processLegendResponse"),
                c = {
                    f: "json"
                };
            a._params.dynamicLayers && (c.dynamicLayers = N.stringify(this._createDynamicLayers(a)), "[{}]" === c.dynamicLayers && (c.dynamicLayers = "[]"));
            a._params.bandIds && (c.bandIds = a._params.bandIds);
            a._params.renderingRule && (c.renderingRule = a._params.renderingRule);
            return I({
                url: b,
                content: c,
                callbackParamName: "callback",
                load: function(b, c) {
                    d(a, b, c)
                },
                error: H.defaults.io.errorHandler
            })
        },
        _legendRequestTools: function(a) {
            var b =
                a.url.toLowerCase().indexOf("/rest/"),
                b = a.url.substring(0, b) + a.url.substring(b + 5, a.url.length),
                b = this._legendUrl + "?soapUrl\x3d" + window.escape(b);
            if (!v("ie") || 8 < v("ie")) b += "\x26returnbytes\x3dtrue";
            var c = s.hitch(this, "_processLegendResponse");
            return I({
                url: b,
                content: {
                    f: "json"
                },
                callbackParamName: "callback",
                load: function(b, f) {
                    c(a, b, f)
                },
                error: H.defaults.io.errorHandler
            })
        },
        _processLegendResponse: function(a, b) {
            b && b.layers ? (a.legendResponse = b, q.byId(this.id + "_" + a.id) && e.empty(q.byId(this.id + "_" + a.id)), e.create("span", {
                innerHTML: this._getServiceTitle(a),
                "class": "esriLegendServiceLabel"
            }, e.create("td", {
                align: this._align
            }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                width: "95%"
            }, q.byId(this.id + "_" + a.id)))))), this._createLegendForLayer(a)) : console.log("Legend could not get generated for " + a.url + ": " + L.toJson(b))
        },
        _buildLegendItems: function(a, b, c) {
            var d = !1,
                f = q.byId(this.id + "_" + a.id),
                g = b.parentLayerId;
            if (b.subLayerIds) a = e.create("div", {
                id: this.id + "_" + a.id + "_" + b.id + "_group",
                style: {
                    display: "none"
                },
                "class": -1 ==
                    g ? 0 < c ? "esriLegendGroupLayer" : "" : this._legendAlign
            }, -1 == g ? f : q.byId(this.id + "_" + a.id + "_" + g + "_group")), e.create("td", {
                innerHTML: b.name,
                align: this._align
            }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                width: "95%",
                "class": "esriLegendLayerLabel"
            }, a))));
            else {
                if (a.visibleLayers && -1 == ("," + a.visibleLayers + ",").indexOf("," + b.id + ",")) return d;
                c = e.create("div", {
                    id: this.id + "_" + a.id + "_" + b.id,
                    style: {
                        display: "none"
                    },
                    "class": -1 < g ? this._legendAlign : ""
                }, -1 == g ? f : q.byId(this.id + "_" + a.id + "_" + g + "_group"));
                e.create("td", {
                    innerHTML: b.name || "",
                    align: this._align
                }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                    width: "95%",
                    "class": "esriLegendLayerLabel"
                }, c))));
                a.legendResponse ? d = d || this._buildLegendItems_Tools(a, b, c) : a.renderer && (d = d || this._buildLegendItems_Renderer(a, b, c))
            }
            return d
        },
        _buildLegendItems_Tools: function(a, b, c) {
            var d = b.parentLayerId,
                f = this.map.getScale(),
                g = !1,
                p = function(a, b) {
                    var c, d;
                    for (c = 0; c < a.length; c++)
                        if (b.dynamicLayerInfos)
                            for (d = 0; d < b.dynamicLayerInfos[d].length; d++) {
                                if (b.dynamicLayerInfos[d].mapLayerId ==
                                    a[c].layerId) return a[c]
                            } else if (b.id == a[c].layerId) return a[c];
                    return {}
                };
            if (!this._respectCurrentMapScale || this._respectCurrentMapScale && this._isLayerInScale(a, b, f)) {
                var l = !0;
                if ("esri.layers.ArcGISDynamicMapServiceLayer" === a.declaredClass || "esri.layers.ArcGISMapServiceLayer" === a.declaredClass) {
                    var k = this._getEffectiveScale(a, b);
                    if (k.minScale && k.minScale < f || k.maxScale && k.maxScale > f) l = !1
                }
                if (l) {
                    var f = p(a.legendResponse.layers, b),
                        h = f.legendType,
                        w = f.legend;
                    if (w) {
                        c = e.create("table", {
                            cellpadding: 0,
                            cellspacing: 0,
                            width: "95%",
                            "class": "esriLegendLayer"
                        }, c);
                        var r = e.create("tbody", {}, c);
                        (a._hoverLabel || a._hoverLabels) && this._createHoverAction(c, a, b);
                        m.forEach(w, function(c) {
                            if (!(10.1 <= a.version && !c.values && 1 < w.length && (a._hideDefaultSymbol || "\x3call other values\x3e" === c.label || !c.label && !("esri.layers.ArcGISImageServiceLayer" === a.declaredClass && 10.3 <= a.version))))
                                if (c.url && 0 === c.url.indexOf("http") || c.imageData && 0 < c.imageData.length) g = !0, this._buildRow_Tools(c, r, a, b.id, h)
                        }, this)
                    }
                }
            }
            g && (t.set(q.byId(this.id + "_" +
                a.id + "_" + b.id), "display", "block"), -1 < d && (t.set(q.byId(this.id + "_" + a.id + "_" + d + "_group"), "display", "block"), this._findParentGroup(a.id, a, d)));
            return g
        },
        _buildRow_Tools: function(a, b, c, d, f) {
            var g = e.create("tr", {}, b),
                p;
            this.alignRight ? (b = e.create("td", {
                align: this._isRightToLeft ? "left" : "right"
            }, g), p = e.create("td", {
                align: this._isRightToLeft ? "left" : "right",
                width: 35
            }, g)) : (p = e.create("td", {
                width: 35
            }, g), b = e.create("td", {}, g));
            g = a.url;
            (!v("ie") || 9 <= v("ie") || 9 > v("ie") && "esri.layers.ArcGISImageServiceLayer" ===
                c.declaredClass) && a.imageData && 0 < a.imageData.length ? g = "data:image/png;base64," + a.imageData : 0 !== a.url.indexOf("http") && (g = c.url + "/" + d + "/images/" + a.url, (d = c._getToken()) && (g += "?token\x3d" + d));
            d = e.create("img", {
                src: g,
                border: 0,
                style: "opacity:" + c.opacity
            }, p);
            a = e.create("td", {
                innerHTML: a.label,
                align: this._align
            }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                width: "95%",
                dir: "ltr"
            }, b))));
            f && ("Stretched" === f && 10.3 <= c.version && "esri.layers.ArcGISImageServiceLayer" === c.declaredClass) && (a.style.verticalAlign =
                "top", a.style.lineHeight = "1", d.style.marginBottom = "-1px", d.style.display = "block", b.style.verticalAlign = "top");
            9 > v("ie") && (d.style.filter = "alpha(opacity\x3d" + 100 * c.opacity + ")")
        },
        _getVariable: function(a, b) {
            return a ? a[b] || m.filter(a.visualVariables, function(a) {
                return a.type === b
            })[0] : null
        },
        _buildLegendItems_Renderer: function(a, b, c) {
            var d = b.parentLayerId,
                f = this.map,
                g = f.getScale(),
                p = !1;
            if (!this._respectCurrentMapScale || this._isLayerInScale(a, b, g)) {
                var l, k, h = a.renderer,
                    w, r, u, n, z;
                if (h instanceof R && (h = (h =
                        "zoom" === h.rangeType ? h.getRendererInfoByZoom(f.getZoom()) : h.getRendererInfoByScale(g)) && h.renderer, !h)) return !1;
                var f = this._getVariable(h, "colorInfo"),
                    g = this._getVariable(h, "opacityInfo"),
                    v = this._getVariable(h, "sizeInfo");
                f ? (w = this._getMedianColor(h, f), f.field && (u = s.isFunction(f.field) ? null : a._getField(f.field, !0))) : g && (z = s.isFunction(g.field) ? null : a._getField(g.field, !0));
                v && v.field && (n = s.isFunction(v.field) ? null : a._getField(v.field, !0));
                if (h instanceof U) p = !0, this._showHeatRamp(a, b, h, c);
                else if (h instanceof S) p = !0, this._showDotDensityLegend(a, b, h, c);
                else if (h instanceof T) p = !0, k = e.create("table", {
                    cellpadding: 0,
                    cellspacing: 0,
                    width: "95%",
                    "class": "esriLegendLayer"
                }, c), l = e.create("tbody", {}, k), (a._hoverLabel || a._hoverLabels) && this._createHoverAction(k, a, b), h.latestObservationRenderer && h.latestObservationRenderer instanceof B && this._buildRow_Renderer(a, h.latestObservationRenderer.symbol, w, h.latestObservationRenderer.label || this.NLS_currentObservations, null, l), h.observationRenderer && h.observationRenderer instanceof
                B && this._buildRow_Renderer(a, h.observationRenderer.symbol, w, h.observationRenderer.label || this.NLS_previousObservations, null, l);
                else if (h instanceof J) {
                    if (h.infos && 0 < h.infos.length) {
                        p = !0;
                        k = e.create("table", {
                            cellpadding: 0,
                            cellspacing: 0,
                            width: "95%",
                            "class": "esriLegendLayer"
                        }, c);
                        l = e.create("tbody", {}, k);
                        (a._hoverLabel || a._hoverLabels) && this._createHoverAction(k, a, b);
                        var x = [];
                        m.forEach(h.infos, function(b) {
                            var c = null;
                            a._editable && a.types && (c = this._getTemplateFromTypes(a.types, b.value));
                            var d = b.label;
                            null ==
                                d && (d = b.value); - 1 === m.indexOf(x, d) && (x.push(d), this._buildRow_Renderer(a, b.symbol, w, d, c, l))
                        }, this)
                    }
                } else h instanceof E ? h.infos && 0 < h.infos.length && (p = !0, k = e.create("table", {
                    cellpadding: 0,
                    cellspacing: 0,
                    width: "95%",
                    "class": "esriLegendLayer"
                }, c), l = e.create("tbody", {}, k), (a._hoverLabel || a._hoverLabels) && this._createHoverAction(k, a, b), m.forEach(h.infos, function(b) {
                    var c = b.label;
                    null == c && (c = b.minValue + " - " + b.maxValue);
                    this._buildRow_Renderer(a, b.symbol, w, c, null, l)
                }, this)) : h instanceof B && (p = !0, k = e.create("table", {
                    cellpadding: 0,
                    cellspacing: 0,
                    width: "95%",
                    "class": "esriLegendLayer"
                }, c), l = e.create("tbody", {}, k), (a._hoverLabel || a._hoverLabels) && this._createHoverAction(k, a, b), r = null, a._editable && (a.templates && 0 < a.templates.length) && (r = a.templates[0]), k = (u || z) && n ? null : u || z || n, this._buildRow_Renderer(a, h.symbol, w, k ? k.alias || k.name : h.label, r, l), r = h.symbol && h.symbol.color, k && (u = z = n = null));
                p && (f && f.field ? (u && this._isSmartRenderer(h, u.name) && (u = null), this._showColorRamp(a, b, h, null, c, f, u)) : g && r && this._showColorRamp(a,
                    b, h, r, c, g, z), v && v.field && (n && this._isSmartRenderer(h, n.name) && (n = null), this._showSizeLegend(a, b, h, v, w, c, n)));
                !a._hideDefaultSymbol && h.defaultSymbol && (p = !0, k = e.create("table", {
                    cellpadding: 0,
                    cellspacing: 0,
                    width: "95%",
                    "class": "esriLegendLayer"
                }, c), l = e.create("tbody", {}, k), this._buildRow_Renderer(a, h.defaultSymbol, null, h.defaultLabel || "others", null, l))
            }
            p && (t.set(q.byId(this.id + "_" + a.id + "_" + b.id), "display", "block"), -1 < d && (t.set(q.byId(this.id + "_" + a.id + "_" + d + "_group"), "display", "block"), this._findParentGroup(a.id,
                d)));
            return p
        },
        _isSmartRenderer: function(a, b) {
            return a instanceof E && a.infos && 1 === a.infos.length && a.attributeField === b
        },
        _showColorRamp: function(a, b, c, d, f, g, p) {
            var l;
            l = e.create("table", {
                cellpadding: 0,
                cellspacing: 0,
                width: "95%",
                "class": "esriLegendLayer"
            }, f);
            f = e.create("tbody", {}, l);
            (a._hoverLabel || a._hoverLabels) && this._createHoverAction(l, a, b);
            p && this._addSubHeader(f, p.alias || p.name);
            b = this._getRampStops(c, g, d);
            b.length && this._drawColorRamp(f, b, a)
        },
        _getMedianColor: function(a, b) {
            var c, d;
            b.colors ? (c =
                b.minDataValue, d = b.maxDataValue) : b.stops && (c = b.stops[0].value, d = b.stops[b.stops.length - 1].value);
            return a.getColor(c + (d - c) / 2, {
                colorInfo: b
            })
        },
        _getRampStops: function(a, b, c) {
            var d, f, g, p, e = !1;
            b.colors || b.opacityValues ? (f = b.maxDataValue - b.minDataValue, d = m.map([0, 0.25, 0.5, 0.75, 1], function(a) {
                g = b.minDataValue + a * f;
                return Number(g.toFixed(6))
            }), this._checkPrecision(0, 4, d)) : b.stops && (d = m.map(b.stops, function(a) {
                return a.value
            }), (e = m.some(b.stops, function(a) {
                return !!a.label
            })) && (p = m.map(b.stops, function(a) {
                return a.label
            })));
            var k = d[0],
                h, n, r;
            f = d[d.length - 1] - k;
            return m.map(d, function(g, m) {
                c ? (h = new y(c.toRgba()), n = a.getOpacity(g, {
                    opacityInfo: b
                }), null != n && (h.a = n)) : h = a.getColor(g, {
                    colorInfo: b
                });
                r = "";
                0 === m ? r = "\u2264 " : m === d.length - 1 && (r = "\u2265 ");
                return {
                    value: g,
                    color: h,
                    offset: 1 - (g - k) / f,
                    label: e ? p[m] : r + F.format(g, {
                        places: 20,
                        round: -1
                    }).replace(this.reZerosFractional, "$1").replace(this.reZeros, "")
                }
            }, this).reverse()
        },
        _checkPrecision: function(a, b, c) {
            var d = a + (b - a) / 2,
                f = c[a],
                g = c[d],
                p = c[b],
                e = Math.floor(f),
                k = Math.floor(g),
                h = Math.floor(p);
            e === f && (h === p && k !== g && e !== k && h !== k) && (c[d] = k);
            a + 1 !== d && this._checkPrecision(a, d, c);
            d + 1 !== b && this._checkPrecision(d, b, c)
        },
        _drawColorRamp: function(a, b, c) {
            var d = e.create("tr", {}, a),
                f, g, p, l, k, h, n;
            this.alignRight ? (a = e.create("td", {
                align: this._isRightToLeft ? "left" : "right"
            }, d), f = e.create("td", {
                align: this._isRightToLeft ? "left" : "right",
                width: 34
            }, d)) : (f = e.create("td", {
                width: 34,
                align: "center"
            }, d), a = e.create("td", {}, d));
            g = e.create("div", {
                style: "position: relative; width:34px;"
            }, f);
            p = e.create("div", {
                    "class": "esriLegendColorRamp"
                },
                g);
            d = t.get(p, "width");
            f = t.get(p, "height");
            t.set(g, "height", f + "px");
            p = G.createSurface(p, d, f);
            9 > v("ie") && (k = p.getEventSource(), t.set(k, "position", "relative"), t.set(k.parentNode, "position", "relative"));
            try {
                h = p.createRect({
                    width: d,
                    height: f
                }), h.setFill({
                    type: "linear",
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: f,
                    colors: b
                }).setStroke(null), p.createRect({
                    width: d,
                    height: f
                }).setFill(new y([255, 255, 255, 1 - c.opacity])).setStroke(null), this._surfaceItems.push(p)
            } catch (r) {
                p.clear(), p.destroy()
            }
            l = e.create("div", {
                    "class": "esriLegendColorRampLabels"
                },
                a);
            m.forEach(b, function(a, c) {
                a.label && (n = "top:" + 100 * a.offset + "%;", e.create("div", {
                    "class": "esriLegendColorRampTick" + (c === b.length - 1 ? " esriLegendColorRampTickLast" : ""),
                    innerHTML: "\x26nbsp;",
                    style: n
                }, g), e.create("div", {
                    "class": "esriLegendColorRampLabel",
                    innerHTML: a.label,
                    style: n
                }, l))
            })
        },
        _showHeatRamp: function(a, b, c, d) {
            var f, g = c.field;
            f = e.create("table", {
                cellpadding: 0,
                cellspacing: 0,
                width: "95%",
                "class": "esriLegendLayer"
            }, d);
            d = e.create("tbody", {}, f);
            (a._hoverLabel || a._hoverLabels) && this._createHoverAction(f,
                a, b);
            (g = g && a.getField(g)) && this._addSubHeader(d, g.alias || g.name);
            b = this._getHeatmapStops(c);
            b.length && this._drawColorRamp(d, b, a)
        },
        _getHeatmapStops: function(a) {
            var b = a.colorStops;
            a = a.colors;
            var c, d, f, g;
            if (b && b[0])
                if (c = b.length - 1, a = b[0] && null != b[0].ratio) {
                    if ((a = b[c]) && 1 !== a.ratio) b = b.slice(0), b.push({
                        ratio: 1,
                        color: a.color
                    }), c++
                } else d = b[0].value, f = b[c].value - d, b = m.map(b, function(a) {
                    return {
                        color: a.color,
                        ratio: (a.value - d) / f
                    }
                });
            else a && a[0] && (c = a.length - 1, g = 1 / (a.length - 1), b = m.map(a, function(a, b) {
                return {
                    color: a,
                    ratio: b * g
                }
            }));
            b = m.map(b, function(a, b) {
                var d = "";
                0 === b ? d = "Low" : b === c && (d = "High");
                return {
                    color: a.color,
                    label: d,
                    offset: 1 - a.ratio
                }
            });
            return b.reverse()
        },
        _showDotDensityLegend: function(a, b, c, d) {
            var f = c.legendOptions,
                g, p, l, k, h, n, r, u = this.dotDensitySwatchSize,
                q = Math.round(u / 2);
            f && (p = f.backgroundColor, l = f.outline, k = f.valueUnit, h = f.dotCoverage);
            h = (h || this.dotCoverage) / 100;
            r = Math.round(u * u / Math.pow(c.dotSize, 2) * h);
            d = e.create("table", {
                cellpadding: 0,
                cellspacing: 0,
                width: "95%",
                "class": "esriLegendLayer"
            }, d);
            n = e.create("tbody", {}, d);
            (a._hoverLabel || a._hoverLabels) && this._createHoverAction(d, a, b);
            this._addSubHeader(n, D.substitute({
                value: c.dotValue,
                unit: k || ""
            }, this.NLS_dotValue));
            m.forEach(c.fields, function(b) {
                b = s.mixin({}, b);
                b.numPoints = r;
                g = new W(c._generateImageSrc(u, u, [b], {
                    x: 0,
                    y: 0
                }, {
                    x: u,
                    y: u
                }, p), l || c.outline, u, u);
                b = a._getField(b.name, !0) || b;
                this._buildRow_Renderer(a, g, null, b.alias || b.name, null, n, {
                    type: "path",
                    path: "M " + -q + "," + -q + " L " + q + "," + -q + " L " + q + "," + q + " L " + -q + "," + q + " L " + -q + "," + -q + " E"
                })
            }, this)
        },
        _showSizeLegend: function(a,
            b, c, d, f, g, p) {
            var l = d.legendOptions,
                l = l && l.customValues,
                k, h = d.minDataValue,
                n = d.maxDataValue,
                r = this._getSizeSymbol(c, f);
            "unknown" !== d.valueUnit || (!r || !l && (null == h || null == n)) || (f = e.create("table", {
                cellpadding: 0,
                cellspacing: 0,
                width: "95%",
                "class": "esriLegendLayer"
            }, g), k = e.create("tbody", {}, f), (a._hoverLabel || a._hoverLabels) && this._createHoverAction(f, a, b), p && this._addSubHeader(k, p.alias || p.name), b = l || this._getDataValues(h, n), m.forEach(b, function(b) {
                r = C.fromJson(r.toJson());
                this._applySize(r, c, d, b);
                b = F.format(b, {
                    places: 20,
                    round: -1
                }).replace(this.reZerosFractional, "$1").replace(this.reZeros, "");
                this._buildRow_Renderer(a, r, null, b, null, k)
            }, this))
        },
        _getSizeSymbol: function(a, b) {
            var c, d;
            if (a instanceof B) d = !0, c = a.symbol;
            else if (a instanceof J || a instanceof E) c = a.infos[0].symbol;
            if (c = -1 !== c.type.indexOf("fillsymbol") ? null : c) !d && "picturemarkersymbol" === c.type ? (c = new V, c.setStyle("square"), c.outline.setWidth(1)) : c = C.fromJson(c.toJson()), b ? c.setColor(new y(b.toRgba())) : d || c.setColor(new y([127, 127, 127]));
            return c
        },
        _applySize: function(a, b, c, d) {
            var f = a.type;
            c = {
                sizeInfo: c,
                shape: -1 !== f.indexOf("markersymbol") ? a.style : null
            };
            b = b.getSize(d, c);
            switch (f) {
                case "simplemarkersymbol":
                    a.setSize(b);
                    break;
                case "picturemarkersymbol":
                    a.setWidth(b);
                    a.setHeight(b);
                    break;
                case "simplelinesymbol":
                case "cartographiclinesymbol":
                    a.setWidth(b)
            }
        },
        _getDataValues: function(a, b) {
            var c = [a, b],
                d = Math.LN10,
                f = Math.log(a),
                g = Math.log(b),
                e, l, k, h, n;
            m.forEach([1, 2.5, 5], function(a) {
                h = Math.log(a);
                e = Math.ceil((f - h) / d);
                l = Math.floor((g - h) / d);
                if (!(Infinity ===
                        Math.abs(e) || Infinity === Math.abs(l)))
                    for (k = e; k < l + 1; k++) n = a * Math.pow(10, k), -1 === m.indexOf(c, n) && c.push(n)
            });
            c.sort(this._sorter);
            return c.reverse()
        },
        _sorter: function(a, b) {
            return a - b
        },
        _buildRow_Renderer: function(a, b, c, d, f, g, p) {
            var l = e.create("tr", {}, g),
                k;
            this.alignRight ? (g = e.create("td", {
                align: this._isRightToLeft ? "left" : "right"
            }, l), k = e.create("td", {
                align: this._isRightToLeft ? "left" : "right",
                width: 35
            }, l)) : (k = e.create("td", {
                width: 35,
                align: "center"
            }, l), g = e.create("td", {}, l));
            var h = l = 30;
            "simplemarkersymbol" ==
            b.type ? (l = Math.min(Math.max(l, b.size + 12), 125), h = Math.min(Math.max(h, b.size + 12), 125)) : "picturemarkersymbol" == b.type && (l = Math.min(Math.max(l, b.width), 125), h = Math.min(b.height || h, 125));
            k = e.create("div", {
                style: "width:" + l + "px;height:" + h + "px;"
            }, k);
            D.isDefined(d) && "number" === typeof d && (d = "" + d);
            e.create("td", {
                innerHTML: d || "",
                align: this._align
            }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                width: "95%"
            }, g))));
            a = this._drawSymbol(k, b, c, l, h, f, a, p);
            this._surfaceItems.push(a)
        },
        _addSubHeader: function(a,
            b) {
            var c = e.create("tr", {}, a),
                c = e.create("td", {
                    align: this._align,
                    colspan: 2
                }, c);
            e.create("td", {
                innerHTML: b || "",
                align: this._align
            }, e.create("tr", {}, e.create("tbody", {}, e.create("table", {
                width: "95%"
            }, c))))
        },
        _drawSymbol: function(a, b, c, d, f, g, e, l) {
            b = C.fromJson(b.toJson());
            var k = e.opacity;
            c && b.setColor(new y(c.toRgba()));
            if ("simplelinesymbol" === b.type || "cartographiclinesymbol" === b.type || "textsymbol" === b.type) {
                if (!b.color) return;
                c = b.color.toRgba();
                c[3] *= k;
                b.color.setColor(c)
            } else if ("simplemarkersymbol" ===
                b.type || "simplefillsymbol" === b.type) {
                if (!b.color) return;
                c = b.color.toRgba();
                c[3] *= k;
                b.color.setColor(c);
                b.outline && b.outline.color && (c = b.outline.color.toRgba(), c[3] *= k, b.outline.color.setColor(c))
            } else "picturemarkersymbol" === b.type && (a.style.opacity = k, a.style.filter = "alpha(opacity\x3d(" + 100 * k + "))");
            a = G.createSurface(a, d, f);
            9 > v("ie") && (c = a.getEventSource(), t.set(c, "position", "relative"), t.set(c.parentNode, "position", "relative"));
            g = this._getDrawingToolShape(b, g) || C.getShapeDescriptors(b);
            var h;
            try {
                h =
                    a.createShape(l || g.defaultShape).setFill(g.fill).setStroke(g.stroke)
            } catch (n) {
                a.clear();
                a.destroy();
                return
            }
            var m = h.getBoundingBox();
            l = m.width;
            g = m.height;
            var k = -(m.x + l / 2),
                q = -(m.y + g / 2);
            c = a.getDimensions();
            k = {
                dx: k + c.width / 2,
                dy: q + c.height / 2
            };
            if ("simplemarkersymbol" === b.type && "path" === b.style) d = e._getScaleMatrix(m, b.size), h.applyTransform(P.scaleAt(d.xx, d.yy, {
                x: c.width / 2,
                y: c.height / 2
            }));
            else if (l > d || g > f) e = l / d > g / f, d = ((e ? d : f) - 5) / (e ? l : g), s.mixin(k, {
                xx: d,
                yy: d
            });
            h.applyTransform(k);
            return a
        },
        _getDrawingToolShape: function(a,
            b) {
            var c;
            switch (b ? b.drawingTool || null : null) {
                case "esriFeatureEditToolArrow":
                    c = {
                        type: "path",
                        path: "M 10,1 L 3,8 L 3,5 L -15,5 L -15,-2 L 3,-2 L 3,-5 L 10,1 E"
                    };
                    break;
                case "esriFeatureEditToolTriangle":
                    c = {
                        type: "path",
                        path: "M -10,14 L 2,-10 L 14,14 L -10,14 E"
                    };
                    break;
                case "esriFeatureEditToolRectangle":
                    c = {
                        type: "path",
                        path: "M -10,-10 L 10,-10 L 10,10 L -10,10 L -10,-10 E"
                    };
                    break;
                case "esriFeatureEditToolCircle":
                    c = {
                        type: "circle",
                        cx: 0,
                        cy: 0,
                        r: 10
                    };
                    break;
                case "esriFeatureEditToolEllipse":
                    c = {
                        type: "ellipse",
                        cx: 0,
                        cy: 0,
                        rx: 10,
                        ry: 5
                    };
                    break;
                default:
                    return null
            }
            return {
                defaultShape: c,
                fill: a.getFill(),
                stroke: a.getStroke()
            }
        },
        _repaintItems: function() {
            m.forEach(this._surfaceItems, function(a) {
                this._repaint(a)
            }, this)
        },
        _repaint: function(a) {
            if (a) {
                a.getStroke && a.setStroke && a.setStroke(a.getStroke());
                try {
                    a.getFill && a.setFill && a.setFill(a.getFill())
                } catch (b) {}
                a.children && s.isArray(a.children) && m.forEach(a.children, this._repaint, this)
            }
        },
        _createHoverAction: function(a, b, c) {
            var d = b._hoverLabel || b._hoverLabels[c.id];
            d && (b.mouseMoveHandler =
                b.mouseMoveHandler || {}, b.mouseMoveHandler[c.id] = n.connect(a, "onmousemove", s.hitch(this, function(a, b) {
                    this.mouseX = b.clientX;
                    this.mouseY = b.clientY;
                    this.hoverLabelShowing && (this.hoverLabelShowing = !1, t.set(q.byId(this.id + "_hoverLabel"), "display", "none"));
                    setTimeout(s.hitch(this, function(a, b, c) {
                        if (a == this.mouseX && b == this.mouseY && !this.hoverLabelShowing)
                            if (this.hoverLabelShowing = !0, q.byId(this.id + "_hoverLabel")) {
                                var d = q.byId(this.id + "_hoverLabel");
                                d.innerHTML = "\x3cspan\x3e" + c + "\x3c/span\x3e";
                                t.set(d, "top",
                                    b + "px");
                                t.set(d, "left", a + 15 + "px");
                                t.set(d, "display", "")
                            } else e.create("div", {
                                innerHTML: "\x3cspan\x3e" + c + "\x3c/span\x3e",
                                id: this.id + "_hoverLabel",
                                "class": "esriLegendHoverLabel",
                                style: {
                                    top: b + "px",
                                    left: a + 15 + "px"
                                }
                            }, document.body)
                    }, b.clientX, b.clientY, a), 500)
                }, d)), b.mouseOutHandler = b.mouseOutHandler || {}, b.mouseOutHandler[c.id] = n.connect(a, "onmouseout", s.hitch(this, function(a) {
                    this.mouseY = this.mouseX = -1;
                    this.hoverLabelShowing && (this.hoverLabelShowing = !1, t.set(q.byId(this.id + "_hoverLabel"), "display", "none"))
                })))
        },
        _removeHoverHandlers: function() {
            var a;
            m.forEach(this.layers, function(b) {
                if (b.mouseMoveHandler)
                    for (a in b.mouseMoveHandler) n.disconnect(b.mouseMoveHandler[a]);
                if (b.mouseOutHandler)
                    for (a in b.mouseOutHandler) n.disconnect(b.mouseOutHandler[a])
            })
        },
        _createDynamicLayers: function(a) {
            var b = [],
                c;
            m.forEach(a.dynamicLayerInfos || a.layerInfos, function(d) {
                c = {
                    id: d.id
                };
                c.source = d.source && d.source.toJson();
                var f;
                a.layerDefinitions && a.layerDefinitions[d.id] && (f = a.layerDefinitions[d.id]);
                f && (c.definitionExpression =
                    f);
                var g;
                a.layerDrawingOptions && a.layerDrawingOptions[d.id] && (g = a.layerDrawingOptions[d.id]);
                g && (c.drawingInfo = g.toJson());
                c.minScale = d.minScale || 0;
                c.maxScale = d.maxScale || 0;
                b.push(c)
            });
            return b
        },
        _getTemplateFromTypes: function(a, b) {
            var c;
            for (c = 0; c < a.length; c++)
                if (a[c].id == b && a[c].templates && 0 < a[c].templates.length) return a[c].templates[0];
            return null
        },
        _findParentGroup: function(a, b, c) {
            var d, f = b.dynamicLayerInfos || b.layerInfos;
            for (d = 0; d < f.length; d++)
                if (c == f[d].id) {
                    -1 < f[d].parentLayerId && (t.set(q.byId(this.id +
                        "_" + a + "_" + f[d].parentLayerId + "_group"), "display", "block"), this._findParentGroup(a, b, f[d].parentLayerId));
                    break
                }
        },
        _addSubLayersToHide: function(a) {
            function b(c, d) {
                var f = a.layer.dynamicLayerInfos || a.layer.layerInfos,
                    g, e;
                for (g = 0; g < f.length; g++)
                    if (f[g].id === c && f[g].subLayerIds)
                        for (e = 0; e < f[g].subLayerIds.length; e++) {
                            var l = f[g].subLayerIds[e]; - 1 === m.indexOf(d, l) && (d.push(l), b(l, d))
                        }
            }
            a.layer.layerInfos && m.forEach(a.layer._hideLayersInLegend, function(c) {
                b(c, a.layer._hideLayersInLegend)
            })
        },
        _isLayerInScale: function(a,
            b, c) {
            var d, f = !0;
            if (a.legendResponse && a.legendResponse.layers)
                for (d = 0; d < a.legendResponse.layers.length; d++) {
                    var g = a.legendResponse.layers[d];
                    if (b.id == g.layerId) {
                        var e, l;
                        !a.minScale && 0 !== a.minScale || !a.maxScale && 0 !== a.maxScale ? (0 == g.minScale && a.tileInfo && (e = a.tileInfo.lods[0].scale), 0 == g.maxScale && a.tileInfo && (l = a.tileInfo.lods[a.tileInfo.lods.length - 1].scale)) : (e = Math.min(a.minScale, g.minScale) || a.minScale || g.minScale, l = Math.max(a.maxScale, g.maxScale));
                        if (0 < e && e < c || l > c) f = !1;
                        break
                    }
                } else if (a.minScale ||
                    a.maxScale)
                    if (a.minScale && a.minScale < c || a.maxScale && a.maxScale > c) f = !1;
            return f
        },
        _getServiceTitle: function(a) {
            var b = a._titleForLegend;
            b || ((b = a.url) ? -1 < a.url.indexOf("/MapServer") ? (b = a.url.substring(0, a.url.indexOf("/MapServer")), b = b.substring(b.lastIndexOf("/") + 1, b.length)) : -1 < a.url.indexOf("/ImageServer") ? (b = a.url.substring(0, a.url.indexOf("/ImageServer")), b = b.substring(b.lastIndexOf("/") + 1, b.length)) : -1 < a.url.indexOf("/FeatureServer") && (b = a.url.substring(0, a.url.indexOf("/FeatureServer")), b = b.substring(b.lastIndexOf("/") +
                1, b.length)) : b = "", a.name && (b = 0 < b.length ? b + (" - " + a.name) : a.name));
            return Q.encode(b)
        },
        _getEffectiveScale: function(a, b) {
            var c = b.minScale,
                d = b.maxScale;
            if (D.isDefined(b.parentLayerId)) {
                var f = a.layerInfos,
                    g = b.parentLayerId,
                    e;
                for (e = f.length - 1; 0 <= e; e--)
                    if (f[e].id == g)
                        if (0 == c && 0 < f[e].minScale ? c = f[e].minScale : 0 < c && 0 == f[e].minScale || 0 < c && 0 < f[e].minScale && (c = Math.min(c, f[e].minScale)), d = Math.max(d || 0, f[e].maxScale || 0), -1 < f[e].parentLayerId) g = f[e].parentLayerId;
                        else break
            }
            return {
                minScale: c,
                maxScale: d
            }
        },
        _isSupportedLayerType: function(a) {
            return a &&
                ("esri.layers.ArcGISDynamicMapServiceLayer" === a.declaredClass || "esri.layers.ArcGISImageServiceLayer" === a.declaredClass && 10.2 <= a.version || "esri.layers.ArcGISTiledMapServiceLayer" === a.declaredClass || "esri.layers.FeatureLayer" === a.declaredClass || "esri.layers.StreamLayer" === a.declaredClass || "esri.layers.KMLLayer" === a.declaredClass || "esri.layers.GeoRSSLayer" === a.declaredClass || "esri.layers.WMSLayer" === a.declaredClass || "esri.layers.CSVLayer" === a.declaredClass) ? !0 : !1
        }
    });
    s.mixin(x, {
        ALIGN_LEFT: 0,
        ALIGN_RIGHT: 1
    });
    return x
});
},
'dojox/html/entities':function(){
define(["dojo/_base/lang"], function(lang) {
	// dojox.html.entities.html [public] Array
	//		Entity characters for HTML, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	//		The function wrapper is to fix global leking with the build tools.
	var dhe = lang.getObject("dojox.html.entities",true);	
	
	var _applyEncodingMap = function(str, map){
		// summary:
		//		Private internal function for performing encoding of entity characters.
		// tags:
		//		private
	
		// Check to see if we have genned and cached a regexp for this map yet
		// If we have, use it, if not, gen it, cache, then use.
		var mapper, regexp;
		if(map._encCache &&
			map._encCache.regexp &&
			map._encCache.mapper &&
			map.length == map._encCache.length){
			mapper = map._encCache.mapper;
			regexp = map._encCache.regexp;
		}else{
			mapper = {};
			regexp = ["["];
			var i;
			for(i = 0; i < map.length; i++){
				mapper[map[i][0]] = "&" + map[i][1] + ";";
				regexp.push(map[i][0]);
			}
			regexp.push("]");
			regexp = new RegExp(regexp.join(""), "g");
			map._encCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};
	
	var _applyDecodingMap = function(str, map){
		// summary:
		//		Private internal function for performing decoding of entity characters.
		// tags:
		//		private
		var mapper, regexp;
		if(map._decCache &&
			map._decCache.regexp &&
			map._decCache.mapper &&
			map.length == map._decCache.length){
			mapper = map._decCache.mapper;
			regexp = map._decCache.regexp;
		}else{
			mapper = {};
			regexp = ["("];
			var i;
			for(i = 0; i < map.length; i++){
				var e = "&" + map[i][1] + ";";
				if(i){regexp.push("|");}
				mapper[e] = map[i][0];
				regexp.push(e);
			}
			regexp.push(")");
			regexp = new RegExp(regexp.join(""), "g");
			map._decCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};

	dhe.html = [
		["\u0026","amp"], ["\u0022","quot"],["\u003C","lt"], ["\u003E","gt"],
		["\u00A0","nbsp"]
	];
	
	// dojox.html.entities.latin [public] Array
	//		Entity characters for Latin characters and similar, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	dhe.latin = [
		["\u00A1","iexcl"],["\u00A2","cent"],["\u00A3","pound"],["\u20AC","euro"],
		["\u00A4","curren"],["\u00A5","yen"],["\u00A6","brvbar"],["\u00A7","sect"],
		["\u00A8","uml"],["\u00A9","copy"],["\u00AA","ordf"],["\u00AB","laquo"],
		["\u00AC","not"],["\u00AD","shy"],["\u00AE","reg"],["\u00AF","macr"],
		["\u00B0","deg"],["\u00B1","plusmn"],["\u00B2","sup2"],["\u00B3","sup3"],
		["\u00B4","acute"],["\u00B5","micro"],["\u00B6","para"],["\u00B7","middot"],
		["\u00B8","cedil"],["\u00B9","sup1"],["\u00BA","ordm"],["\u00BB","raquo"],
		["\u00BC","frac14"],["\u00BD","frac12"],["\u00BE","frac34"],["\u00BF","iquest"],
		["\u00C0","Agrave"],["\u00C1","Aacute"],["\u00C2","Acirc"],["\u00C3","Atilde"],
		["\u00C4","Auml"],["\u00C5","Aring"],["\u00C6","AElig"],["\u00C7","Ccedil"],
		["\u00C8","Egrave"],["\u00C9","Eacute"],["\u00CA","Ecirc"],["\u00CB","Euml"],
		["\u00CC","Igrave"],["\u00CD","Iacute"],["\u00CE","Icirc"],["\u00CF","Iuml"],
		["\u00D0","ETH"],["\u00D1","Ntilde"],["\u00D2","Ograve"],["\u00D3","Oacute"],
		["\u00D4","Ocirc"],["\u00D5","Otilde"],["\u00D6","Ouml"],["\u00D7","times"],
		["\u00D8","Oslash"],["\u00D9","Ugrave"],["\u00DA","Uacute"],["\u00DB","Ucirc"],
		["\u00DC","Uuml"],["\u00DD","Yacute"],["\u00DE","THORN"],["\u00DF","szlig"],
		["\u00E0","agrave"],["\u00E1","aacute"],["\u00E2","acirc"],["\u00E3","atilde"],
		["\u00E4","auml"],["\u00E5","aring"],["\u00E6","aelig"],["\u00E7","ccedil"],
		["\u00E8","egrave"],["\u00E9","eacute"],["\u00EA","ecirc"],["\u00EB","euml"],
		["\u00EC","igrave"],["\u00ED","iacute"],["\u00EE","icirc"],["\u00EF","iuml"],
		["\u00F0","eth"],["\u00F1","ntilde"],["\u00F2","ograve"],["\u00F3","oacute"],
		["\u00F4","ocirc"],["\u00F5","otilde"],["\u00F6","ouml"],["\u00F7","divide"],
		["\u00F8","oslash"],["\u00F9","ugrave"],["\u00FA","uacute"],["\u00FB","ucirc"],
		["\u00FC","uuml"],["\u00FD","yacute"],["\u00FE","thorn"],["\u00FF","yuml"],
		["\u0192","fnof"],["\u0391","Alpha"],["\u0392","Beta"],["\u0393","Gamma"],
		["\u0394","Delta"],["\u0395","Epsilon"],["\u0396","Zeta"],["\u0397","Eta"],
		["\u0398","Theta"], ["\u0399","Iota"],["\u039A","Kappa"],["\u039B","Lambda"],
		["\u039C","Mu"],["\u039D","Nu"],["\u039E","Xi"],["\u039F","Omicron"],
		["\u03A0","Pi"],["\u03A1","Rho"],["\u03A3","Sigma"],["\u03A4","Tau"],
		["\u03A5","Upsilon"],["\u03A6","Phi"],["\u03A7","Chi"],["\u03A8","Psi"],
		["\u03A9","Omega"],["\u03B1","alpha"],["\u03B2","beta"],["\u03B3","gamma"],
		["\u03B4","delta"],["\u03B5","epsilon"],["\u03B6","zeta"],["\u03B7","eta"],
		["\u03B8","theta"],["\u03B9","iota"],["\u03BA","kappa"],["\u03BB","lambda"],
		["\u03BC","mu"],["\u03BD","nu"],["\u03BE","xi"],["\u03BF","omicron"],
		["\u03C0","pi"],["\u03C1","rho"],["\u03C2","sigmaf"],["\u03C3","sigma"],
		["\u03C4","tau"],["\u03C5","upsilon"],["\u03C6","phi"],["\u03C7","chi"],
		["\u03C8","psi"],["\u03C9","omega"],["\u03D1","thetasym"],["\u03D2","upsih"],
		["\u03D6","piv"],["\u2022","bull"],["\u2026","hellip"],["\u2032","prime"],
		["\u2033","Prime"],["\u203E","oline"],["\u2044","frasl"],["\u2118","weierp"],
		["\u2111","image"],["\u211C","real"],["\u2122","trade"],["\u2135","alefsym"],
		["\u2190","larr"],["\u2191","uarr"],["\u2192","rarr"],["\u2193","darr"],
		["\u2194","harr"],["\u21B5","crarr"],["\u21D0","lArr"],["\u21D1","uArr"],
		["\u21D2","rArr"],["\u21D3","dArr"],["\u21D4","hArr"],["\u2200","forall"],
		["\u2202","part"],["\u2203","exist"],["\u2205","empty"],["\u2207","nabla"],
		["\u2208","isin"],["\u2209","notin"],["\u220B","ni"],["\u220F","prod"],
		["\u2211","sum"],["\u2212","minus"],["\u2217","lowast"],["\u221A","radic"],
		["\u221D","prop"],["\u221E","infin"],["\u2220","ang"],["\u2227","and"],
		["\u2228","or"],["\u2229","cap"],["\u222A","cup"],["\u222B","int"],
		["\u2234","there4"],["\u223C","sim"],["\u2245","cong"],["\u2248","asymp"],
		["\u2260","ne"],["\u2261","equiv"],["\u2264","le"],["\u2265","ge"],
		["\u2282","sub"],["\u2283","sup"],["\u2284","nsub"],["\u2286","sube"],
		["\u2287","supe"],["\u2295","oplus"],["\u2297","otimes"],["\u22A5","perp"],
		["\u22C5","sdot"],["\u2308","lceil"],["\u2309","rceil"],["\u230A","lfloor"],
		["\u230B","rfloor"],["\u2329","lang"],["\u232A","rang"],["\u25CA","loz"],
		["\u2660","spades"],["\u2663","clubs"],["\u2665","hearts"],["\u2666","diams"],
		["\u0152","OElig"],["\u0153","oelig"],["\u0160","Scaron"],["\u0161","scaron"],
		["\u0178","Yuml"],["\u02C6","circ"],["\u02DC","tilde"],["\u2002","ensp"],
		["\u2003","emsp"],["\u2009","thinsp"],["\u200C","zwnj"],["\u200D","zwj"],
		["\u200E","lrm"],["\u200F","rlm"],["\u2013","ndash"],["\u2014","mdash"],
		["\u2018","lsquo"],["\u2019","rsquo"],["\u201A","sbquo"],["\u201C","ldquo"],
		["\u201D","rdquo"],["\u201E","bdquo"],["\u2020","dagger"],["\u2021","Dagger"],
		["\u2030","permil"],["\u2039","lsaquo"],["\u203A","rsaquo"]
	];
	
	dhe.encode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the and Latin entities as the
		//		set to map and escape.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyEncodingMap(str, dhe.html);
				str = _applyEncodingMap(str, dhe.latin);
	
			}else{
				str = _applyEncodingMap(str, m);
			}
		}
		return str;
	};
	
	dhe.decode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding to decode.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the HTML and Latin entities as the
		//		set to map and decode.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyDecodingMap(str, dhe.html);
				str = _applyDecodingMap(str, dhe.latin);
	
			}else{
				str = _applyDecodingMap(str, m);
			}
		}
		return str;
	};
	return dhe;
});


},
'esri/dijit/LocateButton':function(){
//>>built
define(["require", "dojo/Evented", "dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../config", "dijit/_WidgetBase", "dijit/a11yclick", "dijit/_TemplatedMixin", "dojo/on", "dojo/Deferred", "dojo/text!./templates/LocateButton.html", "dojo/i18n!../nls/jsapi", "dojo/dom-class", "dojo/dom-style", "dojo/dom-attr", "../geometry/webMercatorUtils", "../geometry/Point", "../SpatialReference", "../graphic", "../symbols/PictureMarkerSymbol", "../tasks/ProjectParameters"], function(n, p, q, d, C, D, k, r, s, t, l, g, u, v, e, m, h, w, x, y, z, A, B) {
    return q("esri.dijit.LocateButton", [r, t, p], {
        templateString: u,
        options: {
            theme: "LocateButton",
            map: null,
            visible: !0,
            highlightLocation: !0,
            symbol: new A(n.toUrl(".") + "/images/sdk_gps_location.png", 28, 28),
            infoTemplate: null,
            scale: null,
            useTracking: !1,
            clearOnTrackingStop: !1,
            setScale: !0,
            centerAt: !0,
            timeout: 15E3,
            graphicsLayer: null,
            geolocationOptions: {
                maximumAge: 0,
                timeout: 15E3,
                enableHighAccuracy: !0
            }
        },
        constructor: function(a, c) {
            var b = d.mixin({}, this.options, a);
            this.domNode = c;
            this._i18n = v;
            navigator.geolocation || (b.visible = !1, console.log("LocateButton::navigator.geolocation unsupported."));
            this.set("map", b.map);
            this.set("theme", b.theme);
            this.set("visible", b.visible);
            this.set("scale", b.scale);
            this.set("highlightLocation", b.highlightLocation);
            this.set("symbol", b.symbol);
            this.set("infoTemplate", b.infoTemplate);
            this.set("geolocationOptions", b.geolocationOptions);
            this.set("useTracking", b.useTracking);
            this.set("setScale", b.setScale);
            this.set("centerAt", b.centerAt);
            this.set("timeout", b.timeout);
            this.set("graphicsLayer", b.graphicsLayer);
            this.set("clearOnTrackingStop", b.clearOnTrackingStop);
            this.watch("theme", this._updateThemeWatch);
            this.watch("visible", this._visible);
            this.watch("tracking", this._locate);
            this.watch("useTracking", d.hitch(this, function() {
                this.get("tracking") && !this.get("useTracking") && this._stopTracking();
                this._setTitle()
            }));
            this._css = {
                container: "locateContainer",
                locate: "zoomLocateButton",
                loading: "loading",
                tracking: "tracking"
            }
        },
        postCreate: function() {
            this.inherited(arguments);
            this.own(l(this._locateNode, s, d.hitch(this, this.locate)))
        },
        startup: function() {
            this.get("map") ||
                (this.destroy(), console.log("LocateButton::map required"));
            if (this.get("map").loaded) this._init();
            else l.once(this.get("map"), "load", d.hitch(this, function() {
                this._init()
            }))
        },
        destroy: function() {
            this._graphicsEvent && this._graphicsEvent.remove();
            this._removeWatchPosition();
            this.inherited(arguments)
        },
        clear: function() {
            var a = this.get("highlightGraphic"),
                c = this.get("graphicsLayer");
            a && (c ? c.remove(a) : this.get("map").graphics.remove(a), this.set("highlightGraphic", null))
        },
        locate: function() {
            this.get("useTracking") &&
                this.set("tracking", !this.get("tracking"));
            return this._locate()
        },
        show: function() {
            this.set("visible", !0)
        },
        hide: function() {
            this.set("visible", !1)
        },
        _setTitle: function() {
            this.get("useTracking") ? this.get("tracking") ? h.set(this._locateNode, "title", this._i18n.widgets.locateButton.locate.stopTracking) : h.set(this._locateNode, "title", this._i18n.widgets.locateButton.locate.tracking) : h.set(this._locateNode, "title", this._i18n.widgets.locateButton.locate.title)
        },
        _removeWatchPosition: function() {
            this.get("watchId") &&
                (navigator.geolocation.clearWatch(this.get("watchId")), this.set("watchId", null));
            this._removePrivateVars()
        },
        _stopTracking: function() {
            e.remove(this._locateNode, this._css.tracking);
            this._removeWatchPosition();
            this.get("clearOnTrackingStop") && this.clear();
            this._hideLoading()
        },
        _startTracking: function() {
            e.add(this._locateNode, this._css.tracking);
            this._removeWatchPosition();
            var a = navigator.geolocation.watchPosition(d.hitch(this, function(a) {
                this._setPosition(a).then(d.hitch(this, function(a) {
                        this._locateEvent(a)
                    }),
                    d.hitch(this, function(a) {
                        a || (a = Error("LocateButton::Error setting the position."));
                        this._locateError(a)
                    }))
            }), d.hitch(this, function(a) {
                a || (a = Error("LocateButton::Could not get tracking position."));
                this._locateError(a)
            }), this.get("geolocationOptions"));
            this.set("watchId", a)
        },
        _removePrivateVars: function() {
            this._scale = this._position = this._graphic = null
        },
        _getCurrentPosition: function() {
            var a = new g;
            this._removePrivateVars();
            var c = setTimeout(d.hitch(this, function() {
                    clearTimeout(c);
                    a.reject(Error("LocateButton::time expired for getting location."))
                }),
                this.get("timeout"));
            navigator.geolocation.getCurrentPosition(d.hitch(this, function(b) {
                clearTimeout(c);
                this._setPosition(b).then(d.hitch(this, function(b) {
                    a.resolve(b)
                }), d.hitch(this, function(b) {
                    b || (b = Error("LocateButton::Error setting map position."));
                    a.reject(b)
                }))
            }), d.hitch(this, function(b) {
                b || (b = Error("LocateButton::Could not get current position."));
                a.reject(b)
            }), this.get("geolocationOptions"));
            return a.promise
        },
        _locate: function() {
            var a = new g;
            this._showLoading();
            if (navigator.geolocation) this.get("useTracking") ?
                this.get("tracking") ? (this._startTracking(), a.resolve({
                    tracking: !0
                })) : (this._stopTracking(), a.resolve({
                    tracking: !1
                })) : this._getCurrentPosition().then(d.hitch(this, function(b) {
                    this._locateEvent(b);
                    a.resolve(b)
                }), d.hitch(this, function(b) {
                    b || (b = Error("LocateButton::Could not get current position."));
                    this._locateError(b);
                    a.reject(b)
                }));
            else {
                var c = Error("LocateButton::geolocation unsupported");
                this._locateError(c);
                a.reject(c)
            }
            this._setTitle();
            return a.promise
        },
        _projectPoint: function(a) {
            var c = new g,
                b = this.get("map").spatialReference,
                f = b.wkid;
            b.isWebMercator() ? (a = w.geographicToWebMercator(a), c.resolve(a)) : k.defaults.geometryService && 4326 !== f ? (f = new B, f.geometries = [a], f.outSR = b, k.defaults.geometryService.project(f).then(d.hitch(this, function(a) {
                a && a.length ? c.resolve(a[0]) : c.reject(Error("LocateButton::Point was not projected."))
            }), function(a) {
                a || (a = Error("LocateButton::please specify a geometry service on esri/config to project."));
                c.reject(a)
            })) : c.resolve(a);
            return c.promise
        },
        _getScale: function(a) {
            var c = this.get("scale");
            return a &&
                a.coords ? c || a.coords.accuracy || 5E4 : c || 5E4
        },
        _createPoint: function(a) {
            var c;
            a && a.coords && (c = new x([a.coords.longitude, a.coords.latitude], new y({
                wkid: 4326
            })));
            return c
        },
        _setPosition: function(a) {
            var c = new g,
                b, f;
            this._removePrivateVars();
            if ((this._position = a) && a.coords) {
                if (b = this._createPoint(a)) this._graphic = f = this._createGraphic(b, a);
                var e = this._getScale(a);
                this._scale = e;
                b ? this._projectPoint(b).then(d.hitch(this, function(b) {
                    this._graphic = f = this._createGraphic(b, a);
                    var g = {
                        graphic: f,
                        scale: e,
                        position: a
                    };
                    this.get("setScale") && this.get("map").setScale(e);
                    this.get("centerAt") ? this.get("map").centerAt(b).then(d.hitch(this, function() {
                        c.resolve(g)
                    }), d.hitch(this, function(a) {
                        a || (a = Error("LocateButton::Could not center map."));
                        c.reject(a)
                    })) : c.resolve(g)
                }), d.hitch(this, function(a) {
                    a || (a = Error("LocateButton::Error projecting point."));
                    c.reject(a)
                })) : (b = Error("LocateButton::Invalid point"), c.reject(b))
            } else b = Error("LocateButton::Invalid position"), c.reject(b);
            return c.promise
        },
        _createGraphic: function(a, c) {
            var b;
            a && (b = {
                position: c
            }, b = new z(a, this.get("symbol"), b, this.get("infoTemplate")));
            return b
        },
        _locateEvent: function(a) {
            if (a.graphic) {
                var c = this.get("highlightGraphic"),
                    b = this.get("graphicsLayer");
                c ? (c.setGeometry(a.graphic.geometry), c.setAttributes(a.graphic.attributes), c.setInfoTemplate(a.graphic.infoTemplate), c.setSymbol(a.graphic.symbol)) : (c = a.graphic, this.get("highlightLocation") && (b ? b.add(c) : this.get("map").graphics.add(c)));
                this.set("highlightGraphic", c)
            }
            this._hideLoading();
            this.emit("locate", a)
        },
        _locateError: function(a) {
            a = {
                graphic: this._graphic,
                scale: this._scale,
                position: this._position,
                error: a
            };
            this._hideLoading();
            this.emit("locate", a)
        },
        _showLoading: function() {
            this.get("useTracking") || e.add(this._locateNode, this._css.loading)
        },
        _hideLoading: function() {
            this.get("useTracking") || e.remove(this._locateNode, this._css.loading)
        },
        _init: function() {
            this._visible();
            this._setTitle();
            this.get("tracking") && this.get("useTracking") && this._locate();
            this.set("loaded", !0);
            this.emit("load", {})
        },
        _updateThemeWatch: function(a,
            c, b) {
            e.remove(this.domNode, c);
            e.add(this.domNode, b)
        },
        _visible: function() {
            this.get("visible") ? m.set(this.domNode, "display", "block") : m.set(this.domNode, "display", "none")
        }
    })
});
},
'esri/tasks/ProjectParameters':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/has", "../kernel", "../lang", "../geometry/jsonUtils"], function(c, g, d, b, h, k, e, f) {
    return c(null, {
        declaredClass: "esri.tasks.ProjectParameters",
        geometries: null,
        outSR: null,
        transformation: null,
        transformForward: null,
        toJson: function() {
            var c = d.map(this.geometries, function(a) {
                    return a.toJson()
                }),
                a = {};
            a.outSR = this.outSR.wkid || b.toJson(this.outSR.toJson());
            a.inSR = this.geometries[0].spatialReference.wkid || b.toJson(this.geometries[0].spatialReference.toJson());
            a.geometries = b.toJson({
                geometryType: f.getJsonType(this.geometries[0]),
                geometries: c
            });
            this.transformation && (a.transformation = this.transformation.wkid || b.toJson(this.transformation));
            e.isDefined(this.transformForward) && (a.transformForward = this.transformForward);
            return a
        }
    })
});
},
'esri/dijit/PopupMobile':function(){
//>>built
define(["require", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/connect", "dojo/_base/array", "dojo/_base/window", "dojo/_base/kernel", "dojo/has", "dojo/query", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "../InfoWindowBase", "../PopupBase", "./InfoView", "./NavigationBar", "../kernel", "../domUtils", "dojo/i18n!../nls/jsapi", "dojo/NodeList-dom"], function(n, t, r, b, q, s, h, C, D, u, v, e, p, w, m, x, y, z, A, E, g, B) {
    return t([x, y], {
        declaredClass: "esri.dijit.PopupMobile",
        offsetX: 3,
        offsetY: 3,
        zoomFactor: 4,
        marginLeft: 10,
        marginTop: 10,
        highlight: !0,
        popupNavigationBar: null,
        popupInfoView: null,
        location: null,
        xIcon: n.toUrl("./images/whitex.png"),
        dArrowIcon: n.toUrl("./images/whitedown.png"),
        lArrowIcon: n.toUrl("./images/whitel.png"),
        rArrowIcon: n.toUrl("./images/whiter.png"),
        constructor: function(a, c) {
            this.initialize();
            r.mixin(this, a);
            this.domNode = u.byId(c);
            this._nls = r.mixin({}, B.widgets.popup);
            var f = this.domNode;
            e.add(f, "esriPopupMobile");
            v.set(f, "innerHTML", "\x3cdiv class\x3d'sizer'\x3e\x3cdiv class\x3d'titlePane'\x3e\x3cdiv class\x3d'spinner hidden'\x3e\x3c/div\x3e\x3cdiv class\x3d'title'\x3e\x3c/div\x3e\x3cdiv style\x3d'text-align:center'\x3e\x3cdiv class\x3d'titleButton prev hidden'\x3e\x3c/div\x3e\x3cdiv class\x3d'footer' style\x3d'display:inline-block;width:60px;height:15px;'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton next hidden'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton close'\x3e\x3c/div\x3e\x3cdiv class\x3d'titleButton arrow hidden'\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'pointer top hidden'\x3e\x3c/div\x3e\x3cdiv class\x3d'pointer bottom hidden'\x3e\x3c/div\x3e");
            var d = h.query(".titlePane", f)[0];
            this._arrowButton = h.query(".arrow", d)[0];
            this._pointerTop = h.query(".top", f)[0];
            this._pointerBottom = h.query(".bottom", f)[0];
            this._title = h.query(".title", d)[0];
            this._footer = h.query(".footer", d)[0];
            this._prev = h.query(".prev", d)[0];
            this._next = h.query(".next", d)[0];
            this._spinner = h.query(".spinner", d)[0];
            this._eventConnections = [b.connect(h.query(".close", d)[0], "onclick", this, this.hide), b.connect(this._arrowButton, "onclick", this, this._toggleView), b.connect(this._prev, "onclick",
                this,
                function() {
                    this.selectPrevious();
                    this._updateUI()
                }), b.connect(this._next, "onclick", this, function() {
                this.selectNext();
                this._updateUI()
            })];
            this._initPopupNavigationBar();
            this._initPopupInfoView();
            g.hide(f);
            this.isShowing = !1
        },
        setMap: function(a) {
            this.inherited(arguments);
            p.place(this.domNode, a.root);
            this.highlight && this.enableHighlight(a)
        },
        unsetMap: function() {
            this.disableHighlight(this.map);
            this.inherited(arguments)
        },
        setTitle: function(a, c) {
            this.destroyDijits(this._title);
            this.place(a, this._title);
            this.destroyDijits(this._footer);
            this.place(c, this._footer);
            this.isShowing && (this.startupDijits(this._title), this.startupDijits(this._footer))
        },
        setContent: function(a) {
            this.destroyDijits(this._contentPane);
            this.place(a, this._contentPane);
            this.startupDijits(this._contentPane)
        },
        show: function(a) {
            if (a) {
                var c = this.map;
                a.spatialReference ? (this.location = a, a = c.toScreen(a)) : this.location = c.toMap(a);
                this._maximized ? this.restore() : this._setPosition(a);
                this.isShowing || (g.show(this.domNode), this.isShowing = !0, this.onShow())
            } else g.show(this.domNode),
                this.isShowing = !0
        },
        hide: function() {
            this.isShowing && (g.hide(this.domNode), this.isShowing = !1, this.onHide())
        },
        onShow: function() {
            this._followMap();
            this.startupDijits(this._title);
            this.showHighlight()
        },
        onHide: function() {
            this._unfollowMap();
            this.hideHighlight()
        },
        destroy: function() {
            this.map && this.unsetMap();
            this.cleanup();
            this.isShowing && this.hide();
            this.destroyDijits(this._title);
            this.destroyDijits(this._footer);
            q.forEach(this._eventConnections, b.disconnect);
            p.destroy(this.domNode)
        },
        selectNext: function() {
            this.select(this.selectedIndex +
                1)
        },
        selectPrevious: function() {
            this.select(this.selectedIndex - 1)
        },
        setFeatures: function() {
            this.inherited(arguments);
            this._updateUI()
        },
        onSetFeatures: function() {},
        onClearFeatures: function() {
            this.setTitle("\x26nbsp;", "\x26nbsp;");
            e.add(this._arrowButton, "hidden");
            this._updateUI();
            this.hideHighlight()
        },
        onSelectionChange: function() {
            var a = this.selectedIndex;
            this._updateUI();
            0 <= a && (this.setContent(this.features[a].getContent()), this.updateHighlight(this.map, this.features[a]), this.isShowing && this.showHighlight())
        },
        onDfdComplete: function() {
            this._updateUI()
        },
        _followMap: function() {
            this._unfollowMap();
            var a = this.map;
            this._handles = [b.connect(a, "onPanStart", this, this._onPanStart), b.connect(a, "onPan", this, this._onPan), b.connect(a, "onZoomStart", this, this._onZoomStart), b.connect(a, "onExtentChange", this, this._onExtentChange)]
        },
        _unfollowMap: function() {
            var a = this._handles;
            a && (q.forEach(a, b.disconnect), this._handles = null)
        },
        _onPanStart: function() {
            var a = this.domNode.style;
            this._panOrigin = {
                left: a.left,
                top: a.top,
                right: a.right,
                bottom: a.bottom
            }
        },
        _onPan: function(a, c) {
            var f = this._panOrigin,
                d = c.x,
                e = c.y,
                b = f.left,
                k = f.top,
                l = f.right,
                f = f.bottom;
            b && (b = parseFloat(b) + d + "px");
            k && (k = parseFloat(k) + e + "px");
            l && (l = parseFloat(l) - d + "px");
            f && (f = parseFloat(f) - e + "px");
            m.set(this.domNode, {
                left: b,
                top: k,
                right: l,
                bottom: f
            })
        },
        _onZoomStart: function() {
            g.hide(this.domNode)
        },
        _onExtentChange: function(a, c, f) {
            f && (g.show(this.domNode), this.show(this._targetLocation || this.location), this._targetLocation = null)
        },
        _setPosition: function(a) {
            var c = a.x;
            a = a.y;
            var f =
                w.getContentBox(this.map.container),
                d = f.w,
                f = f.h,
                b = 0,
                g = a + 10,
                k = 118,
                l = d - 18;
            18 < c && c < l ? (b = c - 130, 0 > b ? b = 0 : b > d - 260 && (b = d - 260)) : 18 >= c ? b = c - 18 : c >= l && (b = d - 260 + (c - l));
            118 < c && c < d - 130 ? k = 118 : 118 >= c ? 18 < c ? k = c - 12 : 18 >= c && (k = 6) : c >= d - 130 && (c < l ? k = 118 + c - (d - 130) : c >= l && (k = 118 + l - (d - 130)));
            a <= f / 2 ? (m.set(this.domNode, {
                left: b + "px",
                top: g + "px",
                bottom: null
            }), m.set(this._pointerTop, {
                left: k + "px"
            }), e.add(this._pointerBottom, "hidden"), e.remove(this._pointerTop, "hidden")) : (m.set(this.domNode, {
                left: b + "px",
                top: g - 64 + "px",
                bottom: null
            }), m.set(this._pointerBottom, {
                left: k + "px"
            }), e.add(this._pointerTop, "hidden"), e.remove(this._pointerBottom, "hidden"))
        },
        _showPointer: function(a) {
            q.forEach(["topLeft", "topRight", "bottomRight", "bottomLeft"], function(c) {
                c === a ? h.query(".pointer." + c, this.domNode).removeClass("hidden") : h.query(".pointer." + c, this.domNode).addClass("hidden")
            }, this)
        },
        _toggleView: function() {
            this.popupNavigationBar || this._initPopupNavigationBar();
            this.popupInfoView || this._initPopupInfoView();
            this.hide();
            g.show(this.popupNavigationBar.container);
            g.show(this.popupInfoView.container);
            0 <= this.selectedIndex && this.setContent(this.features[this.selectedIndex].getContent())
        },
        _handleNavigationBar: function(a) {
            this.popupInfoView.animateTo(0);
            switch (a.name) {
                case "CloseButton":
                    g.hide(this.popupNavigationBar.container);
                    g.hide(this.popupInfoView.container);
                    this.hide();
                    break;
                case "ToggleButton":
                    g.hide(this.popupNavigationBar.container);
                    g.hide(this.popupInfoView.container);
                    this.show(this.location);
                    break;
                case "PreviousButton":
                    this.selectPrevious();
                    this._updateUI();
                    break;
                case "NextButton":
                    this.selectNext(),
                        this._updateUI()
            }
        },
        _initPopupNavigationBar: function() {
            var a = {};
            a.items = [{
                name: "CloseButton",
                type: "img",
                src: this.xIcon,
                srcAlt: this.xIcon,
                position: "left"
            }, {
                name: "Title",
                type: "span",
                text: "",
                position: "center"
            }, {
                name: "ToggleButton",
                type: "img",
                src: this.dArrowIcon,
                srcAlt: this.dArrowIcon,
                position: "right",
                toggleGroup: "toggle"
            }, {
                name: "PreviousButton",
                type: "img",
                src: this.lArrowIcon,
                srcAlt: this.lArrowIcon,
                position: "right2",
                toggleGroup: "previous"
            }, {
                name: "NextButton",
                type: "img",
                src: this.rArrowIcon,
                srcAlt: this.rArrowIcon,
                position: "right1",
                toggleGroup: "next"
            }];
            this.popupNavigationBar = new A(a, p.create("div", {}, s.body()));
            b.connect(this.popupNavigationBar, "onCreate", this, function(a) {
                this._prevFeatureButton = a[3]._node;
                this._nextFeatureButton = a[4]._node
            });
            b.connect(this.popupNavigationBar, "onSelect", this, this._handleNavigationBar);
            b.connect(this.popupNavigationBar, "onUnSelect", this, this._handleNavigationBar);
            this.popupNavigationBar.startup();
            g.hide(this.popupNavigationBar.container)
        },
        _initPopupInfoView: function() {
            this.popupInfoView =
                new z({
                    items: [{
                        name: "Navigator",
                        type: "div",
                        text: ""
                    }, {
                        name: "content",
                        type: "div",
                        text: ""
                    }, {
                        name: "attachment",
                        type: "div",
                        text: ""
                    }]
                }, p.create("div", {}, s.body()));
            e.add(this.popupInfoView.container, "esriMobilePopupInfoView");
            this.popupInfoView.enableTouchScroll();
            b.connect(this.popupInfoView, "onCreate", this, function(a) {
                this._contentPane = a[1]._node;
                0 <= this.selectedIndex && this.setContent(this.features[this.selectedIndex].getContent())
            });
            b.connect(this.popupInfoView, "onSwipeLeft", this, function() {});
            b.connect(this.popupInfoView,
                "onSwipeRight", this,
                function() {});
            this.popupInfoView.startup()
        },
        _updateUI: function() {
            var a = "\x26nbsp;",
                c = "\x26nbsp;",
                b = this.selectedIndex,
                d = this.features,
                g = this.deferreds,
                h = this._prevFeatureButton.parentNode,
                k = this._nextFeatureButton.parentNode,
                l = this._spinner,
                m = this._nls;
            d && 1 <= d.length ? (a = d[b].getTitle(), c = b + 1 + " of " + d.length, e.remove(this._arrowButton, "hidden"), 0 === b ? (e.add(h, "hidden"), e.add(this._prev, "hidden")) : (e.remove(h, "hidden"), e.remove(this._prev, "hidden")), b === d.length - 1 ? (e.add(k, "hidden"),
                e.add(this._next, "hidden")) : (e.remove(k, "hidden"), e.remove(this._next, "hidden"))) : (e.add(this._arrowButton, "hidden"), e.add(h, "hidden"), e.add(k, "hidden"), e.add(this._prev, "hidden"), e.add(this._next, "hidden"));
            this.setTitle(a, c);
            this.popupNavigationBar.getItems()[1]._node.innerHTML = c;
            g && g.length ? (e.remove(l, "hidden"), this.setTitle(m.NLS_searching + "...", "\x26nbsp;")) : (e.add(l, "hidden"), (!d || !d.length) && this.setTitle("No Information", "\x26nbsp;"))
        }
    })
});
},
'esri/dijit/InfoView':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/kernel", "dojo/has", "dojo/query", "dojo/dom", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "../kernel", "./_TouchBase"], function(l, r, m, d, n, s, t, p, h, e, k, u, q) {
    return l(null, {
        declaredClass: "esri.dijit.InfoView",
        _items: [],
        _top: null,
        _sections: [],
        _isDecelerate: !1,
        constructor: function(a, c) {
            var b;
            this.container = p.byId(c);
            this._touchBase = q(this.container, null);
            this._slideDiv = e.create("div", null, this.container, "first");
            this.events = [];
            this._items = a.items;
            a.sections && (this._sections = a.sections);
            h.add(this.container, "esriMobileInfoView");
            if (0 === this._sections.length) e.create("div", {}, this._slideDiv);
            else
                for (b = 0; b < this._sections.length; b++) {
                    var d = e.create("div", {
                        "class": "esriMobileInfoViewSection"
                    }, this._slideDiv);
                    e.create("div", {
                        innerHTML: this._sections[b].title
                    }, d)
                }
            for (b = 0; b < this._items.length; b++) {
                var f, d = 0;
                this._items[b].section && (d = this._items[b].section);
                switch (this._items[b].type) {
                    case "div":
                        f = e.create("div", {
                            "class": "esriMobileInfoViewItem",
                            style: this._items[b].style
                        }, this._slideDiv.childNodes[d]), f = e.create("div", {
                            innerHTML: this._items[b].text
                        }, f)
                }
                this._items[b].className && h.add(f, this._items[b].className);
                f._index = b;
                f._item = this._items[b];
                this._items[b]._node = f
            }
            this.startTouchY = 0
        },
        startup: function() {
            this.onCreate(this._items);
            this._animateTo(0)
        },
        destroy: function() {
            m.forEach(this.events, d.disconnect);
            this._touchBase = null;
            n.query("img", this.container).forEach(function(a) {
                a._index = null;
                a._item = null;
                e.destroy(a)
            });
            this._items = null;
            e.destroy(this._slideDiv);
            e.destroy(this.container);
            this.container = this._slideDiv = null
        },
        getItems: function() {
            return this._items
        },
        setPreventDefault: function(a) {
            this._touchBase.setPreventDefault(a)
        },
        enableTouchScroll: function() {
            this._touchBase.setPreventDefault(!0);
            this.events.push(d.connect(this._touchBase, "onTouchStart", this, this._onTouchStartHandler));
            this.events.push(d.connect(this._touchBase, "onTouchMove", this, this._onTouchMoveHandler));
            this.events.push(d.connect(this._touchBase,
                "onTouchEnd", this, this._onTouchEndHandler));
            this._slideDiv.style.webkitTransform = "translate3d(0," + this._top + "px, 0)"
        },
        disableTouchScroll: function() {
            d.disconnect(this.events.pop());
            d.disconnect(this.events.pop());
            d.disconnect(this.events.pop());
            this._touchBase.setPreventDefault(!1);
            this._slideDiv.style.webkitTransform = "translate3d(0, 0px, 0)"
        },
        animateTo: function() {
            this._slideDiv.style.WebkitTransitionDuration = "0s";
            this._animateTo(0)
        },
        onSelect: function(a) {},
        onUnSelect: function(a) {},
        onCreate: function(a) {},
        onClick: function(a) {},
        onSwipeLeft: function() {},
        onSwipeRight: function() {},
        _onTouchStartHandler: function(a) {
            this._slideDiv.style.WebkitTransitionDuration = "0s";
            this._moveDirection = null;
            this._startTime = new Date;
            this.startTouchY = a.touches[0].clientY;
            this.contentStartOffsetY = this.contentOffsetY
        },
        _onTouchMoveHandler: function(a) {
            this._moveDirection || (Math.abs(a.curY) > Math.abs(a.curX) ? this._moveDirection = "vertical" : this._moveDirection = "horizontal");
            "horizontal" !== this._moveDirection && "vertical" === this._moveDirection &&
                this._animateTo(a.touches[0].clientY - this.startTouchY + this.contentStartOffsetY)
        },
        _onTouchEndHandler: function(a) {
            this._endTime = new Date;
            this._deltaMovement = a.curY;
            if ("vertical" === this._moveDirection) this._shouldStartMomentum() ? this._doMomentum() : this._snapToBounds();
            else if ("horizontal" === this._moveDirection)
                if ("left" === a.swipeDirection) this.onSwipeLeft();
                else if ("right" === a.swipeDirection) this.onSwipeRight()
        },
        _shouldStartMomentum: function() {
            this._diff = this._endTime - this._startTime;
            this._velocity =
                this._deltaMovement / this._diff;
            return 0.2 < Math.abs(this._velocity) && 200 > this._diff ? !0 : !1
        },
        _pullToStop: function(a) {
            80 < Math.abs(a) && (a = 0 < a ? 80 : -contentBox.h + parentBox.h - 10 - 80);
            console.log(a);
            this._slideDiv.style.webkitTransition = "-webkit-transform 200ms cubic-bezier(0, 0, 1, 1)";
            var c = d.connect(this._slideDiv, "webkitTransitionEnd", this, function() {
                0 < a ? this._animateTo(0) : this._animateTo(-contentBox.h + parentBox.h - 10);
                d.disconnect(c)
            });
            this._animateTo(a)
        },
        _doMomentum: function() {
            var a, c;
            a = k.getContentBox(this.container);
            var b = 0 > this._velocity ? 0.0010 : -0.0010;
            c = -(this._velocity * this._velocity) / (2 * b);
            var d = -this._velocity / b,
                b = 3 * 0.6 - 0,
                f = 1 - b,
                g = 0,
                e = 0;
            if (a.h > this._slideDiv.scrollHeight) this.contentOffsetY = 0, e = 300;
            else if (0 < this.contentOffsetY + c) {
                a = 0;
                for (c = Math.floor(d / 20); a < c; a++)
                    if (g = (f * 20 * a ^ 3) + (b * 20 * a ^ 2) + 0 * 20 * a + 0, g = 0 > this._velocity ? -g : g, 0 < this.contentOffsetY + g) {
                        e = 20 * a;
                        break
                    }
                0 === e && (e = 300);
                this.contentOffsetY = 0
            } else if (Math.abs(this.contentOffsetY + c) + a.h > this._slideDiv.scrollHeight) {
                this.contentOffsetY = a.h - this._slideDiv.scrollHeight;
                a = 0;
                for (c = Math.floor(d / 20); a < c; a++)
                    if (g = (f * 20 * a ^ 3) + (b * 20 * a ^ 2) + 0 * 20 * a + 0, g = 0 > this._velocity ? -g : g, Math.abs(this.contentOffsetY + g) > this._slideDiv.scrollHeight) {
                        e = 20 * a;
                        break
                    }
            } else e = d, this.contentOffsetY += c;
            this._slideDiv.style.webkitTransition = "-webkit-transform " + e + "ms cubic-bezier(0, 0.3, 0.6, 1)";
            this._animateTo(this.contentOffsetY)
        },
        _snapToBounds: function() {
            var a = k.getContentBox(this.container);
            a.h > this._slideDiv.scrollHeight ? this.contentOffsetY = 0 : 0 < this.contentOffsetY ? this.contentOffsetY = 0 : Math.abs(this.contentOffsetY) +
                a.h > this._slideDiv.scrollHeight && (this.contentOffsetY = a.h - this._slideDiv.scrollHeight);
            this._slideDiv.style.WebkitTransitionDuration = "0.5s";
            this._animateTo(this.contentOffsetY)
        },
        _animateTo: function(a) {
            this.contentOffsetY = a;
            this._slideDiv.style.webkitTransform = "translate3d(0, " + a + "px, 0)"
        },
        _stopMomentum: function() {
            if (this._isDecelerating()) {
                var a = document.defaultView.getComputedStyle(this._slideDiv, null),
                    a = new WebKitCSSMatrix(a.webkitTransform);
                this._slideDiv.style.webkitTransition = "";
                this.animateTo(a.m42)
            }
        },
        _isDecelerating: function() {
            return this.isDecelerate ? !0 : !1
        },
        _toggleNode: function(a, c) {
            "ON" === c.toggleState ? (c.toggleState = "OFF", c.src && (a.src = c.src.toString()), this.onUnSelect(c)) : (c.toggleState = "ON", c.srcAlt && (a.src = c.srcAlt), this.onSelect(c))
        }
    })
});
},
'esri/dijit/_TouchBase':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/connect", "dojo/dom", "dojo/has", "../kernel"], function(c, e, b, d, f, g) {
    return c(null, {
        declaredClass: "esri.dijit._TouchBase",
        _preventDefault: !0,
        _swipeThreshold: 20,
        constructor: function(a, c) {
            this.domNode = d.byId(a);
            this.events = [b.connect(this.domNode, "touchstart", this, this._touchStartHandler), b.connect(this.domNode, "touchmove", this, this._touchMoveHandler), b.connect(this.domNode, "touchend", this, this._touchEndHandler), b.connect(this.domNode, "onclick",
                this, this._clickHandler)]
        },
        setPreventDefault: function(a) {
            this._preventDefault = a
        },
        disableOnClick: function() {
            b.disconnect(this.events.pop())
        },
        _clickHandler: function(a) {
            if (this._moved) a.preventDefault();
            else this.onclick(a)
        },
        _touchStartHandler: function(a) {
            this._moved = !1;
            this.client_x = a.targetTouches[0].clientX;
            this.client_y = a.targetTouches[0].clientY;
            this.down_x = a.targetTouches[0].pageX;
            this.down_y = a.targetTouches[0].pageY;
            a.downX = this.down_x;
            a.downY = this.down_y;
            this.onTouchStart(a)
        },
        _touchMoveHandler: function(a) {
            this._preventDefault &&
                a.preventDefault();
            this._moved = !0;
            this.up_x = a.targetTouches[0].pageX;
            this.cur_x = a.targetTouches[0].pageX - this.down_x;
            this.cur_y = a.targetTouches[0].pageY - this.down_y;
            a.curX = this.cur_x;
            a.curY = this.cur_y;
            this.onTouchMove(a)
        },
        _touchEndHandler: function(a) {
            this._moved ? (a.curX = this.cur_x, a.curY = this.cur_y, this.down_x - this.up_x > this._swipeThreshold ? a.swipeDirection = "left" : this.up_x - this.down_x > this._swipeThreshold && (a.swipeDirection = "right")) : (a.clientX = this.client_x, a.clientY = this.client_y);
            this.onTouchEnd(a)
        },
        onTouchStart: function(a) {},
        onTouchMove: function(a) {},
        onTouchEnd: function(a) {},
        onclick: function(a) {}
    })
});
},
'esri/dijit/NavigationBar':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/connect", "dojo/_base/array", "dojo/_base/kernel", "dojo/has", "dojo/query", "dojo/dom", "dojo/dom-class", "dojo/dom-construct", "./_TouchBase", "../kernel"], function(m, r, k, n, l, s, t, p, g, d, q, u) {
    return m(null, {
        declaredClass: "esri.dijit.NavigationBar",
        _items: [],
        constructor: function(a, b) {
            var c;
            this.container = p.byId(b);
            this._touchBase = q(this.container, null);
            this._slideDiv = d.create("div", {}, this.container, "first");
            this.events = [k.connect(this._touchBase, "onclick", this,
                this._onClickHandler)];
            this._items = a.items;
            g.add(this.container, "esriMobileNavigationBar");
            var h = d.create("div", {}, this._slideDiv);
            for (c = 0; c < this._items.length; c++) {
                var e, f;
                switch (this._items[c].type) {
                    case "img":
                        f = d.create("div", {
                            "class": "esriMobileNavigationItem"
                        }, h);
                        e = d.create("img", {
                            src: this._items[c].src.toString(),
                            style: {
                                width: "100%",
                                height: "100%"
                            }
                        }, f);
                        break;
                    case "span":
                        f = d.create("div", {
                            "class": "esriMobileNavigationItem"
                        }, h);
                        e = d.create("span", {
                            innerHTML: this._items[c].text
                        }, f);
                        break;
                    case "div":
                        f =
                            d.create("div", {
                                "class": "esriMobileNavigationInfoPanel"
                            }, h), e = d.create("div", {
                                innerHTML: this._items[c].text
                            }, f)
                }
                g.add(f, this._items[c].position);
                this._items[c].className && g.add(e, this._items[c].className);
                e._index = c;
                e._item = this._items[c];
                this._items[c]._node = e
            }
        },
        startup: function() {
            this.onCreate(this._items)
        },
        destroy: function() {
            n.forEach(this.events, k.disconnect);
            this._touchBase = null;
            l.query("img", this.container).forEach(function(a) {
                a._index = null;
                a._item = null;
                d.destroy(a)
            });
            this._items = null;
            d.destroy(this._slideDiv);
            d.destroy(this.container);
            this.container = this._slideDiv = null
        },
        getItems: function() {
            return this._items
        },
        select: function(a) {
            this._markSelected(a._node, a)
        },
        onSelect: function(a) {},
        onUnSelect: function(a) {},
        onCreate: function(a) {},
        _onClickHandler: function(a) {
            if ("img" === a.target.tagName.toLowerCase()) {
                var b = a.target,
                    c = b._item;
                l.query("img", this.container).forEach(function(a) {
                    a !== b && a._item.toggleGroup === c.toggleGroup && this._markUnSelected(a, a._item)
                }, this);
                this._toggleNode(b, c)
            }
        },
        _toggleNode: function(a, b) {
            "ON" ===
            b.toggleState ? (b.toggleState = "OFF", b.src && (a.src = b.src.toString()), this.onUnSelect(b)) : (b.toggleState = "ON", b.srcAlt && (a.src = b.srcAlt), this.onSelect(b))
        },
        _markSelected: function(a, b) {
            b.toggleState = "ON";
            b.srcAlt && (a.src = b.srcAlt);
            this.onSelect(b)
        },
        _markUnSelected: function(a, b) {
            "ON" === b.toggleState && (b.toggleState = "OFF", b.src && (a.src = b.src.toString()), this.onUnSelect(b))
        }
    })
});
},
'esri/dijit/Scalebar':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/has", "dojo/query", "../kernel", "../lang", "../domUtils", "../units", "../SpatialReference", "../WKIDUnitConversion", "../geometry/Point", "../geometry/ScreenPoint", "../geometry/Polyline", "../geometry/geodesicUtils", "../geometry/webMercatorUtils", "../geometry/screenUtils", "../geometry/normalizeUtils", "dojo/i18n!../nls/jsapi"], function(D, m, l, g, n, p, E, s, G, k, H, t, u, v, w, q, x, y, z, A, r,
    B, C, F) {
    return D(null, {
        declaredClass: "esri.dijit.Scalebar",
        map: null,
        mapUnit: null,
        scalebarUnit: null,
        unitsDictionary: [],
        domNode: null,
        screenPt1: null,
        screenPt2: null,
        localStrings: F.widgets.scalebar,
        constructor: function(a, c) {
            this.metricScalebar = p.create("div", {
                innerHTML: "\x3cdiv class\x3d'esriScaleLabelDiv'\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarLineLabel esriScalebarSecondNumber'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarLine esriScalebarMetricLine'\x3e\x3c/div\x3e"
            });
            this.englishScalebar =
                p.create("div", {
                    innerHTML: "\x3cdiv class\x3d'esriScalebarLine esriScalebarEnglishLine'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScaleLabelDiv'\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarLineLabel esriScalebarSecondNumber'\x3e\x3c/div\x3e\x3c/div\x3e"
                });
            this.domNode = p.create("div");
            a = a || {};
            if (a.map) {
                if (a.scalebarUnit) {
                    if ("english" !== a.scalebarUnit && "metric" !== a.scalebarUnit && "dual" !== a.scalebarUnit) {
                        console.error("scalebar unit only accepts english or metric or dual");
                        return
                    }
                    this.scalebarUnit =
                        a.scalebarUnit
                } else this.scalebarUnit = "english";
                if (a.scalebarStyle) {
                    if ("ruler" !== a.scalebarStyle && "line" !== a.scalebarStyle) {
                        console.error("scalebar style must be ruler or line");
                        return
                    }
                    this.scalebarStyle = a.scalebarStyle
                } else this.scalebarStyle = "ruler";
                this.background = a.background;
                switch (this.scalebarUnit) {
                    case "english":
                        "ruler" === this.scalebarStyle && (this.englishScalebar.innerHTML = "\x3cdiv class\x3d'esriScalebarRuler'\x3e\x3cdiv class\x3d'esriScalebarRulerBlock upper_firstpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock upper_secondpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock lower_firstpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock lower_secondpiece'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'scaleLabelDiv'\x3e\x3cdiv class\x3d'esriScalebarLabel' style\x3d'left: -3%'\x3e0\x3c/div\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarFirstNumber'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarSecondNumber'\x3e\x3c/div\x3e\x3c/div\x3e");
                        this.domNode.appendChild(this.englishScalebar);
                        break;
                    case "metric":
                        "ruler" === this.scalebarStyle && (this.metricScalebar.innerHTML = "\x3cdiv class\x3d'esriScalebarRuler'\x3e\x3cdiv class\x3d'esriScalebarRulerBlock upper_firstpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock upper_secondpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock lower_firstpiece'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarRulerBlock lower_secondpiece'\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d'scaleLabelDiv'\x3e\x3cdiv class\x3d'esriScalebarLabel' style\x3d'left: -3%'\x3e0\x3c/div\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarFirstNumber'\x3e\x3c/div\x3e\x3cdiv class\x3d'esriScalebarLabel esriScalebarSecondNumber'\x3e\x3c/div\x3e\x3c/div\x3e");
                        this.domNode.appendChild(this.metricScalebar);
                        break;
                    case "dual":
                        this.domNode.appendChild(this.metricScalebar), this.domNode.appendChild(this.englishScalebar)
                }
                this.map = a.map;
                c ? c.appendChild(this.domNode) : (this.map.container.appendChild(this.domNode), a.attachTo ? n.add(this.domNode, "scalebar_" + a.attachTo) : n.add(this.domNode, "scalebar_bottom-left"));
                n.add(this.domNode, "esriScalebar");
                if (this.map.loaded) this._getDistance(this.map.extent), this._checkBingMaps();
                else var b = g.connect(this.map, "onLoad", this,
                    function() {
                        g.disconnect(b);
                        b = null;
                        this._getDistance(this.map.extent);
                        this._checkBingMaps()
                    });
                this._mapOnPan = g.connect(this.map, "onPan", this, this._getDistance);
                this._mapOnExtentChange = g.connect(this.map, "onExtentChange", this, this._getDistance);
                l.forEach(this.map.layerIds, function(a, b) {
                    "esri.virtualearth.VETiledLayer" === this.map.getLayer(a).declaredClass && g.connect(this.map.getLayer(a), "onVisibilityChange", m.hitch(this, function(a) {
                        this._checkBingMaps()
                    }))
                }, this);
                this._mapOnLayerAdd = g.connect(this.map,
                    "onLayerAdd", m.hitch(this, function(a) {
                        "esri.virtualearth.VETiledLayer" === a.declaredClass && g.connect(a, "onVisibilityChange", m.hitch(this, function(a) {
                            this._checkBingMaps()
                        }));
                        this._checkBingMaps()
                    }));
                this._mapOnLayerRemove = g.connect(this.map, "onLayerRemove", m.hitch(this, this._checkBingMaps))
            } else console.error("scalebar: unable to find the 'map' property in parameters")
        },
        hide: function() {
            this._hidden = !0;
            u.hide(this.domNode)
        },
        show: function() {
            this._hidden = !1;
            u.show(this.domNode)
        },
        destroy: function() {
            g.disconnect(this._mapOnPan);
            g.disconnect(this._mapOnExtentChange);
            g.disconnect(this._mapOnLayerAdd);
            g.disconnect(this._mapOnLayerRemove);
            this.hide();
            this.map = null;
            p.destroy(this.domNode)
        },
        _checkBingMaps: function() {
            n.contains(this.domNode, "scalebar_bottom-left") && (s.set(this.domNode, "left", "25px"), l.forEach(this.map.layerIds, function(a, c) {
                if ("esri.virtualearth.VETiledLayer" === this.map.getLayer(a).declaredClass && this.map.getLayer(a).visible) {
                    var b = "95px";
                    this.map._mapParams.nav && (b = "115px");
                    s.set(this.domNode, "left", b)
                }
            }, this))
        },
        _getDistance: function(a) {
            var c = E.position(this.domNode, !0).y - this.map.position.y,
                c = c > this.map.height ? this.map.height : c,
                c = 0 > c ? 0 : c,
                b = new y(0, c),
                c = new y(this.map.width, c),
                f, e;
            this.mapUnit = "esriDecimalDegrees";
            var d = B.toMapPoint(a, this.map.width, this.map.height, b),
                h = B.toMapPoint(a, this.map.width, this.map.height, c),
                b = new x(a.xmin, (a.ymin + a.ymax) / 2, this.map.spatialReference),
                c = new x(a.xmax, (a.ymin + a.ymax) / 2, this.map.spatialReference);
            if (3857 === this.map.spatialReference.wkid || 102100 === this.map.spatialReference.wkid ||
                102113 === this.map.spatialReference.wkid || this.map.spatialReference.wkt && -1 != this.map.spatialReference.wkt.indexOf("WGS_1984_Web_Mercator")) d = r.webMercatorToGeographic(d, !0), h = r.webMercatorToGeographic(h, !0), b = r.webMercatorToGeographic(b, !0), c = r.webMercatorToGeographic(c, !0);
            else if (t.isDefined(q[this.map.spatialReference.wkid]) || this.map.spatialReference.wkt && 0 === this.map.spatialReference.wkt.indexOf("PROJCS")) {
                this.mapUnit = "linearUnit";
                a = Math.abs(a.xmax - a.xmin);
                if (t.isDefined(q[this.map.spatialReference.wkid])) e =
                    q.values[q[this.map.spatialReference.wkid]];
                else {
                    e = this.map.spatialReference.wkt;
                    f = e.lastIndexOf(",") + 1;
                    var g = e.lastIndexOf("]]");
                    e = parseFloat(e.substring(f, g))
                }
                a *= e;
                e = a / 1609;
                f = a / 1E3
            }
            "esriDecimalDegrees" === this.mapUnit && (a = new z(new w({
                wkid: 4326
            })), a.addPath([d, h]), d = C._straightLineDensify(a, 10), a = A.geodesicLengths([d], v.KILOMETERS)[0], d = new z(new w({
                wkid: 4326
            })), d.addPath([b, c]), b = C._straightLineDensify(d, 10), A.geodesicLengths([b], v.KILOMETERS), e = a / 1.609, f = a);
            "english" === this.scalebarUnit ? this._getScaleBarLength(e,
                "mi") : "metric" === this.scalebarUnit ? this._getScaleBarLength(f, "km") : "dual" === this.scalebarUnit && (this._getScaleBarLength(e, "mi"), this._getScaleBarLength(f, "km"))
        },
        _getScaleBarLength: function(a, c) {
            var b = 50 * a / this.map.width,
                f = 0,
                e = c;
            0.1 > b && ("mi" === c ? (b *= 5280, e = "ft") : "km" === c && (b *= 1E3, e = "m"));
            for (; 1 <= b;) b /= 10, f++;
            var d, h;
            0.5 < b ? (d = 1, h = 0.5) : 0.3 < b ? (d = 0.5, h = 0.3) : 0.2 < b ? (d = 0.3, h = 0.2) : 0.15 < b ? (d = 0.2, h = 0.15) : 0.1 <= b && (d = 0.15, h = 0.1);
            d = d / b >= b / h ? h : d;
            b = 50 * (d / b);
            f = Math.pow(10, f) * d;
            this._drawScaleBar(b, f, e)
        },
        _drawScaleBar: function(a,
            c, b) {
            var f = 2 * Math.round(a),
                e, d;
            "mi" === b || "ft" === b ? (this.englishScalebar.style.width = f + "px", a = k(".esriScalebarFirstNumber", this.englishScalebar), e = k(".esriScalebarSecondNumber", this.englishScalebar), d = k(".esriScalebarMetricLineBackground", this.englishScalebar)) : (this.metricScalebar.style.width = f + "px", a = k(".esriScalebarFirstNumber", this.metricScalebar), e = k(".esriScalebarSecondNumber", this.metricScalebar), d = k(".esriScalebarMetricLineBackground", this.metricScalebar));
            l.forEach(d, function(a, b) {
                a.style.width =
                    f - 2 + "px"
            }, this);
            l.forEach(a, function(a, b) {
                a.innerHTML = c
            }, this);
            l.forEach(e, function(a, d) {
                a.innerHTML = "esriUnknown" !== this.mapUnit ? 2 * c + this.localStrings[b] : 2 * c + "Unknown Unit"
            }, this)
        }
    })
});
},
'esri/units':function(){
//>>built
define(["dojo/has", "./kernel"], function(a, b) {
    return {
        CENTIMETERS: "esriCentimeters",
        DECIMAL_DEGREES: "esriDecimalDegrees",
        DEGREE_MINUTE_SECONDS: "esriDegreeMinuteSeconds",
        DECIMETERS: "esriDecimeters",
        FEET: "esriFeet",
        INCHES: "esriInches",
        KILOMETERS: "esriKilometers",
        METERS: "esriMeters",
        MILES: "esriMiles",
        MILLIMETERS: "esriMillimeters",
        NAUTICAL_MILES: "esriNauticalMiles",
        POINTS: "esriPoints",
        UNKNOWN: "esriUnknownUnits",
        YARDS: "esriYards",
        ACRES: "esriAcres",
        ARES: "esriAres",
        SQUARE_KILOMETERS: "esriSquareKilometers",
        SQUARE_MILES: "esriSquareMiles",
        SQUARE_FEET: "esriSquareFeet",
        SQUARE_METERS: "esriSquareMeters",
        HECTARES: "esriHectares",
        SQUARE_YARDS: "esriSquareYards",
        SQUARE_INCHES: "esriSquareInches",
        SQUARE_MILLIMETERS: "esriSquareMillimeters",
        SQUARE_CENTIMETERS: "esriSquareCentimeters",
        SQUARE_DECIMETERS: "esriSquareDecimeters",
        SQUARE_NAUTICAL_MILES: "esriSquareNauticalMiles"
    }
});
},
'esri/geometry/geodesicUtils':function(){
//>>built
define(["dojo/_base/array", "dojo/_base/lang", "dojo/has", "../kernel", "../SpatialReference", "./Point", "./Polyline", "./Polygon"], function(s, E, F, G, D, t, y, B) {
    function v(a) {
        var r = Math.PI / 180,
            b = Math.sin(a.y * r),
            b = 0.9933056200098026 * (b / (1 - 0.006694379990197414 * b * b) - 6.111035746609262 * Math.log((1 - 0.0818191908429643 * b) / (1 + 0.0818191908429643 * b)));
        return new t(6378137 * a.x * r, 3189068.5 * b)
    }

    function x(a, r, b, d) {
        var f = 1 / 298.257223563,
            p = Math.sin(b);
        b = Math.cos(b);
        a = (1 - f) * Math.tan(a);
        var h = 1 / Math.sqrt(1 + a * a),
            m = a * h,
            e = Math.atan2(a,
                b);
        a = h * p * h * p;
        for (var k = 1 - a, c = 2.7233160610754688E11 * k / 4.040829998466145E13, u = 1 + c / 16384 * (4096 + c * (-768 + c * (320 - 175 * c))), g = c / 1024 * (256 + c * (-128 + c * (74 - 47 * c))), c = d / (6356752.31424518 * u), w = 2 * Math.PI, l, n, q, s; 1E-12 < Math.abs(c - w);) q = Math.cos(2 * e + c), l = Math.sin(c), n = Math.cos(c), s = g * l * (q + g / 4 * (n * (-1 + 2 * q * q) - g / 6 * q * (-3 + 4 * l * l) * (-3 + 4 * q * q))), w = c, c = d / (6356752.31424518 * u) + s;
        d = m * l - h * n * b;
        d = Math.atan2(m * n + h * l * b, (1 - f) * Math.sqrt(a + d * d));
        p = Math.atan2(l * p, h * n - m * l * b);
        b = f / 16 * k * (4 + f * (4 - 3 * k));
        f = p - (1 - b) * f * Math.sqrt(a) * (c + b * l * (q + b * n *
            (-1 + 2 * q * q)));
        return new t((r + f) / (Math.PI / 180), d / (Math.PI / 180), new D({
            wkid: 4326
        }))
    }

    function z(a, r, b, d) {
        var f = 1 / 298.257223563,
            p = d - r,
            h = Math.atan((1 - f) * Math.tan(a)),
            m = Math.atan((1 - f) * Math.tan(b)),
            e = Math.sin(h),
            h = Math.cos(h),
            k = Math.sin(m),
            m = Math.cos(m),
            c = p,
            u, g = 1E3,
            w, l, n, q, s, t, v;
        do {
            n = Math.sin(c);
            q = Math.cos(c);
            l = Math.sqrt(m * n * m * n + (h * k - e * m * q) * (h * k - e * m * q));
            if (0 === l) return 0;
            q = e * k + h * m * q;
            s = Math.atan2(l, q);
            t = h * m * n / l;
            w = 1 - t * t;
            n = q - 2 * e * k / w;
            isNaN(n) && (n = 0);
            v = f / 16 * w * (4 + f * (4 - 3 * w));
            u = c;
            c = p + (1 - v) * f * t * (s + v * l * (n + v * q * (-1 +
                2 * n * n)))
        } while (1E-12 < Math.abs(c - u) && 0 < --g);
        if (0 === g) return e = 6371009 * Math.acos(Math.sin(a) * Math.sin(b) + Math.cos(a) * Math.cos(b) * Math.cos(d - r)), k = d - r, h = Math.sin(k) * Math.cos(b), a = Math.cos(a) * Math.sin(b) - Math.sin(a) * Math.cos(b) * Math.cos(k), {
            azimuth: Math.atan2(h, a),
            geodesicDistance: e
        };
        a = 2.7233160610754688E11 * w / 4.040829998466145E13;
        b = a / 1024 * (256 + a * (-128 + a * (74 - 47 * a)));
        a = 6356752.31424518 * (1 + a / 16384 * (4096 + a * (-768 + a * (320 - 175 * a)))) * (s - b * l * (n + b / 4 * (q * (-1 + 2 * n * n) - b / 6 * n * (-3 + 4 * l * l) * (-3 + 4 * n * n))));
        b = Math.atan2(m * Math.sin(c),
            h * k - e * m * Math.cos(c));
        e = Math.atan2(h * Math.sin(c), h * k * Math.cos(c) - e * m);
        return {
            azimuth: b,
            geodesicDistance: a,
            reverseAzimuth: e
        }
    }

    function C(a, r) {
        var b = Math.PI / 180;
        637.100877151506 > r && (r = 637.100877151506);
        if (!(a instanceof y || a instanceof B)) throw console.error("_geodesicDensify: the input geometry is neither polyline nor polygon"), Error("_geodesicDensify: the input geometry is neither polyline nor polygon");
        var d = a instanceof y,
            f = [],
            p;
        s.forEach(d ? a.paths : a.rings, function(a) {
            f.push(p = []);
            p.push([a[0][0],
                a[0][1]
            ]);
            var m, e, k, c, u, g;
            m = a[0][0] * b;
            e = a[0][1] * b;
            for (u = 0; u < a.length - 1; u++)
                if (k = a[u + 1][0] * b, c = a[u + 1][1] * b, !(m === k && e === c)) {
                    c = z(e, m, c, k);
                    k = c.azimuth;
                    c = c.geodesicDistance;
                    var d = c / r;
                    if (1 < d) {
                        for (g = 1; g <= d - 1; g++) {
                            var l = x(e, m, k, g * r);
                            p.push([l.x, l.y])
                        }
                        g = x(e, m, k, (c + Math.floor(d - 1) * r) / 2);
                        p.push([g.x, g.y])
                    }
                    e = x(e, m, k, c);
                    p.push([e.x, e.y]);
                    m = e.x * b;
                    e = e.y * b
                }
        });
        return d ? new y({
            paths: f,
            spatialReference: a.spatialReference
        }) : new B({
            rings: f,
            spatialReference: a.spatialReference
        })
    }
    var A = {
        esriMiles: 1,
        esriKilometers: 1.609344,
        esriFeet: 5280,
        esriMeters: 1609.34,
        esriYards: 1760,
        esriNauticalMiles: 0.869,
        esriCentimeters: 160934,
        esriDecimeters: 16093.4,
        esriInches: 63360,
        esriMillimeters: 1609340,
        esriAcres: 1,
        esriAres: 40.4685642,
        esriSquareKilometers: 0.00404685642,
        esriSquareMiles: 0.0015625,
        esriSquareFeet: 43560,
        esriSquareMeters: 4046.85642,
        esriHectares: 0.404685642,
        esriSquareYards: 4840,
        esriSquareInches: 6272640,
        esriSquareMillimeters: 4046856420,
        esriSquareCentimeters: 4.04685642E7,
        esriSquareDecimeters: 404685.642
    };
    return {
        geodesicDensify: C,
        geodesicLengths: function(a,
            r) {
            var b = Math.PI / 180,
                d = [];
            s.forEach(a, function(a, p) {
                var h = 0;
                s.forEach(a.paths, function(a, e) {
                    var k = 0,
                        c, d, g, f, l;
                    for (c = 1; c < a.length; c++) d = a[c - 1][0] * b, g = a[c][0] * b, f = a[c - 1][1] * b, l = a[c][1] * b, f === l && d === g || (d = z(f, d, l, g), k += d.geodesicDistance / 1609.344);
                    h += k
                });
                h *= A[r];
                d.push(h)
            });
            return d
        },
        geodesicAreas: function(a, r) {
            var b = [];
            s.forEach(a, function(a, d) {
                var e = C(a, 1E4);
                b.push(e)
            });
            var d = [],
                f, p;
            s.forEach(b, function(a, b) {
                var e = 0;
                s.forEach(a.rings, function(a, b) {
                    f = v(new t(a[0][0], a[0][1]));
                    p = v(new t(a[a.length - 1][0],
                        a[a.length - 1][1]));
                    var d = p.x * f.y - f.x * p.y,
                        g;
                    for (g = 0; g < a.length - 1; g++) f = v(new t(a[g + 1][0], a[g + 1][1])), p = v(new t(a[g][0], a[g][1])), d += p.x * f.y - f.x * p.y;
                    e += d / 4046.87
                });
                e *= A[r];
                d.push(e / -2)
            });
            return d
        },
        _unitsDictionary: A,
        _toEqualAreaPoint: v,
        _directGeodeticSolver: x,
        _inverseGeodeticSolver: z
    }
});
},
'esri/tasks/IdentifyTask':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/has", "../kernel", "../request", "../geometry/normalizeUtils", "./Task", "./IdentifyResult"], function(b, h, l, r, s, m, n, p, q) {
    b = b(p, {
        declaredClass: "esri.tasks.IdentifyTask",
        _eventMap: {
            complete: ["results"]
        },
        constructor: function(a, f) {
            this._url.path += "/identify";
            this._handler = h.hitch(this, this._handler);
            this.gdbVersion = f && f.gdbVersion;
            this.registerConnectEvents()
        },
        __msigns: [{
            n: "execute",
            c: 3,
            a: [{
                i: 0,
                p: ["geometry"]
            }],
            e: 2
        }],
        _handler: function(a, f, b,
            d, c) {
            try {
                var e = [];
                l.forEach(a.results, function(a, b) {
                    e[b] = new q(a)
                });
                this._successHandler([e], "onComplete", b, c)
            } catch (g) {
                this._errorHandler(g, d, c)
            }
        },
        execute: function(a, b, k, d) {
            var c = d.assembly;
            a = this._encode(h.mixin({}, this._url.query, {
                f: "json"
            }, a.toJson(c && c[0])));
            var e = this._handler,
                g = this._errorHandler;
            this.gdbVersion && (a.gdbVersion = this.gdbVersion);
            return m({
                url: this._url.path,
                content: a,
                callbackParamName: "callback",
                load: function(a, c) {
                    e(a, c, b, k, d.dfd)
                },
                error: function(a) {
                    g(a, k, d.dfd)
                }
            })
        },
        onComplete: function() {}
    });
    n._createWrappers(b);
    return b
});
},
'esri/tasks/IdentifyResult':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../graphic", "../geometry/jsonUtils"], function(b, c, f, g, d, e) {
    return b(null, {
        declaredClass: "esri.tasks.IdentifyResult",
        constructor: function(a) {
            c.mixin(this, a);
            this.feature = new d(a.geometry ? e.fromJson(a.geometry) : null, null, a.attributes);
            delete this.geometry;
            delete this.attributes
        }
    })
});
},
'esri/tasks/IdentifyParameters':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/json", "dojo/has", "../kernel", "../layerUtils", "../geometry/jsonUtils", "../geometry/scaleUtils"], function(f, n, g, e, r, s, h, p, q) {
    var d = f(null, {
        declaredClass: "esri.tasks.IdentifyParameters",
        constructor: function() {
            this.layerOption = d.LAYER_OPTION_TOP
        },
        geometry: null,
        spatialReference: null,
        layerIds: null,
        tolerance: null,
        returnGeometry: !1,
        mapExtent: null,
        width: 400,
        height: 400,
        dpi: 96,
        layerDefinitions: null,
        timeExtent: null,
        layerTimeOptions: null,
        dynamicLayerInfos: null,
        toJson: function(b) {
            var c = b && b.geometry || this.geometry,
                a = this.mapExtent,
                d = this.spatialReference,
                k = this.layerIds;
            b = {
                tolerance: this.tolerance,
                returnGeometry: this.returnGeometry,
                imageDisplay: this.width + "," + this.height + "," + this.dpi,
                maxAllowableOffset: this.maxAllowableOffset
            };
            if (c) {
                var l = c.toJson();
                delete l.spatialReference;
                b.geometry = e.toJson(l);
                b.geometryType = p.getJsonType(c)
            }
            d ? b.sr = d.wkid || e.toJson(d.toJson()) : c && c.spatialReference ? b.sr = c.spatialReference.wkid || e.toJson(c.spatialReference.toJson()) :
                a && a.spatialReference && (b.sr = a.spatialReference.wkid || e.toJson(a.spatialReference.toJson()));
            a && (b.mapExtent = a.xmin + "," + a.ymin + "," + a.xmax + "," + a.ymax);
            b.layers = this.layerOption;
            k && (b.layers += ":" + k.join(","));
            b.layerDefs = h._serializeLayerDefinitions(this.layerDefinitions);
            c = this.timeExtent;
            b.time = c ? c.toJson().join(",") : null;
            b.layerTimeOptions = h._serializeTimeOptions(this.layerTimeOptions);
            if (this.dynamicLayerInfos && 0 < this.dynamicLayerInfos.length) {
                var a = q.getScale({
                        extent: a,
                        width: this.width,
                        spatialReference: a.spatialReference
                    }),
                    f = h._getLayersForScale(a, this.dynamicLayerInfos),
                    m = [];
                g.forEach(this.dynamicLayerInfos, function(b) {
                    if (!b.subLayerIds) {
                        var a = b.id;
                        if ((!this.layerIds || this.layerIds && -1 !== g.indexOf(this.layerIds, a)) && -1 !== g.indexOf(f, a)) {
                            var c = {
                                id: a
                            };
                            c.source = b.source && b.source.toJson();
                            var d;
                            this.layerDefinitions && this.layerDefinitions[a] && (d = this.layerDefinitions[a]);
                            d && (c.definitionExpression = d);
                            var e;
                            this.layerTimeOptions && this.layerTimeOptions[a] && (e = this.layerTimeOptions[a]);
                            e && (c.layerTimeOptions = e.toJson());
                            m.push(c)
                        }
                    }
                }, this);
                a = e.toJson(m);
                "[]" === a && (a = "[{}]");
                b.dynamicLayers = a
            }
            return b
        }
    });
    n.mixin(d, {
        LAYER_OPTION_TOP: "top",
        LAYER_OPTION_VISIBLE: "visible",
        LAYER_OPTION_ALL: "all"
    });
    return d
});
},
'esri/toolbars/draw':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/Color", "dojo/_base/window", "dojo/has", "dojo/sniff", "dojo/keys", "dojo/dom-construct", "dojo/dom-style", "dojo/dom-geometry", "../kernel", "../sniff", "./_toolbar", "../symbols/SimpleMarkerSymbol", "../symbols/SimpleLineSymbol", "../symbols/SimpleFillSymbol", "../graphic", "../geometry/jsonUtils", "../geometry/webMercatorUtils", "../geometry/Polyline", "../geometry/Polygon", "../geometry/Multipoint", "../geometry/Rect", "dojo/i18n!../nls/jsapi"], function(G,
    l, y, k, w, x, p, A, H, B, C, I, M, N, J, D, u, E, r, K, L, s, q, z, F, t) {
    var h = G(J, {
        declaredClass: "esri.toolbars.Draw",
        _eventMap: {
            "draw-complete": !0,
            "draw-end": ["geometry"]
        },
        constructor: function(c, a) {
            this.markerSymbol = new D(D.STYLE_SOLID, 10, new u(u.STYLE_SOLID, new w([255, 0, 0]), 2), new w([0, 0, 0, 0.25]));
            this.lineSymbol = new u(u.STYLE_SOLID, new w([255, 0, 0]), 2);
            this.fillSymbol = new E(E.STYLE_SOLID, new u(u.STYLE_SOLID, new w([255, 0, 0]), 2), new w([0, 0, 0, 0.25]));
            this._points = [];
            this._mouse = !p("esri-touch") && !p("esri-pointer");
            this._defaultOptions = {
                showTooltips: !0,
                drawTime: 75,
                tolerance: 8,
                tooltipOffset: 15
            };
            this._options = l.mixin(l.mixin({}, this._defaultOptions), a || {});
            if (A("ios") || A("android")) this._options.showTooltips = !1;
            this._onKeyDownHandler = l.hitch(this, this._onKeyDownHandler);
            this._onMouseDownHandler = l.hitch(this, this._onMouseDownHandler);
            this._onMouseUpHandler = l.hitch(this, this._onMouseUpHandler);
            this._onClickHandler = l.hitch(this, this._onClickHandler);
            this._onMouseMoveHandler = l.hitch(this, this._onMouseMoveHandler);
            this._onMouseDragHandler =
                l.hitch(this, this._onMouseDragHandler);
            this._onDblClickHandler = l.hitch(this, this._onDblClickHandler);
            this._updateTooltip = l.hitch(this, this._updateTooltip);
            this._hideTooltip = l.hitch(this, this._hideTooltip);
            this._redrawGraphic = l.hitch(this, this._redrawGraphic)
        },
        _geometryType: null,
        respectDrawingVertexOrder: !1,
        setRespectDrawingVertexOrder: function(c) {
            this.respectDrawingVertexOrder = c
        },
        setMarkerSymbol: function(c) {
            this.markerSymbol = c
        },
        setLineSymbol: function(c) {
            this.lineSymbol = c
        },
        setFillSymbol: function(c) {
            this.fillSymbol =
                c
        },
        activate: function(c, a) {
            this._geometryType && this.deactivate();
            var b = this.map,
                d = k.connect,
                g = h;
            this._options = l.mixin(l.mixin({}, this._options), a || {});
            b.navigationManager.setImmediateClick(!1);
            switch (c) {
                case g.ARROW:
                case g.LEFT_ARROW:
                case g.RIGHT_ARROW:
                case g.UP_ARROW:
                case g.DOWN_ARROW:
                case g.TRIANGLE:
                case g.CIRCLE:
                case g.ELLIPSE:
                case g.RECTANGLE:
                    this._deactivateMapTools(!0, !1, !1, !0);
                    this._onClickHandler_connect = d(b, "onClick", this._onClickHandler);
                    this._onMouseDownHandler_connect = d(b, this._mouse ? "onMouseDown" :
                        "onSwipeStart", this._onMouseDownHandler);
                    this._onMouseDragHandler_connect = d(b, this._mouse ? "onMouseDrag" : "onSwipeMove", this._onMouseDragHandler);
                    this._onMouseUpHandler_connect = d(b, this._mouse ? "onMouseUp" : "onSwipeEnd", this._onMouseUpHandler);
                    p("esri-touch") && !p("esri-pointer") && (this._onMouseDownHandler2_connect = d(b, "onMouseDown", this._onMouseDownHandler), this._onMouseDragHandler2_connect = d(b, "onMouseDrag", this._onMouseDragHandler), this._onMouseUpHandler2_connect = d(b, "onMouseUp", this._onMouseUpHandler));
                    break;
                case g.POINT:
                    this._onClickHandler_connect = d(b, "onClick", this._onClickHandler);
                    break;
                case g.LINE:
                case g.EXTENT:
                case g.FREEHAND_POLYLINE:
                case g.FREEHAND_POLYGON:
                    this._deactivateMapTools(!0, !1, !1, !0);
                    this._onMouseDownHandler_connect = d(b, this._mouse ? "onMouseDown" : "onSwipeStart", this._onMouseDownHandler);
                    this._onMouseDragHandler_connect = d(b, this._mouse ? "onMouseDrag" : "onSwipeMove", this._onMouseDragHandler);
                    this._onMouseUpHandler_connect = d(b, this._mouse ? "onMouseUp" : "onSwipeEnd", this._onMouseUpHandler);
                    p("esri-touch") && !p("esri-pointer") && (this._onMouseDownHandler2_connect = d(b, "onMouseDown", this._onMouseDownHandler), this._onMouseDragHandler2_connect = d(b, "onMouseDrag", this._onMouseDragHandler), this._onMouseUpHandler2_connect = d(b, "onMouseUp", this._onMouseUpHandler));
                    break;
                case g.POLYLINE:
                case g.POLYGON:
                case g.MULTI_POINT:
                    b.navigationManager.setImmediateClick(!0);
                    this._onClickHandler_connect = d(b, "onClick", this._onClickHandler);
                    this._onDblClickHandler_connect = d(b, "onDblClick", this._onDblClickHandler);
                    this._dblClickZoom = b.isDoubleClickZoom;
                    b.disableDoubleClickZoom();
                    break;
                default:
                    console.error("Unsupported geometry type: " + c);
                    return
            }
            this._onKeyDown_connect = d(b, "onKeyDown", this._onKeyDownHandler);
            this._redrawConnect = d(b, "onExtentChange", this._redrawGraphic);
            this._geometryType = c;
            this._toggleTooltip(!0);
            b.snappingManager && ("freehandpolyline" !== this._geometryType && "freehandpolygon" !== this._geometryType) && (b.snappingManager._startSelectionLayerQuery(), b.snappingManager._setUpSnapping());
            this.onActivate(this._geometryType)
        },
        deactivate: function() {
            var c = this.map;
            this._clear();
            var a = k.disconnect;
            a(this._onMouseMoveHandler_connect);
            a(this._onMouseDownHandler_connect);
            a(this._onMouseDragHandler_connect);
            a(this._onMouseUpHandler_connect);
            a(this._onMouseDownHandler2_connect);
            a(this._onMouseDragHandler2_connect);
            a(this._onMouseUpHandler2_connect);
            a(this._onClickHandler_connect);
            a(this._onDblClickHandler_connect);
            a(this._onKeyDown_connect);
            a(this._redrawConnect);
            this._onMouseDownHandler_connect = this._onMouseMoveHandler_connect =
                this._onMouseDragHandler_connect = this._onMouseUpHandler_connect = this._onMouseDownHandler2_connect = this._onMouseDragHandler2_connect = this._onMouseUpHandler2_connect = this._onClickHandler_connect = this._onDblClickHandler_connect = this._onKeyDown_connect = this._redrawConnect = null;
            c.snappingManager && (c.snappingManager._stopSelectionLayerQuery(), c.snappingManager._killOffSnapping());
            switch (this._geometryType) {
                case h.CIRCLE:
                case h.ELLIPSE:
                case h.TRIANGLE:
                case h.ARROW:
                case h.LEFT_ARROW:
                case h.RIGHT_ARROW:
                case h.UP_ARROW:
                case h.DOWN_ARROW:
                case h.RECTANGLE:
                case h.LINE:
                case h.EXTENT:
                case h.FREEHAND_POLYLINE:
                case h.FREEHAND_POLYGON:
                    this._activateMapTools(!0, !1, !1, !0);
                    break;
                case h.POLYLINE:
                case h.POLYGON:
                case h.MULTI_POINT:
                    this._dblClickZoom && c.enableDoubleClickZoom()
            }
            a = this._geometryType;
            this._geometryType = null;
            c.navigationManager.setImmediateClick(!1);
            this._toggleTooltip(!1);
            this.onDeactivate(a)
        },
        _clear: function() {
            this._graphic && this.map.graphics.remove(this._graphic, !0);
            this._tGraphic && this.map.graphics.remove(this._tGraphic, !0);
            this._graphic = this._tGraphic = null;
            this.map.snappingManager && this.map.snappingManager._setGraphic(null);
            this._points = []
        },
        finishDrawing: function() {
            var c, a = this._points,
                b = this.map.spatialReference,
                d = h,
                a = a.slice(0, a.length);
            switch (this._geometryType) {
                case d.POLYLINE:
                    if (!this._graphic || 2 > a.length) return;
                    c = new s(b);
                    c.addPath([].concat(a));
                    break;
                case d.POLYGON:
                    if (!this._graphic || 3 > a.length) return;
                    c = new q(b);
                    a = [].concat(a, [a[0].offset(0, 0)]);
                    !q.prototype.isClockwise(a) && !this.respectDrawingVertexOrder && (console.debug(this.declaredClass + " :  Polygons drawn in anti-clockwise direction will be reversed to be clockwise."), a.reverse());
                    c.addRing(a);
                    break;
                case d.MULTI_POINT:
                    c = new z(b), y.forEach(a, function(a) {
                        c.addPoint(a)
                    })
            }
            k.disconnect(this._onMouseMoveHandler_connect);
            this._clear();
            this._setTooltipMessage(0);
            this._drawEnd(c)
        },
        _drawEnd: function(c) {
            if (c) {
                var a = this.map.spatialReference,
                    b;
                this.onDrawEnd(c);
                a && (a.isWebMercator() ? b = L.webMercatorToGeographic(c, !0) : 4326 === a.wkid && (b = K.fromJson(c.toJson())));
                this.onDrawComplete({
                    geometry: c,
                    geographicGeometry: b
                })
            }
        },
        _normalizeRect: function(c, a, b) {
            var d = c.x;
            c = c.y;
            var g = a.x;
            a = a.y;
            var h = Math.abs(d -
                    g),
                l = Math.abs(c - a);
            return {
                x: Math.min(d, g),
                y: Math.max(c, a),
                width: h,
                height: l,
                spatialReference: b
            }
        },
        _onMouseDownHandler: function(c) {
            this._dragged = !1;
            var a;
            this.map.snappingManager && (a = this.map.snappingManager._snappingPoint);
            var b = a || c.mapPoint,
                d = h;
            a = this.map;
            var g = a.spatialReference;
            this._points.push(b.offset(0, 0));
            switch (this._geometryType) {
                case d.LINE:
                    this._graphic = a.graphics.add(new r(new s({
                        paths: [
                            [
                                [b.x, b.y],
                                [b.x, b.y]
                            ]
                        ],
                        spatialReference: g
                    }), this.lineSymbol), !0);
                    a.snappingManager && a.snappingManager._setGraphic(this._graphic);
                    break;
                case d.FREEHAND_POLYLINE:
                    this._oldPoint = c.screenPoint;
                    b = new s(g);
                    b.addPath(this._points);
                    this._graphic = a.graphics.add(new r(b, this.lineSymbol), !0);
                    a.snappingManager && a.snappingManager._setGraphic(this._graphic);
                    break;
                case d.CIRCLE:
                case d.ELLIPSE:
                case d.TRIANGLE:
                case d.ARROW:
                case d.LEFT_ARROW:
                case d.RIGHT_ARROW:
                case d.UP_ARROW:
                case d.DOWN_ARROW:
                case d.RECTANGLE:
                case d.FREEHAND_POLYGON:
                    this._oldPoint = c.screenPoint, b = new q(g), b.addRing(this._points), this._graphic = a.graphics.add(new r(b, this.fillSymbol), !0), a.snappingManager && a.snappingManager._setGraphic(this._graphic)
            }
            p("esri-touch") && c.preventDefault()
        },
        _onMouseMoveHandler: function(c) {
            var a;
            this.map.snappingManager && (a = this.map.snappingManager._snappingPoint);
            var b = this._points[this._points.length - 1];
            c = a || c.mapPoint;
            a = this._tGraphic;
            var d = a.geometry;
            switch (this._geometryType) {
                case h.POLYLINE:
                case h.POLYGON:
                    d.setPoint(0, 0, {
                        x: b.x,
                        y: b.y
                    }), d.setPoint(0, 1, {
                        x: c.x,
                        y: c.y
                    }), a.setGeometry(d)
            }
        },
        _onMouseDragHandler: function(c) {
            if (p("esri-touch") && !this._points.length) c.preventDefault();
            else {
                this._dragged = !0;
                var a;
                this.map.snappingManager && (a = this.map.snappingManager._snappingPoint);
                var b = this._points[0],
                    d = a || c.mapPoint,
                    g = this.map,
                    v = g.spatialReference;
                a = this._graphic;
                var k = h,
                    m = g.toScreen(b),
                    f = g.toScreen(d),
                    e = [],
                    e = f.x - m.x,
                    f = f.y - m.y,
                    n = Math.sqrt(e * e + f * f);
                switch (this._geometryType) {
                    case k.CIRCLE:
                        this._hideTooltip();
                        a.geometry = q.createCircle({
                            center: m,
                            r: n,
                            numberOfPoints: 60,
                            map: g
                        });
                        a.setGeometry(a.geometry);
                        break;
                    case k.ELLIPSE:
                        this._hideTooltip();
                        a.geometry = q.createEllipse({
                            center: m,
                            longAxis: e,
                            shortAxis: f,
                            numberOfPoints: 60,
                            map: g
                        });
                        a.setGeometry(a.geometry);
                        break;
                    case k.TRIANGLE:
                        this._hideTooltip();
                        e = [
                            [0, -n],
                            [0.8660254037844386 * n, 0.5 * n],
                            [-0.8660254037844386 * n, 0.5 * n],
                            [0, -n]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.ARROW:
                        this._hideTooltip();
                        b = f / n;
                        g = e / n;
                        d = 0.25 * g * n;
                        v = 0.25 * n / (f / e);
                        n *= 0.25 * b;
                        e = [
                            [e, f],
                            [e - d * (1 + 24 / v), f + 24 * g - n],
                            [e - d * (1 + 12 / v), f + 12 * g - n],
                            [-12 * b, 12 * g],
                            [12 * b, -12 * g],
                            [e - d * (1 - 12 / v), f - 12 * g - n],
                            [e - d * (1 - 24 / v), f - 24 * g - n],
                            [e, f]
                        ];
                        a.geometry = this._toPolygon(e,
                            m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.LEFT_ARROW:
                        this._hideTooltip();
                        e = 0 >= e ? [
                            [e, 0],
                            [0.75 * e, f],
                            [0.75 * e, 0.5 * f],
                            [0, 0.5 * f],
                            [0, -0.5 * f],
                            [0.75 * e, -0.5 * f],
                            [0.75 * e, -f],
                            [e, 0]
                        ] : [
                            [0, 0],
                            [0.25 * e, f],
                            [0.25 * e, 0.5 * f],
                            [e, 0.5 * f],
                            [e, -0.5 * f],
                            [0.25 * e, -0.5 * f],
                            [0.25 * e, -f],
                            [0, 0]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.RIGHT_ARROW:
                        this._hideTooltip();
                        e = 0 <= e ? [
                            [e, 0],
                            [0.75 * e, f],
                            [0.75 * e, 0.5 * f],
                            [0, 0.5 * f],
                            [0, -0.5 * f],
                            [0.75 * e, -0.5 * f],
                            [0.75 * e, -f],
                            [e, 0]
                        ] : [
                            [0, 0],
                            [0.25 * e, f],
                            [0.25 * e, 0.5 * f],
                            [e, 0.5 * f],
                            [e, -0.5 * f],
                            [0.25 * e, -0.5 * f],
                            [0.25 * e, -f],
                            [0, 0]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.UP_ARROW:
                        this._hideTooltip();
                        e = 0 >= f ? [
                            [0, f],
                            [-e, 0.75 * f],
                            [-0.5 * e, 0.75 * f],
                            [-0.5 * e, 0],
                            [0.5 * e, 0],
                            [0.5 * e, 0.75 * f],
                            [e, 0.75 * f],
                            [0, f]
                        ] : [
                            [0, 0],
                            [-e, 0.25 * f],
                            [-0.5 * e, 0.25 * f],
                            [-0.5 * e, f],
                            [0.5 * e, f],
                            [0.5 * e, 0.25 * f],
                            [e, 0.25 * f],
                            [0, 0]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.DOWN_ARROW:
                        this._hideTooltip();
                        e = 0 <= f ? [
                            [0, f],
                            [-e, 0.75 * f],
                            [-0.5 * e, 0.75 * f],
                            [-0.5 *
                                e, 0
                            ],
                            [0.5 * e, 0],
                            [0.5 * e, 0.75 * f],
                            [e, 0.75 * f],
                            [0, f]
                        ] : [
                            [0, 0],
                            [-e, 0.25 * f],
                            [-0.5 * e, 0.25 * f],
                            [-0.5 * e, f],
                            [0.5 * e, f],
                            [0.5 * e, 0.25 * f],
                            [e, 0.25 * f],
                            [0, 0]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.RECTANGLE:
                        this._hideTooltip();
                        e = [
                            [0, 0],
                            [e, 0],
                            [e, f],
                            [0, f],
                            [0, 0]
                        ];
                        a.geometry = this._toPolygon(e, m.x, m.y);
                        a.setGeometry(a.geometry);
                        break;
                    case k.LINE:
                        a.setGeometry(l.mixin(a.geometry, {
                            paths: [
                                [
                                    [b.x, b.y],
                                    [d.x, d.y]
                                ]
                            ]
                        }));
                        break;
                    case k.EXTENT:
                        a && g.graphics.remove(a, !0);
                        a = new F(this._normalizeRect(b,
                            d, v));
                        a._originOnly = !0;
                        this._graphic = g.graphics.add(new r(a, this.fillSymbol), !0);
                        g.snappingManager && g.snappingManager._setGraphic(this._graphic);
                        break;
                    case k.FREEHAND_POLYLINE:
                        this._hideTooltip();
                        if (!1 === this._canDrawFreehandPoint(c)) {
                            p("esri-touch") && c.preventDefault();
                            return
                        }
                        this._points.push(c.mapPoint.offset(0, 0));
                        a.geometry._insertPoints([d.offset(0, 0)], 0);
                        a.setGeometry(a.geometry);
                        break;
                    case k.FREEHAND_POLYGON:
                        this._hideTooltip();
                        if (!1 === this._canDrawFreehandPoint(c)) {
                            p("esri-touch") && c.preventDefault();
                            return
                        }
                        this._points.push(c.mapPoint.offset(0, 0));
                        a.geometry._insertPoints([d.offset(0, 0)], 0);
                        a.setGeometry(a.geometry)
                }
                p("esri-touch") && c.preventDefault()
            }
        },
        _canDrawFreehandPoint: function(c) {
            if (!this._oldPoint) return !1;
            var a = this._oldPoint.x - c.screenPoint.x,
                b = this._oldPoint.y - c.screenPoint.y,
                d = this._options.tolerance;
            if ((0 > a ? -1 * a : a) < d && (0 > b ? -1 * b : b) < d) return !1;
            a = new Date;
            if (a - this._startTime < this._options.drawTime) return !1;
            this._startTime = a;
            this._oldPoint = c.screenPoint;
            return !0
        },
        _onMouseUpHandler: function(c) {
            if (this._dragged) {
                0 ===
                    this._points.length && this._points.push(c.mapPoint.offset(0, 0));
                var a;
                this.map.snappingManager && (a = this.map.snappingManager._snappingPoint);
                var b = this._points[0];
                a = a || c.mapPoint;
                var d = this.map.spatialReference,
                    g = h,
                    k;
                switch (this._geometryType) {
                    case g.CIRCLE:
                    case g.ELLIPSE:
                    case g.TRIANGLE:
                    case g.ARROW:
                    case g.LEFT_ARROW:
                    case g.RIGHT_ARROW:
                    case g.UP_ARROW:
                    case g.DOWN_ARROW:
                    case g.RECTANGLE:
                        k = this._graphic.geometry;
                        break;
                    case g.LINE:
                        k = new s({
                            paths: [
                                [
                                    [b.x, b.y],
                                    [a.x, a.y]
                                ]
                            ],
                            spatialReference: d
                        });
                        break;
                    case g.EXTENT:
                        k =
                            (new F(this._normalizeRect(b, a, d))).getExtent();
                        break;
                    case g.FREEHAND_POLYLINE:
                        k = new s(d);
                        k.addPath([].concat(this._points, [a.offset(0, 0)]));
                        break;
                    case g.FREEHAND_POLYGON:
                        k = new q(d), b = [].concat(this._points, [a.offset(0, 0), this._points[0].offset(0, 0)]), !q.prototype.isClockwise(b) && !this.respectDrawingVertexOrder && (console.debug(this.declaredClass + " :  Polygons drawn in anti-clockwise direction will be reversed to be clockwise."), b.reverse()), k.addRing(b)
                }
                p("esri-touch") && c.preventDefault();
                this._clear();
                this._drawEnd(k)
            } else this._clear()
        },
        _onClickHandler: function(c) {
            var a;
            this.map.snappingManager && (a = this.map.snappingManager._snappingPoint);
            c = a || c.mapPoint;
            a = this.map;
            var b = a.toScreen(c),
                d = h;
            this._points.push(c.offset(0, 0));
            switch (this._geometryType) {
                case d.POINT:
                    this._drawEnd(c.offset(0, 0));
                    this._setTooltipMessage(0);
                    break;
                case d.POLYLINE:
                    1 === this._points.length ? (b = new s(a.spatialReference), b.addPath(this._points), this._graphic = a.graphics.add(new r(b, this.lineSymbol), !0), a.snappingManager && a.snappingManager._setGraphic(this._graphic),
                        this._onMouseMoveHandler_connect = k.connect(a, "onMouseMove", this._onMouseMoveHandler), this._tGraphic = a.graphics.add(new r(new s({
                            paths: [
                                [
                                    [c.x, c.y],
                                    [c.x, c.y]
                                ]
                            ],
                            spatialReference: a.spatialReference
                        }), this.lineSymbol), !0)) : (this._graphic.geometry._insertPoints([c.offset(0, 0)], 0), this._graphic.setGeometry(this._graphic.geometry).setSymbol(this.lineSymbol), a = this._tGraphic, b = a.geometry, b.setPoint(0, 0, c.offset(0, 0)), b.setPoint(0, 1, c.offset(0, 0)), a.setGeometry(b));
                    break;
                case d.POLYGON:
                    1 === this._points.length ?
                        (b = new q(a.spatialReference), b.addRing(this._points), this._graphic = a.graphics.add(new r(b, this.fillSymbol), !0), a.snappingManager && a.snappingManager._setGraphic(this._graphic), this._onMouseMoveHandler_connect = k.connect(a, "onMouseMove", this._onMouseMoveHandler), this._tGraphic = a.graphics.add(new r(new s({
                            paths: [
                                [
                                    [c.x, c.y],
                                    [c.x, c.y]
                                ]
                            ],
                            spatialReference: a.spatialReference
                        }), this.fillSymbol), !0)) : (this._graphic.geometry._insertPoints([c.offset(0, 0)], 0), this._graphic.setGeometry(this._graphic.geometry).setSymbol(this.fillSymbol),
                            a = this._tGraphic, b = a.geometry, b.setPoint(0, 0, c.offset(0, 0)), b.setPoint(0, 1, c.offset(0, 0)), a.setGeometry(b));
                    break;
                case d.MULTI_POINT:
                    c = this._points;
                    1 === c.length ? (b = new z(a.spatialReference), b.addPoint(c[c.length - 1]), this._graphic = a.graphics.add(new r(b, this.markerSymbol), !0), a.snappingManager && a.snappingManager._setGraphic(this._graphic)) : (this._graphic.geometry.addPoint(c[c.length - 1]), this._graphic.setGeometry(this._graphic.geometry).setSymbol(this.markerSymbol));
                    break;
                case d.ARROW:
                    this._addShape([
                        [0,
                            0
                        ],
                        [-24, 24],
                        [-24, 12],
                        [-96, 12],
                        [-96, -12],
                        [-24, -12],
                        [-24, -24],
                        [0, 0]
                    ], b.x, b.y);
                    break;
                case d.LEFT_ARROW:
                    this._addShape([
                        [0, 0],
                        [24, 24],
                        [24, 12],
                        [96, 12],
                        [96, -12],
                        [24, -12],
                        [24, -24],
                        [0, 0]
                    ], b.x, b.y);
                    break;
                case d.RIGHT_ARROW:
                    this._addShape([
                        [0, 0],
                        [-24, 24],
                        [-24, 12],
                        [-96, 12],
                        [-96, -12],
                        [-24, -12],
                        [-24, -24],
                        [0, 0]
                    ], b.x, b.y);
                    break;
                case d.UP_ARROW:
                    this._addShape([
                        [0, 0],
                        [-24, 24],
                        [-12, 24],
                        [-12, 96],
                        [12, 96],
                        [12, 24],
                        [24, 24],
                        [0, 0]
                    ], b.x, b.y);
                    break;
                case d.DOWN_ARROW:
                    this._addShape([
                        [0, 0],
                        [-24, -24],
                        [-12, -24],
                        [-12, -96],
                        [12, -96],
                        [12, -24],
                        [24, -24],
                        [0, 0]
                    ], b.x, b.y);
                    break;
                case d.TRIANGLE:
                    this._addShape([
                        [0, -48],
                        [41.56921938165306, 24],
                        [-41.56921938165306, 24],
                        [0, -48]
                    ], b.x, b.y);
                    break;
                case d.RECTANGLE:
                    this._addShape([
                        [0, -96],
                        [96, -96],
                        [96, 0],
                        [0, 0],
                        [0, -96]
                    ], b.x - 48, b.y + 48);
                    break;
                case d.CIRCLE:
                    this._clear();
                    this._drawEnd(q.createCircle({
                        center: b,
                        r: 48,
                        numberOfPoints: 60,
                        map: a
                    }));
                    break;
                case d.ELLIPSE:
                    this._clear(), this._drawEnd(q.createEllipse({
                        center: b,
                        longAxis: 48,
                        shortAxis: 24,
                        numberOfPoints: 60,
                        map: a
                    }))
            }
            this._setTooltipMessage(this._points.length)
        },
        _addShape: function(c, a, b) {
            this._setTooltipMessage(0);
            this._clear();
            this._drawEnd(this._toPolygon(c, a, b))
        },
        _toPolygon: function(c, a, b) {
            var d = this.map,
                g = new q(d.spatialReference);
            g.addRing(y.map(c, function(c) {
                return d.toMap({
                    x: c[0] + a,
                    y: c[1] + b
                })
            }));
            return g
        },
        _onDblClickHandler: function(c) {
            var a, b = this._points,
                d = this.map.spatialReference,
                g = h;
            p("esri-touch") && b.push(c.mapPoint);
            b = b.slice(0, b.length);
            switch (this._geometryType) {
                case g.POLYLINE:
                    if (!this._graphic || 2 > b.length) {
                        k.disconnect(this._onMouseMoveHandler_connect);
                        this._clear();
                        this._onClickHandler(c);
                        return
                    }
                    a = new s(d);
                    a.addPath([].concat(b));
                    break;
                case g.POLYGON:
                    if (!this._graphic || 2 > b.length) {
                        k.disconnect(this._onMouseMoveHandler_connect);
                        this._clear();
                        this._onClickHandler(c);
                        return
                    }
                    a = new q(d);
                    c = [].concat(b, [b[0].offset(0, 0)]);
                    !q.prototype.isClockwise(c) && !this.respectDrawingVertexOrder && (console.debug(this.declaredClass + " :  Polygons drawn in anti-clockwise direction will be reversed to be clockwise."), c.reverse());
                    a.addRing(c);
                    break;
                case g.MULTI_POINT:
                    a =
                        new z(d), y.forEach(b, function(b) {
                            a.addPoint(b)
                        })
            }
            k.disconnect(this._onMouseMoveHandler_connect);
            this._clear();
            this._setTooltipMessage(0);
            this._drawEnd(a)
        },
        _onKeyDownHandler: function(c) {
            c.keyCode === H.ESCAPE && (k.disconnect(this._onMouseMoveHandler_connect), this._clear(), this._setTooltipMessage(0))
        },
        _toggleTooltip: function(c) {
            this._options.showTooltips && (c ? this._tooltip || (this._tooltip = B.create("div", {
                    "class": "tooltip"
                }, this.map.container), I.isBodyLtr() || C.set(this._tooltip, "direction", "rtl"), this._tooltip.style.display =
                "none", this._tooltip.style.position = "fixed", this._setTooltipMessage(0), this._onTooltipMouseEnterHandler_connect = k.connect(this.map, "onMouseOver", this._updateTooltip), this._onTooltipMouseLeaveHandler_connect = k.connect(this.map, "onMouseOut", this._hideTooltip), this._onTooltipMouseMoveHandler_connect = k.connect(this.map, "onMouseMove", this._updateTooltip)) : this._tooltip && (k.disconnect(this._onTooltipMouseEnterHandler_connect), k.disconnect(this._onTooltipMouseLeaveHandler_connect), k.disconnect(this._onTooltipMouseMoveHandler_connect),
                B.destroy(this._tooltip), this._tooltip = null))
        },
        _hideTooltip: function() {
            var c = this._tooltip;
            c && (c.style.display = "none")
        },
        _setTooltipMessage: function(c) {
            var a = this._tooltip;
            if (a) {
                var b = "";
                switch (this._geometryType) {
                    case h.POINT:
                        b = t.toolbars.draw.addPoint;
                        break;
                    case h.ARROW:
                    case h.LEFT_ARROW:
                    case h.RIGHT_ARROW:
                    case h.UP_ARROW:
                    case h.DOWN_ARROW:
                    case h.TRIANGLE:
                    case h.RECTANGLE:
                    case h.CIRCLE:
                    case h.ELLIPSE:
                        b = t.toolbars.draw.addShape;
                        break;
                    case h.LINE:
                    case h.EXTENT:
                    case h.FREEHAND_POLYLINE:
                    case h.FREEHAND_POLYGON:
                        b =
                            t.toolbars.draw.freehand;
                        break;
                    case h.POLYLINE:
                    case h.POLYGON:
                        b = t.toolbars.draw.start;
                        1 === c ? b = t.toolbars.draw.resume : 2 <= c && (b = t.toolbars.draw.complete);
                        break;
                    case h.MULTI_POINT:
                        b = t.toolbars.draw.addMultipoint, 1 <= c && (b = t.toolbars.draw.finish)
                }
                a.innerHTML = b
            }
        },
        _updateTooltip: function(c) {
            var a = this._tooltip;
            if (a) {
                var b;
                c.clientX || c.pageY ? (b = c.clientX, c = c.clientY) : (b = c.clientX + x.body().scrollLeft - x.body().clientLeft, c = c.clientY + x.body().scrollTop - x.body().clientTop);
                a.style.display = "none";
                C.set(a, {
                    left: b +
                        this._options.tooltipOffset + "px",
                    top: c + "px"
                });
                a.style.display = ""
            }
        },
        _redrawGraphic: function(c, a, b, d) {
            if (b || this.map.wrapAround180)(c = this._graphic) && c.setGeometry(c.geometry), (c = this._tGraphic) && c.setGeometry(c.geometry)
        },
        onActivate: function() {},
        onDeactivate: function() {},
        onDrawComplete: function() {},
        onDrawEnd: function() {}
    });
    l.mixin(h, {
        POINT: "point",
        MULTI_POINT: "multipoint",
        LINE: "line",
        EXTENT: "extent",
        POLYLINE: "polyline",
        POLYGON: "polygon",
        FREEHAND_POLYLINE: "freehandpolyline",
        FREEHAND_POLYGON: "freehandpolygon",
        ARROW: "arrow",
        LEFT_ARROW: "leftarrow",
        RIGHT_ARROW: "rightarrow",
        UP_ARROW: "uparrow",
        DOWN_ARROW: "downarrow",
        TRIANGLE: "triangle",
        CIRCLE: "circle",
        ELLIPSE: "ellipse",
        RECTANGLE: "rectangle"
    });
    return h
});
},
'esri/toolbars/_toolbar':function(){
//>>built
define(["dojo/_base/declare", "dojo/_base/lang", "dojo/has", "../kernel", "../Evented"], function(g, k, l, m, h) {
    return g([h], {
        declaredClass: "esri.toolbars._Toolbar",
        constructor: function(c) {
            this.map = c
        },
        _cursors: {
            move: "pointer",
            "move-v": "pointer",
            "move-gv": "pointer",
            box0: "nw-resize",
            box1: "n-resize",
            box2: "ne-resize",
            box3: "e-resize",
            box4: "se-resize",
            box5: "s-resize",
            box6: "sw-resize",
            box7: "w-resize",
            box8: "pointer"
        },
        _deactivateMapTools: function(c, d, e, f) {
            var a = this.map;
            c && (this._mapNavState = {
                isDoubleClickZoom: a.isDoubleClickZoom,
                isClickRecenter: a.isClickRecenter,
                isPan: a.isPan,
                isRubberBandZoom: a.isRubberBandZoom,
                isKeyboardNavigation: a.isKeyboardNavigation,
                isScrollWheelZoom: a.isScrollWheelZoom
            }, a.disableDoubleClickZoom(), a.disableClickRecenter(), a.disablePan(), a.disableRubberBandZoom(), a.disableKeyboardNavigation());
            d && a.hideZoomSlider();
            e && a.hidePanArrows();
            f && a.graphics.disableMouseEvents()
        },
        _activateMapTools: function(c, d, e, f) {
            var a = this.map,
                b = this._mapNavState;
            c && b && (b.isDoubleClickZoom && a.enableDoubleClickZoom(), b.isClickRecenter &&
                a.enableClickRecenter(), b.isPan && a.enablePan(), b.isRubberBandZoom && a.enableRubberBandZoom(), b.isKeyboardNavigation && a.enableKeyboardNavigation(), b.isScrollWheelZoom && a.enableScrollWheelZoom());
            d && a.showZoomSlider();
            e && a.showPanArrows();
            f && a.graphics.enableMouseEvents()
        }
    })
});
},
'xstyle/has-class':function(){
define(["dojo/has"], function(has){
	var tested = {};
	return function(){
		var test, args = arguments;
		for(var i = 0; i < args.length; i++){
			var test = args[i];
			if(!tested[test]){
				tested[test] = true;
				var parts = test.match(/^(no-)?(.+?)((-[\d\.]+)(-[\d\.]+)?)?$/), // parse the class name
					hasResult = has(parts[2]), // the actual has test
					lower = -parts[4]; // lower bound if it is in the form of test-4 or test-4-6 (would be 4)
				if((lower > 0 ? lower <= hasResult && (-parts[5] || lower) >= hasResult :  // if it has a range boundary, compare to see if we are in it
						!!hasResult) == !parts[1]){ // parts[1] is the no- prefix that can negate the result
					document.documentElement.className += ' has-' + test;
				}
			}
		}
	}
});
},
'url:esri/dijit/templates/Geocoder.html':"<div class=\"${theme}\" role=\"presentation\">\n    <div class=\"${_css.GeocoderContainerClass}\" role=\"presentation\">\n    \t<div class=\"${_css.GeocoderClass}\" data-dojo-attach-point=\"containerNode\" role=\"presentation\">\n    \t\t<div title=\"${_i18n.widgets.Geocoder.main.searchButtonTitle}\" tabindex=\"0\" class=\"${_css.searchButtonClass} ${_css.GeocoderIconClass}\" data-dojo-attach-point=\"submitNode\" role=\"button\"></div>\n    \t\t<div aria-haspopup=\"true\" id=\"${id}_menu_button\" title=\"${_i18n.widgets.Geocoder.main.geocoderMenuButtonTitle}\" tabindex=\"0\" class=\"${_css.geocoderMenuArrowClass} ${_css.GeocoderIconClass}\" data-dojo-attach-point=\"geocoderMenuArrowNode\" role=\"button\" aria-expanded=\"false\"></div>\n    \t\t<input aria-haspopup=\"true\" id=\"${id}_input\" tabindex=\"0\" placeholder=\"\" value=\"${value}\" autocomplete=\"off\" type=\"text\" data-dojo-attach-point=\"inputNode\" role=\"textbox\">\n    \t\t<div tabindex=\"0\" class=\"${_css.clearButtonClass} ${_css.GeocoderIconClass}\" data-dojo-attach-point=\"clearNode\" role=\"button\"></div>\n    \t\t<div class=\"${_css.GeocoderClearClass}\" role=\"presentation\"></div>\n    \t</div>\n    \t<div class=\"${_css.resultsContainerClass}\" data-dojo-attach-point=\"resultsNode\" aria-labelledby=\"${id}_input\" role=\"menu\" aria-hidden=\"true\"></div>\n    \t<div class=\"${_css.geocoderMenuClass}\" data-dojo-attach-point=\"geocoderMenuNode\" role=\"presentation\">\n    \t\t<div class=\"${_css.geocoderMenuHeaderClass}\">\n    \t\t\t${_i18n.widgets.Geocoder.main.geocoderMenuHeader}\n    \t\t\t<div role=\"button\" data-dojo-attach-point=\"geocoderMenuCloseNode\" title=\"${_i18n.widgets.Geocoder.main.geocoderMenuCloseTitle}\" tabindex=\"0\" class=\"${_css.geocoderMenuCloseClass}\"></div>\n    \t\t\t<div class=\"${_css.GeocoderClearClass}\" role=\"presentation\"></div>\n    \t\t</div>\n    \t\t<div data-dojo-attach-point=\"geocoderMenuInsertNode\" aria-labelledby=\"${id}_menu_button\" role=\"menu\" aria-hidden=\"true\"></div>\n    \t</div>\n    </div>\n</div>",
'url:esri/dijit/templates/HomeButton.html':"<div class=\"${theme}\" role=\"presentation\">\n    <div class=\"${_css.container}\">\n            <div data-dojo-attach-point=\"_homeNode\" title=\"${_i18n.widgets.homeButton.home.title}\" role=\"button\" class=\"${_css.home}\"><span>${_i18n.widgets.homeButton.home.button}</span></div>\n    </div>\n</div>",
'url:esri/dijit/templates/LocateButton.html':"<div class=\"${theme}\" role=\"presentation\">\n    <div class=\"${_css.container}\">\n            <div data-dojo-attach-point=\"_locateNode\" role=\"button\" class=\"${_css.locate}\"><span>${_i18n.widgets.locateButton.locate.button}</span></div>\n    </div>\n</div>\n",
'*now':function(r){r(['dojo/i18n!*preload*dojo/nls/dojo*["ar","ca","cs","da","de","el","en-gb","es-es","fi-fi","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nl-nl","nb","pl","pt-br","pt-pt","ru","sk","sl","sv","th","tr","zh-tw","zh-cn"]']);}
}});
(function(){
	// must use this.require to make this work in node.js
	var require = this.require;
	// consume the cached dojo layer
	require({cache:{}});
	!require.async && require(["dojo"]);
	require.boot && require.apply(null, require.boot);
})();
